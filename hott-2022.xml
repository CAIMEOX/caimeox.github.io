<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>4603</anchor>  <taxon>Reference</taxon> <addr>hott-2022</addr>  <route>hott-2022.xml</route>  <authors><author>Egbert Rijke</author> </authors> <title>Introduction to Homotopy Type Theory</title>  <meta name="doi">10.48550/arXiv.2212.11082</meta><meta name="venue">Logic, Category Theory</meta></frontmatter> <mainmatter><p>
    This is an introductory textbook to univalent mathematics and homotopy type theory, a mathematical foundation that takes advantage of the structural nature of mathematical definitions and constructions. 
</p></mainmatter> <backmatter><contributions/> <context/> <related/> <backlinks><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>4604</anchor>  <taxon>Type Theory</taxon> <addr>tt-0005</addr>  <route>tt-0005.xml</route> <date><year>2024</year> <month>1</month> <day>31</day></date>  <title>Identity Types</title>  </frontmatter> <mainmatter><p>
    This post discuss the identity types in type theory.
    Refer to <link href="hott-2022.xml" type="local" addr="hott-2022" title="Introduction to Homotopy Type Theory">Introduction to Homotopy Type Theory</link>.
</p><p>
    How can we think of <strong>equality</strong> in type theory?
    Mentioned before, given a type <tex>A</tex> and two its elements <tex>a,b:A</tex>
    we can define a new type <tex>a=_Ab</tex> which is called the <strong>identity type</strong>.
    In this case, a term of <tex>a=_Ab</tex> is said to be a <em>witness</em> of the equality of <tex>a</tex> and <tex>b</tex>.
    And this witness is itself a type.
    We can then define their equality.
    This gives every type a <strong>groupoid structure</strong>.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4605</anchor>  <taxon>Definition</taxon> <addr>def-002N</addr>  <route>def-002N.xml</route>   <title>Identity Type</title>  </frontmatter> <mainmatter><p>
    The <strong>identity type</strong> is an inductive type,
    generated by just a <strong>reflexivity</strong> <em>identification</em>
    that providing an equality of a term with itself.
</p><p>
    Consider a type <tex>A</tex> and let <tex>a:A</tex> be an element.
    The identity type of <tex>A</tex> at <tex>a</tex> is an inductive family of types <tex>a=_Ax</tex> 
    indexed by <tex>x:A</tex>.
    <tex display="block">          \frac {              \Gamma \vdash  a:A         }{              \Gamma ,x:A \vdash  a=_Ax \space \text {type}          }     </tex>
    The only constructor is the refl:
    <tex display="block">          \frac {              \Gamma \vdash  a:A         }{              \Gamma \vdash   \text {refl} _a:a=_Ax         }     </tex></p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4606</anchor>          </frontmatter> <mainmatter><strong>
    Path Induction / Identification Elimination
</strong><p/>
    The induction principle of the identity type states that
    for any type family <tex>P(x,p)</tex> indexed by <tex>x:A</tex> and <tex>p:a=_Ax</tex>,
    <tex display="block">          \text {ind-eq}_{ a } :P(a,  \text {refl} _a) \to  (x:A) \to  (p:a=_Ax) \to  P(x,p)     </tex>
    satisfies <tex>\text {ind-eq}_{ a } (u,a, \text {refl} _a) \equiv  u</tex> where <tex>u:P(a, \text {refl} _a)</tex>.
    Formally we can write:
    <tex display="block">          \frac {              \Gamma \vdash  a:A, \quad   \Gamma ,x:A,p:a=_Ax \vdash  P(x,p) \space \text {type}          }{              \Gamma \vdash   \text {ind-eq}_{ a } (a, \text {refl} _a): P(a, \text {refl} _a)  \to  (x:A) \to  (p:a=_Ax) \to  P(x,p)         } \text {eq-elim}     </tex>
    <tex display="block">          \frac {              \Gamma \vdash  a:A, \quad   \Gamma ,x:A,p:a=_Ax \vdash  P(x,p) \space \text {type}          }{              \Gamma ,u:P(a, \text {refl} _a) \vdash   \text {ind-eq}_{ a } (u,a, \text {refl} _a) \equiv  u:P(a, \text {refl} _a)         } \text {eq-comp}     </tex>

</mainmatter> </tree>
  
<p>
    A term of <tex>a=_Ax</tex> is called a <strong>identification</strong> of <tex>a</tex> and <tex>x</tex>,
    or the <strong>path</strong> from <tex>a</tex> to <tex>x</tex>.
</p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4607</anchor>          </frontmatter> <mainmatter><strong>Variable Version</strong><p/>
    We can form an identity type with variables of <tex>A</tex>.
    <tex display="block">          \Gamma ,x:A,y:A \vdash  x=_Ay \space \text {type}      </tex>
    with the following introduction rule:
    <tex display="block">          \frac {              \Gamma ,x:A \vdash  x:A         }{              \Gamma ,x:A \vdash   \text {refl} _x:x=_Ax         }     </tex>
    and similarly the elimination rule and computation rule.
</mainmatter> </tree>
  
</mainmatter> </tree><p>
    The identifications can be <strong>concatenated</strong> and <strong>inverted</strong>,
    which implies the <em>transitivity</em> and <em>symmetry</em> of the identity type.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4608</anchor>  <taxon>Definition</taxon> <addr>def-002O</addr>  <route>def-002O.xml</route>   <title>Concatenation Operation</title>  </frontmatter> <mainmatter><p>
    Let <tex>A</tex> be a type.
    The <strong>Concatenation</strong> operation is defined:
    <tex display="block">          \text {concat} : (x:A) \to  (y:A) \to  (z:A) \to  (x=_Ay) \to  (y=_Az) \to  (x=_Az)     </tex></p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4609</anchor>          </frontmatter> <mainmatter><strong>Construction</strong><p/>
    We can first construct:
    <tex display="block">         f(x):(y:A) \to  (x=_Ay) \to (z:A) \to  (y=_Az) \to (x=_Az)     </tex>
    For any <tex>x:A</tex>, it suffices to construct
    <tex display="block">         f(x,x, \text {refl} _x) : (z:A)  \to  (x=_Az) \to (x=_Az)     </tex>
    That is the identity function <tex>\lambda  z.  \text {id} _{x=_Az}</tex>.
    Then we can define by induction:
    <tex display="block">         f(x) : \equiv   \text {ind-eq}_{ x } ( \lambda  z. \text {id} )     </tex>
    Finally:
    <tex display="block">          \text {concat} _{x,y,z}(p,q) : \equiv  f(x,y,p,z,q)     </tex>
    Or simply we denote <tex>\text {concat} (p,q)</tex> as <tex>p  \cdot  q</tex>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4610</anchor>  <taxon>Definition</taxon> <addr>def-002P</addr>  <route>def-002P.xml</route>   <title>Inverse Operation</title>  </frontmatter> <mainmatter><p>
    Let <tex>A</tex> be a type. The <strong>inverse oepration</strong> is defined:
    <tex display="block">          \text {inv} : (x:A) \to  (y:A) \to  (x=_Ay) \to  (y=_Ax)     </tex></p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4611</anchor>          </frontmatter> <mainmatter>
    <strong>Construction</strong>
<p/>
    By induction, it suffices to construct:
    <tex display="block">          \text {inv} (x,x, \text {refl} _x) : (x=_Ax)     </tex>
    for any <tex>x:A</tex>. And trivially we have <tex>\text {inv} (x,x, \text {refl} _x) \equiv \text {refl} _x</tex>.
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4612</anchor>  <taxon>Definition</taxon> <addr>def-002W</addr>  <route>def-002W.xml</route>   <title>Associator</title>  </frontmatter> <mainmatter><p>
    Let <tex>A</tex> be a type.
    These are 3 consecutive identifications
    <tex display="block">         p:x=_Ay,q:y=_Az, r:z=_Aw     </tex>
    we define the <strong>associator</strong>:
    <tex display="block">          \text {assoc} : (p,q,r): (p \cdot  q) \cdot  r = p \cdot  (q \cdot  r)     </tex></p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4613</anchor>          </frontmatter> <mainmatter>
    <strong>Construction</strong>
<p/>
    By definition it suffices to show that
    <tex display="block">          \Pi _{(z:A)} \Pi _{(q:x=_Az)}          \Pi _{(w:A)} \Pi _{(r:z=_Aw)}         ( \text {refl} _x \cdot  q) \cdot  r =  \text {refl} _x \cdot  (q \cdot  r)     </tex>
    Let <tex>q:x=_Az</tex> and <tex>r:z=_Aw</tex>. By computation rule of identity types
    <tex display="block">          \text {refl} _x \cdot  q  \equiv  q     </tex>
    Then we can conclude that
    <tex display="block">         ( \text {refl} _x \cdot  q) \cdot  r  \equiv  q \cdot  r     </tex>
    similarly <tex>\text {refl} _x \cdot  (q \cdot  r)  \equiv  q \cdot  r</tex>.
    Hence we have the left and right side
    <tex display="block">         ( \text {refl} _x \cdot  q) \cdot  r =  \text {refl} _x \cdot  (q \cdot  r)     </tex>
    are judgementally equal, 
    so we can simply define the associator as
    <tex display="block">          \text {assoc} ( \text {refl} _x,q,r) : \equiv   \text {refl} _{q \cdot  r}     </tex>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4614</anchor>  <taxon>Definition</taxon> <addr>def-002X</addr>  <route>def-002X.xml</route>   <title>Unit Law Operations</title>  </frontmatter> <mainmatter><p>
    Let <tex>A</tex> be a type.
    We defined the <strong>unit law</strong> operations for <tex>x=_Ay</tex>:
    <tex display="block">          \begin {align*}              \text {left-unit} &amp; : (x=_Ay) \to  ( \text {refl} _x \cdot  x = x)  \\               \text {right-unit} &amp; : (x=_Ay) \to  (x \cdot \text {refl} _y = x)          \end {align*}     </tex></p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4615</anchor>          </frontmatter> <mainmatter>
    <strong>Construction</strong>
<p/>
    By elimination it suffices to construct:
    <tex display="block">          \begin {align*}              \text {left-unit}( \text {refl} _x) &amp;:  \text {refl} _x  \cdot   \text {refl} _x =  \text {refl} _x  \\               \text {right-unit}( \text {refl} _x) &amp;:  \text {refl} _x  \cdot   \text {refl} _x =  \text {refl} _x          \end {align*}     </tex>
    In both cases we need only to construct <tex>\text {refl} _{ \text {refl} _x}</tex>.
</mainmatter> </tree>
  
</mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>4616</anchor>  <taxon>Type Theory</taxon> <addr>tt-0004</addr>  <route>tt-0004.xml</route> <date><year>2024</year> <month>1</month> <day>30</day></date>  <title>Inductive Types</title>  </frontmatter> <mainmatter><p>
    In previous post, we have seen the definition of natural numbers as an inductive type.
    In this post, we will see more examples of inductive types, such as 
    unit type, empty type, product type, sum type and etc.
    Refer to <link href="hott-2022.xml" type="local" addr="hott-2022" title="Introduction to Homotopy Type Theory">Egbert Rijke's Book</link>.
</p><p>
    This section is much more informal than the previous one.
    Without displaying the inference rules, we will just present the <strong>constructor</strong>
    and <strong>induction principle</strong> of each inductive type.
</p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4617</anchor>      <date><year>2024</year> <month>1</month> <day>30</day></date>   <parent>tt-0004</parent> </frontmatter> <mainmatter><strong>General Inductive Type</strong><p/>
    <p>
    Just like <tex>\mathbb {N}</tex>, other inductive types can be defined by 
    their constructors and induction principles (and computation rules).
    </p>
    <ul><li>
            The constructors specify the structure of the type equipped.
        </li>
        <li>
            The induction principle specifies the data required to construct 
            a section of an arbitrary type family over the inductive type.
        </li>
        <li>
            The computation rules specify the behavior of the constructors.
        </li></ul>
</mainmatter> </tree>
  
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4618</anchor>  <taxon>Definition</taxon> <addr>def-0020</addr>  <route>def-0020.xml</route>   <title>Unit Type</title>  </frontmatter> <mainmatter><p>
        
        The <strong>unit type</strong> is the simplest inductive type.
        It has only one constructor, denoted by <tex>\star : \textbf {1}</tex>.
    </p><p>
        The induction principle of the unit type is trivial.
        It says that to define a dependent function <tex>f: \Pi  _{(x: \textbf {1} )} P(x)</tex>, 
        it suffices to give a value <tex>p:P( \star )</tex>.
        <tex display="block">             f ( \star ) : \equiv  p         </tex></p></mainmatter> </tree><p>
    A degenrate inductive type is the <strong>empty type</strong>.
    It has no constructor, and its induction principle is trivial.
    Empty type is connected to the <strong>exfalso quodlibet principle</strong> in logic.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4619</anchor>  <taxon>Definition</taxon> <addr>def-0021</addr>  <route>def-0021.xml</route>   <title>Empty Type</title>  </frontmatter> <mainmatter><p>
    The <strong>empty type</strong> is a degenerate inductive type <tex>\emptyset</tex> satisfying 
    the following induction principle:
    <tex display="block">          \text {ind}_ \emptyset  :  \Pi _{(x: \emptyset )}P(x)     </tex>
    And a special case is <strong>exfalso</strong>:
    <tex display="block">          \text {exfalso} : \equiv   \text {ind}_ \emptyset  :  \empty   \to  A      </tex>
    which can draw any conclusion.
</p></mainmatter> </tree><p>
    With the empty type we can define the <strong>negation</strong> of a type
    and the <strong>proof of negation</strong>.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4620</anchor>  <taxon>Definition</taxon> <addr>def-0022</addr>  <route>def-0022.xml</route>   <title>Type Negation</title>  </frontmatter> <mainmatter><p>
    The <strong>negation</strong> of type <tex>A</tex> is defined as
    <tex display="block">          \neg  A : \equiv  A  \to   \emptyset      </tex>
    A type <tex>A</tex> is said to be <strong>empty</strong> if and only if <tex>\neg  A</tex> is inhabited.
    <tex display="block">          \text {empty}(A) : \equiv   \neg  A     </tex></p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4621</anchor>          </frontmatter> <mainmatter><strong>Proof of negation</strong><p/>
        <p>
            To prove <tex>\neg  A</tex>, we need to show that <tex>A</tex> implies a contradiction.
            In other words, constructing a function of type <tex>A  \to   \emptyset</tex>.
        </p>
    </mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4622</anchor>  <taxon>Definition</taxon> <addr>def-0023</addr>  <route>def-0023.xml</route>   <title>Coproduct Type</title>  </frontmatter> <mainmatter><p>
    Let <tex>A</tex> and <tex>B</tex> be types. The <strong>coproduct (disjoint sum)</strong> <tex>A+B</tex> is a typed defined by the following constructors:
    <ul><li><tex>\text {inl} :A \to  A+B</tex></li>
        <li><tex>\text {inr} :B \to  A+B</tex></li></ul>
    For any type family indexed by <tex>x:A+B</tex>, satisfies the following induction principle:
    <tex display="block">          \text {ind}_ + : ( \Pi _{(x:A)}P( \text {inl} (x))) \to ( \Pi _{(y:B)}P( \text {inr} (y))) \to \Pi _{(z:A+B)}P(z)     </tex>
    (Note that sometimes we denoted <tex>\text {ind}_ + (f,g)</tex> as <tex>[f,g]</tex>) And the computation rule:
    <tex display="block">          \begin {align*}              \text {ind}_ + (f,g, \text {inl} (x))&amp; \equiv  f(x) \\               \text {ind}_ + (f,g, \text {inr} (y))&amp; \equiv  g(y)          \end {align*}     </tex>
    where <tex>f</tex> and <tex>g</tex> are defined:
    <tex display="block">          \begin {align*}             f&amp;: \Pi _{(x:A)}P( \text {inl} (x)) \\              g&amp;: \Pi _{(y:B)}P( \text {inr} (y))          \end {align*}     </tex>
    This can be presented by pattern matching to define a function <tex>h: \Pi  _{(z:A+B)}.P(z)</tex>:
    <tex display="block">          \begin {align*}             h( \text {inl} (x))&amp;: \equiv  f(x) \\              h( \text {inr} (y))&amp;: \equiv  g(y)          \end {align*}     </tex></p></mainmatter> </tree> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4623</anchor>      <date><year>2024</year> <month>1</month> <day>30</day></date>   <parent>tt-0004</parent> </frontmatter> <mainmatter><strong>Special Case of Coproduct</strong><p/>
    The special case of coproduct type is also called the <strong>sum type</strong>.
    <tex display="block">          \text {ind}_ + : (A  \to  X)  \to  (B  \to  X)  \to  (A+B  \to  X)     </tex>
    which is very similar to the <strong>elimination rule</strong> of disjunction in logic.
    <tex display="block">         (P \to  Q)  \to  (R \to  Q)  \to  (P \vee  R \to  Q)     </tex>
</mainmatter> </tree>
  
<p>
    The dependent version of sum type is called the <strong>dependent sum type (dependent coproduct)</strong> traditionally.
    Its terms are ordered pairs.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4624</anchor>  <taxon>Definition</taxon> <addr>def-0024</addr>  <route>def-0024.xml</route>   <title>Dependent Pair Type</title>  </frontmatter> <mainmatter><p>
    The <strong>dependent pair type</strong> is a inductive type <tex>\Sigma _{(x:A)}B(x)</tex> (<tex>(x:A)  \times  B(x)</tex>)
</p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4625</anchor>          </frontmatter> <mainmatter>
    <strong>Formation Rule</strong>
<p/>
    <p>
        Given a type family <tex>B</tex> over <tex>A</tex>, we can form the dependent pair type <tex>\Sigma _{(x:A)}B(x)</tex>.
    </p>
    <tex display="block">          \frac {              \Gamma \vdash  A \space \text {type}               \quad               \Gamma ,x:A \vdash  B(x) \space \text {type}          }{              \Gamma \vdash  (x:A)  \times  B(x) \space \text {type}          }     </tex>
</mainmatter> </tree>
  
 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4626</anchor>          </frontmatter> <mainmatter>
    <strong>Introduction Rule</strong>
<p/>
    <p>
        Given a term <tex>a:A</tex> and a term <tex>b(a):B(a)</tex>, we can form a term <tex>\text {pair} (a,b):(x:A) \times  B(x)</tex>.
    </p>
    <tex display="block">          \frac {              \Gamma \vdash  a:A              \quad               \Gamma \vdash  b(a):B(a)         }{              \Gamma \vdash  (a,b):(x:A) \times  B(x)         }     </tex>
</mainmatter> </tree>
  
 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4627</anchor>          </frontmatter> <mainmatter>
    <strong>Elimination Rule</strong>
<p/>
    <p>
        The elimination rule is formed with two projections.
        <tex display="block">              \frac {                  \Gamma \vdash  p:(x:A) \times  B(x)             }{                  \begin {align*}                      \Gamma &amp; \vdash   \text {pr}_ A (p):A \\                       \Gamma &amp; \vdash   \text {pr}_ B (p):B( \text {pr}_ A (p))                  \end {align*}             }         </tex></p>
</mainmatter> </tree>
  
 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4628</anchor>          </frontmatter> <mainmatter>
    <strong>Computation Rule</strong>
<p/>
    <p><tex display="block">              \frac {                  \Gamma \vdash  x:A                   \quad                    \Gamma \vdash  y:B(x)             }{                  \begin {align*}                      \Gamma &amp; \vdash   \text {pr}_ A ((x,y))=x:A \\                       \Gamma &amp; \vdash   \text {pr}_ B ((x,y))=y:B(x)                  \end {align*}             }         </tex></p>
</mainmatter> </tree>
  
 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4629</anchor>          </frontmatter> <mainmatter>
    <strong>Special Case</strong>
<p/>
    <ul><li>
            In the special case that <tex>B(x) = B</tex> is independent of <tex>A</tex>,
            this reduces to the <strong>product type</strong> <tex>A \times  B</tex>.
        </li>
        <li>
            In the special case that <tex>D  \equiv   \text {Boolean}</tex>,
            this reduces to a <link href="def-0023.xml" type="local" addr="def-0023" title="Coproduct Type">coproduct type</link>.
        </li></ul>
</mainmatter> </tree>
  
</mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>4630</anchor>  <taxon>Type Theory</taxon> <addr>tt-0003</addr>  <route>tt-0003.xml</route> <date><year>2024</year> <month>1</month> <day>30</day></date>  <title>Natural Numbers <tex>\mathbb {N}</tex></title>  </frontmatter> <mainmatter><p>
    In previous post, we have seen the basic inference rules of type theory.
    Now we will see the definition of natural numbers as an inductive type.
    Refer to <link href="hott-book-2013.xml" type="local" addr="hott-book-2013" title="Homotopy Type Theory: Univalent Foundations of Mathematics">HoTT Book</link> and <link href="hott-2022.xml" type="local" addr="hott-2022" title="Introduction to Homotopy Type Theory">Egbert Rijke's</link>.
</p><p>
    In classical mathematics, the <strong>Peano axioms</strong> are a set of axioms for the natural numbers,
    an important object in mathematics.
</p><p>
    In type theory, the type <tex>\mathbb {N}</tex> of natural number is an <link href="def-001X.xml" type="local" addr="def-001X" title="Inductive Type"><strong>inductive type</strong></link>.
    Just like in dependent function type, we need four inference rules to define the natural numbers.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4631</anchor>  <taxon>Definition</taxon> <addr>def-001Y</addr>  <route>def-001Y.xml</route>   <title>Natural Number</title>  </frontmatter> <mainmatter><p>
    In type theory, <strong>natural number</strong> is defined using <strong>peano encoding</strong>.
    The type <tex>\mathbb {N}</tex> is formed by the formation rule:
    <tex display="block">          \frac {}{ \vdash \mathbb {N} \space \text {type} } \mathbb {N} \text {-form}     </tex></p><p>
    Peano's first axiom postulates the existence of a natural number <tex>0</tex>.
    The introduction rule for <tex>\mathbb {N}</tex> has a <tex>0</tex> constructor and a <strong>successor</strong> function.
    <tex display="block">          \frac {}{ \vdash0 : \mathbb {N} } \mathbb {N} \text {-intro-0}          \quad           \frac {}{ \vdash \text {succ} : \mathbb {N} \to \mathbb {N} }  \mathbb {N} \text {-intro-succ}     </tex></p><p>
    The <strong>elimination rule</strong> is actually the type theoretical <strong>induction principle</strong> of <tex>\mathbb {N}</tex>:
    In order to show that <tex>\forall  n: \mathbb {N} .P(n)</tex> holds, it suffices to show that <tex>P(0)</tex> holds and that <tex>\forall  n: \mathbb {N} .P(n) \to  P( \text {succ} (n))</tex> holds.
    The type theoretical induction principle is therefore formulated using a type family <tex>P</tex> over <tex>\mathbb {N}</tex>:
    <tex display="block">          \frac {              \begin {align*}                  \Gamma &amp;, \, n: \mathbb {N} \vdash  P(n) \space \text {type}                   \\                   \Gamma &amp; \vdash  p_0:P(0)                  \\                   \Gamma &amp; \vdash  p_S: \Pi _{(n: \mathbb {N} )}P(n) \to  P( \text {succ} (n))              \end {align*}         }{              \Gamma \vdash \text {ind}_ \mathbb {N} (p_0,p_S): \Pi _{(n: \mathbb {N} )}P(n)         }( \mathbb {N}   \text {-ind})     </tex>
    The induction principle tells us what we need to do in order to construct a dependent function <tex>\text {ind}_ \mathbb {N}</tex> of type <tex>\Pi _{(n: \mathbb {N} )}P(n)</tex>.
    We might alternatively write the induction principle as:
    <tex display="block">          \frac {              \Gamma ,n: \mathbb {N} \vdash  P(n) \space \text {type}          }{              \Gamma \vdash \text {ind}_ \mathbb {N} : \left (P(0) \to \left ( \Pi _{(n: \mathbb {N} )}P(n) \to  P( \text {succ} (n)) \right ) \to \Pi _{(n: \mathbb {N} )}P(n) \right )         }( \mathbb {N}   \text {-ind})     </tex></p><p>
    The <strong>computation rule</strong> asserts that the dependent function <tex>\text {ind}_ \mathbb {N}</tex> behaves as expected:
    <tex display="block">          \frac {              \begin {align*}                  \Gamma &amp;,n: \mathbb {N} \vdash  P(n) \space \text {type}                   \\                   \Gamma &amp; \vdash  p_0:P(0)                  \\                   \Gamma &amp; \vdash  p_S: \Pi _{(n: \mathbb {N} )}P(n) \to  P( \text {succ} (n))              \end {align*}         }{              \text {ind}_ \mathbb {N} (p_0,p_S,m) \equiv               \begin {cases}                 p_0&amp; \text {if }m=0                  \\                  p_S(n, \text {ind}_ \mathbb {N} (p_0,p_S,n))&amp; \text {if }m= \text {succ} (n)              \end {cases}         }( \mathbb {N}   \text {-comp})     </tex></p></mainmatter> </tree><p>
    Now let's use the type theoretical induction principle of <tex>\mathbb {N}</tex> to
    perform some basic construction over <tex>\mathbb {N}</tex>.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4632</anchor>  <taxon>Definition</taxon> <addr>def-001Z</addr>  <route>def-001Z.xml</route>   <title>Addition over <tex>\mathbb {N}</tex></title>  </frontmatter> <mainmatter><p>
    We define addition over <tex>\mathbb {N}</tex> using the type theoretical induction principle of <tex>\mathbb {N}</tex>.
    <tex display="block">          \text {add}_ \mathbb {N}  :  \mathbb {N}   \to  ( \mathbb {N}   \to   \mathbb {N} )     </tex>
    which satisfies the following specification:
    <tex display="block">          \begin {align*}              \text {add}_ \mathbb {N} (n, 0)&amp;: \equiv  n              \\               \text {add}_ \mathbb {N} (m, \text {succ} (n))&amp;: \equiv \text {succ} ( \text {add}_ \mathbb {N} (m,n))          \end {align*}     </tex>
    abbreviated as <tex>m + n</tex> for <tex>\text {add}_ \mathbb {N} (m,n)</tex>.
</p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>4633</anchor>          </frontmatter> <mainmatter><strong>Construction</strong><p/>
    
        <p>
            We construct the additon by perform induction over the second variable <tex>n</tex>.
            That is, to construct an element
            <tex display="block">                 m: \mathbb {N}   \vdash   \text {add}_ \mathbb {N} (m): \mathbb {N}   \to   \mathbb {N}              </tex>
            The context <tex>\Gamma   \equiv  m: \mathbb {N}</tex> is fixed.
        </p>
        Therefore we need to construct:
        <tex display="block">              \begin {align*}                  \Gamma &amp; \vdash   \text {add-zero}_ \mathbb {N} (m): \mathbb {N}                   \\                   \Gamma &amp; \vdash   \text {add-succ}_ \mathbb {N} (m): \mathbb {N} \to \mathbb {N}                               \end {align*}            </tex>
        The <tex>\text {add-zero}_ \mathbb {N}</tex> is defined to be identity function trivially. To see how <tex>\text {add-succ}_ \mathbb {N}</tex> is defined, we need to perform induction:
        <tex display="block">              \begin {align*}                  \text {add}_ \mathbb {N} (m,  \text {succ} (n))&amp; \equiv                   \text {ind}_ \mathbb {N} ( \text {add-zero}_ \mathbb {N} (m),  \text {add-succ}_ \mathbb {N} (m),  \text {succ} (n))                  \\                  &amp; \equiv   \text {add-succ}_ \mathbb {N} (m,n,  \text {add}_ \mathbb {N} (m,n))                  \\                  &amp; \equiv   \text {succ} ( \text {add}_ \mathbb {N} (m,n))              \end {align*}         </tex>
        Hence <tex>\text {add-succ}_ \mathbb {N}</tex> is defined as:
        <tex display="block">              \text {add-succ}_ \mathbb {N} (m,n,x)  \equiv   \text {succ} (x)         </tex>
        A formal construction of <tex>\text {add-succ}_ \mathbb {N}</tex> is as follows:
        <tex display="block">              \dfrac {                  \dfrac {                      \dfrac {                          \dfrac {}{ \vdash \mathbb {N} \space \text {type} }                          \quad                           \dfrac {                              \dfrac {}{ \vdash   \mathbb {N} \space \text {type} }                              \quad                               \dfrac {}{ \vdash   \text {succ} : \mathbb {N} \to \mathbb {N} }                         }{                             n: \mathbb {N} \vdash \text {succ} : \mathbb {N} \to \mathbb {N}                          }                     }{                         m: \mathbb {N} , n: \mathbb {N} \vdash   \text {succ} : \mathbb {N} \to \mathbb {N}                      }                  }{                     m: \mathbb {N} \vdash \lambda  n. \text {succ}  :  \mathbb {N} \to ( \mathbb {N} \to \mathbb {N} )                 }             }{                 m: \mathbb {N} \vdash   \text {add-succ}_ \mathbb {N} (m): \equiv \lambda  m. \text {succ}  :  \mathbb {N} \to ( \mathbb {N} \to \mathbb {N} )             } \text {Block-1}         </tex>
        Finally we combine the derivation together:
        <tex display="block">              \dfrac {                  \dfrac {                      \dfrac {                          \dfrac {                              \vdash   \mathbb {N} \space \text {type}                          }{                             m: \mathbb {N} \vdash  m: \mathbb {N}                          }                     }{                         m: \mathbb {N} \vdash \text {add-zero}_ \mathbb {N} (m): \equiv  m: \mathbb {N}                      }                      \quad                        \dfrac { \text {Block-1}}{                         m: \mathbb {N} \vdash \text {add-succ}_ \mathbb {N} (m): \mathbb {N} \to ( \mathbb {N} \to \mathbb {N} )                     }                 }{                     m: \mathbb {N} \vdash \text {ind}_ \mathbb {N}  ( \text {add-zero}_ \mathbb {N} (m),  \text {add-succ}_ \mathbb {N} (m)): \mathbb {N} \to \mathbb {N}                  }             }{                 m: \mathbb {N} \vdash \text {add}_ \mathbb {N} (m): \equiv \text {ind}_ \mathbb {N}  ( \text {add-zero}_ \mathbb {N} (m),  \text {add-succ}_ \mathbb {N} (m)): \mathbb {N} \to \mathbb {N}              }         </tex>
    
</mainmatter> </tree>
  
</mainmatter> </tree><p>
    Recall the definition of addition function <tex>\text {add}:  \mathbb {N} \to ( \mathbb {N} \to \mathbb {N} )</tex> satisfying the specification:
    <tex display="block">          \begin {align*}             m + 0 &amp; : \equiv  m              \\               m +  \text {succ} (n) &amp; : \equiv   \text {succ} (m + n)          \end {align*}     </tex>
    Such definition is enough to characterize the addition function.
    Because it postulates te <em>behavior</em> of <tex>\text {add}_ \mathbb {N}</tex> at the constructor of <tex>\mathbb {N}</tex></p><p>
    More generally, we can define a dependent function <tex>f: \Pi  n: \mathbb {N} .P(n)</tex> by induction on <tex>n</tex> using
    <tex display="block">          \begin {align*}             p_0 &amp; : P(0)              \\              p_S &amp; :  \Pi _{(n: \mathbb {N} )}P(n) \to  P( \text {succ} (n))          \end {align*}     </tex>
    Just present the definition by writing
    <tex display="block">          \begin {align*}             f(0) &amp; : \equiv  p_0              \\              f( \text {succ} (n)) &amp; : \equiv  p_S(n,f(n))          \end {align*}     </tex>
    <tex>f</tex> is said to be defined by <strong>pattern matching</strong> on the variable <tex>n</tex>.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4634</anchor>  <taxon>Example</taxon> <addr>eg-0001</addr>  <route>eg-0001.xml</route>   <title>Fibonacci Function</title>  </frontmatter> <mainmatter><p>
    The <strong>Fibonacci function</strong> is a well-known function in mathematics.
    It is defined by pattern matching on the variable <tex>n</tex> as follows:
    <tex display="block">          \begin {align*}              \text {fib}(0) &amp; : \equiv  0              \\               \text {fib}(1) &amp; : \equiv  1              \\               \text {fib}(n+2) &amp; : \equiv   \text {fib}(n) +  \text {fib}(n+1)          \end {align*}     </tex></p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>4635</anchor>  <taxon>Type Theory</taxon> <addr>tt-0002</addr>  <route>tt-0002.xml</route> <date><year>2024</year> <month>1</month> <day>27</day></date>  <title>Introduction to Type Theory</title>  </frontmatter> <mainmatter><p>This is a note on dependent type theory. Refer to <link href="hott-book-2013.xml" type="local" addr="hott-book-2013" title="Homotopy Type Theory: Univalent Foundations of Mathematics">HoTT Book</link> and <link href="hott-2022.xml" type="local" addr="hott-2022" title="Introduction to Homotopy Type Theory">Egbert Rijke's</link>.</p><p><strong>Homotopy type theory</strong> is a foundational language for mathematics, an alternative to Zermelo-Fraenkel set theory.
    The set-theoretic foundation has two two layers:
    <ul><li>the deductive system of first-order logic</li>
        <li>the theory of a particular theory, such as ZFC</li></ul> 
    Type theory itself is a deductive system, which has one basic notation: <em>types</em>.
    Propositions are identified with types.
    
    Thus, the activity of proving a theorem is identified with 
    constructing a <em>inhabitant</em> of a certain type.
</p><p>
    Informally, a deductive system is a collection of rules for deriving <strong>judgments</strong>. 
    The judgment is considered to be the external of the theory, living in the <strong>metatheory</strong>.
</p><p>
    In first order logic, there is only one kind of judgment: a proposition has a proof.
    A proposition <tex>P</tex> gives rise to a judgment &quot;<tex>P</tex> has a proof&quot;.
    The proposition <tex>P</tex> lives inside the theory, while the judgment &quot;<tex>P</tex> has a proof&quot; lives in the metatheory. 
</p><p>
    In type theory, analogous to first order logic,
    &quot;<tex>P</tex> has a proof&quot; is written as &quot;<tex>p:P</tex>&quot; (Type <tex>P</tex> has a term <tex>p</tex>).
    <ul><li>If <tex>P</tex> is a proposition, then <tex>p</tex> is a <strong>witness</strong> to the provability of <tex>P</tex>, 
        or <strong>evidence</strong> of the truth of <tex>P</tex>.</li>
        <li><tex>p:P</tex> can also be interpreted as <tex>p \in  P</tex>,
        but <tex>p:P</tex> is a judgment while <tex>p \in  P</tex> is a proposition.</li></ul>
    Working inside type theory we can't write down statements like
    &quot;if <tex>p:P</tex> then ...&quot; nor can we disprove the judgment &quot;<tex>p:P</tex>&quot;.
</p><p>
    A key difference between type theory and set theory is the equality.
    The notion of equality in set theory is simply a proposition.
    Howerver, in type theory, there are two kinds of equality.
    <ul><li>The first kind is the <strong>propositional equality</strong> <tex>a=_Ab</tex>.
        This is a proposition</li>
        <li>The second kind is the <strong>judgmental equality</strong> <tex>a \equiv  b:A</tex>.
        This is a judgment</li></ul>
    Two terms <tex>a:A</tex> and <tex>b:A</tex> are propositionally equal if you can prove <tex>a =_A b</tex> , 
    or equivalently if you can construct a term <tex>h : a =_A b</tex>.
</p>
    <p>
        In type theory there is also a requirement for a judgment-level equality.
        This is called <strong>judgmental equality</strong>, meaning &quot;equal by definition&quot;.
    </p>
    <tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4636</anchor>  <taxon>Definition</taxon> <addr>def-0015</addr>  <route>def-0015.xml</route>   <title>Judgemental Equality</title>  </frontmatter> <mainmatter><p><strong>Judgemental equality</strong> of terms is given by the following judgement:
    <tex display="block">          \Gamma \vdash  a \equiv  a':A     </tex>
    <tex>a</tex> and <tex>a'</tex> are judgementally equal terms of type <tex>A</tex> in context <tex>\Gamma</tex>.
</p><p>
    Note that the notation <tex>\equiv</tex> binds more loosely than anything else.
</p></mainmatter> </tree>
    <p>
        judgments may depend on <em>assumptions</em> of the form <tex>x:A</tex> where <tex>x</tex> is a
        variable and <tex>A</tex> is a type. And the collection (actually ordered list) of such assumptions is called 
        the <strong>context</strong>, denoted <tex>\Gamma</tex>. (from a topological point of view it 
        may be thought of as a <strong>parameters space</strong>).
        The role of a context is to declare what <strong>hypothetical terms</strong> are assumed, 
        along with their types.
        The notation <tex>\vdash</tex> means making conclusion from assumptions.
    </p>
<p>
    Remember the difference between axiom and (inference) rules.
    <ul><li>Rules allow us to conclude one judgment from a collection of other judgments.</li>
        <li>Axioms are judgments that are assumed to be true without proof.</li></ul></p><p>
    We start by introduction to Matrin Lof's dependent type theory. 
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4637</anchor>  <taxon>Definition</taxon> <addr>def-0017</addr>  <route>def-0017.xml</route>   <title>Dependent type theory: Judgments</title>  </frontmatter> <mainmatter>
    <p>
        There are four kinds of judgments in Martin Lof's dependent type theory:
    </p>
    <ul><li><tex>A</tex> is a well-formed type in context <tex>\Gamma</tex>
            <tex display="block">                  \Gamma   \vdash  A  \space \text {type}              </tex></li>
        <li><tex>A</tex> and <tex>B</tex> are judgmentally equal types in context <tex>\Gamma</tex>
            <tex display="block">                  \Gamma   \vdash  A  \equiv  B  \space \text {type}              </tex></li>
        <li><tex>a</tex> is a term of type <tex>A</tex> in context <tex>\Gamma</tex>
            <tex display="block">                  \Gamma   \vdash  a : A             </tex></li>
        <li><tex>a</tex> and <tex>b</tex> are judgmentally equal terms of type <tex>A</tex> in context <tex>\Gamma</tex>
            <tex display="block">                  \Gamma   \vdash  a  \equiv  b : A             </tex></li></ul>
</mainmatter> </tree><p>
    All judgments are context dependent, 
    and indeed that even the types of the variables in a context
    may depend on any previous declared variables.

    To introduce types dependent on terms, 
    we need the notation of type families.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4638</anchor>  <taxon>Definition</taxon> <addr>def-0018</addr>  <route>def-0018.xml</route>   <title>Type Family</title>  </frontmatter> <mainmatter><p>
    Consider a type <tex>A</tex> in context <tex>\Gamma</tex>.
    A <strong>family</strong> of types over <tex>A</tex> in context <tex>\Gamma</tex>
    is a type <tex>B(x)</tex> in context <tex>\Gamma , x:A</tex>.
    <tex display="block">          \Gamma , x:A  \vdash  B(x)  \space \text {type}      </tex>
    <tex>B</tex> is a family of types over <tex>A</tex> in context <tex>\Gamma</tex>.
    Alternatively, we say that <tex>B(x)</tex> is a type <strong>indexed</strong> by <tex>x:A</tex> in context <tex>\Gamma</tex>.
</p></mainmatter> </tree><p>
    Now we can define a term of a type family, that is, a section of a type family.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4639</anchor>  <taxon>Definition</taxon> <addr>def-0019</addr>  <route>def-0019.xml</route>   <title>Section of Type Family</title>  </frontmatter> <mainmatter><p>
    Let <tex>B</tex> be a <link href="def-0018.xml" type="local" addr="def-0018" title="Type Family">type family</link> over <tex>A</tex> in context <tex>\Gamma</tex>.
    A <strong>section</strong> of <tex>B</tex> is a term <tex>b</tex> of type <tex>B(x)</tex> in context <tex>\Gamma ,x:A</tex>.
    <tex display="block">          \Gamma , x:A  \vdash  b : B(x)     </tex>
    Alternatively, we say that <tex>b</tex> is a term of <tex>B(x)</tex> indexed by <tex>x:A</tex> in context <tex>\Gamma</tex>.
</p></mainmatter> </tree><p>
    We now ready to present the inference rules for dependent type theory.
    These rules are known as the <strong>structual rules</strong> of the theory.
    There are 6 sets of rules:
    <ul><li>Formation contexts, types and terms</li>
        <li>Postulating that judgmental equality is an equivalence relation</li>
        <li>Vairable conversion</li>
        <li>Substitution</li>
        <li>Weakening</li>
        <li>Generic element</li></ul></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4640</anchor>  <taxon>Definition</taxon> <addr>def-001A</addr>  <route>def-001A.xml</route>   <title>
    Formation of contexts, types and terms
</title>  </frontmatter> <mainmatter><p>
    The following rules follow from the presuppotion
    about contexts, types and terms, can be used freely.
</p><ul><li><tex display="block">              \frac {                  \Gamma ,x:A \vdash  B(x) \space \text {type}              }{                  \Gamma \vdash  A \space \text {type}              }         </tex></li>
    <li><tex display="block">              \frac {                  \Gamma \vdash  A \equiv  B \space \text {type}              }{                  \Gamma \vdash  A \space \text {type}              }              \quad               \frac {                  \Gamma \vdash  A \equiv  B \space \text {type}              }{                  \Gamma \vdash  B \space \text {type}              }         </tex></li>
    <li><tex display="block">              \frac {                  \Gamma \vdash  a:A             }{                  \Gamma \vdash  A \space \text {type}              }         </tex></li>
    <li><tex display="block">              \frac {                  \Gamma \vdash  a \equiv  b:A             }{                  \Gamma \vdash  a:A             }              \quad                \frac {                  \Gamma \vdash  a \equiv  b:A             }{                  \Gamma \vdash  b:A             }         </tex></li></ul></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4641</anchor>  <taxon>Definition</taxon> <addr>def-001B</addr>  <route>def-001B.xml</route>   <title>
    Judgmental equality is equivalence relation
</title>  </frontmatter> <mainmatter><p>
    Judgmental equality on types and on elements is an <link href="def-000X.xml" type="local" addr="def-000X" title="Equivalence Relation">equivalence relation</link> 
    simply postulate that these relations are reflexive, symmetric, and transitive:
</p><ul><li><tex display="block">              \frac {                  \Gamma \vdash  a:A             }{                  \Gamma \vdash  a \equiv  a:A             }              \quad               \frac {                  \Gamma \vdash  a \equiv  b:A             }{                  \Gamma \vdash  b \equiv  a:A             }              \quad               \frac {                  \Gamma \vdash  a \equiv  b:A                  \quad                   \Gamma \vdash  b \equiv  c:A             }{                  \Gamma \vdash  a \equiv  c:A             }         </tex></li>
    <li><tex display="block">              \frac {                  \Gamma \vdash  A \space \text {type}              }{                  \Gamma \vdash  A \equiv  A \space \text {type}              }              \quad               \frac {                  \Gamma \vdash  A \equiv  B \space \text {type}              }{                  \Gamma \vdash  B \equiv  A \space \text {type}              }              \quad               \frac {                  \Gamma \vdash  A \equiv  B \space \text {type}                   \quad                   \Gamma \vdash  B \equiv  C \space \text {type}              }{                  \Gamma \vdash  A \equiv  C \space \text {type}              }         </tex></li></ul></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4642</anchor>  <taxon>Definition</taxon> <addr>def-001C</addr>  <route>def-001C.xml</route>   <title>Variable Conversion</title>  </frontmatter> <mainmatter><p>
    This rule postulates that we can
    convert the type of a variable to a judgmentally equal type.
    <tex display="block">          \frac {              \Gamma \vdash  A \equiv  A' \space \text {type}               \quad               \Gamma ,x:A, \Delta \vdash  B(x) \space \text {type}          }{              \Gamma ,x:A', \Delta \vdash  B(x) \space \text {type}          }     </tex>
    Similarly, we can convert judgmental equality of types and terms.
    We state all of them at once using a <em>generic judgment thesis</em> <tex>\mathcal {J}</tex>.
    <tex display="block">          \frac {              \Gamma \vdash  A \equiv  A' \space \text {type}               \quad               \Gamma ,x:A, \Delta \vdash   \mathcal {J}         }{              \Gamma ,x:A', \Delta \vdash   \mathcal {J}         }VC     </tex></p></mainmatter> </tree><p>
    Consider a term <tex>f:B(x)</tex> indexed by <tex>x:A</tex> in context <tex>\Gamma</tex>,
    and we also have a term <tex>a:A</tex>.
    We can simultaneously substitute <tex>a</tex> for all occurrences of <tex>x</tex> in <tex>f</tex>
    to obtain a new term <tex>f[x:=a]:B(a)</tex>.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4643</anchor>  <taxon>Definition</taxon> <addr>def-001D</addr>  <route>def-001D.xml</route>   <title>Substitution</title>  </frontmatter> <mainmatter><p>
    The substitution rule postulates that we can substitute a term for a variable.
    <tex display="block">          \frac {              \Gamma \vdash  a:A              \quad               \Gamma ,x:A, \Delta \vdash   \mathcal {J}         }{              \Gamma , \Delta [x:=a] \vdash   \mathcal {J}[x:=a]         }S     </tex>
    The notation <tex>\Gamma , \Delta [x:=a]</tex> means that we substitute <tex>a</tex> for <tex>x</tex> in <tex>\Delta</tex>.
</p><p>
    With the substitution rule, we need two more <em>congruence rules</em> to
    convert judgmental equality of terms and types.
    <tex display="block">          \frac {              \Gamma \vdash  a \equiv  a':A              \quad               \Gamma ,x:A, \Delta \vdash  B  \space \text {type}          }{              \Gamma , \Delta [x:=a] \vdash  B[x:=a] \equiv  B[x:=a']  \space \text {type}          }     </tex>

    <tex display="block">          \frac {              \Gamma \vdash  A \equiv  A' \space \text {type}               \quad               \Gamma ,x:A, \Delta \vdash  b:A         }{              \Gamma , \Delta [x:=a] \vdash  b[x:=a] \equiv  b[x:=a']:A'[x:=a]  \space \text {type}          }     </tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4644</anchor>  <taxon>Definition</taxon> <addr>def-001G</addr>  <route>def-001G.xml</route>   <title>Fiber and Value</title>  </frontmatter> <mainmatter><p>
    Let <tex>B</tex> be a <link href="def-0018.xml" type="local" addr="def-0018" title="Type Family">type family</link> over <tex>A</tex> in context <tex>\Gamma</tex>,
    an a well-formed term <tex>a:A</tex>,
    then we say that <tex>B[x:=a]</tex> is the <strong>fiber</strong> of <tex>B</tex> at <tex>a</tex>, denoted <tex>B(a)</tex>.
</p><p>
    Let <tex>b</tex> a <link href="def-0019.xml" type="local" addr="def-0019" title="Section of Type Family">section</link> of <tex>B</tex> over <tex>A</tex> in context <tex>\Gamma</tex>,
    then we say that <tex>b(a): \equiv  b[x:=a]</tex> is the <strong>value</strong> of <tex>b</tex> at <tex>a</tex>.

</p></mainmatter> </tree><p>
    The process of expanding the context by a fresh variable of type <tex>A</tex> is called weakening (by <tex>A</tex>).
    Intuitively, weakening is the process of adding a new hypothesis to the context.
    And the hypothesis will weaken the conclusion.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4645</anchor>  <taxon>Definition</taxon> <addr>def-001E</addr>  <route>def-001E.xml</route>   <title>Weakening</title>  </frontmatter> <mainmatter><p>
    Weakening rule asserts that we can add a variable to the context.
    <tex display="block">          \frac {              \Gamma \vdash  A \space \text {type}               \quad                \Gamma , \Delta \vdash   \mathcal {J}         }{              \Gamma ,x:A, \Delta \vdash   \mathcal {J}         }W      </tex></p></mainmatter> </tree><p>
    Finally, the generic elemets rule ensures that
    the variables declared in a context.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4646</anchor>  <taxon>Definition</taxon> <addr>def-001F</addr>  <route>def-001F.xml</route>   <title>Generic Elements</title>  </frontmatter> <mainmatter><p>
    The rule for the generic element asserts that 
    any hypothetical element <tex>x:A</tex> in context <tex>\Gamma ,x:A</tex>
    is also an element of <tex>A</tex> in context <tex>\Gamma ,x:A</tex>.
    <tex display="block">          \frac {              \Gamma \vdash  A \space \text {type}          }{              \Gamma ,x:A \vdash  x:A         } \delta      </tex>
    This rule is also called the <strong>variable rule</strong>.   
</p></mainmatter> </tree><p>
    The next topic is the dependent function type, a fundamental concept of dependent type theory.
    Simply put, a dependent function type is a function whose type of output may depend on the input.
</p><p>
    Consider a section <tex>b</tex> of a family <tex>B</tex> over <tex>A</tex> in context <tex>\Gamma</tex>:
    <tex display="block">          \Gamma ,x:A \vdash  b(x):B(x)     </tex>
    Such a section <tex>b</tex> is an operation or assignment <tex>x \mapsto  b(x)</tex> that assigns to each element <tex>x:A</tex>
    to a term <tex>b(x):B(x)</tex>.
    We may see <tex>b</tex> as a function takes <tex>x:A</tex> to <tex>b(x):B(x)</tex>.
    The function <tex>x \mapsto  b(x)</tex> is called a <strong>dependent function</strong>.
    The type of all dependent functions from <tex>A</tex> to <tex>B</tex> is called the <strong>dependent function type</strong>.
    <tex display="block">          \Pi _{(x:A)}B(x)  \text { or } (x:A) \to  B(x)     </tex></p><p>
    To introduce a type we need the following four rules:
    <ul><li>Formation rule</li>
        <li>Introduction rule</li>
        <li>Elimination rule</li>
        <li>Computation rule</li></ul>
    Besides these we also need the <strong>congruence rule</strong> for judgmental equality.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4647</anchor>  <taxon>Definition</taxon> <addr>def-001T</addr>  <route>def-001T.xml</route>   <title>Dependent Function Type</title>  </frontmatter> <mainmatter><p><strong>Formation Rule</strong>
    For any type family <tex>B</tex> over <tex>A</tex> in context <tex>\Gamma</tex>:
    <tex display="block">          \frac {              \Gamma ,x:A \vdash  B(x) \space \text {type}          }{              \Gamma \vdash   \Pi _{(x:A)}B(x) \space \text {type}          } \Pi      </tex>
    We also require that the operation of forming dependent function types
    respects judgmental equality.
    <tex display="block">          \frac {              \Gamma \vdash  A \equiv  A' \space \text {type}               \quad               \Gamma ,x:A \vdash  B(x) \equiv  B'(x) \space \text {type}          }{              \Gamma \vdash   \Pi _{(x:A)}B(x) \equiv   \Pi _{(x:A')}B'(x) \space \text {type}          } \Pi \text {-eq}     </tex></p><p><strong>Introduction Rule (<tex>\lambda</tex>-abstraction)</strong>
    In order to construct a dependent function we have to
    construct a term <tex>f(x):B(x)</tex> indexed by <tex>x:A</tex> in context <tex>\Gamma</tex>:
    <tex display="block">          \frac {              \Gamma ,x:A \vdash  b(x):B(x)         }{              \Gamma \vdash   \lambda  x.b(x): \Pi _{(x:A)}B(x)         } \lambda      </tex>
    And the congruence rule:
    <tex display="block">          \frac {              \Gamma ,x:A \vdash  b(x) \equiv  b'(x):B(x)         }{              \Gamma \vdash   \lambda  x.b(x) \equiv   \lambda  x.b'(x): \Pi _{(x:A)}B(x)         } \lambda \text {-eq}     </tex></p><p><strong>Elimination Rule (Evaluation Rule)</strong>
    In order to use dependent function we need to provide an argument of the domain type.
    <tex display="block">          \frac {              \Gamma \vdash  f: \Pi _{(x:A)}B(x)         }{              \Gamma ,x:A \vdash  f(x):B(x)         }ev     </tex>
    Again we require the judgmental equality to be respected:
    <tex display="block">          \frac {              \Gamma \vdash  f \equiv  f': \Pi _{(x:A)}B(x)         }{              \Gamma ,x:A \vdash  f(x) \equiv  f'(x):B(x)         }ev \text {-eq}     </tex></p><p><strong>Computation Rule (<tex>\beta</tex>-reduction)</strong>
    <tex display="block">          \frac {              \Gamma ,x:A \vdash  b(x):B(x)         }{              \Gamma ,x:A \vdash  ( \lambda  y.b(y))(x) \equiv  b(x):B(x)         } \beta      </tex>
    We postulate that all elements of a dependent function type are dependent functions.
    <tex display="block">          \frac {              \Gamma \vdash  f: \Pi _{(x:A)}B(x)         }{              \Gamma \vdash  f \equiv   \lambda  x.f(x): \Pi _{(x:A)}B(x)         } \eta      </tex></p></mainmatter> </tree><p>
    A degenrated case of dependent function type is the ordinary function type.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>4648</anchor>  <taxon>Definition</taxon> <addr>def-001U</addr>  <route>def-001U.xml</route>   <title>Ordinary Function Type</title>  </frontmatter> <mainmatter><p>
    A special case of <link href="def-001T.xml" type="local" addr="def-001T" title="Dependent Function Type"><tex>\Pi</tex>-type</link> is the <strong>ordinary function type</strong>.
    Using weakening rule we can obtain thee type <tex>A \to  B</tex> of ordinary function from <tex>A</tex> to <tex>B</tex>
    <tex display="block">          \frac {              \Gamma \vdash  A \space \text {type}               \quad               \Gamma \vdash  B \space \text {type}          }{ \dfrac {              \Gamma ,x:A \vdash  B \space \text {type}          }{              \Gamma \vdash   \Pi _{(x:A)}B \space \text {type}          } \Pi }W     </tex>
    A term <tex>f:  \Pi _{(x:A)}B</tex> is an ordinary function. The type <tex>A  \to  B</tex> is defined:
    <tex display="block">         A \to  B :=  \Pi _{(x:A)}B     </tex>
    The type <tex>A</tex> is called <strong>domain</strong> of <tex>f</tex>,
    and type <tex>B</tex> is called <strong>codomain</strong> of <tex>f</tex>.
    The notation <tex>:=</tex> here means to make a definition.
</p></mainmatter> </tree></mainmatter> </tree></backlinks> <references/></backmatter></tree>