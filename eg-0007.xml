<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>855</fr:anchor><fr:taxon>Example</fr:taxon><fr:addr>eg-0007</fr:addr><fr:route>eg-0007.xml</fr:route><fr:title>Divergent Combinator</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    An interesting example named <fr:strong>omega combinator</fr:strong> of beta reduction is the following:
    <fr:tex display="block">          ( ( \lambda  x. ( x \space x ) ) \space ( \lambda  x. ( x \space x ) ) )           \to _ \beta           ( ( \lambda  x. ( x \space x ) ) \space ( \lambda  x. ( x \space x ) ) )      </fr:tex>
    The result of the beta reduction is the same term as the original term,
    and never terminates.
</fr:p></fr:mainmatter><fr:backmatter><fr:contributions></fr:contributions><fr:context><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>854</fr:anchor><fr:taxon>Type Theory</fr:taxon><fr:addr>tt-0001</fr:addr><fr:route>tt-0001.xml</fr:route><fr:title>Untyped Lambda Calculus</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
    Refer to <fr:link href="ttafp-2014.xml" type="local" addr="ttafp-2014">Type Theory and Formal Proof</fr:link>.
</fr:p><fr:p>
    The idea to generalize the behavior of functions in mathematics and logic led to the development of the lambda calculus.
    The lambda calculus is a formal system for expressing computation based on function abstraction and application using <fr:em>variable binding</fr:em> and <fr:em>substitution</fr:em>. 
    In dealing with functions there are two <fr:strong>construction principles</fr:strong> and one <fr:strong>evalutaion rule</fr:strong>.
    <fr:ul><fr:li><fr:strong>Construction Principles</fr:strong>: note that expressions do not force to be meaningful.</fr:li>
        <fr:ul><fr:li>Function Abstraction: <fr:tex>\lambda  x.M</fr:tex></fr:li>
            <fr:li>Function Application: <fr:tex>M N</fr:tex>, this only produces a new expression,
            in which the function has not yet been executed.</fr:li></fr:ul>
    <fr:li><fr:strong>Evaluation Rule</fr:strong></fr:li>
        <fr:ul><fr:li>Beta Reduction: <fr:tex>( \lambda  x.M)N \to  M[x:=N]</fr:tex></fr:li></fr:ul></fr:ul>
    The beta reduction makes use of the <fr:strong>substitution</fr:strong> <fr:tex>M[x:=N]</fr:tex> which represents the result of replacing all free occurrences of <fr:tex>x</fr:tex> in <fr:tex>M</fr:tex> with <fr:tex>N</fr:tex>.
    Note that the application is <fr:strong>left associative</fr:strong>, that is, <fr:tex>MNP</fr:tex> means <fr:tex>(MN)P</fr:tex>.
    And application has the highest precedence, that is, <fr:tex>\lambda  x.MN</fr:tex> means <fr:tex>\lambda  x.(MN)</fr:tex>.
</fr:p><fr:p>
    The multi-argument function <fr:tex>\lambda  x_1 \ldots  x_n.M</fr:tex> is defined as <fr:tex>\lambda  x_1.( \lambda  x_2.( \ldots ( \lambda  x_n.M) \ldots ))</fr:tex> (right associative),
    that is, simulated by a sequence of single-argument functions. The later function is called <fr:strong>curried function</fr:strong> and the
    process of transforming a multi-argument function into a sequence of single-argument functions is called <fr:strong>currying</fr:strong>.
</fr:p>
    <fr:strong>Lambda Terms</fr:strong>
    <fr:p>Expressions in the lambda calculus is called <fr:strong>terms</fr:strong>. The set of terms is denoted <fr:tex>\Lambda</fr:tex>.</fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>250</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-000F</fr:addr><fr:route>def-000F.xml</fr:route><fr:title>Set of Lambda Terms</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
Let <fr:tex>\Lambda</fr:tex> be the set of lambda terms. Then <fr:tex>\Lambda</fr:tex> is defined inductively as follows:
(<fr:tex>V</fr:tex> is the set of variables)
<fr:ul><fr:li>Variable: <fr:tex>\forall  x \in  V, x \in   \Lambda</fr:tex></fr:li>
<fr:li>Abstraction: <fr:tex>\forall  x \in  V, M \in   \Lambda ,  \lambda  x.M \in   \Lambda</fr:tex></fr:li>
<fr:li>Application: <fr:tex>\forall  M,N \in   \Lambda , (MN) \in   \Lambda</fr:tex></fr:li></fr:ul></fr:p><fr:p>
Another way to define <fr:tex>\Lambda</fr:tex> is to use the following grammar (The 3 possibilities are separated by <fr:code>|</fr:code>):
<fr:tex display="block">\Lambda  = V |  \lambda  V. \Lambda  |  \Lambda \Lambda</fr:tex></fr:p></fr:mainmatter></fr:tree>
<fr:p>
    With the following recursive definition we can determine 
    what the <fr:strong>subterms</fr:strong> of a give <fr:tex>\lambda \text {-term}</fr:tex> are. Here we use 
    a concept named <fr:link href="def-0035.xml" type="local" addr="def-0035">multiset</fr:link>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>251</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0036</fr:addr><fr:route>def-0036.xml</fr:route><fr:title>Multiset of Subterms</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    We define a map <fr:tex>\text {Sub}</fr:tex>:
    <fr:ul><fr:li><fr:strong>Basis</fr:strong>: <fr:tex>\forall  x \in  V, \text {Sub} (x) = \{   x   \}</fr:tex></fr:li>
        <fr:li><fr:strong>Application</fr:strong>: <fr:tex>\forall  M,N \in \Lambda , \text {Sub} (MN) =  \text {Sub} (M) \cup \text {Sub} (N) \cup \{   MN   \}</fr:tex></fr:li>
        <fr:li><fr:strong>Abstraction</fr:strong>: <fr:tex>\forall  x \in  V,M \in \Lambda , \text {Sub} ( \lambda  x.M) =  \text {Sub} (M) \cup \{   \lambda  x.M   \}</fr:tex></fr:li></fr:ul>
    <fr:tex>L</fr:tex> is a subterm of <fr:tex>M</fr:tex> if <fr:tex>L \in \text {Sub} (M)</fr:tex>.
    If <fr:tex>L \not \equiv  M</fr:tex> then we say <fr:tex>L</fr:tex> is a <fr:strong>proper subterm</fr:strong> of <fr:tex>M</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    The definition above uses a notation <fr:tex>\equiv</fr:tex> which means <fr:em>syntactic equality</fr:em> here.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>252</fr:anchor><fr:taxon>Example</fr:taxon><fr:addr>eg-0006</fr:addr><fr:route>eg-0006.xml</fr:route><fr:title>Subterms</fr:title></fr:frontmatter><fr:mainmatter><fr:ul><fr:li><fr:tex>\text {Sub} ( ( x \space z ) )</fr:tex> = <fr:tex>\{   x,z, ( x \space z )   \}</fr:tex></fr:li>
    <fr:li><fr:tex>              \text {Sub} ( \lambda  x. ( x \space x ) )              =  \{   \lambda  x. ( x \space x ) , ( x \space x ) ,x,x   \}          </fr:tex></fr:li></fr:ul></fr:mainmatter></fr:tree><fr:p>
    The substerm mapping satisfies the following lemma.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>253</fr:anchor><fr:taxon>Lemma</fr:taxon><fr:addr>thm-000W</fr:addr><fr:route>thm-000W.xml</fr:route><fr:title>Lemma of subterms</fr:title></fr:frontmatter><fr:mainmatter><fr:p><fr:ul><fr:li><fr:strong>Reflexivity</fr:strong>: <fr:tex>\forall  M \in \Lambda ,M \in \text {Sub} (M)</fr:tex></fr:li>
        <fr:li><fr:strong>Transitivity</fr:strong>: <fr:tex>\forall  L,M,N \in \Lambda ,L \in \text {Sub} (M) \land  M \in \text {Sub} (N) \implies  L \in \text {Sub} (N)</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter></fr:tree><fr:p>
    Variable occurrences in a <fr:tex>\lambda \text {-term}</fr:tex> can be divided into 3 categories:
    <fr:ul><fr:li>Bound Occurrences: <fr:tex>x</fr:tex> is bound in <fr:tex>M</fr:tex> if <fr:tex>x</fr:tex> is the argument of an <fr:strong>abstraction</fr:strong> in <fr:tex>M</fr:tex>.</fr:li>
        <fr:li>Free Occurrences: <fr:tex>x</fr:tex> is free in <fr:tex>M</fr:tex> if <fr:tex>x</fr:tex> is not bound by any <fr:strong>abstraction</fr:strong> in <fr:tex>M</fr:tex>.</fr:li>
        <fr:li>Binding Occurrences: something after a lambda notation <fr:tex>\lambda</fr:tex></fr:li></fr:ul>
    We mainly focus on the <fr:strong>free variables</fr:strong> of a term.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>254</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0037</fr:addr><fr:route>def-0037.xml</fr:route><fr:title>Set of Free Variables</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>FV(L)</fr:tex> be the set of free variables in a term <fr:tex>L</fr:tex>.
    <fr:ul><fr:li><fr:strong>Variable</fr:strong>: <fr:tex>\forall  x \in  V, \text {FV} (x) =  \{   x   \}</fr:tex></fr:li>
        <fr:li><fr:strong>Application</fr:strong>: <fr:tex>\forall  M,N \in \Lambda , \text {FV} (MN) =  \text {FV} (M) \cup \text {FV} (N)</fr:tex></fr:li>
        <fr:li><fr:strong>Abstraction</fr:strong>: <fr:tex>\forall  x \in  V,M \in \Lambda , \text {FV} ( \lambda  x.M) =  \text {FV} (M) \setminus \{   x   \}</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>255</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0038</fr:addr><fr:route>def-0038.xml</fr:route><fr:title>Closed Lambda Terms</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:tex>\lambda \text {-term}</fr:tex> <fr:tex>M</fr:tex> is <fr:strong>closed</fr:strong> if <fr:tex>\text {FV} (M) =  \emptyset</fr:tex>.
    A closed <fr:tex>\lambda \text {-term}</fr:tex> is also called a <fr:strong>combinator</fr:strong>.
    The set of all combinators is denoted by <fr:tex>\Lambda ^0</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>256</fr:anchor><fr:title>Alpha conversion</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:parent>tt-0001</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Functions in <fr:tex>\lambda \text {-calculus}</fr:tex> have the property that the name of 
    the binding variables is irrelevant.
    In order to describe this equality we need to define a relation
    called <fr:tex>\alpha \text {-conversion}</fr:tex> or <fr:tex>\alpha \text {-equivalence}</fr:tex>,
    which is based on the process of renaming binding variables.</fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>257</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0039</fr:addr><fr:route>def-0039.xml</fr:route><fr:title>Renaming</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>M ^{ x \to y }</fr:tex> be the result of replacing all free occurrences of <fr:tex>x</fr:tex> in <fr:tex>M</fr:tex> with <fr:tex>y</fr:tex>.
    The relation <fr:strong>renaming</fr:strong> is expression with the symbol <fr:tex>=_ \alpha</fr:tex>:
    <fr:tex>\lambda  x.M =_ \alpha \lambda  y. M ^{ x \to y }</fr:tex> if <fr:tex>y \not \in \text {FV} (M)</fr:tex> and <fr:tex>y</fr:tex> is not a binding variable in <fr:tex>M</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    The definition of <fr:strong>renaming</fr:strong> should be extended to more general terms.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>258</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003A</fr:addr><fr:route>def-003A.xml</fr:route><fr:title>Alpha Equivalence</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:tex>\alpha</fr:tex> equivalence is a relation between <fr:tex>\lambda \text {-term}</fr:tex>, defined as follows:
    <fr:ul><fr:li><fr:strong>Renaming</fr:strong>: <fr:tex>\lambda  x. M  =_ \alpha   \lambda  y.  M ^{ x \to y }</fr:tex> if <fr:tex>y \not \in \text {FV} (M)</fr:tex> and <fr:tex>y</fr:tex> is not a binding variable in <fr:tex>M</fr:tex>.
        </fr:li>
        <fr:li><fr:strong>Compatibility</fr:strong>: If <fr:tex>M =_ \alpha  N</fr:tex> then <fr:tex>\lambda  x.M =_ \alpha \lambda  x.N</fr:tex> and <fr:tex>ML  =_ \alpha  NL, LM  =_ \alpha  LN</fr:tex>.
        </fr:li>
        <fr:li><fr:strong>Reflexivity</fr:strong>: <fr:tex>M =_ \alpha  M</fr:tex>.
        </fr:li>
        <fr:li><fr:strong>Symmetry</fr:strong>: If <fr:tex>M =_ \alpha  N</fr:tex> then <fr:tex>N =_ \alpha  M</fr:tex>.
        </fr:li>
        <fr:li><fr:strong>Transitivity</fr:strong>: If <fr:tex>M =_ \alpha  N</fr:tex> and <fr:tex>N =_ \alpha  L</fr:tex> then <fr:tex>M =_ \alpha  L</fr:tex>.
        </fr:li></fr:ul>
    The first principle is the basis of alpha equivalence, which is the same as <fr:link href="def-0039.xml" type="local" addr="def-0039">renaming</fr:link>.
    The last 3 properties ensures that <fr:tex>=_ \alpha</fr:tex> is an <fr:link href="def-000X.xml" type="local" addr="def-000X">equivalence relation</fr:link>.
    
</fr:p><fr:p>
    If <fr:tex>M =_ \alpha  N</fr:tex> then we say <fr:tex>M</fr:tex> and <fr:tex>N</fr:tex> are <fr:tex>\alpha \text {-equivalent}</fr:tex> or <fr:tex>\alpha \text {-convertible}</fr:tex>.
    <fr:tex>M</fr:tex> is an <fr:tex>\alpha \text {-variant}</fr:tex> of <fr:tex>N</fr:tex> and vice versa.

</fr:p></fr:mainmatter></fr:tree><fr:p>
    In previous sections we informally mentioned the concept of <fr:strong>substitution</fr:strong>.
    Now we give a precise formulation
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>259</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003B</fr:addr><fr:route>def-003B.xml</fr:route><fr:title>Substitution</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>substitution</fr:strong> is defined by the following rules:
    <fr:ul><fr:li><fr:tex>M [ x := N ] : \equiv  N</fr:tex></fr:li>
        <fr:li><fr:tex>y [ x := N ] : \equiv  y</fr:tex> if <fr:tex>y \not \equiv  x</fr:tex></fr:li>
        <fr:li><fr:tex>(PQ) [ x := N ] : \equiv ( P [ x := N ] )( Q [ x := N ] )</fr:tex></fr:li>
        <fr:li><fr:tex>( \lambda  y.P) [ x := N ] : \equiv \lambda  z. P ^{ y \to z } [ x := N ]</fr:tex> 
            if <fr:tex>\lambda  z. P ^{ y \to z }   =_ \alpha   \lambda  y.P</fr:tex> and <fr:tex>z \not \in \text {FV} (N)</fr:tex></fr:li></fr:ul>
    The terms with form <fr:tex>P [ x := N ]</fr:tex> are not <fr:tex>\lambda \text {-term}</fr:tex>,
    but we can regard them as a <fr:em>meta notation</fr:em> that appears
    in the substitution process and the result contains no such terms.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    Renaming can be considered as a special case of substitution.
    We can show that <fr:tex>M ^{ x \to u } =_ \alpha M [ x := u ]</fr:tex> if the conditions of renaming are satisfied.
</fr:p><fr:p>
    We may do <fr:strong>sequential substitution</fr:strong> in a term,
    that is, doing a number of substitutions consecutively.
    And we have the following lemma, which states that the order of substitution is important.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>260</fr:anchor><fr:taxon>Lemma</fr:taxon><fr:addr>thm-000X</fr:addr><fr:route>thm-000X.xml</fr:route><fr:title>Substitution is not commutative</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>x \not \equiv  y</fr:tex> and assume <fr:tex>x \not \in \text {FV} (L)</fr:tex>.
    Then <fr:tex>L[y:=N][x:=M]  \equiv  L[x:=M][y:=N[x:=M]]</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>261</fr:anchor><fr:title><fr:tex>\lambda \text {-term}</fr:tex> modulo <fr:tex>\alpha \text {-equivalence}</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:parent>tt-0001</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>As we have seen, the relation <fr:tex>=_ \alpha</fr:tex> is an equivalence relation.
    Hence we can define the set of equivalence classes of terms with respect to <fr:tex>=_ \alpha</fr:tex>.
    Now we can identify a term with its equivalence class.
    We still use <fr:tex>\equiv</fr:tex> for syntactic equality modulo <fr:tex>\alpha \text {-equivalence}</fr:tex>.
    </fr:p></fr:mainmatter></fr:tree><fr:p><fr:tex>\alpha \text {-equivalence}</fr:tex> is a congruence relation, which means that it is conserved by elementary process of term construction.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>262</fr:anchor><fr:taxon>Lemma</fr:taxon><fr:addr>thm-000Y</fr:addr><fr:route>thm-000Y.xml</fr:route><fr:title>Congruence Property of Substitution</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>L =_ \alpha  M</fr:tex> and <fr:tex>N =_ \alpha  P</fr:tex>.
    <fr:ul><fr:li><fr:tex>                 LN  =_ \alpha  MP             </fr:tex></fr:li>
        <fr:li><fr:tex>                  \lambda  x.L  =_ \alpha   \lambda  x.M             </fr:tex></fr:li>
        <fr:li><fr:tex>                  L [ x := N ]   =_ \alpha   M [ x := P ]              </fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>263</fr:anchor><fr:title>Barendregt Convention</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:parent>tt-0001</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The Barendregt Convention states that we should avoid using the same variable name in different abstractions.
    This is to avoid the confusion of free variables. It states that 
    we choose the names for the binding variables in a <fr:tex>\lambda \text {-term}</fr:tex> in such a manner
    that they are all different, and each of them differs from 
    all free variables occurring in the term.</fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>264</fr:anchor><fr:title>Beta Reduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:parent>tt-0001</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
        Since we have formally defined the <fr:strong>substitution</fr:strong>,
        we can rephrase the reduction as a relation on <fr:tex>\lambda \text {-term}</fr:tex>, namely <fr:tex>\beta \text {-reduction}</fr:tex>.
    </fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>265</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003C</fr:addr><fr:route>def-003C.xml</fr:route><fr:title>One Step Beta Reduction</fr:title></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>One step beta reduction</fr:strong> (<fr:tex>\to _ \beta</fr:tex>) is defined as follows:
    <fr:ul><fr:li><fr:strong>Basis</fr:strong>:
            <fr:tex>                 ( \lambda  x.M)N \to _ \beta M [ x := N ]              </fr:tex></fr:li>
        <fr:li><fr:strong>Compatibility</fr:strong>:
            If <fr:tex>M \to _ \beta  N</fr:tex> then <fr:tex>\lambda  x.M \to _ \beta \lambda  x.N</fr:tex>,
            <fr:tex>ML \to _ \beta  NL</fr:tex> and <fr:tex>LM \to _ \beta  LN</fr:tex>.
        </fr:li></fr:ul></fr:p><fr:p>
    The term of the form <fr:tex>( \lambda  x.M)N</fr:tex> is called a <fr:strong>redex (reducible expression)</fr:strong>.
    The term of the form <fr:tex>M [ x := N ]</fr:tex> is called the <fr:strong>contractum</fr:strong> (of the redex).
</fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>266</fr:anchor><fr:taxon>Example</fr:taxon><fr:addr>eg-0007</fr:addr><fr:route>eg-0007.xml</fr:route><fr:title>Divergent Combinator</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    An interesting example named <fr:strong>omega combinator</fr:strong> of beta reduction is the following:
    <fr:tex display="block">          ( ( \lambda  x. ( x \space x ) ) \space ( \lambda  x. ( x \space x ) ) )           \to _ \beta           ( ( \lambda  x. ( x \space x ) ) \space ( \lambda  x. ( x \space x ) ) )      </fr:tex>
    The result of the beta reduction is the same term as the original term,
    and never terminates.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    We can often perform a sequence of beta reductions. This leads to the definition.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>267</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003D</fr:addr><fr:route>def-003D.xml</fr:route><fr:title>Beta Reduction</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>(zero-or-more-step) beta reduction</fr:strong> (<fr:tex>\twoheadrightarrow _{ \beta }</fr:tex>) is a
    generalized version of the <fr:link href="def-003C.xml" type="local" addr="def-003C">one step beta reduction</fr:link>.
    <fr:tex>M \twoheadrightarrow _{ \beta }  N</fr:tex> if there exists <fr:tex>n \geq  0</fr:tex> and there are terms <fr:tex>M_0,M_1, \ldots ,M_n</fr:tex>
    such that <fr:tex>M_0=M</fr:tex>, <fr:tex>M_n=N</fr:tex> and <fr:tex>M_i \to _ \beta  M_{i+1}</fr:tex> for <fr:tex>0 \leq  i&lt;n</fr:tex>.
    In other words there exists a chain of one-step beta reductions from <fr:tex>M</fr:tex> to <fr:tex>N</fr:tex>.
    <fr:tex display="block">         M \equiv  M_0 \to _ \beta  M_1 \to _ \beta \cdots \to _ \beta  M_n \equiv  N     </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>268</fr:anchor><fr:taxon>Lemma</fr:taxon><fr:addr>thm-000Z</fr:addr><fr:route>thm-000Z.xml</fr:route><fr:title>Properties of Beta Reduction</fr:title></fr:frontmatter><fr:mainmatter><fr:p><fr:ul><fr:li><fr:strong>Compatibility</fr:strong>:
            <fr:tex>\twoheadrightarrow _{ \beta }</fr:tex> extends <fr:tex>\to _ \beta</fr:tex>, i.e. if <fr:tex>M \to _ \beta  N</fr:tex> then <fr:tex>M \twoheadrightarrow _{ \beta }  N</fr:tex>.
        </fr:li>
        <fr:li><fr:strong>Reflixivity</fr:strong>:
            <fr:tex>                 M \twoheadrightarrow _{ \beta }  M             </fr:tex></fr:li>
        <fr:li><fr:strong>Transitivity</fr:strong>:
            <fr:tex>                 M \twoheadrightarrow _{ \beta }  N  \land  N \twoheadrightarrow _{ \beta }  P  \implies  M \twoheadrightarrow _{ \beta }  P             </fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:context><fr:related></fr:related><fr:backlinks><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>853</fr:anchor><fr:taxon>Compute Science</fr:taxon><fr:addr>cs-0002</fr:addr><fr:route>cs-0002.xml</fr:route><fr:title>Primitive Recursion in Lambda Calculus</fr:title></fr:frontmatter><fr:mainmatter><fr:p> 
    We begin with the <fr:strong>schema of iteration</fr:strong> and then proceed 
    the more complex schema of primitive recursion and general recursion.
    Refer to <fr:link href="tapl.xml" type="local" addr="tapl">TAPL</fr:link>.
</fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>369</fr:anchor><fr:title><fr:strong>Function Composition</fr:strong></fr:title><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
    Giving two functions <fr:tex>f, g</fr:tex> we can compose then to get a new function <fr:tex>f \circ  g = f(g(x))</fr:tex>.
    Using <fr:tex>\lambda</fr:tex>-notation, we can define the composition of two functions as follows:
    <fr:tex display="block">         f \circ  g =  \lambda  x.f(g(x))     </fr:tex>
    And the composition operation is also a lambda abstraction.
    <fr:tex display="block">          \circ  = B =  \lambda  f. \lambda  g. \lambda  x.f(g(x))     </fr:tex>
    Composing identity function with any function does not change the function.
    We expect the following equation to hold:
    <fr:tex display="block">         f \circ  I = f = I \circ  f     </fr:tex>
    where <fr:tex>I</fr:tex> is the identity function. This can be verified by the following calculation:
    <fr:tex display="block">          \begin {align*}             B \space  f \space  I &amp;= ( \lambda  f. \lambda  g. \lambda  x.f(g(x))) \space  f \space  I  \\              &amp; \to _ \beta   \lambda  g. \lambda  x.f(g(x)) \space  I  \\              &amp; \to _ \beta   \lambda  x.f(I(x))  \\              &amp; \to _ \beta   \lambda  x.f(x)  \\              &amp; =_ \eta  f          \end {align*}     </fr:tex>
    The last step requires an extensional equality, which is the called <fr:strong>eta-conversion</fr:strong>.
    <fr:tex display="block">          \text {for} \space  x \not \in \text {FV} (f) , \lambda  x.f(x)  =_ \eta  f     </fr:tex>
    It makes more sense to use the equation from right to left called <fr:strong>eta-expansion</fr:strong> 
    (And more discipline has to be imposed or expansion does not terminate).
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>370</fr:anchor><fr:title><fr:strong>Non-termination</fr:strong></fr:title><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
        The well-known <fr:link href="eg-0007.xml" type="local" addr="eg-0007"><fr:strong>divergent combinator</fr:strong></fr:link> implies that 
        the lambda calculus is not strongly normalizing.
    </fr:p>
    <fr:p>
        However, we can always compute a normal form if one exists.
        Though there are many reduction strategies,
        there is a complete one for expressions that have normal form.
        This kind of reduction strategy is called <fr:strong>normal order reduction</fr:strong> or
        <fr:strong>leftmost-outermost reduction</fr:strong>. It scans through the expression from left to right
        and when it find a redex, it reduces it by applying beta reduction and returns to the beginning.
    </fr:p>
    <fr:p>
        The notation of leftmost-outermost reduction is closely related to the 
        notion of <fr:strong>call-by-name evaluation</fr:strong> in programming languages.
        (A little more distance to <fr:strong>call-by-need</fr:strong> evaluation in Haskell)
    </fr:p>
    <fr:p>
        In contrast, <fr:strong>call-by-value</fr:strong> evaluation is not complete, which would 
        reduce the argument of a function before applying beta reduction.
    </fr:p>
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>371</fr:anchor><fr:title><fr:strong>Church-Rosser Property</fr:strong></fr:title><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
    The outcome of a computation <fr:tex>e</fr:tex> is its normal form.
    It is naturally to ask the question whether the normal form is unique.
    The key to this question is the <fr:strong>Church-Rosser property</fr:strong> or <fr:strong>confluence</fr:strong>:
    If <fr:tex>e \to ^* e_1</fr:tex> and <fr:tex>e \to ^* e_2</fr:tex>, then there exists a term <fr:tex>e_3</fr:tex> such that
    <fr:tex display="block">         e_1 \to ^* e_3 \space \text {and} \space  e_2 \to ^* e_3     </fr:tex>
    This implies the uniqueness of the normal form.
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>373</fr:anchor><fr:title><fr:strong>Representing Natural Numbers</fr:strong></fr:title><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
        We can represent natural numbers in lambda calculus by using the 
        <fr:strong>Church numerals</fr:strong> or <fr:strong>Church encoding</fr:strong>.
        The two abstractions should be related in some ways: 
        one <fr:tex>x</fr:tex> stands for zero and the other <fr:tex>f</fr:tex> stands for the successor function.
    </fr:p>
    <fr:p>
        The Church numeral <fr:tex>n</fr:tex> is a function that takes two arguments <fr:tex>f</fr:tex> and <fr:tex>x</fr:tex> and applies <fr:tex>f</fr:tex> to <fr:tex>x</fr:tex> <fr:tex>n</fr:tex> times.
        The Church numeral <fr:tex>0</fr:tex> is defined as the identity function <fr:tex>\lambda  f. \lambda  x.x</fr:tex>.
        The Church numeral <fr:tex>1</fr:tex> is defined as the successor of <fr:tex>0</fr:tex>:
        <fr:tex display="block">             1 =  \lambda  f. \lambda  x.f(x)         </fr:tex>
        The Church numeral <fr:tex>2</fr:tex> is defined as the successor of <fr:tex>1</fr:tex>:
        <fr:tex display="block">             2 =  \lambda  f. \lambda  x.f(f(x))         </fr:tex>
        And so on.
    </fr:p>
    <fr:p>
        The Church numeral <fr:tex>n</fr:tex> is defined as the successor of <fr:tex>n-1</fr:tex>:
        <fr:tex display="block">             n =  \lambda  f. \lambda  x.f^n(x)         </fr:tex>
        where <fr:tex>f^n(x)</fr:tex> means applying <fr:tex>f</fr:tex> to <fr:tex>x</fr:tex> <fr:tex>n</fr:tex> times.
    </fr:p>
    <fr:p>
        The successor function is defined as follows:
        <fr:tex display="block">             S =  \lambda  n. \lambda  f. \lambda  x.f(n \space  f \space  x)         </fr:tex></fr:p>
    
 
   
   <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>372</fr:anchor><fr:taxon>Proof</fr:taxon><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                  \begin {align*}                     S \space  n &amp;= ( \lambda  n. \lambda  f. \lambda  x.f(n \space  f \space  x)) \space  n  \\                      &amp; \to _ \beta   \lambda  f. \lambda  x.f(n \space  f \space  x)  \\                      &amp; \to _ \beta   \lambda  f. \lambda  x.f^n(x)  \\                      &amp; \to _ \beta  n+1                  \end {align*}             </fr:tex>
        </fr:mainmatter></fr:tree>
 

    <fr:p>
        Using the iteration property we can define mathematical functions 
        over the natural numbers in lambda calculus.
        The addition of two Church numerals <fr:tex>m</fr:tex> and <fr:tex>n</fr:tex> is defined as follows:
        <fr:tex display="block">             m+n =  \lambda  n. \lambda  k. n \space  S \space  k         </fr:tex></fr:p>
    <fr:p>
        The multiplication of two Church numerals <fr:tex>m</fr:tex> and <fr:tex>n</fr:tex> is defined by
        iterating the addition function <fr:tex>m</fr:tex> times:
        <fr:tex display="block">             m*n =  \lambda  n. \lambda  k. n \space  (k + )  \space  0         </fr:tex></fr:p>
    <fr:p>
        The exponentiation of two Church numerals <fr:tex>m</fr:tex> and <fr:tex>n</fr:tex> is defined as follows:
        <fr:tex display="block">             m^n =  \lambda  m. \lambda  n. n \space  (m *)  \space  1         </fr:tex></fr:p>
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>374</fr:anchor><fr:title><fr:strong>The Schema of Iteration</fr:strong></fr:title><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
        As we saw before, a natural number <fr:tex>n</fr:tex> is represented by a function 
        that iterates its first argument <fr:tex>n</fr:tex> times on its second argument.
        <fr:tex display="block">             n =  \lambda  g. \lambda  c.g^n(c)         </fr:tex>
        Another way to specify such a function schematically is 
        <fr:tex display="block">              \begin {align*}                 f  \space0  &amp;= c  \\                  f (n+1) &amp;= g \space  (f \space  n)              \end {align*}         </fr:tex>
        If such a function satisfies such a <fr:strong>schema of iteration</fr:strong>, then it can 
        be defined in the lambda calculus on Church numerals as
        <fr:tex display="block">             f =  \lambda  n.n  \space  g  \space  c         </fr:tex>
        This definition is <fr:strong>total</fr:strong> which means it is defined for all natural numbers.
        Let&apos;s define the multiplication again
        <fr:tex display="block">              \begin {align*}                 m*0 &amp;= 0  \\                  m*(n+1) &amp;= m + (m*n)              \end {align*}         </fr:tex>
        To fit our schema of iteration, we can define the multiplication by abstracting over <fr:tex>k</fr:tex>:
        <fr:tex display="block">              \begin {align*}                  \text {times} \space  0 &amp;=  \lambda  k.0  \\                   \text {times} \space  (n+1) &amp;=  \lambda  k.k + ( \text {times} \space  n \space  k)              \end {align*}         </fr:tex>
        where the <fr:tex>c</fr:tex> and <fr:tex>g</fr:tex> are
        <fr:tex display="block">              \begin {align*}                 c &amp;=  \lambda  k.0  \\                  g &amp;=  \lambda  r. \lambda  k.k+(r \space  k)              \end {align*}         </fr:tex>
        and we obtain
        <fr:tex display="block">              \text {times} =  \lambda  n.n( \lambda  rk. k + (r \space  k))( \lambda  k.0)         </fr:tex></fr:p>
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>379</fr:anchor><fr:title><fr:strong>The Schema of Primitive Recursion</fr:strong></fr:title><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
        Everything appears simply until we think of a very simple function,
        the <fr:strong>predecessor function</fr:strong> <fr:tex>\text {pred}</fr:tex> defined by
        <fr:tex display="block">              \begin {align*}                  \text {pred} \space  0 = 0  \\                   \text {pred} \space  (n+1) = n              \end {align*}         </fr:tex>
        What we would need is the <fr:strong>schema of primitive recursion</fr:strong>
        <fr:tex display="block">              \begin {align*}                 f \space  0 &amp;= c  \\                  f \space  (n+1) &amp;= g \space  n \space  (f \space  n)              \end {align*}         </fr:tex>
        With which we can define the predecessor function by 
        <fr:tex display="block">             g =  \lambda  x. \lambda  y.x         </fr:tex></fr:p>
    
    
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>375</fr:anchor><fr:title><fr:strong>Define predecessor function</fr:strong></fr:title><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
        The key idea is to gain access to <fr:tex>n</fr:tex> in the schema of 
        primitive recursion by rebuilding it during the iteration.
        <fr:tex display="block">              \text {pred}_2 \space  n =  \langle  n,  \text {pred} \space  n  \rangle          </fr:tex>
        The key step is to express the definition by a schema of iteration
        rather than primitive recursion.
        <fr:tex display="block">              \text {pred}_2 \space  0 =  \langle  0, 0  \rangle          </fr:tex>
        We need a helper function for the successor case
        <fr:tex display="block">              \text {letPair} \space \langle  e_1,e_2 \rangle \space  k = k \space  e_1 \space  e_2         </fr:tex>
        This function passes the elements of the pair to a <fr:strong>continuation</fr:strong> <fr:tex>k</fr:tex>.
        <fr:tex display="block">              \text {pred}_2 (n+1) =  \text {letPair} \space  ( \text {pred}_2 \space  n) \space  ( \lambda  xy.  \langle  x+1, x  \rangle )          </fr:tex>
    </fr:mainmatter></fr:tree>

    
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>376</fr:anchor><fr:title><fr:strong>Define Pairs</fr:strong></fr:title><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
        Now we need to define pairs and <fr:tex>\text {letPair}</fr:tex>.
        The idea is to simply abstract over the continuation itself.
        <fr:tex display="block">              \begin {align*}                  \langle  x,y \rangle  &amp;=  \lambda  k.k \space  x \space  y  \\                   \text {pair} &amp;=  \lambda  x. \lambda  y. \lambda  k.k \space  x \space  y  \\                    \text {letPair} &amp;=  \lambda  p.p              \end {align*}         </fr:tex>
        The letPair is not really needed here.
    </fr:mainmatter></fr:tree>

    
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>377</fr:anchor><fr:title><fr:strong>Summary</fr:strong></fr:title><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
        Summarizing the above and we obtain the full definition of the predecessor function.
        <fr:tex display="block">              \begin {align*}                  \text {pred}_2 &amp;=  \lambda  n.n \space  ( \lambda  p.p ( \lambda  xy. \text {pair}  \space  (x+1)  \space  x)) \space   \text {pair} ( \space  0  \space  0) \\                    \text {pred} &amp;=  \lambda  n. ( \text {pred}_2 \space  n)  \space  ( \lambda  xy.y)              \end {align*}            </fr:tex>
    </fr:mainmatter></fr:tree>

    
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>378</fr:anchor><fr:title><fr:strong>General Primitive Recursion</fr:strong></fr:title><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
        The general case of primitive recursion follows by a similar pattern.
        We begin by defining a function <fr:tex>f_2</fr:tex>:
        <fr:tex display="block">             f_2 \space  n =  \langle  n, f \space  n  \rangle          </fr:tex>
        We can define <fr:tex>f_2</fr:tex> using the schema of iteration
        <fr:tex display="block">              \begin {align*}                 f_2 \space  0 &amp;=  \langle  0, c  \rangle   \\                  f_2 \space  (n+1) &amp;=  \text {letPair} \space  (f_2 \space  n) \space  ( \lambda  xy. \langle  x+1, g \space  x \space  y  \rangle )  \\                  f \space  n &amp;=  \text {letPair} \space  (f_2 \space  n) \space  ( \lambda  xy.y)              \end {align*}         </fr:tex>
    </fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>
<fr:p>
    When computing over natural numbers we can restrict the functions that can be 
    formed in schematic ways to obtain a language in which all functions <fr:strong>terminate</fr:strong>.
    Because if <fr:tex>c</fr:tex> and <fr:tex>g</fr:tex> are terminating then so is <fr:tex>f</fr:tex> formed from them by primitive recursion.
</fr:p></fr:mainmatter></fr:tree></fr:backlinks><fr:references></fr:references></fr:backmatter></fr:tree>