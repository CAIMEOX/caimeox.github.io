<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>397</fr:anchor><fr:addr type="machine">#338</fr:addr><fr:route>unstable-338.xml</fr:route><fr:title text="Algebraic Graphs › Core of Algebraic Graphs › Graph Construction"><fr:link type="local" href="unstable-337.xml" addr="#337" title="Algebraic Graphs › Core of Algebraic Graphs"><fr:link type="local" href="cs-0008.xml" addr="cs-0008" title="Algebraic Graphs">Algebraic Graphs</fr:link> › Core of Algebraic Graphs</fr:link> › Graph Construction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#337</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The simplest possible graph is the empty graph. We denote it by <fr:tex display="inline"> \epsilon  = (\varnothing , \varnothing ) </fr:tex>.
            A graph with a single vertex is <fr:tex display="inline"> \text {Vertex} x = (\{x\}, \varnothing ) </fr:tex>.
            To construct larger graphs from the above primitives we define binary operations overlay and connect, denoted by <fr:tex display="inline"> + </fr:tex> and <fr:tex display="inline"> \to  </fr:tex> respectively.
            The overlay operation <fr:tex display="inline"> + </fr:tex> is defined as:
            <fr:tex display="block">                 (V_1, E_1) + (V_2, E_2) = (V_1 \cup  V_2, E_1 \cup  E_2)             </fr:tex>
            The connect operation <fr:tex display="inline"> \to  </fr:tex> is defined similarly (We give it a higher precedence than <fr:tex display="inline"> + </fr:tex>):
            <fr:tex display="block">                 (V_1, E_1) \to  (V_2, E_2) = (V_1 \cup  V_2, E_1 \cup  E_2 \cup  V_1 \times  V_2)             </fr:tex></fr:p><fr:p>As shown above, the core can be represented by a simple data type <fr:code>Graph</fr:code>, parameterized by the type of vertices <fr:code>a</fr:code>.
            We can push this further by defining a type class <fr:code>GraphLike</fr:code> that captures the core operations of the algebraic graph.</fr:p></fr:mainmatter><fr:backmatter><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title text="Context">Context</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>398</fr:anchor><fr:addr type="user">cs-0008</fr:addr><fr:route>cs-0008.xml</fr:route><fr:title text="Algebraic Graphs">Algebraic Graphs</fr:title><fr:taxon>Graph Theory</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This post focus on the the algebra of graphs introduced in paper <fr:strong>Algebraic graphs with class (functional pearl)</fr:strong>,
    which built on rigorous mathematical foundation that allows us to apply equational reasoning for proving the correctness of graph transformation algorithms.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>381</fr:anchor><fr:addr type="machine">#336</fr:addr><fr:route>unstable-336.xml</fr:route><fr:title text="Introduction to Graphs">Introduction to Graphs</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0008</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Graphs are ubiquitous in computing. Roughly speaking, a graph is a collection of vertices and edges, where each edge connects two vertices.
        For the most trivial case, a graph is an ordered pair <fr:tex display="inline"> G=(V,E)</fr:tex> comprising:
        <fr:ul><fr:li><fr:tex display="inline"> V </fr:tex> is a set of vertices.</fr:li>
            <fr:li><fr:tex display="inline"> E \subseteq  \{ (x,y) \mid  x, y \in  V\} </fr:tex> is a set of edges.</fr:li></fr:ul>
        We can define a graph type in some programming languages (e.g. Haskell) as:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Graph a = Graph [a] [(a, a)]</html:code></fr:pre>

        Work with such low-level fiddling with sets of vertices and edges is very painful. And we can easily construct a graph that breaks the invariant of the graph structure like <fr:code>Graph [1] [(1,2)]</fr:code> which has an edge connecting a non-existent vertex.</fr:p><fr:p>How the state-of-art libraries deal with this problem? 
        The <fr:strong>container</fr:strong> library in Haskell provides a type <fr:code>Data.Graph</fr:code> which represents graph using adjacency array:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">type Graph a = Array a [a]</html:code></fr:pre>

        which ensures performance and generality. But the consistency invariant is not <fr:strong>statically</fr:strong> checked, which may lead
        to runtime errors like <fr:code>index out of ranges</fr:code>. Another approach is the <fr:strong>fgl</fr:strong> (Martin Erwig&apos;s Functional Graph Library)
        where the graph is introduced as an <fr:strong>inductive type</fr:strong>. The approach is very complex and its API contains partial functions.
        So is there a <fr:strong>safe</fr:strong> graph construction interface we can build on top?</fr:p><fr:p><fr:strong>Andrey Mokhov</fr:strong>&apos;s paper presents a new interface for constructing and transforming graphs in a safe and convenient manner.
        And abstract away from the actual representation details and characterize graphs by a set of axioms, just like numbers are algebraically characterized
        by rings. The core calculus is based on the algebra of parameterized graphs. Algebraic graphs have a safe and minimalistic core of four graph construction primitives, as captured by the following data type:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Graph a
    = Empty
    | Vertex a
    | Overlay (Graph a) (Graph a)
    | Connect (Graph a) (Graph a)</html:code></fr:pre></fr:p><fr:p>The <fr:code>Empty</fr:code> and <fr:code>Vertex</fr:code> construct the empty and single-vertex graphs respectively. <fr:code>Overlay</fr:code> composes two graphs by taking the union of their vertices and edges, and <fr:code>Connect</fr:code> is similar to <fr:code>Overlay</fr:code> but also creates edges between vertices of the two graphs. 
        
        The overlay and connect operations have three properties:
        <fr:ul><fr:li>(Closure)  They are closed on the set of graphs (all total functions)</fr:li>
            <fr:li>(Complete) They can be used to construct any graph starting from the empty and single-vertex graphs</fr:li>
            <fr:li>(Sound) Malformed graphs are impossible to construct</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>385</fr:anchor><fr:addr type="machine">#337</fr:addr><fr:route>unstable-337.xml</fr:route><fr:title text="Core of Algebraic Graphs">Core of Algebraic Graphs</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0008</fr:parent></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>386</fr:anchor><fr:addr type="machine">#338</fr:addr><fr:route>unstable-338.xml</fr:route><fr:title text="Graph Construction">Graph Construction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#337</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The simplest possible graph is the empty graph. We denote it by <fr:tex display="inline"> \epsilon  = (\varnothing , \varnothing ) </fr:tex>.
            A graph with a single vertex is <fr:tex display="inline"> \text {Vertex} x = (\{x\}, \varnothing ) </fr:tex>.
            To construct larger graphs from the above primitives we define binary operations overlay and connect, denoted by <fr:tex display="inline"> + </fr:tex> and <fr:tex display="inline"> \to  </fr:tex> respectively.
            The overlay operation <fr:tex display="inline"> + </fr:tex> is defined as:
            <fr:tex display="block">                 (V_1, E_1) + (V_2, E_2) = (V_1 \cup  V_2, E_1 \cup  E_2)             </fr:tex>
            The connect operation <fr:tex display="inline"> \to  </fr:tex> is defined similarly (We give it a higher precedence than <fr:tex display="inline"> + </fr:tex>):
            <fr:tex display="block">                 (V_1, E_1) \to  (V_2, E_2) = (V_1 \cup  V_2, E_1 \cup  E_2 \cup  V_1 \times  V_2)             </fr:tex></fr:p><fr:p>As shown above, the core can be represented by a simple data type <fr:code>Graph</fr:code>, parameterized by the type of vertices <fr:code>a</fr:code>.
            We can push this further by defining a type class <fr:code>GraphLike</fr:code> that captures the core operations of the algebraic graph.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>387</fr:anchor><fr:addr type="machine">#339</fr:addr><fr:route>unstable-339.xml</fr:route><fr:title text="Type Class">Type Class</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#337</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>We abstract the graph construction primitives defined above as the type class Graph (Note that assocaited types requires <fr:code>TypeFamilies</fr:code> GHC extension):
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">class Graph g where
    type Vertex g
    empty :: g
    vertex :: Vertex g -&gt; g
    overlay :: g -&gt; g -&gt; g
    connect :: g -&gt; g -&gt; g</html:code></fr:pre></fr:p><fr:p>This interface is very simple and easy to use, which allows fewer opportunities for usage errors and greater opportunities for reuse.
            Now let&apos;s create some functions to construct graphs. For instance, a single edge is obtained by connecting two vertices:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">edge :: (Graph g) =&gt; Vertex g -&gt; Vertex g -&gt; g
edge x y = connect (vertex x) (vertex y)</html:code></fr:pre></fr:p><fr:p>A graph that contains a given list of isolated vertices can be constructed as follows:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">vertices :: Graph g =&gt; [Vertex g] -&gt; g
vertices = foldr (overlay . vertex) empty</html:code></fr:pre>

            which turns each vertex into a singleton graph and overlay the results. By replacing the 
            <fr:code>overlay</fr:code> with <fr:code>connect</fr:code> we can construct a full connected graph.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">clique :: (Graph g) =&gt; [Vertex g] -&gt; g
clique = foldr (connect . vertex) empty</html:code></fr:pre></fr:p><fr:p>The graph construction functions defined above are total, fully polymorphic, and elegant. 
            Thanks to the minimalistic core type class, it is easy to wrap our favourite graph library into the described interface, 
            and reuse the functions defined with graph class.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>392</fr:anchor><fr:addr type="machine">#340</fr:addr><fr:route>unstable-340.xml</fr:route><fr:title text="Algebraic Structure">Algebraic Structure</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0008</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>In this section we characterise the <fr:code>Graph</fr:code> type class with a set of axioms that reveal an algebraic structure very similar to a semiring. This provides a convenient framework for proving graph properties, using equational reasoning. The presented characterization is generally useful for formal verification, as well as automated testing of graph library APIs.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:backmatter></fr:tree>