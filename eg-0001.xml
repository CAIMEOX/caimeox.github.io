<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>914</fr:anchor><fr:taxon>Example</fr:taxon><fr:addr>eg-0001</fr:addr><fr:route>eg-0001.xml</fr:route><fr:title>Fibonacci Function</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>Fibonacci function</fr:strong> is a well-known function in mathematics.
    It is defined by pattern matching on the variable <fr:tex>n</fr:tex> as follows:
    <fr:tex display="block">          \begin {align*}              \text {fib}(0) &amp; : \equiv  0              \\               \text {fib}(1) &amp; : \equiv  1              \\               \text {fib}(n+2) &amp; : \equiv   \text {fib}(n) +  \text {fib}(n+1)          \end {align*}     </fr:tex></fr:p></fr:mainmatter><fr:backmatter><fr:contributions></fr:contributions><fr:context><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>913</fr:anchor><fr:taxon>Type Theory</fr:taxon><fr:addr>tt-0003</fr:addr><fr:route>tt-0003.xml</fr:route><fr:title>Natural Numbers <fr:tex>\mathbb {N}</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
    In previous post, we have seen the basic inference rules of type theory.
    Now we will see the definition of natural numbers as an inductive type.
    Refer to <fr:link href="hott-book-2013.xml" type="local" addr="hott-book-2013">HoTT Book</fr:link> and <fr:link href="hott-2022.xml" type="local" addr="hott-2022">Egbert Rijke&apos;s</fr:link>.
</fr:p><fr:p>
    In classical mathematics, the <fr:strong>Peano axioms</fr:strong> are a set of axioms for the natural numbers,
    an important object in mathematics.
</fr:p><fr:p>
    In type theory, the type <fr:tex>\mathbb {N}</fr:tex> of natural number is an <fr:link href="def-001X.xml" type="local" addr="def-001X"><fr:strong>inductive type</fr:strong></fr:link>.
    Just like in dependent function type, we need four inference rules to define the natural numbers.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>536</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001Y</fr:addr><fr:route>def-001Y.xml</fr:route><fr:title>Natural Number</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    In type theory, <fr:strong>natural number</fr:strong> is defined using <fr:strong>peano encoding</fr:strong>.
    The type <fr:tex>\mathbb {N}</fr:tex> is formed by the formation rule:
    <fr:tex display="block">          \frac {}{ \vdash \mathbb {N} \space \text {type} } \mathbb {N} \text {-form}     </fr:tex></fr:p><fr:p>
    Peano&apos;s first axiom postulates the existence of a natural number <fr:tex>0</fr:tex>.
    The introduction rule for <fr:tex>\mathbb {N}</fr:tex> has a <fr:tex>0</fr:tex> constructor and a <fr:strong>successor</fr:strong> function.
    <fr:tex display="block">          \frac {}{ \vdash0 : \mathbb {N} } \mathbb {N} \text {-intro-0}          \quad           \frac {}{ \vdash \text {succ} : \mathbb {N} \to \mathbb {N} }  \mathbb {N} \text {-intro-succ}     </fr:tex></fr:p><fr:p>
    The <fr:strong>elimination rule</fr:strong> is actually the type theoretical <fr:strong>induction principle</fr:strong> of <fr:tex>\mathbb {N}</fr:tex>:
    In order to show that <fr:tex>\forall  n: \mathbb {N} .P(n)</fr:tex> holds, it suffices to show that <fr:tex>P(0)</fr:tex> holds and that <fr:tex>\forall  n: \mathbb {N} .P(n) \to  P( \text {succ} (n))</fr:tex> holds.
    The type theoretical induction principle is therefore formulated using a type family <fr:tex>P</fr:tex> over <fr:tex>\mathbb {N}</fr:tex>:
    <fr:tex display="block">          \frac {              \begin {align*}                  \Gamma &amp;, \, n: \mathbb {N} \vdash  P(n) \space \text {type}                   \\                   \Gamma &amp; \vdash  p_0:P(0)                  \\                   \Gamma &amp; \vdash  p_S: \Pi _{(n: \mathbb {N} )}P(n) \to  P( \text {succ} (n))              \end {align*}         }{              \Gamma \vdash \text {ind}_ \mathbb {N} (p_0,p_S): \Pi _{(n: \mathbb {N} )}P(n)         }( \mathbb {N}   \text {-ind})     </fr:tex>
    The induction principle tells us what we need to do in order to construct a dependent function <fr:tex>\text {ind}_ \mathbb {N}</fr:tex> of type <fr:tex>\Pi _{(n: \mathbb {N} )}P(n)</fr:tex>.
    We might alternatively write the induction principle as:
    <fr:tex display="block">          \frac {              \Gamma ,n: \mathbb {N} \vdash  P(n) \space \text {type}          }{              \Gamma \vdash \text {ind}_ \mathbb {N} : \left (P(0) \to \left ( \Pi _{(n: \mathbb {N} )}P(n) \to  P( \text {succ} (n)) \right ) \to \Pi _{(n: \mathbb {N} )}P(n) \right )         }( \mathbb {N}   \text {-ind})     </fr:tex></fr:p><fr:p>
    The <fr:strong>computation rule</fr:strong> asserts that the dependent function <fr:tex>\text {ind}_ \mathbb {N}</fr:tex> behaves as expected:
    <fr:tex display="block">          \frac {              \begin {align*}                  \Gamma &amp;,n: \mathbb {N} \vdash  P(n) \space \text {type}                   \\                   \Gamma &amp; \vdash  p_0:P(0)                  \\                   \Gamma &amp; \vdash  p_S: \Pi _{(n: \mathbb {N} )}P(n) \to  P( \text {succ} (n))              \end {align*}         }{              \text {ind}_ \mathbb {N} (p_0,p_S,m) \equiv               \begin {cases}                 p_0&amp; \text {if }m=0                  \\                  p_S(n, \text {ind}_ \mathbb {N} (p_0,p_S,n))&amp; \text {if }m= \text {succ} (n)              \end {cases}         }( \mathbb {N}   \text {-comp})     </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:p>
    Now let&apos;s use the type theoretical induction principle of <fr:tex>\mathbb {N}</fr:tex> to
    perform some basic construction over <fr:tex>\mathbb {N}</fr:tex>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>538</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001Z</fr:addr><fr:route>def-001Z.xml</fr:route><fr:title>Addition over <fr:tex>\mathbb {N}</fr:tex></fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    We define addition over <fr:tex>\mathbb {N}</fr:tex> using the type theoretical induction principle of <fr:tex>\mathbb {N}</fr:tex>.
    <fr:tex display="block">          \text {add}_ \mathbb {N}  :  \mathbb {N}   \to  ( \mathbb {N}   \to   \mathbb {N} )     </fr:tex>
    which satisfies the following specification:
    <fr:tex display="block">          \begin {align*}              \text {add}_ \mathbb {N} (n, 0)&amp;: \equiv  n              \\               \text {add}_ \mathbb {N} (m, \text {succ} (n))&amp;: \equiv \text {succ} ( \text {add}_ \mathbb {N} (m,n))          \end {align*}     </fr:tex>
    abbreviated as <fr:tex>m + n</fr:tex> for <fr:tex>\text {add}_ \mathbb {N} (m,n)</fr:tex>.
</fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>537</fr:anchor><fr:title><fr:strong>Construction</fr:strong></fr:title><fr:parent>def-001Z</fr:parent></fr:frontmatter><fr:mainmatter>
    
        <fr:p>
            We construct the additon by perform induction over the second variable <fr:tex>n</fr:tex>.
            That is, to construct an element
            <fr:tex display="block">                 m: \mathbb {N}   \vdash   \text {add}_ \mathbb {N} (m): \mathbb {N}   \to   \mathbb {N}              </fr:tex>
            The context <fr:tex>\Gamma   \equiv  m: \mathbb {N}</fr:tex> is fixed.
        </fr:p>
        Therefore we need to construct:
        <fr:tex display="block">              \begin {align*}                  \Gamma &amp; \vdash   \text {add-zero}_ \mathbb {N} (m): \mathbb {N}                   \\                   \Gamma &amp; \vdash   \text {add-succ}_ \mathbb {N} (m): \mathbb {N} \to \mathbb {N}                               \end {align*}            </fr:tex>
        The <fr:tex>\text {add-zero}_ \mathbb {N}</fr:tex> is defined to be identity function trivially. To see how <fr:tex>\text {add-succ}_ \mathbb {N}</fr:tex> is defined, we need to perform induction:
        <fr:tex display="block">              \begin {align*}                  \text {add}_ \mathbb {N} (m,  \text {succ} (n))&amp; \equiv                   \text {ind}_ \mathbb {N} ( \text {add-zero}_ \mathbb {N} (m),  \text {add-succ}_ \mathbb {N} (m),  \text {succ} (n))                  \\                  &amp; \equiv   \text {add-succ}_ \mathbb {N} (m,n,  \text {add}_ \mathbb {N} (m,n))                  \\                  &amp; \equiv   \text {succ} ( \text {add}_ \mathbb {N} (m,n))              \end {align*}         </fr:tex>
        Hence <fr:tex>\text {add-succ}_ \mathbb {N}</fr:tex> is defined as:
        <fr:tex display="block">              \text {add-succ}_ \mathbb {N} (m,n,x)  \equiv   \text {succ} (x)         </fr:tex>
        A formal construction of <fr:tex>\text {add-succ}_ \mathbb {N}</fr:tex> is as follows:
        <fr:tex display="block">              \dfrac {                  \dfrac {                      \dfrac {                          \dfrac {}{ \vdash \mathbb {N} \space \text {type} }                          \quad                           \dfrac {                              \dfrac {}{ \vdash   \mathbb {N} \space \text {type} }                              \quad                               \dfrac {}{ \vdash   \text {succ} : \mathbb {N} \to \mathbb {N} }                         }{                             n: \mathbb {N} \vdash \text {succ} : \mathbb {N} \to \mathbb {N}                          }                     }{                         m: \mathbb {N} , n: \mathbb {N} \vdash   \text {succ} : \mathbb {N} \to \mathbb {N}                      }                  }{                     m: \mathbb {N} \vdash \lambda  n. \text {succ}  :  \mathbb {N} \to ( \mathbb {N} \to \mathbb {N} )                 }             }{                 m: \mathbb {N} \vdash   \text {add-succ}_ \mathbb {N} (m): \equiv \lambda  m. \text {succ}  :  \mathbb {N} \to ( \mathbb {N} \to \mathbb {N} )             } \text {Block-1}         </fr:tex>
        Finally we combine the derivation together:
        <fr:tex display="block">              \dfrac {                  \dfrac {                      \dfrac {                          \dfrac {                              \vdash   \mathbb {N} \space \text {type}                          }{                             m: \mathbb {N} \vdash  m: \mathbb {N}                          }                     }{                         m: \mathbb {N} \vdash \text {add-zero}_ \mathbb {N} (m): \equiv  m: \mathbb {N}                      }                      \quad                        \dfrac { \text {Block-1}}{                         m: \mathbb {N} \vdash \text {add-succ}_ \mathbb {N} (m): \mathbb {N} \to ( \mathbb {N} \to \mathbb {N} )                     }                 }{                     m: \mathbb {N} \vdash \text {ind}_ \mathbb {N}  ( \text {add-zero}_ \mathbb {N} (m),  \text {add-succ}_ \mathbb {N} (m)): \mathbb {N} \to \mathbb {N}                  }             }{                 m: \mathbb {N} \vdash \text {add}_ \mathbb {N} (m): \equiv \text {ind}_ \mathbb {N}  ( \text {add-zero}_ \mathbb {N} (m),  \text {add-succ}_ \mathbb {N} (m)): \mathbb {N} \to \mathbb {N}              }         </fr:tex>
    
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:p>
    Recall the definition of addition function <fr:tex>\text {add}:  \mathbb {N} \to ( \mathbb {N} \to \mathbb {N} )</fr:tex> satisfying the specification:
    <fr:tex display="block">          \begin {align*}             m + 0 &amp; : \equiv  m              \\               m +  \text {succ} (n) &amp; : \equiv   \text {succ} (m + n)          \end {align*}     </fr:tex>
    Such definition is enough to characterize the addition function.
    Because it postulates te <fr:em>behavior</fr:em> of <fr:tex>\text {add}_ \mathbb {N}</fr:tex> at the constructor of <fr:tex>\mathbb {N}</fr:tex></fr:p><fr:p>
    More generally, we can define a dependent function <fr:tex>f: \Pi  n: \mathbb {N} .P(n)</fr:tex> by induction on <fr:tex>n</fr:tex> using
    <fr:tex display="block">          \begin {align*}             p_0 &amp; : P(0)              \\              p_S &amp; :  \Pi _{(n: \mathbb {N} )}P(n) \to  P( \text {succ} (n))          \end {align*}     </fr:tex>
    Just present the definition by writing
    <fr:tex display="block">          \begin {align*}             f(0) &amp; : \equiv  p_0              \\              f( \text {succ} (n)) &amp; : \equiv  p_S(n,f(n))          \end {align*}     </fr:tex>
    <fr:tex>f</fr:tex> is said to be defined by <fr:strong>pattern matching</fr:strong> on the variable <fr:tex>n</fr:tex>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>539</fr:anchor><fr:taxon>Example</fr:taxon><fr:addr>eg-0001</fr:addr><fr:route>eg-0001.xml</fr:route><fr:title>Fibonacci Function</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>Fibonacci function</fr:strong> is a well-known function in mathematics.
    It is defined by pattern matching on the variable <fr:tex>n</fr:tex> as follows:
    <fr:tex display="block">          \begin {align*}              \text {fib}(0) &amp; : \equiv  0              \\               \text {fib}(1) &amp; : \equiv  1              \\               \text {fib}(n+2) &amp; : \equiv   \text {fib}(n) +  \text {fib}(n+1)          \end {align*}     </fr:tex></fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:context><fr:related></fr:related><fr:backlinks></fr:backlinks><fr:references></fr:references></fr:backmatter></fr:tree>