<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>839</fr:anchor><fr:addr type="machine">#342</fr:addr><fr:route>unstable-342.xml</fr:route><fr:title text="Categorical Semantics for Type Theories › Logic, Types and Categories › Logic as Adjoint Functors"><fr:link type="local" href="unstable-339.xml" addr="#339" title="Categorical Semantics for Type Theories › Logic, Types and Categories"><fr:link type="local" href="cs-0007.xml" addr="cs-0007" title="Categorical Semantics for Type Theories">Categorical Semantics for Type Theories</fr:link> › Logic, Types and Categories</fr:link> › Logic as Adjoint Functors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#339</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Categorical logic is a new approach to logic, due to <fr:strong>Lawvere</fr:strong>. 
            He showed that logical constructs are fundamentally just <fr:strong>adjoint functors</fr:strong>.
            This allows us to capture many logical constructs by using only one categorical concept.
            Adjoint also provides a strong guarantee about the derived syntactic formulation.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>607</fr:anchor><fr:addr type="user">def-003V</fr:addr><fr:route>def-003V.xml</fr:route><fr:title text="Adjoint Functor">Adjoint Functor</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">\mathcal {C}</fr:tex> and <fr:tex display="inline">\mathcal {D}</fr:tex> be categories and a pair of functors 
    <fr:tex display="inline">F:\mathcal {C}\to \mathcal {D}</fr:tex> and <fr:tex display="inline">G:\mathcal {D}\to \mathcal {C}</fr:tex>. This is called 
    pair of <fr:strong>adjoint functors</fr:strong> (or <fr:strong>adjunction</fr:strong>) with <fr:tex display="inline">F</fr:tex> the left adjoint
    and <fr:tex display="inline">G</fr:tex> the right adjoint denoted 
    <fr:tex display="block">         F\dashv  G     </fr:tex>
    if there is a natural isomorphism between the hom-functors:
    <fr:tex display="block">         \hom _{\mathcal {D}}(F(-),-)\cong \hom _{\mathcal {C}}(-,G(-))     </fr:tex>
    which means forall objects <fr:tex display="inline">C\in \mathcal {C}</fr:tex> and <fr:tex display="inline">D\in \mathcal {D}</fr:tex>, there is a bijection
    <fr:tex display="block">         \hom _{\mathcal {D}}(F(C),D)\cong \hom _{\mathcal {C}}(C,G(D)) \\          (F(C)\xrightarrow {f}D) \mapsto  (C\xrightarrow {G(f)}G(D))     </fr:tex>
    which is natural in both <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title text="Context">Context</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>840</fr:anchor><fr:addr type="user">cs-0007</fr:addr><fr:route>cs-0007.xml</fr:route><fr:title text="Categorical Semantics for Type Theories">Categorical Semantics for Type Theories</fr:title><fr:taxon>Type Theory</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is a collection of notes on categorical semantics for type theories.
    The notes are based on the <fr:link type="local" href="cs-tt-2020.xml" addr="cs-tt-2020" title="Categorical Semantics for Type Theories">paper</fr:link> by Jason Z.S. Hu and <fr:link type="local" href="ncatlab.xml" addr="ncatlab" title="NLab">NLab</fr:link>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>590</fr:anchor><fr:addr type="machine">#336</fr:addr><fr:route>unstable-336.xml</fr:route><fr:title text="Introduction">Introduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0007</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Over the last few decades, many type systems are designed for different purposes:
        general program safety, security, and correctness. The <fr:strong>categorical semantics</fr:strong>
        is a collection of methods which define meanings of types and programs in category theory.</fr:p><fr:p>Category theory is a branch of mathematics studying an abstract kind of mappings, called morphisms,
        and their algebraic relations. Its generality serves as a common language for navigating connections
        between different concepts in different areas. We will first go over some basic concepts in category theory.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>591</fr:anchor><fr:addr type="machine">#337</fr:addr><fr:route>unstable-337.xml</fr:route><fr:title text="Basic Category Theory concepts">Basic Category Theory concepts</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0007</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Formally, a definition in category theory consists of two parts: data and axioms.
        The most basic definition is the <fr:strong>category</fr:strong></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>592</fr:anchor><fr:addr type="user">def-003E</fr:addr><fr:route>def-003E.xml</fr:route><fr:title text="Category">Category</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>513</fr:anchor><fr:addr type="machine">#315</fr:addr><fr:route>unstable-315.xml</fr:route><fr:title text="With one collection"><fr:strong>With one collection</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>def-003E</fr:parent></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex display="inline">C</fr:tex> consists
    <fr:ul><fr:li>A collection of <fr:strong>objects</fr:strong> <fr:tex display="inline">C_0</fr:tex> (<fr:tex display="inline">\text {Ob}(C)</fr:tex>).</fr:li>
        <fr:li>A collection <fr:tex display="inline">C_1</fr:tex> (<fr:tex display="inline">\text {Mor}(C)</fr:tex>) of <fr:strong>morphisms</fr:strong> (arrows).</fr:li>
        <fr:li>For every morphism <fr:tex display="inline">f</fr:tex> there are an object <fr:tex display="inline">s(f)</fr:tex> (<fr:strong>source</fr:strong>, domain) and an object <fr:tex display="inline">t(f)</fr:tex> (<fr:strong>target</fr:strong>, codomain).</fr:li>
        <fr:li>For every pair of morphisms <fr:tex display="inline">f, g</fr:tex> such that <fr:tex display="inline">t(f) = s(g)</fr:tex>, there is a morphism <fr:tex display="inline">g \circ  f</fr:tex> (<fr:strong>composition</fr:strong>) (Also written <fr:tex display="inline">gf</fr:tex> or <fr:tex display="inline">f;g</fr:tex>).</fr:li>
        <fr:li>For every object <fr:tex display="inline">x</fr:tex>, there is a morphism <fr:tex display="inline">\text {id}_x</fr:tex> (or <fr:tex display="inline">1_x</fr:tex>) called <fr:strong>identity</fr:strong>.</fr:li>
        <fr:li>The following properties hold:
            <fr:ul><fr:li><fr:tex display="inline">s(g \circ  f) = s(f)</fr:tex> and <fr:tex display="inline">t(g \circ  f) = t(g)</fr:tex>.</fr:li>
                <fr:li><fr:tex display="inline">s(1_x) = x</fr:tex> and <fr:tex display="inline">t(1_x) = x</fr:tex>.</fr:li>
                <fr:li>Composition is <fr:strong>associative</fr:strong>: <fr:tex display="inline">h \circ  (g \circ  f) = (h \circ  g) \circ  f</fr:tex> when <fr:tex display="inline">t(f) = s(g)</fr:tex>, and <fr:tex display="inline">t(g) = s(h)</fr:tex>.</fr:li>
                <fr:li>Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex display="inline">f \circ  \text {id}_x = f</fr:tex> and <fr:tex display="inline">\text {id}_y \circ  f = f</fr:tex></fr:li></fr:ul></fr:li></fr:ul>
    If the identity map and its axioms are omitted then one speaks of a <fr:strong>semicategory</fr:strong>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>514</fr:anchor><fr:addr type="machine">#316</fr:addr><fr:route>unstable-316.xml</fr:route><fr:title text="With a family of collections of morphisms"><fr:strong>With a family of collections of morphisms</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>def-003E</fr:parent></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex display="inline">C</fr:tex> consists
    <fr:ul><fr:li>A collection of <fr:strong>objects</fr:strong> <fr:tex display="inline">C_0</fr:tex> (<fr:tex display="inline">\text {Ob}(C)</fr:tex>).</fr:li>
        <fr:li>For every pair of objects <fr:tex display="inline">x, y</fr:tex>, a collection <fr:tex display="inline">C_1(x, y)</fr:tex> (<fr:tex display="inline">\hom _C(x,y)</fr:tex>) of <fr:strong>morphisms</fr:strong> from <fr:tex display="inline">x</fr:tex> to <fr:tex display="inline">y</fr:tex>.</fr:li>
        <fr:li>For each pair of morphisms <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex> and <fr:tex display="inline">g</fr:tex> in <fr:tex display="inline">C_1(y,z)</fr:tex>, a morphism <fr:tex display="inline">g \circ  f</fr:tex> in <fr:tex display="inline">C_1(x,z)</fr:tex>.
            called their <fr:strong>composition</fr:strong>.</fr:li>
        <fr:li>For each object <fr:tex display="inline">x</fr:tex>, a morphism <fr:tex display="inline">\text {id}_x</fr:tex> in <fr:tex display="inline">C_1(x,x)</fr:tex> called the <fr:strong>identity</fr:strong> on <fr:tex display="inline">x</fr:tex>.</fr:li>
        <fr:li>The following properties hold:
            <fr:ul><fr:li>Composition is <fr:strong>associative</fr:strong>: <fr:tex display="inline">h \circ  (g \circ  f) = (h \circ  g) \circ  f</fr:tex> for all <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex>, <fr:tex display="inline">g</fr:tex> in <fr:tex display="inline">C_1(y,z)</fr:tex>, and <fr:tex display="inline">h</fr:tex> in <fr:tex display="inline">C_1(z,w)</fr:tex>.</fr:li>
                <fr:li>Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex display="inline">f \circ  \text {id}_x = f</fr:tex> and <fr:tex display="inline">\text {id}_y \circ  f = f</fr:tex> for all <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex>.</fr:li></fr:ul></fr:li></fr:ul>
    Usually we write <fr:tex display="inline">\text {Mor}(C)</fr:tex> for the disjoint union <fr:tex display="inline">\bigsqcup _{x,y \in  C_0} C_1(x,y)</fr:tex>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We only talk about <fr:strong>collections</fr:strong> here, which is vague, because we do not specify 
        they are sets or classes. If both objects and morphisms fit in sets, we say the category
        is <fr:strong>small</fr:strong>. For a counterexample, the category of all sets is not small. However,
        all functions between sets can be contained in a set. In this case, the category is <fr:strong>locally small</fr:strong>.
        When morphisms between two objects fit in a set, we call the set <fr:strong>hom-set</fr:strong>.</fr:p><fr:p>Since category theory is constructed to study structures and a category is actually a structure,
        we can talk about the category of all small categories <fr:tex display="inline">\mathbf {Cat}</fr:tex>. Similar to morphisms, we can 
        define <fr:strong>functor</fr:strong> between categories.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>593</fr:anchor><fr:addr type="user">def-003G</fr:addr><fr:route>def-003G.xml</fr:route><fr:title text="Functor">Functor</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>functor</fr:strong> <fr:tex display="inline">F</fr:tex> from a category <fr:tex display="inline">C</fr:tex> to a category <fr:tex display="inline">D</fr:tex> is a map
    sending each <fr:tex display="inline">x\in  C</fr:tex> to an object <fr:tex display="inline">F(x)\in  D</fr:tex> and each morphism
    <fr:tex display="inline">f:x\to  y</fr:tex> in <fr:tex display="inline">C</fr:tex> to morphism <fr:tex display="inline">F(f):F(x)\to  F(y)</fr:tex> in <fr:tex display="inline">D</fr:tex>, such that 
    <fr:ul><fr:li>Composition is preserved: <fr:tex display="inline">F(g\circ  f) = F(g)\circ  F(f)</fr:tex>.</fr:li>
        <fr:li>Identity is preserved: <fr:tex display="inline">F(\text {id}_x) = \text {id}_{F(x)}</fr:tex>.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We can push this idea further by considering functors as objects and <fr:strong>natural transformations</fr:strong> as morphisms.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>594</fr:anchor><fr:addr type="user">def-003I</fr:addr><fr:route>def-003I.xml</fr:route><fr:title text="Functor Category">Functor Category</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex> be categories, the functor category <fr:tex display="inline">D^C</fr:tex> 
    (or <fr:tex display="inline">[C,D]</fr:tex>) is the category whose
    <fr:ul><fr:li>objects are functors from <fr:tex display="inline">C</fr:tex> to <fr:tex display="inline">D</fr:tex>.</fr:li>
        <fr:li>morphisms are <fr:strong>natural transformations</fr:strong> between functors.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Here we use a <fr:strong>commutative diagram</fr:strong> to represent a natural transformation.
        When a diagram commutes, morphisms composed by different paths with the same end points
        are equal. The following diagram represents the equality that <fr:tex display="inline">G(f)\circ \alpha _x = \alpha _y\circ  F(f)</fr:tex>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>595</fr:anchor><fr:addr type="user">def-003J</fr:addr><fr:route>def-003J.xml</fr:route><fr:title text="Natural Transformation">Natural Transformation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex> be categories and <fr:tex display="inline">F,G:C\to  D</fr:tex> be functors.
    A <fr:strong>natural transformation</fr:strong> <fr:tex display="inline">\alpha :F\Rightarrow   G</fr:tex> is 
    an assignment to every object <fr:tex display="inline">x\in  C</fr:tex> of a morphism <fr:tex display="inline">\alpha _x:F(x)\to  G(x)</fr:tex> in <fr:tex display="inline">D</fr:tex>,
    (called the <fr:strong>component</fr:strong> of <fr:tex display="inline">\alpha </fr:tex> at <fr:tex display="inline">x</fr:tex>)
    the following diagram commutes in <fr:tex display="inline">D</fr:tex>:
    
    <fr:embedded-tex hash="9e8c6059143e8cbd6e00022532ed04e2"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            {F(x)} &amp;&amp; {F(y)} \\
            \\
            {G(x)} &amp;&amp; {G(y)}
            \arrow [&quot;{F(f)}&quot;, from=1-1, to=1-3]
            \arrow [&quot;{G(f)}&quot;, from=3-1, to=3-3]
            \arrow [&quot;{\alpha _x}&quot;, from=1-1, to=3-1]
            \arrow [&quot;{\alpha _y}&quot;, from=1-3, to=3-3]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>596</fr:anchor><fr:addr type="machine">#338</fr:addr><fr:route>unstable-338.xml</fr:route><fr:title text="Basic Category Theory Structures">Basic Category Theory Structures</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0007</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Though the theory is already rich by only considering sets and categories, 
        it would not be interesting enough. We want to know a little more about the 
        category that we are working with. To achieve so, we can require some additional
        structures on the category. A common structure is the cartesian product.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>597</fr:anchor><fr:addr type="user">def-003P</fr:addr><fr:route>def-003P.xml</fr:route><fr:title text="Cartesian Product">Cartesian Product</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given any category <fr:tex display="inline">\mathcal {C}</fr:tex>, and any set <fr:tex display="inline">\{X_i\}_{i\in  I}</fr:tex> of
    its objects, the product of all these objects is, if it exists, an object
    <fr:tex display="inline">         \prod _{i\in  I} X_i \in  \mathcal {C}     </fr:tex>
    equipped with morphisms (projections)
    <fr:tex display="block">         p_i : \left (\prod _{i\in  I} X_i\right ) \to  X_i     </fr:tex>
    for each <fr:tex display="inline">i\in  I</fr:tex>, such that it is <fr:strong>universal with this property</fr:strong>, i.e.
    such that given any other object <fr:tex display="inline">Q\in  C</fr:tex> with morphisms
    <fr:tex display="inline">         Q \xrightarrow {f_i} X_i      </fr:tex>
    there is a <fr:strong>unique</fr:strong> morphism
    <fr:tex display="block">         (f_i)_{i\in  I} : Q \to  \prod _{i\in  I} X_i     </fr:tex>
    where the following diagram commutes:
    
    <fr:embedded-tex hash="4025ac184b830256b9ce3b0638958390"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            Q \\
            \\
            {\prod _{i\in  I} X_i} &amp;&amp; {X_i}
            \arrow [&quot;{p_i}&quot;, from=3-1, to=3-3]
            \arrow [&quot;{f_i}&quot;, from=1-1, to=3-3]
            \arrow [&quot;{(f_i)_{i\in  I}}&quot;&apos;, from=1-1, to=3-1]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>With this definition, it is natural to ask what can serve as a <fr:strong>nullary product</fr:strong>.
        The concept is characterized by terminal objects.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>598</fr:anchor><fr:addr type="user">def-003Q</fr:addr><fr:route>def-003Q.xml</fr:route><fr:title text="Terminal Object">Terminal Object</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>terminal object</fr:strong> in a category <fr:tex display="inline">\mathcal {C}</fr:tex> is an object <fr:tex display="inline">\top </fr:tex> of <fr:tex display="inline">\mathcal {C}</fr:tex> 
    satisfying the following universal property: for any object <fr:tex display="inline">X</fr:tex> in <fr:tex display="inline">\mathcal {C}</fr:tex>,
    there exists a unique morphism <fr:tex display="inline">!:X\to  \top </fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>When making math statements, we often encounter concepts that are dual to each other.
        In category theory, this phenomenon is captured by the concept of <fr:strong>duality</fr:strong>.
        Intuitively, duality offers us free dual theorem from the original one.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>599</fr:anchor><fr:addr type="user">def-003R</fr:addr><fr:route>def-003R.xml</fr:route><fr:title text="Opposite Category">Opposite Category</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For a category <fr:tex display="inline">\mathcal {C}</fr:tex>, the <fr:strong>opposite category</fr:strong> <fr:tex display="inline">\mathcal {C}^{op}</fr:tex> 
    has the same objects as <fr:tex display="inline">\mathcal {C}</fr:tex>, but the morphisms are reversed.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>For example, the product in the opposite category, all <fr:strong>universal properties</fr:strong> corresponds
        to a dual concept.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>600</fr:anchor><fr:addr type="user">def-003S</fr:addr><fr:route>def-003S.xml</fr:route><fr:title text="Coproduct">Coproduct</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For <fr:tex display="inline">\mathcal {C}</fr:tex> a category and <fr:tex display="inline">X, Y \in \text {Ob}{\mathcal {C}}</fr:tex>,
    the <fr:strong>coproduct</fr:strong> is an object <fr:tex display="inline">X\sqcup   Y</fr:tex> equipped with 
    two morphisms <fr:tex display="inline">i_X:X\to  X\sqcup   Y</fr:tex> and <fr:tex display="inline">i_Y:Y\to  X\sqcup   Y</fr:tex> such that
    it is universal with this property. That is, for any object <fr:tex display="inline">Z</fr:tex> and morphisms
    <fr:tex display="inline">f:X\to  Z</fr:tex> and <fr:tex display="inline">g:Y\to  Z</fr:tex>, there exists a unique morphism <fr:tex display="inline">\langle  f, g\rangle :X\sqcup   Y\to  Z</fr:tex>
    such that the following diagram commutes:
    
    <fr:embedded-tex hash="e6897b75170fa778dd177cd469cbcef7"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            X &amp;&amp; {X\sqcup  Y} &amp;&amp; Y \\
            \\
            &amp;&amp; Z
            \arrow [&quot;{[f,g]}&quot;&apos;, dashed, from=1-3, to=3-3]
            \arrow [&quot;f&quot;&apos;, from=1-1, to=3-3]
            \arrow [&quot;{i_Y}&quot;&apos;, from=1-5, to=1-3]
            \arrow [&quot;{i_X}&quot;, from=1-1, to=1-3]
            \arrow [&quot;g&quot;, from=1-5, to=3-3]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>601</fr:anchor><fr:addr type="machine">#339</fr:addr><fr:route>unstable-339.xml</fr:route><fr:title text="Logic, Types and Categories">Logic, Types and Categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0007</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>One important principle in type theory is the <fr:strong>Curry-Howard Isomorphism</fr:strong> (Propositions as types).
        It depicts the connection between logic and types. A program can represent a logical argument, and 
        operations in logic find meaningful correspondences in program execution.
        The principle was later extended with category theory due to <fr:strong>Lambek</fr:strong>. In his work, he showed
        a correspondence between STLC and <fr:strong>Cartesian Closed Categories (CCC)</fr:strong> and revealed the connection
        between types and categories. The correspondence is called the <fr:strong>Curry-Howard-Lambek Isomorphism</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>602</fr:anchor><fr:addr type="machine">#340</fr:addr><fr:route>unstable-340.xml</fr:route><fr:title text="Syntax and Semantics">Syntax and Semantics</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#339</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>In general, there are two approaches to understand or design a type system: the <fr:strong>syntactic</fr:strong> view 
            and <fr:strong>semantic</fr:strong> view.

            The syntactic view focuses on the syntactic structure of types and programs. We study about <fr:strong>subject reduction</fr:strong>,
            <fr:strong>cut elimination</fr:strong> and etc, simply by manipulating the syntax. It is usually more direct and easier to understand
            as it is often conducted via induction on some syntactic structures. And it also suggest algorithms which can be implemented.
            The disadvantage is that it is limited and hard to proof some properties like normalization.

            The semantic appoaches are more powerful in general. It is based on mathematics models of type systems.
            In exchange of the strength and generality, it is usually harder to understand and heavyweight, requries
            more intuition of the concepts.</fr:p><fr:p>One clasical semantic approach to logic is algebraic logic. A logical system is modeled by some algebraic theory.
            (often related to <fr:strong>lattices</fr:strong> and <fr:strong>semi-lattices</fr:strong>). Famous examples include <fr:strong>Boolean algebras</fr:strong>
            for classic propositional logic and <fr:strong>Heyting algebras</fr:strong> for intuitionistic counterpart. 
            The algebraic logic is a powerful tool to study the properties of logical systems, but has a limitation that 
            all operations are limited in one structured set.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>603</fr:anchor><fr:addr type="machine">#341</fr:addr><fr:route>unstable-341.xml</fr:route><fr:title text="Computations as Monads">Computations as Monads</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#339</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>An important result from ategorical semantics could be <fr:strong>monads</fr:strong>.
            In <fr:strong>Moggi</fr:strong>&apos;s paper, he showed that monads can be used to model computational effects.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>604</fr:anchor><fr:addr type="user">def-003T</fr:addr><fr:route>def-003T.xml</fr:route><fr:title text="Monad">Monad</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>monad</fr:strong> of a category <fr:tex display="inline">\mathcal {C}</fr:tex> is an endofunctor <fr:tex display="inline">M:\mathcal {C}\to \mathcal {C}</fr:tex> with two natural
    transformations <fr:tex display="inline">\eta :\text {id}_{\mathcal {C}}\Rightarrow  M</fr:tex> and <fr:tex display="inline">\mu :M^2\Rightarrow  M</fr:tex> satisfying the following conditions:
    
    <fr:embedded-tex hash="d8d933290bf594a11e12a52477471318"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            {M^2(X)} &amp;&amp; {M(X)} &amp;&amp; {M^2(X)} \\
            &amp;&amp; {M(X)} \\
            \\
            &amp; {M^3(X)} &amp;&amp; {M^2(X)} \\
            &amp; {M^2(X)} &amp;&amp; {M(X)}
            \arrow [&quot;{\mu _{M(X)}}&quot;&apos;, from=4-2, to=5-2]
            \arrow [&quot;{\mu _X}&quot;, from=5-2, to=5-4]
            \arrow [&quot;{1_{M(X)}}&quot;, from=1-3, to=2-3]
            \arrow [&quot;{\mu _X}&quot;&apos;, from=1-1, to=2-3]
            \arrow [&quot;{M(\eta _X)}&quot;&apos;, from=1-3, to=1-1]
            \arrow [&quot;{\eta _{ M(X)}}&quot;, from=1-3, to=1-5]
            \arrow [&quot;{\mu _X}&quot;, from=1-5, to=2-3]
            \arrow [&quot;{\mu _X}&quot;, from=4-4, to=5-4]
            \arrow [&quot;{M(\mu _X)}&quot;, from=4-2, to=4-4]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>It requires an operation over functors named <fr:strong>whiskering</fr:strong></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>605</fr:anchor><fr:addr type="user">def-003U</fr:addr><fr:route>def-003U.xml</fr:route><fr:title text="Whiskering">Whiskering</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">F,G:C\to  D</fr:tex> and <fr:tex display="inline">H,D\to  E</fr:tex> be functors and <fr:tex display="inline">\eta :F\to  G</fr:tex> be a natural 
    transformation whose coordinate at any object <fr:tex display="inline">A</fr:tex> of <fr:tex display="inline">C</fr:tex> is <fr:tex display="inline">\eta _A</fr:tex>, then 
    <fr:strong>whiskering</fr:strong> <fr:tex display="inline">H</fr:tex> and <fr:tex display="inline">\eta </fr:tex> yields the natural transformation 
    <fr:tex display="inline">H\circ \eta :H\circ  F\to  H\circ  G</fr:tex> whose coordinate at <fr:tex display="inline">A</fr:tex> is <fr:tex display="inline">H(\eta _A)</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>606</fr:anchor><fr:addr type="machine">#342</fr:addr><fr:route>unstable-342.xml</fr:route><fr:title text="Logic as Adjoint Functors">Logic as Adjoint Functors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#339</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Categorical logic is a new approach to logic, due to <fr:strong>Lawvere</fr:strong>. 
            He showed that logical constructs are fundamentally just <fr:strong>adjoint functors</fr:strong>.
            This allows us to capture many logical constructs by using only one categorical concept.
            Adjoint also provides a strong guarantee about the derived syntactic formulation.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>607</fr:anchor><fr:addr type="user">def-003V</fr:addr><fr:route>def-003V.xml</fr:route><fr:title text="Adjoint Functor">Adjoint Functor</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">\mathcal {C}</fr:tex> and <fr:tex display="inline">\mathcal {D}</fr:tex> be categories and a pair of functors 
    <fr:tex display="inline">F:\mathcal {C}\to \mathcal {D}</fr:tex> and <fr:tex display="inline">G:\mathcal {D}\to \mathcal {C}</fr:tex>. This is called 
    pair of <fr:strong>adjoint functors</fr:strong> (or <fr:strong>adjunction</fr:strong>) with <fr:tex display="inline">F</fr:tex> the left adjoint
    and <fr:tex display="inline">G</fr:tex> the right adjoint denoted 
    <fr:tex display="block">         F\dashv  G     </fr:tex>
    if there is a natural isomorphism between the hom-functors:
    <fr:tex display="block">         \hom _{\mathcal {D}}(F(-),-)\cong \hom _{\mathcal {C}}(-,G(-))     </fr:tex>
    which means forall objects <fr:tex display="inline">C\in \mathcal {C}</fr:tex> and <fr:tex display="inline">D\in \mathcal {D}</fr:tex>, there is a bijection
    <fr:tex display="block">         \hom _{\mathcal {D}}(F(C),D)\cong \hom _{\mathcal {C}}(C,G(D)) \\          (F(C)\xrightarrow {f}D) \mapsto  (C\xrightarrow {G(f)}G(D))     </fr:tex>
    which is natural in both <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:backmatter></fr:tree>