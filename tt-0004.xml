<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>652</fr:anchor><fr:taxon>Type Theory</fr:taxon><fr:addr>tt-0004</fr:addr><fr:route>tt-0004.xml</fr:route><fr:title>Inductive Types</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
    In previous post, we have seen the definition of natural numbers as an inductive type.
    In this post, we will see more examples of inductive types, such as 
    unit type, empty type, product type, sum type and etc.
    Refer to <fr:link href="hott-2022.xml" type="local" addr="hott-2022">Egbert Rijke&apos;s Book</fr:link>.
</fr:p><fr:p>
    This section is much more informal than the previous one.
    Without displaying the inference rules, we will just present the <fr:strong>constructor</fr:strong>
    and <fr:strong>induction principle</fr:strong> of each inductive type.
</fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>268</fr:anchor><fr:title><fr:strong>General Inductive Type</fr:strong></fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:parent>tt-0004</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
    Just like <fr:tex>\mathbb {N}</fr:tex>, other inductive types can be defined by 
    their constructors and induction principles (and computation rules).
    </fr:p>
    <fr:ul><fr:li>
            The constructors specify the structure of the type equipped.
        </fr:li>
        <fr:li>
            The induction principle specifies the data required to construct 
            a section of an arbitrary type family over the inductive type.
        </fr:li>
        <fr:li>
            The computation rules specify the behavior of the constructors.
        </fr:li></fr:ul>
</fr:mainmatter></fr:tree>
<fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>269</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0020</fr:addr><fr:route>def-0020.xml</fr:route><fr:title>Unit Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
        
        The <fr:strong>unit type</fr:strong> is the simplest inductive type.
        It has only one constructor, denoted by <fr:tex>\star : \textbf {1}</fr:tex>.
    </fr:p><fr:p>
        The induction principle of the unit type is trivial.
        It says that to define a dependent function <fr:tex>f: \Pi  _{(x: \textbf {1} )} P(x)</fr:tex>, 
        it suffices to give a value <fr:tex>p:P( \star )</fr:tex>.
        <fr:tex display="block">             f ( \star ) : \equiv  p         </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:p>
    A degenrate inductive type is the <fr:strong>empty type</fr:strong>.
    It has no constructor, and its induction principle is trivial.
    Empty type is connected to the <fr:strong>exfalso quodlibet principle</fr:strong> in logic.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>270</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0021</fr:addr><fr:route>def-0021.xml</fr:route><fr:title>Empty Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>empty type</fr:strong> is a degenerate inductive type <fr:tex>\emptyset</fr:tex> satisfying 
    the following induction principle:
    <fr:tex display="block">          \text {ind}_ \emptyset  :  \Pi _{(x: \emptyset )}P(x)     </fr:tex>
    And a special case is <fr:strong>exfalso</fr:strong>:
    <fr:tex display="block">          \text {exfalso} : \equiv   \text {ind}_ \emptyset  :  \empty   \to  A      </fr:tex>
    which can draw any conclusion.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    With the empty type we can define the <fr:strong>negation</fr:strong> of a type
    and the <fr:strong>proof of negation</fr:strong>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>272</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0022</fr:addr><fr:route>def-0022.xml</fr:route><fr:title>Type Negation</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>negation</fr:strong> of type <fr:tex>A</fr:tex> is defined as
    <fr:tex display="block">          \neg  A : \equiv  A  \to   \emptyset      </fr:tex>
    A type <fr:tex>A</fr:tex> is said to be <fr:strong>empty</fr:strong> if and only if <fr:tex>\neg  A</fr:tex> is inhabited.
    <fr:tex display="block">          \text {empty}(A) : \equiv   \neg  A     </fr:tex></fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>271</fr:anchor><fr:title><fr:strong>Proof of negation</fr:strong></fr:title><fr:parent>def-0022</fr:parent></fr:frontmatter><fr:mainmatter>
        <fr:p>
            To prove <fr:tex>\neg  A</fr:tex>, we need to show that <fr:tex>A</fr:tex> implies a contradiction.
            In other words, constructing a function of type <fr:tex>A  \to   \emptyset</fr:tex>.
        </fr:p>
    </fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>273</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0023</fr:addr><fr:route>def-0023.xml</fr:route><fr:title>Coproduct Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>A</fr:tex> and <fr:tex>B</fr:tex> be types. The <fr:strong>coproduct (disjoint sum)</fr:strong> <fr:tex>A+B</fr:tex> is a typed defined by the following constructors:
    <fr:ul><fr:li><fr:tex>\text {inl} :A \to  A+B</fr:tex></fr:li>
        <fr:li><fr:tex>\text {inr} :B \to  A+B</fr:tex></fr:li></fr:ul>
    For any type family indexed by <fr:tex>x:A+B</fr:tex>, satisfies the following induction principle:
    <fr:tex display="block">          \text {ind}_ + : ( \Pi _{(x:A)}P( \text {inl} (x))) \to ( \Pi _{(y:B)}P( \text {inr} (y))) \to \Pi _{(z:A+B)}P(z)     </fr:tex>
    (Note that sometimes we denoted <fr:tex>\text {ind}_ + (f,g)</fr:tex> as <fr:tex>[f,g]</fr:tex>) And the computation rule:
    <fr:tex display="block">          \begin {align*}              \text {ind}_ + (f,g, \text {inl} (x))&amp; \equiv  f(x) \\               \text {ind}_ + (f,g, \text {inr} (y))&amp; \equiv  g(y)          \end {align*}     </fr:tex>
    where <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> are defined:
    <fr:tex display="block">          \begin {align*}             f&amp;: \Pi _{(x:A)}P( \text {inl} (x)) \\              g&amp;: \Pi _{(y:B)}P( \text {inr} (y))          \end {align*}     </fr:tex>
    This can be presented by pattern matching to define a function <fr:tex>h: \Pi  _{(z:A+B)}.P(z)</fr:tex>:
    <fr:tex display="block">          \begin {align*}             h( \text {inl} (x))&amp;: \equiv  f(x) \\              h( \text {inr} (y))&amp;: \equiv  g(y)          \end {align*}     </fr:tex></fr:p></fr:mainmatter></fr:tree>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>274</fr:anchor><fr:title><fr:strong>Special Case of Coproduct</fr:strong></fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:parent>tt-0004</fr:parent></fr:frontmatter><fr:mainmatter>
    The special case of coproduct type is also called the <fr:strong>sum type</fr:strong>.
    <fr:tex display="block">          \text {ind}_ + : (A  \to  X)  \to  (B  \to  X)  \to  (A+B  \to  X)     </fr:tex>
    which is very similar to the <fr:strong>elimination rule</fr:strong> of disjunction in logic.
    <fr:tex display="block">         (P \to  Q)  \to  (R \to  Q)  \to  (P \vee  R \to  Q)     </fr:tex>
</fr:mainmatter></fr:tree>
<fr:p>
    The dependent version of sum type is called the <fr:strong>dependent sum type (dependent coproduct)</fr:strong> traditionally.
    Its terms are ordered pairs.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>280</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0024</fr:addr><fr:route>def-0024.xml</fr:route><fr:title>Dependent Pair Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>dependent pair type</fr:strong> is a inductive type <fr:tex>\Sigma _{(x:A)}B(x)</fr:tex> (<fr:tex>(x:A)  \times  B(x)</fr:tex>)
</fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>275</fr:anchor><fr:title>
    <fr:strong>Formation Rule</fr:strong>
</fr:title><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
        Given a type family <fr:tex>B</fr:tex> over <fr:tex>A</fr:tex>, we can form the dependent pair type <fr:tex>\Sigma _{(x:A)}B(x)</fr:tex>.
    </fr:p>
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \space \text {type}               \quad               \Gamma ,x:A \vdash  B(x) \space \text {type}          }{              \Gamma \vdash  (x:A)  \times  B(x) \space \text {type}          }     </fr:tex>
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>276</fr:anchor><fr:title>
    <fr:strong>Introduction Rule</fr:strong>
</fr:title><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
        Given a term <fr:tex>a:A</fr:tex> and a term <fr:tex>b(a):B(a)</fr:tex>, we can form a term <fr:tex>\text {pair} (a,b):(x:A) \times  B(x)</fr:tex>.
    </fr:p>
    <fr:tex display="block">          \frac {              \Gamma \vdash  a:A              \quad               \Gamma \vdash  b(a):B(a)         }{              \Gamma \vdash  (a,b):(x:A) \times  B(x)         }     </fr:tex>
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>277</fr:anchor><fr:title>
    <fr:strong>Elimination Rule</fr:strong>
</fr:title><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
        The elimination rule is formed with two projections.
        <fr:tex display="block">              \frac {                  \Gamma \vdash  p:(x:A) \times  B(x)             }{                  \begin {align*}                      \Gamma &amp; \vdash   \text {pr}_ A (p):A \\                       \Gamma &amp; \vdash   \text {pr}_ B (p):B( \text {pr}_ A (p))                  \end {align*}             }         </fr:tex></fr:p>
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>278</fr:anchor><fr:title>
    <fr:strong>Computation Rule</fr:strong>
</fr:title><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p><fr:tex display="block">              \frac {                  \Gamma \vdash  x:A                   \quad                    \Gamma \vdash  y:B(x)             }{                  \begin {align*}                      \Gamma &amp; \vdash   \text {pr}_ A ((x,y))=x:A \\                       \Gamma &amp; \vdash   \text {pr}_ B ((x,y))=y:B(x)                  \end {align*}             }         </fr:tex></fr:p>
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>279</fr:anchor><fr:title>
    <fr:strong>Special Case</fr:strong>
</fr:title><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:ul><fr:li>
            In the special case that <fr:tex>B(x) = B</fr:tex> is independent of <fr:tex>A</fr:tex>,
            this reduces to the <fr:strong>product type</fr:strong> <fr:tex>A \times  B</fr:tex>.
        </fr:li>
        <fr:li>
            In the special case that <fr:tex>D  \equiv   \text {Boolean}</fr:tex>,
            this reduces to a <fr:link href="def-0023.xml" type="local" addr="def-0023">coproduct type</fr:link>.
        </fr:li></fr:ul>
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree></fr:mainmatter><fr:backmatter><fr:contributions></fr:contributions><fr:context><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>650</fr:anchor><fr:addr>posts</fr:addr><fr:route>posts.xml</fr:route><fr:title>Blog posts</fr:title><fr:authors><fr:contributor>CAIMEO</fr:contributor></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false"><fr:frontmatter><fr:anchor>262</fr:anchor><fr:taxon>Type Theory</fr:taxon><fr:addr>tt-0002</fr:addr><fr:route>tt-0002.xml</fr:route><fr:title>Introduction to Type Theory</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>This is a note on dependent type theory. Refer to <fr:link href="hott-book-2013.xml" type="local" addr="hott-book-2013">HoTT Book</fr:link> and <fr:link href="hott-2022.xml" type="local" addr="hott-2022">Egbert Rijke&apos;s</fr:link>.</fr:p><fr:p><fr:strong>Homotopy type theory</fr:strong> is a foundational language for mathematics, an alternative to Zermelo-Fraenkel set theory.
    The set-theoretic foundation has two two layers:
    <fr:ul><fr:li>the deductive system of first-order logic</fr:li>
        <fr:li>the theory of a particular theory, such as ZFC</fr:li></fr:ul> 
    Type theory itself is a deductive system, which has one basic notation: <fr:em>types</fr:em>.
    Propositions are identified with types.
    
    Thus, the activity of proving a theorem is identified with 
    constructing a <fr:em>inhabitant</fr:em> of a certain type.
</fr:p><fr:p>
    Informally, a deductive system is a collection of rules for deriving <fr:strong>judgments</fr:strong>. 
    The judgment is considered to be the external of the theory, living in the <fr:strong>metatheory</fr:strong>.
</fr:p><fr:p>
    In first order logic, there is only one kind of judgment: a proposition has a proof.
    A proposition <fr:tex>P</fr:tex> gives rise to a judgment &quot;<fr:tex>P</fr:tex> has a proof&quot;.
    The proposition <fr:tex>P</fr:tex> lives inside the theory, while the judgment &quot;<fr:tex>P</fr:tex> has a proof&quot; lives in the metatheory. 
</fr:p><fr:p>
    In type theory, analogous to first order logic,
    &quot;<fr:tex>P</fr:tex> has a proof&quot; is written as &quot;<fr:tex>p:P</fr:tex>&quot; (Type <fr:tex>P</fr:tex> has a term <fr:tex>p</fr:tex>).
    <fr:ul><fr:li>If <fr:tex>P</fr:tex> is a proposition, then <fr:tex>p</fr:tex> is a <fr:strong>witness</fr:strong> to the provability of <fr:tex>P</fr:tex>, 
        or <fr:strong>evidence</fr:strong> of the truth of <fr:tex>P</fr:tex>.</fr:li>
        <fr:li><fr:tex>p:P</fr:tex> can also be interpreted as <fr:tex>p \in  P</fr:tex>,
        but <fr:tex>p:P</fr:tex> is a judgment while <fr:tex>p \in  P</fr:tex> is a proposition.</fr:li></fr:ul>
    Working inside type theory we can&apos;t write down statements like
    &quot;if <fr:tex>p:P</fr:tex> then ...&quot; nor can we disprove the judgment &quot;<fr:tex>p:P</fr:tex>&quot;.
</fr:p><fr:p>
    A key difference between type theory and set theory is the equality.
    The notion of equality in set theory is simply a proposition.
    Howerver, in type theory, there are two kinds of equality.
    <fr:ul><fr:li>The first kind is the <fr:strong>propositional equality</fr:strong> <fr:tex>a=_Ab</fr:tex>.
        This is a proposition</fr:li>
        <fr:li>The second kind is the <fr:strong>judgmental equality</fr:strong> <fr:tex>a \equiv  b:A</fr:tex>.
        This is a judgment</fr:li></fr:ul>
    Two terms <fr:tex>a:A</fr:tex> and <fr:tex>b:A</fr:tex> are propositionally equal if you can prove <fr:tex>a =_A b</fr:tex> , 
    or equivalently if you can construct a term <fr:tex>h : a =_A b</fr:tex>.
</fr:p>
    <fr:p>
        In type theory there is also a requirement for a judgment-level equality.
        This is called <fr:strong>judgmental equality</fr:strong>, meaning &quot;equal by definition&quot;.
    </fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>249</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0015</fr:addr><fr:route>def-0015.xml</fr:route><fr:title>Judgemental Equality</fr:title></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Judgemental equality</fr:strong> of terms is given by the following judgement:
    <fr:tex display="block">          \Gamma \vdash  a \equiv  a&apos;:A     </fr:tex>
    <fr:tex>a</fr:tex> and <fr:tex>a&apos;</fr:tex> are judgementally equal terms of type <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>.
</fr:p><fr:p>
    Note that the notation <fr:tex>\equiv</fr:tex> binds more loosely than anything else.
</fr:p></fr:mainmatter></fr:tree>
    <fr:p>
        judgments may depend on <fr:em>assumptions</fr:em> of the form <fr:tex>x:A</fr:tex> where <fr:tex>x</fr:tex> is a
        variable and <fr:tex>A</fr:tex> is a type. And the collection (actually ordered list) of such assumptions is called 
        the <fr:strong>context</fr:strong>, denoted <fr:tex>\Gamma</fr:tex>. (from a topological point of view it 
        may be thought of as a <fr:strong>parameters space</fr:strong>).
        The role of a context is to declare what <fr:strong>hypothetical terms</fr:strong> are assumed, 
        along with their types.
        The notation <fr:tex>\vdash</fr:tex> means making conclusion from assumptions.
    </fr:p>
<fr:p>
    Remember the difference between axiom and (inference) rules.
    <fr:ul><fr:li>Rules allow us to conclude one judgment from a collection of other judgments.</fr:li>
        <fr:li>Axioms are judgments that are assumed to be true without proof.</fr:li></fr:ul></fr:p><fr:p>
    We start by introduction to Matrin Lof&apos;s dependent type theory. 
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>250</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0017</fr:addr><fr:route>def-0017.xml</fr:route><fr:title>Dependent type theory: Judgments</fr:title></fr:frontmatter><fr:mainmatter>
    <fr:p>
        There are four kinds of judgments in Martin Lof&apos;s dependent type theory:
    </fr:p>
    <fr:ul><fr:li><fr:tex>A</fr:tex> is a well-formed type in context <fr:tex>\Gamma</fr:tex>
            <fr:tex display="block">                  \Gamma   \vdash  A  \space \text {type}              </fr:tex></fr:li>
        <fr:li><fr:tex>A</fr:tex> and <fr:tex>B</fr:tex> are judgmentally equal types in context <fr:tex>\Gamma</fr:tex>
            <fr:tex display="block">                  \Gamma   \vdash  A  \equiv  B  \space \text {type}              </fr:tex></fr:li>
        <fr:li><fr:tex>a</fr:tex> is a term of type <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>
            <fr:tex display="block">                  \Gamma   \vdash  a : A             </fr:tex></fr:li>
        <fr:li><fr:tex>a</fr:tex> and <fr:tex>b</fr:tex> are judgmentally equal terms of type <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>
            <fr:tex display="block">                  \Gamma   \vdash  a  \equiv  b : A             </fr:tex></fr:li></fr:ul>
</fr:mainmatter></fr:tree><fr:p>
    All judgments are context dependent, 
    and indeed that even the types of the variables in a context
    may depend on any previous declared variables.

    To introduce types dependent on terms, 
    we need the notation of type families.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>251</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0018</fr:addr><fr:route>def-0018.xml</fr:route><fr:title>Type Family</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Consider a type <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>.
    A <fr:strong>family</fr:strong> of types over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>
    is a type <fr:tex>B(x)</fr:tex> in context <fr:tex>\Gamma , x:A</fr:tex>.
    <fr:tex display="block">          \Gamma , x:A  \vdash  B(x)  \space \text {type}      </fr:tex>
    <fr:tex>B</fr:tex> is a family of types over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>.
    Alternatively, we say that <fr:tex>B(x)</fr:tex> is a type <fr:strong>indexed</fr:strong> by <fr:tex>x:A</fr:tex> in context <fr:tex>\Gamma</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    Now we can define a term of a type family, that is, a section of a type family.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>252</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0019</fr:addr><fr:route>def-0019.xml</fr:route><fr:title>Section of Type Family</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>B</fr:tex> be a <fr:link href="def-0018.xml" type="local" addr="def-0018">type family</fr:link> over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>.
    A <fr:strong>section</fr:strong> of <fr:tex>B</fr:tex> is a term <fr:tex>b</fr:tex> of type <fr:tex>B(x)</fr:tex> in context <fr:tex>\Gamma ,x:A</fr:tex>.
    <fr:tex display="block">          \Gamma , x:A  \vdash  b : B(x)     </fr:tex>
    Alternatively, we say that <fr:tex>b</fr:tex> is a term of <fr:tex>B(x)</fr:tex> indexed by <fr:tex>x:A</fr:tex> in context <fr:tex>\Gamma</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    We now ready to present the inference rules for dependent type theory.
    These rules are known as the <fr:strong>structual rules</fr:strong> of the theory.
    There are 6 sets of rules:
    <fr:ul><fr:li>Formation contexts, types and terms</fr:li>
        <fr:li>Postulating that judgmental equality is an equivalence relation</fr:li>
        <fr:li>Vairable conversion</fr:li>
        <fr:li>Substitution</fr:li>
        <fr:li>Weakening</fr:li>
        <fr:li>Generic element</fr:li></fr:ul></fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>253</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001A</fr:addr><fr:route>def-001A.xml</fr:route><fr:title>
    Formation of contexts, types and terms
</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The following rules follow from the presuppotion
    about contexts, types and terms, can be used freely.
</fr:p><fr:ul><fr:li><fr:tex display="block">              \frac {                  \Gamma ,x:A \vdash  B(x) \space \text {type}              }{                  \Gamma \vdash  A \space \text {type}              }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">              \frac {                  \Gamma \vdash  A \equiv  B \space \text {type}              }{                  \Gamma \vdash  A \space \text {type}              }              \quad               \frac {                  \Gamma \vdash  A \equiv  B \space \text {type}              }{                  \Gamma \vdash  B \space \text {type}              }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">              \frac {                  \Gamma \vdash  a:A             }{                  \Gamma \vdash  A \space \text {type}              }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">              \frac {                  \Gamma \vdash  a \equiv  b:A             }{                  \Gamma \vdash  a:A             }              \quad                \frac {                  \Gamma \vdash  a \equiv  b:A             }{                  \Gamma \vdash  b:A             }         </fr:tex></fr:li></fr:ul></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>254</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001B</fr:addr><fr:route>def-001B.xml</fr:route><fr:title>
    Judgmental equality is equivalence relation
</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Judgmental equality on types and on elements is an <fr:link href="def-000X.xml" type="local" addr="def-000X">equivalence relation</fr:link> 
    simply postulate that these relations are reflexive, symmetric, and transitive:
</fr:p><fr:ul><fr:li><fr:tex display="block">              \frac {                  \Gamma \vdash  a:A             }{                  \Gamma \vdash  a \equiv  a:A             }              \quad               \frac {                  \Gamma \vdash  a \equiv  b:A             }{                  \Gamma \vdash  b \equiv  a:A             }              \quad               \frac {                  \Gamma \vdash  a \equiv  b:A                  \quad                   \Gamma \vdash  b \equiv  c:A             }{                  \Gamma \vdash  a \equiv  c:A             }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">              \frac {                  \Gamma \vdash  A \space \text {type}              }{                  \Gamma \vdash  A \equiv  A \space \text {type}              }              \quad               \frac {                  \Gamma \vdash  A \equiv  B \space \text {type}              }{                  \Gamma \vdash  B \equiv  A \space \text {type}              }              \quad               \frac {                  \Gamma \vdash  A \equiv  B \space \text {type}                   \quad                   \Gamma \vdash  B \equiv  C \space \text {type}              }{                  \Gamma \vdash  A \equiv  C \space \text {type}              }         </fr:tex></fr:li></fr:ul></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>255</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001C</fr:addr><fr:route>def-001C.xml</fr:route><fr:title>Variable Conversion</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    This rule postulates that we can
    convert the type of a variable to a judgmentally equal type.
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \equiv  A&apos; \space \text {type}               \quad               \Gamma ,x:A, \Delta \vdash  B(x) \space \text {type}          }{              \Gamma ,x:A&apos;, \Delta \vdash  B(x) \space \text {type}          }     </fr:tex>
    Similarly, we can convert judgmental equality of types and terms.
    We state all of them at once using a <fr:em>generic judgment thesis</fr:em> <fr:tex>\mathcal {J}</fr:tex>.
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \equiv  A&apos; \space \text {type}               \quad               \Gamma ,x:A, \Delta \vdash   \mathcal {J}         }{              \Gamma ,x:A&apos;, \Delta \vdash   \mathcal {J}         }VC     </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:p>
    Consider a term <fr:tex>f:B(x)</fr:tex> indexed by <fr:tex>x:A</fr:tex> in context <fr:tex>\Gamma</fr:tex>,
    and we also have a term <fr:tex>a:A</fr:tex>.
    We can simultaneously substitute <fr:tex>a</fr:tex> for all occurrences of <fr:tex>x</fr:tex> in <fr:tex>f</fr:tex>
    to obtain a new term <fr:tex>f[x:=a]:B(a)</fr:tex>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>256</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001D</fr:addr><fr:route>def-001D.xml</fr:route><fr:title>Substitution</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The substitution rule postulates that we can substitute a term for a variable.
    <fr:tex display="block">          \frac {              \Gamma \vdash  a:A              \quad               \Gamma ,x:A, \Delta \vdash   \mathcal {J}         }{              \Gamma , \Delta [x:=a] \vdash   \mathcal {J}[x:=a]         }S     </fr:tex>
    The notation <fr:tex>\Gamma , \Delta [x:=a]</fr:tex> means that we substitute <fr:tex>a</fr:tex> for <fr:tex>x</fr:tex> in <fr:tex>\Delta</fr:tex>.
</fr:p><fr:p>
    With the substitution rule, we need two more <fr:em>congruence rules</fr:em> to
    convert judgmental equality of terms and types.
    <fr:tex display="block">          \frac {              \Gamma \vdash  a \equiv  a&apos;:A              \quad               \Gamma ,x:A, \Delta \vdash  B  \space \text {type}          }{              \Gamma , \Delta [x:=a] \vdash  B[x:=a] \equiv  B[x:=a&apos;]  \space \text {type}          }     </fr:tex>

    <fr:tex display="block">          \frac {              \Gamma \vdash  A \equiv  A&apos; \space \text {type}               \quad               \Gamma ,x:A, \Delta \vdash  b:A         }{              \Gamma , \Delta [x:=a] \vdash  b[x:=a] \equiv  b[x:=a&apos;]:A&apos;[x:=a]  \space \text {type}          }     </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>257</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001G</fr:addr><fr:route>def-001G.xml</fr:route><fr:title>Fiber and Value</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>B</fr:tex> be a <fr:link href="def-0018.xml" type="local" addr="def-0018">type family</fr:link> over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>,
    an a well-formed term <fr:tex>a:A</fr:tex>,
    then we say that <fr:tex>B[x:=a]</fr:tex> is the <fr:strong>fiber</fr:strong> of <fr:tex>B</fr:tex> at <fr:tex>a</fr:tex>, denoted <fr:tex>B(a)</fr:tex>.
</fr:p><fr:p>
    Let <fr:tex>b</fr:tex> a <fr:link href="def-0019.xml" type="local" addr="def-0019">section</fr:link> of <fr:tex>B</fr:tex> over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>,
    then we say that <fr:tex>b(a): \equiv  b[x:=a]</fr:tex> is the <fr:strong>value</fr:strong> of <fr:tex>b</fr:tex> at <fr:tex>a</fr:tex>.

</fr:p></fr:mainmatter></fr:tree><fr:p>
    The process of expanding the context by a fresh variable of type <fr:tex>A</fr:tex> is called weakening (by <fr:tex>A</fr:tex>).
    Intuitively, weakening is the process of adding a new hypothesis to the context.
    And the hypothesis will weaken the conclusion.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>258</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001E</fr:addr><fr:route>def-001E.xml</fr:route><fr:title>Weakening</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Weakening rule asserts that we can add a variable to the context.
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \space \text {type}               \quad                \Gamma , \Delta \vdash   \mathcal {J}         }{              \Gamma ,x:A, \Delta \vdash   \mathcal {J}         }W      </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:p>
    Finally, the generic elemets rule ensures that
    the variables declared in a context.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>259</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001F</fr:addr><fr:route>def-001F.xml</fr:route><fr:title>Generic Elements</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The rule for the generic element asserts that 
    any hypothetical element <fr:tex>x:A</fr:tex> in context <fr:tex>\Gamma ,x:A</fr:tex>
    is also an element of <fr:tex>A</fr:tex> in context <fr:tex>\Gamma ,x:A</fr:tex>.
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \space \text {type}          }{              \Gamma ,x:A \vdash  x:A         } \delta      </fr:tex>
    This rule is also called the <fr:strong>variable rule</fr:strong>.   
</fr:p></fr:mainmatter></fr:tree><fr:p>
    The next topic is the dependent function type, a fundamental concept of dependent type theory.
    Simply put, a dependent function type is a function whose type of output may depend on the input.
</fr:p><fr:p>
    Consider a section <fr:tex>b</fr:tex> of a family <fr:tex>B</fr:tex> over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>:
    <fr:tex display="block">          \Gamma ,x:A \vdash  b(x):B(x)     </fr:tex>
    Such a section <fr:tex>b</fr:tex> is an operation or assignment <fr:tex>x \mapsto  b(x)</fr:tex> that assigns to each element <fr:tex>x:A</fr:tex>
    to a term <fr:tex>b(x):B(x)</fr:tex>.
    We may see <fr:tex>b</fr:tex> as a function takes <fr:tex>x:A</fr:tex> to <fr:tex>b(x):B(x)</fr:tex>.
    The function <fr:tex>x \mapsto  b(x)</fr:tex> is called a <fr:strong>dependent function</fr:strong>.
    The type of all dependent functions from <fr:tex>A</fr:tex> to <fr:tex>B</fr:tex> is called the <fr:strong>dependent function type</fr:strong>.
    <fr:tex display="block">          \Pi _{(x:A)}B(x)  \text { or } (x:A) \to  B(x)     </fr:tex></fr:p><fr:p>
    To introduce a type we need the following four rules:
    <fr:ul><fr:li>Formation rule</fr:li>
        <fr:li>Introduction rule</fr:li>
        <fr:li>Elimination rule</fr:li>
        <fr:li>Computation rule</fr:li></fr:ul>
    Besides these we also need the <fr:strong>congruence rule</fr:strong> for judgmental equality.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>260</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001T</fr:addr><fr:route>def-001T.xml</fr:route><fr:title>Dependent Function Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Formation Rule</fr:strong>
    For any type family <fr:tex>B</fr:tex> over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>:
    <fr:tex display="block">          \frac {              \Gamma ,x:A \vdash  B(x) \space \text {type}          }{              \Gamma \vdash   \Pi _{(x:A)}B(x) \space \text {type}          } \Pi      </fr:tex>
    We also require that the operation of forming dependent function types
    respects judgmental equality.
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \equiv  A&apos; \space \text {type}               \quad               \Gamma ,x:A \vdash  B(x) \equiv  B&apos;(x) \space \text {type}          }{              \Gamma \vdash   \Pi _{(x:A)}B(x) \equiv   \Pi _{(x:A&apos;)}B&apos;(x) \space \text {type}          } \Pi \text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Introduction Rule (<fr:tex>\lambda</fr:tex>-abstraction)</fr:strong>
    In order to construct a dependent function we have to
    construct a term <fr:tex>f(x):B(x)</fr:tex> indexed by <fr:tex>x:A</fr:tex> in context <fr:tex>\Gamma</fr:tex>:
    <fr:tex display="block">          \frac {              \Gamma ,x:A \vdash  b(x):B(x)         }{              \Gamma \vdash   \lambda  x.b(x): \Pi _{(x:A)}B(x)         } \lambda      </fr:tex>
    And the congruence rule:
    <fr:tex display="block">          \frac {              \Gamma ,x:A \vdash  b(x) \equiv  b&apos;(x):B(x)         }{              \Gamma \vdash   \lambda  x.b(x) \equiv   \lambda  x.b&apos;(x): \Pi _{(x:A)}B(x)         } \lambda \text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Elimination Rule (Evaluation Rule)</fr:strong>
    In order to use dependent function we need to provide an argument of the domain type.
    <fr:tex display="block">          \frac {              \Gamma \vdash  f: \Pi _{(x:A)}B(x)         }{              \Gamma ,x:A \vdash  f(x):B(x)         }ev     </fr:tex>
    Again we require the judgmental equality to be respected:
    <fr:tex display="block">          \frac {              \Gamma \vdash  f \equiv  f&apos;: \Pi _{(x:A)}B(x)         }{              \Gamma ,x:A \vdash  f(x) \equiv  f&apos;(x):B(x)         }ev \text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Computation Rule (<fr:tex>\beta</fr:tex>-reduction)</fr:strong>
    <fr:tex display="block">          \frac {              \Gamma ,x:A \vdash  b(x):B(x)         }{              \Gamma ,x:A \vdash  ( \lambda  y.b(y))(x) \equiv  b(x):B(x)         } \beta      </fr:tex>
    We postulate that all elements of a dependent function type are dependent functions.
    <fr:tex display="block">          \frac {              \Gamma \vdash  f: \Pi _{(x:A)}B(x)         }{              \Gamma \vdash  f \equiv   \lambda  x.f(x): \Pi _{(x:A)}B(x)         } \eta      </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:p>
    A degenrated case of dependent function type is the ordinary function type.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>261</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001U</fr:addr><fr:route>def-001U.xml</fr:route><fr:title>Ordinary Function Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    A special case of <fr:link href="def-001T.xml" type="local" addr="def-001T"><fr:tex>\Pi</fr:tex>-type</fr:link> is the <fr:strong>ordinary function type</fr:strong>.
    Using weakening rule we can obtain thee type <fr:tex>A \to  B</fr:tex> of ordinary function from <fr:tex>A</fr:tex> to <fr:tex>B</fr:tex>
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \space \text {type}               \quad               \Gamma \vdash  B \space \text {type}          }{ \dfrac {              \Gamma ,x:A \vdash  B \space \text {type}          }{              \Gamma \vdash   \Pi _{(x:A)}B \space \text {type}          } \Pi }W     </fr:tex>
    A term <fr:tex>f:  \Pi _{(x:A)}B</fr:tex> is an ordinary function. The type <fr:tex>A  \to  B</fr:tex> is defined:
    <fr:tex display="block">         A \to  B :=  \Pi _{(x:A)}B     </fr:tex>
    The type <fr:tex>A</fr:tex> is called <fr:strong>domain</fr:strong> of <fr:tex>f</fr:tex>,
    and type <fr:tex>B</fr:tex> is called <fr:strong>codomain</fr:strong> of <fr:tex>f</fr:tex>.
    The notation <fr:tex>:=</fr:tex> here means to make a definition.
</fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false"><fr:frontmatter><fr:anchor>267</fr:anchor><fr:taxon>Type Theory</fr:taxon><fr:addr>tt-0003</fr:addr><fr:route>tt-0003.xml</fr:route><fr:title>Natural Numbers <fr:tex>\mathbb {N}</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
    In previous post, we have seen the basic inference rules of type theory.
    Now we will see the definition of natural numbers as an inductive type.
    Refer to <fr:link href="hott-book-2013.xml" type="local" addr="hott-book-2013">HoTT Book</fr:link> and <fr:link href="hott-2022.xml" type="local" addr="hott-2022">Egbert Rijke&apos;s</fr:link>.
</fr:p><fr:p>
    In classical mathematics, the <fr:strong>Peano axioms</fr:strong> are a set of axioms for the natural numbers,
    an important object in mathematics.
</fr:p><fr:p>
    In type theory, the type <fr:tex>\mathbb {N}</fr:tex> of natural number is an <fr:link href="def-001X.xml" type="local" addr="def-001X"><fr:strong>inductive type</fr:strong></fr:link>.
    Just like in dependent function type, we need four inference rules to define the natural numbers.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>263</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001Y</fr:addr><fr:route>def-001Y.xml</fr:route><fr:title>Natural Number</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    In type theory, <fr:strong>natural number</fr:strong> is defined using <fr:strong>peano encoding</fr:strong>.
    The type <fr:tex>\mathbb {N}</fr:tex> is formed by the formation rule:
    <fr:tex display="block">          \frac {}{ \vdash \mathbb {N} \space \text {type} } \mathbb {N} \text {-form}     </fr:tex></fr:p><fr:p>
    Peano&apos;s first axiom postulates the existence of a natural number <fr:tex>0</fr:tex>.
    The introduction rule for <fr:tex>\mathbb {N}</fr:tex> has a <fr:tex>0</fr:tex> constructor and a <fr:strong>successor</fr:strong> function.
    <fr:tex display="block">          \frac {}{ \vdash0 : \mathbb {N} } \mathbb {N} \text {-intro-0}          \quad           \frac {}{ \vdash \text {succ} : \mathbb {N} \to \mathbb {N} }  \mathbb {N} \text {-intro-succ}     </fr:tex></fr:p><fr:p>
    The <fr:strong>elimination rule</fr:strong> is actually the type theoretical <fr:strong>induction principle</fr:strong> of <fr:tex>\mathbb {N}</fr:tex>:
    In order to show that <fr:tex>\forall  n: \mathbb {N} .P(n)</fr:tex> holds, it suffices to show that <fr:tex>P(0)</fr:tex> holds and that <fr:tex>\forall  n: \mathbb {N} .P(n) \to  P( \text {succ} (n))</fr:tex> holds.
    The type theoretical induction principle is therefore formulated using a type family <fr:tex>P</fr:tex> over <fr:tex>\mathbb {N}</fr:tex>:
    <fr:tex display="block">          \frac {              \begin {align*}                  \Gamma &amp;, \, n: \mathbb {N} \vdash  P(n) \space \text {type}                   \\                   \Gamma &amp; \vdash  p_0:P(0)                  \\                   \Gamma &amp; \vdash  p_S: \Pi _{(n: \mathbb {N} )}P(n) \to  P( \text {succ} (n))              \end {align*}         }{              \Gamma \vdash \text {ind}_ \mathbb {N} (p_0,p_S): \Pi _{(n: \mathbb {N} )}P(n)         }( \mathbb {N}   \text {-ind})     </fr:tex>
    The induction principle tells us what we need to do in order to construct a dependent function <fr:tex>\text {ind}_ \mathbb {N}</fr:tex> of type <fr:tex>\Pi _{(n: \mathbb {N} )}P(n)</fr:tex>.
    We might alternatively write the induction principle as:
    <fr:tex display="block">          \frac {              \Gamma ,n: \mathbb {N} \vdash  P(n) \space \text {type}          }{              \Gamma \vdash \text {ind}_ \mathbb {N} : \left (P(0) \to \left ( \Pi _{(n: \mathbb {N} )}P(n) \to  P( \text {succ} (n)) \right ) \to \Pi _{(n: \mathbb {N} )}P(n) \right )         }( \mathbb {N}   \text {-ind})     </fr:tex></fr:p><fr:p>
    The <fr:strong>computation rule</fr:strong> asserts that the dependent function <fr:tex>\text {ind}_ \mathbb {N}</fr:tex> behaves as expected:
    <fr:tex display="block">          \frac {              \begin {align*}                  \Gamma &amp;,n: \mathbb {N} \vdash  P(n) \space \text {type}                   \\                   \Gamma &amp; \vdash  p_0:P(0)                  \\                   \Gamma &amp; \vdash  p_S: \Pi _{(n: \mathbb {N} )}P(n) \to  P( \text {succ} (n))              \end {align*}         }{              \text {ind}_ \mathbb {N} (p_0,p_S,m) \equiv               \begin {cases}                 p_0&amp; \text {if }m=0                  \\                  p_S(n, \text {ind}_ \mathbb {N} (p_0,p_S,n))&amp; \text {if }m= \text {succ} (n)              \end {cases}         }( \mathbb {N}   \text {-comp})     </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:p>
    Now let&apos;s use the type theoretical induction principle of <fr:tex>\mathbb {N}</fr:tex> to
    perform some basic construction over <fr:tex>\mathbb {N}</fr:tex>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>265</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001Z</fr:addr><fr:route>def-001Z.xml</fr:route><fr:title>Addition over <fr:tex>\mathbb {N}</fr:tex></fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    We define addition over <fr:tex>\mathbb {N}</fr:tex> using the type theoretical induction principle of <fr:tex>\mathbb {N}</fr:tex>.
    <fr:tex display="block">          \text {add}_ \mathbb {N}  :  \mathbb {N}   \to  ( \mathbb {N}   \to   \mathbb {N} )     </fr:tex>
    which satisfies the following specification:
    <fr:tex display="block">          \begin {align*}              \text {add}_ \mathbb {N} (n, 0)&amp;: \equiv  n              \\               \text {add}_ \mathbb {N} (m, \text {succ} (n))&amp;: \equiv \text {succ} ( \text {add}_ \mathbb {N} (m,n))          \end {align*}     </fr:tex>
    abbreviated as <fr:tex>m + n</fr:tex> for <fr:tex>\text {add}_ \mathbb {N} (m,n)</fr:tex>.
</fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>264</fr:anchor><fr:title><fr:strong>Construction</fr:strong></fr:title><fr:parent>def-001Z</fr:parent></fr:frontmatter><fr:mainmatter>
    
        <fr:p>
            We construct the additon by perform induction over the second variable <fr:tex>n</fr:tex>.
            That is, to construct an element
            <fr:tex display="block">                 m: \mathbb {N}   \vdash   \text {add}_ \mathbb {N} (m): \mathbb {N}   \to   \mathbb {N}              </fr:tex>
            The context <fr:tex>\Gamma   \equiv  m: \mathbb {N}</fr:tex> is fixed.
        </fr:p>
        Therefore we need to construct:
        <fr:tex display="block">              \begin {align*}                  \Gamma &amp; \vdash   \text {add-zero}_ \mathbb {N} (m): \mathbb {N}                   \\                   \Gamma &amp; \vdash   \text {add-succ}_ \mathbb {N} (m): \mathbb {N} \to \mathbb {N}                               \end {align*}            </fr:tex>
        The <fr:tex>\text {add-zero}_ \mathbb {N}</fr:tex> is defined to be identity function trivially. To see how <fr:tex>\text {add-succ}_ \mathbb {N}</fr:tex> is defined, we need to perform induction:
        <fr:tex display="block">              \begin {align*}                  \text {add}_ \mathbb {N} (m,  \text {succ} (n))&amp; \equiv                   \text {ind}_ \mathbb {N} ( \text {add-zero}_ \mathbb {N} (m),  \text {add-succ}_ \mathbb {N} (m),  \text {succ} (n))                  \\                  &amp; \equiv   \text {add-succ}_ \mathbb {N} (m,n,  \text {add}_ \mathbb {N} (m,n))                  \\                  &amp; \equiv   \text {succ} ( \text {add}_ \mathbb {N} (m,n))              \end {align*}         </fr:tex>
        Hence <fr:tex>\text {add-succ}_ \mathbb {N}</fr:tex> is defined as:
        <fr:tex display="block">              \text {add-succ}_ \mathbb {N} (m,n,x)  \equiv   \text {succ} (x)         </fr:tex>
        A formal construction of <fr:tex>\text {add-succ}_ \mathbb {N}</fr:tex> is as follows:
        <fr:tex display="block">              \dfrac {                  \dfrac {                      \dfrac {                          \dfrac {}{ \vdash \mathbb {N} \space \text {type} }                          \quad                           \dfrac {                              \dfrac {}{ \vdash   \mathbb {N} \space \text {type} }                              \quad                               \dfrac {}{ \vdash   \text {succ} : \mathbb {N} \to \mathbb {N} }                         }{                             n: \mathbb {N} \vdash \text {succ} : \mathbb {N} \to \mathbb {N}                          }                     }{                         m: \mathbb {N} , n: \mathbb {N} \vdash   \text {succ} : \mathbb {N} \to \mathbb {N}                      }                  }{                     m: \mathbb {N} \vdash \lambda  n. \text {succ}  :  \mathbb {N} \to ( \mathbb {N} \to \mathbb {N} )                 }             }{                 m: \mathbb {N} \vdash   \text {add-succ}_ \mathbb {N} (m): \equiv \lambda  m. \text {succ}  :  \mathbb {N} \to ( \mathbb {N} \to \mathbb {N} )             } \text {Block-1}         </fr:tex>
        Finally we combine the derivation together:
        <fr:tex display="block">              \dfrac {                  \dfrac {                      \dfrac {                          \dfrac {                              \vdash   \mathbb {N} \space \text {type}                          }{                             m: \mathbb {N} \vdash  m: \mathbb {N}                          }                     }{                         m: \mathbb {N} \vdash \text {add-zero}_ \mathbb {N} (m): \equiv  m: \mathbb {N}                      }                      \quad                        \dfrac { \text {Block-1}}{                         m: \mathbb {N} \vdash \text {add-succ}_ \mathbb {N} (m): \mathbb {N} \to ( \mathbb {N} \to \mathbb {N} )                     }                 }{                     m: \mathbb {N} \vdash \text {ind}_ \mathbb {N}  ( \text {add-zero}_ \mathbb {N} (m),  \text {add-succ}_ \mathbb {N} (m)): \mathbb {N} \to \mathbb {N}                  }             }{                 m: \mathbb {N} \vdash \text {add}_ \mathbb {N} (m): \equiv \text {ind}_ \mathbb {N}  ( \text {add-zero}_ \mathbb {N} (m),  \text {add-succ}_ \mathbb {N} (m)): \mathbb {N} \to \mathbb {N}              }         </fr:tex>
    
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:p>
    Recall the definition of addition function <fr:tex>\text {add}:  \mathbb {N} \to ( \mathbb {N} \to \mathbb {N} )</fr:tex> satisfying the specification:
    <fr:tex display="block">          \begin {align*}             m + 0 &amp; : \equiv  m              \\               m +  \text {succ} (n) &amp; : \equiv   \text {succ} (m + n)          \end {align*}     </fr:tex>
    Such definition is enough to characterize the addition function.
    Because it postulates te <fr:em>behavior</fr:em> of <fr:tex>\text {add}_ \mathbb {N}</fr:tex> at the constructor of <fr:tex>\mathbb {N}</fr:tex></fr:p><fr:p>
    More generally, we can define a dependent function <fr:tex>f: \Pi  n: \mathbb {N} .P(n)</fr:tex> by induction on <fr:tex>n</fr:tex> using
    <fr:tex display="block">          \begin {align*}             p_0 &amp; : P(0)              \\              p_S &amp; :  \Pi _{(n: \mathbb {N} )}P(n) \to  P( \text {succ} (n))          \end {align*}     </fr:tex>
    Just present the definition by writing
    <fr:tex display="block">          \begin {align*}             f(0) &amp; : \equiv  p_0              \\              f( \text {succ} (n)) &amp; : \equiv  p_S(n,f(n))          \end {align*}     </fr:tex>
    <fr:tex>f</fr:tex> is said to be defined by <fr:strong>pattern matching</fr:strong> on the variable <fr:tex>n</fr:tex>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>266</fr:anchor><fr:taxon>Example</fr:taxon><fr:addr>eg-0001</fr:addr><fr:route>eg-0001.xml</fr:route><fr:title>Fibonacci Function</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>Fibonacci function</fr:strong> is a well-known function in mathematics.
    It is defined by pattern matching on the variable <fr:tex>n</fr:tex> as follows:
    <fr:tex display="block">          \begin {align*}              \text {fib}(0) &amp; : \equiv  0              \\               \text {fib}(1) &amp; : \equiv  1              \\               \text {fib}(n+2) &amp; : \equiv   \text {fib}(n) +  \text {fib}(n+1)          \end {align*}     </fr:tex></fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false"><fr:frontmatter><fr:anchor>281</fr:anchor><fr:taxon>Type Theory</fr:taxon><fr:addr>tt-0004</fr:addr><fr:route>tt-0004.xml</fr:route><fr:title>Inductive Types</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
    In previous post, we have seen the definition of natural numbers as an inductive type.
    In this post, we will see more examples of inductive types, such as 
    unit type, empty type, product type, sum type and etc.
    Refer to <fr:link href="hott-2022.xml" type="local" addr="hott-2022">Egbert Rijke&apos;s Book</fr:link>.
</fr:p><fr:p>
    This section is much more informal than the previous one.
    Without displaying the inference rules, we will just present the <fr:strong>constructor</fr:strong>
    and <fr:strong>induction principle</fr:strong> of each inductive type.
</fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>268</fr:anchor><fr:title><fr:strong>General Inductive Type</fr:strong></fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:parent>tt-0004</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
    Just like <fr:tex>\mathbb {N}</fr:tex>, other inductive types can be defined by 
    their constructors and induction principles (and computation rules).
    </fr:p>
    <fr:ul><fr:li>
            The constructors specify the structure of the type equipped.
        </fr:li>
        <fr:li>
            The induction principle specifies the data required to construct 
            a section of an arbitrary type family over the inductive type.
        </fr:li>
        <fr:li>
            The computation rules specify the behavior of the constructors.
        </fr:li></fr:ul>
</fr:mainmatter></fr:tree>
<fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>269</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0020</fr:addr><fr:route>def-0020.xml</fr:route><fr:title>Unit Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
        
        The <fr:strong>unit type</fr:strong> is the simplest inductive type.
        It has only one constructor, denoted by <fr:tex>\star : \textbf {1}</fr:tex>.
    </fr:p><fr:p>
        The induction principle of the unit type is trivial.
        It says that to define a dependent function <fr:tex>f: \Pi  _{(x: \textbf {1} )} P(x)</fr:tex>, 
        it suffices to give a value <fr:tex>p:P( \star )</fr:tex>.
        <fr:tex display="block">             f ( \star ) : \equiv  p         </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:p>
    A degenrate inductive type is the <fr:strong>empty type</fr:strong>.
    It has no constructor, and its induction principle is trivial.
    Empty type is connected to the <fr:strong>exfalso quodlibet principle</fr:strong> in logic.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>270</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0021</fr:addr><fr:route>def-0021.xml</fr:route><fr:title>Empty Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>empty type</fr:strong> is a degenerate inductive type <fr:tex>\emptyset</fr:tex> satisfying 
    the following induction principle:
    <fr:tex display="block">          \text {ind}_ \emptyset  :  \Pi _{(x: \emptyset )}P(x)     </fr:tex>
    And a special case is <fr:strong>exfalso</fr:strong>:
    <fr:tex display="block">          \text {exfalso} : \equiv   \text {ind}_ \emptyset  :  \empty   \to  A      </fr:tex>
    which can draw any conclusion.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    With the empty type we can define the <fr:strong>negation</fr:strong> of a type
    and the <fr:strong>proof of negation</fr:strong>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>272</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0022</fr:addr><fr:route>def-0022.xml</fr:route><fr:title>Type Negation</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>negation</fr:strong> of type <fr:tex>A</fr:tex> is defined as
    <fr:tex display="block">          \neg  A : \equiv  A  \to   \emptyset      </fr:tex>
    A type <fr:tex>A</fr:tex> is said to be <fr:strong>empty</fr:strong> if and only if <fr:tex>\neg  A</fr:tex> is inhabited.
    <fr:tex display="block">          \text {empty}(A) : \equiv   \neg  A     </fr:tex></fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>271</fr:anchor><fr:title><fr:strong>Proof of negation</fr:strong></fr:title><fr:parent>def-0022</fr:parent></fr:frontmatter><fr:mainmatter>
        <fr:p>
            To prove <fr:tex>\neg  A</fr:tex>, we need to show that <fr:tex>A</fr:tex> implies a contradiction.
            In other words, constructing a function of type <fr:tex>A  \to   \emptyset</fr:tex>.
        </fr:p>
    </fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>273</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0023</fr:addr><fr:route>def-0023.xml</fr:route><fr:title>Coproduct Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>A</fr:tex> and <fr:tex>B</fr:tex> be types. The <fr:strong>coproduct (disjoint sum)</fr:strong> <fr:tex>A+B</fr:tex> is a typed defined by the following constructors:
    <fr:ul><fr:li><fr:tex>\text {inl} :A \to  A+B</fr:tex></fr:li>
        <fr:li><fr:tex>\text {inr} :B \to  A+B</fr:tex></fr:li></fr:ul>
    For any type family indexed by <fr:tex>x:A+B</fr:tex>, satisfies the following induction principle:
    <fr:tex display="block">          \text {ind}_ + : ( \Pi _{(x:A)}P( \text {inl} (x))) \to ( \Pi _{(y:B)}P( \text {inr} (y))) \to \Pi _{(z:A+B)}P(z)     </fr:tex>
    (Note that sometimes we denoted <fr:tex>\text {ind}_ + (f,g)</fr:tex> as <fr:tex>[f,g]</fr:tex>) And the computation rule:
    <fr:tex display="block">          \begin {align*}              \text {ind}_ + (f,g, \text {inl} (x))&amp; \equiv  f(x) \\               \text {ind}_ + (f,g, \text {inr} (y))&amp; \equiv  g(y)          \end {align*}     </fr:tex>
    where <fr:tex>f</fr:tex> and <fr:tex>g</fr:tex> are defined:
    <fr:tex display="block">          \begin {align*}             f&amp;: \Pi _{(x:A)}P( \text {inl} (x)) \\              g&amp;: \Pi _{(y:B)}P( \text {inr} (y))          \end {align*}     </fr:tex>
    This can be presented by pattern matching to define a function <fr:tex>h: \Pi  _{(z:A+B)}.P(z)</fr:tex>:
    <fr:tex display="block">          \begin {align*}             h( \text {inl} (x))&amp;: \equiv  f(x) \\              h( \text {inr} (y))&amp;: \equiv  g(y)          \end {align*}     </fr:tex></fr:p></fr:mainmatter></fr:tree>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>274</fr:anchor><fr:title><fr:strong>Special Case of Coproduct</fr:strong></fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:parent>tt-0004</fr:parent></fr:frontmatter><fr:mainmatter>
    The special case of coproduct type is also called the <fr:strong>sum type</fr:strong>.
    <fr:tex display="block">          \text {ind}_ + : (A  \to  X)  \to  (B  \to  X)  \to  (A+B  \to  X)     </fr:tex>
    which is very similar to the <fr:strong>elimination rule</fr:strong> of disjunction in logic.
    <fr:tex display="block">         (P \to  Q)  \to  (R \to  Q)  \to  (P \vee  R \to  Q)     </fr:tex>
</fr:mainmatter></fr:tree>
<fr:p>
    The dependent version of sum type is called the <fr:strong>dependent sum type (dependent coproduct)</fr:strong> traditionally.
    Its terms are ordered pairs.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>280</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0024</fr:addr><fr:route>def-0024.xml</fr:route><fr:title>Dependent Pair Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>dependent pair type</fr:strong> is a inductive type <fr:tex>\Sigma _{(x:A)}B(x)</fr:tex> (<fr:tex>(x:A)  \times  B(x)</fr:tex>)
</fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>275</fr:anchor><fr:title>
    <fr:strong>Formation Rule</fr:strong>
</fr:title><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
        Given a type family <fr:tex>B</fr:tex> over <fr:tex>A</fr:tex>, we can form the dependent pair type <fr:tex>\Sigma _{(x:A)}B(x)</fr:tex>.
    </fr:p>
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \space \text {type}               \quad               \Gamma ,x:A \vdash  B(x) \space \text {type}          }{              \Gamma \vdash  (x:A)  \times  B(x) \space \text {type}          }     </fr:tex>
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>276</fr:anchor><fr:title>
    <fr:strong>Introduction Rule</fr:strong>
</fr:title><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
        Given a term <fr:tex>a:A</fr:tex> and a term <fr:tex>b(a):B(a)</fr:tex>, we can form a term <fr:tex>\text {pair} (a,b):(x:A) \times  B(x)</fr:tex>.
    </fr:p>
    <fr:tex display="block">          \frac {              \Gamma \vdash  a:A              \quad               \Gamma \vdash  b(a):B(a)         }{              \Gamma \vdash  (a,b):(x:A) \times  B(x)         }     </fr:tex>
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>277</fr:anchor><fr:title>
    <fr:strong>Elimination Rule</fr:strong>
</fr:title><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
        The elimination rule is formed with two projections.
        <fr:tex display="block">              \frac {                  \Gamma \vdash  p:(x:A) \times  B(x)             }{                  \begin {align*}                      \Gamma &amp; \vdash   \text {pr}_ A (p):A \\                       \Gamma &amp; \vdash   \text {pr}_ B (p):B( \text {pr}_ A (p))                  \end {align*}             }         </fr:tex></fr:p>
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>278</fr:anchor><fr:title>
    <fr:strong>Computation Rule</fr:strong>
</fr:title><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p><fr:tex display="block">              \frac {                  \Gamma \vdash  x:A                   \quad                    \Gamma \vdash  y:B(x)             }{                  \begin {align*}                      \Gamma &amp; \vdash   \text {pr}_ A ((x,y))=x:A \\                       \Gamma &amp; \vdash   \text {pr}_ B ((x,y))=y:B(x)                  \end {align*}             }         </fr:tex></fr:p>
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>279</fr:anchor><fr:title>
    <fr:strong>Special Case</fr:strong>
</fr:title><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:ul><fr:li>
            In the special case that <fr:tex>B(x) = B</fr:tex> is independent of <fr:tex>A</fr:tex>,
            this reduces to the <fr:strong>product type</fr:strong> <fr:tex>A \times  B</fr:tex>.
        </fr:li>
        <fr:li>
            In the special case that <fr:tex>D  \equiv   \text {Boolean}</fr:tex>,
            this reduces to a <fr:link href="def-0023.xml" type="local" addr="def-0023">coproduct type</fr:link>.
        </fr:li></fr:ul>
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false"><fr:frontmatter><fr:anchor>299</fr:anchor><fr:taxon>Type Theory</fr:taxon><fr:addr>tt-0005</fr:addr><fr:route>tt-0005.xml</fr:route><fr:title>Identity Types</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>31</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
    This post discuss the identity types in type theory.
    Refer to <fr:link href="hott-2022.xml" type="local" addr="hott-2022">Introduction to Homotopy Type Theory</fr:link>.
</fr:p><fr:p>
    How can we think of <fr:strong>equality</fr:strong> in type theory?
    Mentioned before, given a type <fr:tex>A</fr:tex> and two its elements <fr:tex>a,b:A</fr:tex>
    we can define a new type <fr:tex>a=_Ab</fr:tex> which is called the <fr:strong>identity type</fr:strong>.
    In this case, a term of <fr:tex>a=_Ab</fr:tex> is said to be a <fr:em>witness</fr:em> of the equality of <fr:tex>a</fr:tex> and <fr:tex>b</fr:tex>.
    And this witness is itself a type.
    We can then define their equality.
    This gives every type a <fr:strong>groupoid structure</fr:strong>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>284</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-002N</fr:addr><fr:route>def-002N.xml</fr:route><fr:title>Identity Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>identity type</fr:strong> is an inductive type,
    generated by just a <fr:strong>reflexivity</fr:strong> <fr:em>identification</fr:em>
    that providing an equality of a term with itself.
</fr:p><fr:p>
    Consider a type <fr:tex>A</fr:tex> and let <fr:tex>a:A</fr:tex> be an element.
    The identity type of <fr:tex>A</fr:tex> at <fr:tex>a</fr:tex> is an inductive family of types <fr:tex>a=_Ax</fr:tex> 
    indexed by <fr:tex>x:A</fr:tex>.
    <fr:tex display="block">          \frac {              \Gamma \vdash  a:A         }{              \Gamma ,x:A \vdash  a=_Ax \space \text {type}          }     </fr:tex>
    The only constructor is the refl:
    <fr:tex display="block">          \frac {              \Gamma \vdash  a:A         }{              \Gamma \vdash   \text {refl} _a:a=_Ax         }     </fr:tex></fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>282</fr:anchor><fr:title><fr:strong>
    Path Induction / Identification Elimination
</fr:strong></fr:title><fr:parent>def-002N</fr:parent></fr:frontmatter><fr:mainmatter>
    The induction principle of the identity type states that
    for any type family <fr:tex>P(x,p)</fr:tex> indexed by <fr:tex>x:A</fr:tex> and <fr:tex>p:a=_Ax</fr:tex>,
    <fr:tex display="block">          \text {ind-eq}_{ a } :P(a,  \text {refl} _a) \to  (x:A) \to  (p:a=_Ax) \to  P(x,p)     </fr:tex>
    satisfies <fr:tex>\text {ind-eq}_{ a } (u,a, \text {refl} _a) \equiv  u</fr:tex> where <fr:tex>u:P(a, \text {refl} _a)</fr:tex>.
    Formally we can write:
    <fr:tex display="block">          \frac {              \Gamma \vdash  a:A, \quad   \Gamma ,x:A,p:a=_Ax \vdash  P(x,p) \space \text {type}          }{              \Gamma \vdash   \text {ind-eq}_{ a } (a, \text {refl} _a): P(a, \text {refl} _a)  \to  (x:A) \to  (p:a=_Ax) \to  P(x,p)         } \text {eq-elim}     </fr:tex>
    <fr:tex display="block">          \frac {              \Gamma \vdash  a:A, \quad   \Gamma ,x:A,p:a=_Ax \vdash  P(x,p) \space \text {type}          }{              \Gamma ,u:P(a, \text {refl} _a) \vdash   \text {ind-eq}_{ a } (u,a, \text {refl} _a) \equiv  u:P(a, \text {refl} _a)         } \text {eq-comp}     </fr:tex>

</fr:mainmatter></fr:tree>
<fr:p>
    A term of <fr:tex>a=_Ax</fr:tex> is called a <fr:strong>identification</fr:strong> of <fr:tex>a</fr:tex> and <fr:tex>x</fr:tex>,
    or the <fr:strong>path</fr:strong> from <fr:tex>a</fr:tex> to <fr:tex>x</fr:tex>.
</fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>283</fr:anchor><fr:title><fr:strong>Variable Version</fr:strong></fr:title><fr:parent>def-002N</fr:parent></fr:frontmatter><fr:mainmatter>
    We can form an identity type with variables of <fr:tex>A</fr:tex>.
    <fr:tex display="block">          \Gamma ,x:A,y:A \vdash  x=_Ay \space \text {type}      </fr:tex>
    with the following introduction rule:
    <fr:tex display="block">          \frac {              \Gamma ,x:A \vdash  x:A         }{              \Gamma ,x:A \vdash   \text {refl} _x:x=_Ax         }     </fr:tex>
    and similarly the elimination rule and computation rule.
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>293</fr:anchor><fr:title>The groupoid structure of types</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>31</fr:day></fr:date><fr:parent>tt-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
        The identifications can be <fr:strong>concatenated</fr:strong> and <fr:strong>inverted</fr:strong>,
        which implies the <fr:em>transitivity</fr:em> and <fr:em>symmetry</fr:em> of the identity type.
    </fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>286</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-002O</fr:addr><fr:route>def-002O.xml</fr:route><fr:title>Concatenation Operation</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>A</fr:tex> be a type.
    The <fr:strong>Concatenation</fr:strong> operation is defined:
    <fr:tex display="block">          \text {concat} : (x:A) \to  (y:A) \to  (z:A) \to  (x=_Ay) \to  (y=_Az) \to  (x=_Az)     </fr:tex></fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>285</fr:anchor><fr:title>Construction of Concatenation</fr:title><fr:parent>def-002O</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
        We can first construct:
        <fr:tex display="block">             f(x):(y:A) \to  (x=_Ay) \to (z:A) \to  (y=_Az) \to (x=_Az)         </fr:tex>
        For any <fr:tex>x:A</fr:tex>, it suffices to construct
        <fr:tex display="block">             f(x,x, \text {refl} _x) : (z:A)  \to  (x=_Az) \to (x=_Az)         </fr:tex>
        That is the identity function <fr:tex>\lambda  z.  \text {id} _{x=_Az}</fr:tex>.
        Then we can define by induction:
        <fr:tex display="block">             f(x) : \equiv   \text {ind-eq}_{ x } ( \lambda  z. \text {id} )         </fr:tex>
        Finally:
        <fr:tex display="block">              \text {concat} _{x,y,z}(p,q) : \equiv  f(x,y,p,z,q)         </fr:tex>
        Or simply we denote <fr:tex>\text {concat} (p,q)</fr:tex> as <fr:tex>p  \cdot  q</fr:tex></fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>288</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-002P</fr:addr><fr:route>def-002P.xml</fr:route><fr:title>Inverse Operation</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>A</fr:tex> be a type. The <fr:strong>inverse oepration</fr:strong> is defined:
    <fr:tex display="block">          \text {inv} : (x:A) \to  (y:A) \to  (x=_Ay) \to  (y=_Ax)     </fr:tex>
    Most of the time we write <fr:tex>p^{-1}</fr:tex> for <fr:tex>\text {inv} (p)</fr:tex>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>287</fr:anchor><fr:title>Construction of Inverse</fr:title><fr:parent>def-002P</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
        By induction, it suffices to construct:
        <fr:tex display="block">              \text {inv} (x,x, \text {refl} _x) : (x=_Ax)         </fr:tex>
        for any <fr:tex>x:A</fr:tex>. And trivially we have <fr:tex>\text {inv} (x,x, \text {refl} _x) \equiv \text {refl} _x</fr:tex>.
    </fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:p>
        It is natural to ask whether the identity type is <fr:em>reflexive</fr:em>.
        In the case of associativity we should ask to compare the identifications:
        <fr:tex display="block">             (p \cdot  q) \cdot  r  \quad \text {and} \quad  p \cdot (q \cdot  r)         </fr:tex>
        for any <fr:tex>p:x=y</fr:tex>, <fr:tex>q:y=z</fr:tex> and <fr:tex>r:z=w</fr:tex> in a type <fr:tex>A</fr:tex>. Both <fr:tex> (p \cdot  q) \cdot  r</fr:tex> and 
        <fr:tex>p \cdot (q \cdot  r)</fr:tex> are elements of type <fr:tex>x=w</fr:tex>. We can ask whether there is an
        identification
        <fr:tex display="block">             (p \cdot  q) \cdot  r = p \cdot (q \cdot  r)         </fr:tex></fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>290</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-002W</fr:addr><fr:route>def-002W.xml</fr:route><fr:title>Associator</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>A</fr:tex> be a type.
    These are 3 consecutive identifications
    <fr:tex display="block">         p:x=_Ay,q:y=_Az, r:z=_Aw     </fr:tex>
    we define the <fr:strong>associator</fr:strong>:
    <fr:tex display="block">          \text {assoc} : (p,q,r): (p \cdot  q) \cdot  r = p \cdot  (q \cdot  r)     </fr:tex></fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>289</fr:anchor><fr:title>
    <fr:strong>Construction of Associator</fr:strong>
</fr:title><fr:parent>def-002W</fr:parent></fr:frontmatter><fr:mainmatter>
    By definition it suffices to show that
    <fr:tex display="block">          \Pi _{(z:A)} \Pi _{(q:x=_Az)}          \Pi _{(w:A)} \Pi _{(r:z=_Aw)}         ( \text {refl} _x \cdot  q) \cdot  r =  \text {refl} _x \cdot  (q \cdot  r)     </fr:tex>
    Let <fr:tex>q:x=_Az</fr:tex> and <fr:tex>r:z=_Aw</fr:tex>. By computation rule of identity types
    <fr:tex display="block">          \text {refl} _x \cdot  q  \equiv  q     </fr:tex>
    Then we can conclude that
    <fr:tex display="block">         ( \text {refl} _x \cdot  q) \cdot  r  \equiv  q \cdot  r     </fr:tex>
    similarly <fr:tex>\text {refl} _x \cdot  (q \cdot  r)  \equiv  q \cdot  r</fr:tex>.
    Hence we have the left and right side
    <fr:tex display="block">         ( \text {refl} _x \cdot  q) \cdot  r =  \text {refl} _x \cdot  (q \cdot  r)     </fr:tex>
    are judgementally equal, 
    so we can simply define the associator as
    <fr:tex display="block">          \text {assoc} ( \text {refl} _x,q,r) : \equiv   \text {refl} _{q \cdot  r}     </fr:tex>
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>292</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-002X</fr:addr><fr:route>def-002X.xml</fr:route><fr:title>Unit Law Operations</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>A</fr:tex> be a type.
    We defined the <fr:strong>unit law</fr:strong> operations for <fr:tex>x=_Ay</fr:tex>:
    <fr:tex display="block">          \begin {align*}              \text {left-unit} &amp; : (x=_Ay) \to  ( \text {refl} _x \cdot  x = x)  \\               \text {right-unit} &amp; : (x=_Ay) \to  (x \cdot \text {refl} _y = x)          \end {align*}     </fr:tex></fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>291</fr:anchor><fr:title>
    <fr:strong>Construction of Unit Law</fr:strong>
</fr:title><fr:parent>def-002X</fr:parent></fr:frontmatter><fr:mainmatter>
    By elimination it suffices to construct:
    <fr:tex display="block">          \begin {align*}              \text {left-unit}( \text {refl} _x) &amp;:  \text {refl} _x  \cdot   \text {refl} _x =  \text {refl} _x  \\               \text {right-unit}( \text {refl} _x) &amp;:  \text {refl} _x  \cdot   \text {refl} _x =  \text {refl} _x          \end {align*}     </fr:tex>
    In both cases we need only to construct <fr:tex>\text {refl} _{ \text {refl} _x}</fr:tex>.
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>296</fr:anchor><fr:title>The action on identifications of functions</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>31</fr:day></fr:date><fr:parent>tt-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
        Every function preserves identifications.
    </fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>294</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-004C</fr:addr><fr:route>def-004C.xml</fr:route><fr:title>Action on Paths</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>f:A \to  B</fr:tex> be a map. We define the <fr:strong>action on paths</fr:strong> of <fr:tex>f</fr:tex> as an operation:
    <fr:tex display="block">          \text {ap} _f :  \prod _{x,y:A} (x=y)  \to  (f(x)=f(y))     </fr:tex>
    This can be defined by induction principle of identity types:
    <fr:tex display="block">          \text {ap} _f( \text {refl} _x)  \equiv   \text {refl} _{f(x)}     </fr:tex>
    And there are operations:
    <fr:tex display="block">          \text {ap-id}_A:        \prod _{(x,y:A)} \prod _{(p:x=y)} p =  \text {ap} _{ \text {id} _A}(p)     </fr:tex>
    Taking
    <fr:tex display="block">          \text {ap-id}_A( \text {refl} _x)  \equiv   \text {refl} _{ \text {refl} _x}     </fr:tex>
    Finally we can construct
    <fr:tex display="block">          \text {ap-comp}(f, g):  \prod _{(x,y:A)} \prod _{(p:x=y)}  \text {ap} _{f \circ  g}(p) =  \text {ap} _f( \text {ap} _g(p))     </fr:tex>
    by taking
    <fr:tex display="block">          \text {ap-comp}(f,g, \text {refl} _x)  \equiv   \text {refl} _{ \text {refl} _{g(f(x))}}     </fr:tex>
    There are identifications:
    <fr:ul><fr:li>
            Notice that we have <fr:tex>\text {ap-id}_A( \text {refl} _x)  \equiv   \text {refl} _{ \text {refl} _x}</fr:tex> so
            <fr:tex display="block">                  \begin {align*}                      \text {ap-refl}(f,x) &amp;: \text {ap} _f( \text {refl} _x) =  \text {refl} _{f(x)}  \\                       \text {ap-refl}(f,x) &amp; \equiv   \text {refl} _{ \text {refl} _{f(x)}}                  \end {align*}             </fr:tex></fr:li>
        <fr:li>
            The <fr:tex>\text {ap-inv}</fr:tex> can be constructed by identification elimination on <fr:tex>p</fr:tex>.
            <fr:tex display="block">                  \begin {align*}                     &amp; \text {ap-inv}(f,p): \text {ap} _f(p^{-1}) =  \text {ap} _f(p)^{-1} \\                      &amp; \text {ap-inv}(f, \text {refl} _x) \equiv   \text {refl} _{ \text {ap} _f( \text {refl} _x)}                  \end {align*}             </fr:tex></fr:li>
        <fr:li>
            Similarly, the <fr:tex>\text {ap-concat}</fr:tex> can be constructed by identification elimination on <fr:tex>p</fr:tex>.
            <fr:tex display="block">                  \begin {align*}                     &amp; \text {ap-concat}(f,p,q): \text {ap} _f(p \cdot  q) =  \text {ap} _f(p) \cdot   \text {ap} _f(q)  \\                      &amp; \text {ap-concat}(f, \text {refl} _x,q) \equiv   \text {refl} _{ \text {ap} _f(q)}                  \end {align*}             </fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter></fr:tree><fr:p>
        To construct dependent action on paths if a dependent function <fr:tex>f: \Pi _{(x:A)}B(x)</fr:tex>.
        We need a <fr:strong>transport</fr:strong> because type theory can not distinguish between identified 
        elements from different types.
    </fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>295</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-004D</fr:addr><fr:route>def-004D.xml</fr:route><fr:title>Transport</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>A</fr:tex> be a type and let <fr:tex>B</fr:tex> be a type family over <fr:tex>A</fr:tex>.
    The <fr:strong>transport</fr:strong> operation is defined:
    <fr:tex display="block">          \text {tr} _B: \Pi _{(x,y:A)}(x=y) \to  B(x) \to  B(y)     </fr:tex>
    Simply induction on <fr:tex>p:x=y</fr:tex> we can construct:
    <fr:tex display="block">          \text {tr} _B( \text {refl} _x)  \equiv   \text {id} _{B(x)}     </fr:tex></fr:p><fr:p>
    Now for a given dependent function <fr:tex>f: \Pi _{(a:A)}B(a)</fr:tex> and an identification
    <fr:tex>p:x=y</fr:tex> in <fr:tex>A</fr:tex> we can construct
    <fr:tex display="block">          \text {apd} _f(p) :  \text {tr} _B(p,f(x)) = f(y)     </fr:tex>
    this can be constructed by the induction principle for identity types,
    it suffices to construct an identification:
    <fr:tex display="block">          \text {apd} _f( \text {refl} _x) :  \text {tr} _B( \text {refl} _x,f(x)) = f(x)     </fr:tex>
    which is simply done by taking <fr:tex>\text {apd} _f( \text {refl} _x) \equiv \text {refl} _{f(x)}</fr:tex></fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>298</fr:anchor><fr:title>Uniqueness of refl</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>31</fr:day></fr:date><fr:parent>tt-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
        The identity type is an inductive family of types.
        For instance, while the type <fr:tex>a=x</fr:tex> indexed by <fr:tex>x:A</fr:tex> is inductively generated by <fr:tex>\text {refl} _a</fr:tex>,
        the type <fr:tex>a=a</fr:tex> is <fr:strong>not</fr:strong>, because the endpoint of <fr:tex>p:a=a</fr:tex> is not free. 
        We want to show that <fr:tex>p= \text {refl} _a</fr:tex> for all <fr:tex>p:a=a</fr:tex>. 
    </fr:p><fr:p>
        Nevertheless the identity type <fr:tex>a=x</fr:tex> is generated by a single element <fr:tex>\text {refl} _a:a=a</fr:tex>,
        so it is natural to wonder in <fr:em>what sense</fr:em> the reflexivity identification is unique.
        We prove that only one pair <fr:tex>(a, \text {refl} _a)</fr:tex> is unique in the type of all pairs:
        <fr:tex display="block">             (x,p): \Sigma _(x:A) a = x          </fr:tex>
        We restate this as a proposition: Consider an element <fr:tex>a:A</fr:tex>. Then there is an identification
        <fr:tex>(a,  \text {refl} _a = y)</fr:tex> in the type <fr:tex>\Sigma _(x:A) a = x</fr:tex> for any <fr:tex>y: \Sigma _(x:A) a = x </fr:tex></fr:p>
 
   
   <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>297</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>31</fr:day></fr:date></fr:frontmatter><fr:mainmatter>
        By <fr:tex>\Sigma</fr:tex> induction it suffices to show that there is an identification
        <fr:tex display="block">             (a,  \text {refl} _a) = (x, p)         </fr:tex>
        forall <fr:tex>x:A</fr:tex> and <fr:tex>p:a=x</fr:tex>. Then perform the induction principle of identity types.
        It suffices to show that
        <fr:tex display="block">             (a, \text {refl} _a) = (a,  \text {refl} _a)         </fr:tex>
        which can be obtained by reflexivity.
    </fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false"><fr:frontmatter><fr:anchor>309</fr:anchor><fr:taxon>Type Theory</fr:taxon><fr:addr>tt-0006</fr:addr><fr:route>tt-0006.xml</fr:route><fr:title>Universe</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
    This post discuss the universe in type theory,
    based on Egbert Rijke&apos;s <fr:link href="hott-2022.xml" type="local" addr="hott-2022">Introduction to Homotopy Type Theory</fr:link> and <fr:link href="ncatlab.xml" type="local" addr="ncatlab">NLab</fr:link>.
    In this post, we regard universe as the representation of types in an internal model 
    of the type theory (<fr:strong>Tarski universe</fr:strong> or <fr:strong>universe à la Tarski</fr:strong>).
</fr:p><fr:p>
    A universe consist of a type <fr:tex>\mathcal {U}</fr:tex> with a type family <fr:tex>\mathcal {T}</fr:tex> over <fr:tex>\mathcal {U}</fr:tex>.
    Forall <fr:tex>X: \mathcal {U}</fr:tex> we think of <fr:tex>X</fr:tex> as an <fr:strong>encoding</fr:strong> (representation) of the actual type <fr:tex>\mathcal {T} (X)</fr:tex>.
    The type family <fr:tex>\mathcal {T}</fr:tex> is therefore called a <fr:strong>unversal type family</fr:strong>.
</fr:p><fr:p>
    There several reasons to equip type theory with universes.
    It enables us to define new type families over inductive types, using induction principle.
    For instance, we can define <fr:strong>relations</fr:strong> over <fr:tex>\mathbb {N}</fr:tex>, such as ordering relations <fr:tex>\leq</fr:tex>.
    We will soon meet the idea of <fr:strong>observational equality</fr:strong> for a particular type, different from identity types.
    Another reason is that it allows us to define types equipped with structure such as group.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>305</fr:anchor><fr:title>Specification</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:parent>tt-0006</fr:parent></fr:frontmatter><fr:mainmatter><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>301</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-004E</fr:addr><fr:route>def-004E.xml</fr:route><fr:title>Tarski Universe</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    A <fr:strong>universe</fr:strong> consists of a type <fr:tex>\mathcal {U}</fr:tex> of which the elements are representations of types.
    It is equipped with a type family <fr:tex>\mathcal {T}</fr:tex> indexed by <fr:tex>\mathcal {U}</fr:tex> called <fr:strong>universal type family</fr:strong>.
    The universe is closed under all the type constructors in the sense that it comes equipped with the following structure:
    <fr:ul><fr:li><fr:tex>\mathcal {U}</fr:tex> is closed under <fr:tex>\Pi</fr:tex>, equipped with a function
            <fr:tex display="block">                  \check { \Pi }: \Pi _{(X: \mathcal {U} )}( \mathcal {T} (X) \to \mathcal {U} ) \to \mathcal {U}              </fr:tex>
            for which the judgemental equality
            <fr:tex display="block">                  \mathcal {T} ( \check { \Pi }(X,P)) \equiv \Pi _{(x: \mathcal {T} (X))} \mathcal {T} (P(x))             </fr:tex>
            holds forall <fr:tex>X: \mathcal {U}</fr:tex> and <fr:tex>P: \mathcal {T} (X) \to \mathcal {U}</fr:tex>.
        </fr:li>
        <fr:li><fr:tex>\mathcal {U}</fr:tex> is closed under <fr:tex>\Sigma</fr:tex>, equipped with a function
            <fr:tex display="block">                  \check { \Sigma }: \Pi _{(X: \mathcal {U} )}( \mathcal {T} (X) \to \mathcal {U} ) \to \mathcal {U}              </fr:tex>
            for which the judgemental equality
            <fr:tex display="block">                  \mathcal {T} ( \check { \Sigma }(X,P)) \equiv \Sigma _{(x: \mathcal {T} (X))} \mathcal {T} (P(x))             </fr:tex>
            holds forall <fr:tex>X: \mathcal {U}</fr:tex> and <fr:tex>P: \mathcal {T} (X) \to \mathcal {U}</fr:tex>.
        </fr:li>
        <fr:li><fr:tex>\mathcal {U}</fr:tex> is closed under identity types, equipped with a function
            <fr:tex display="block">                  \check {I}: \Pi _{(X: \mathcal {U} )} \mathcal {T} (X) \to \mathcal {T} (X) \to \mathcal {U}              </fr:tex>
            for which the judgemental equality
            <fr:tex display="block">                  \mathcal {T} ( \check {I}(X,x,y)) \equiv  (x=y)             </fr:tex>
            holds forall <fr:tex>X: \mathcal {U}</fr:tex> and <fr:tex>x,y: \mathcal {T} (X)</fr:tex>.
        </fr:li>
        <fr:li><fr:tex>\mathcal {U}</fr:tex> is closed under coproducts, equipped with a function
            <fr:tex display="block">                  \check {+}: \Pi _{(X: \mathcal {U} )}( \mathcal {T} (X) \to \mathcal {U} ) \to \mathcal {U}              </fr:tex>
            that satisfies the judgemental equality <fr:tex>\mathcal {T} (X \check {+}P) \equiv \mathcal {T} (X)+ \mathcal {T} (P)</fr:tex></fr:li>
        <fr:li><fr:tex>\mathcal {U}</fr:tex> contains elements <fr:tex>\check { \textbf {1} },  \check { \textbf {0} },  \check { \mathbb {N} } :  \mathcal {U}</fr:tex> that satisfies the judgemental equality
            <fr:tex display="block">                  \mathcal {T} ( \check { \textbf {0} }) \equiv   \textbf {0} ,                  \\   \mathcal {T} ( \check { \textbf {1} }) \equiv   \textbf {1} ,                  \\   \mathcal {T} ( \check { \mathbb {N} }) \equiv \mathbb {N}              </fr:tex></fr:li></fr:ul>
    Consider a universe <fr:tex>\mathcal {U}</fr:tex> and a type <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>.
    We say that <fr:tex>A</fr:tex> is a type in <fr:tex>\mathcal {U}</fr:tex> or that <fr:tex>\mathcal {U}</fr:tex> contains <fr:tex>A</fr:tex>,
    if there is an element <fr:tex>\check {A}: \mathcal {U}</fr:tex> such that <fr:tex>\Gamma \vdash \mathcal {T} ( \check {A}) \equiv  A \space \space \text {type}</fr:tex> holds.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>300</fr:anchor><fr:title>Enough Universe</fr:title><fr:parent>def-004E</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
        Sometimes we may consider the universe <fr:tex>\mathcal {U}</fr:tex> itself to be a type in some universes.
        If we have only one <fr:tex>\mathcal {U}</fr:tex>, the <fr:strong>Russell Paradox</fr:strong> may arise.
        Therefore we assume that there are <fr:strong>enough universes</fr:strong></fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>302</fr:anchor><fr:taxon>Postulate</fr:taxon><fr:addr>thm-0013</fr:addr><fr:route>thm-0013.xml</fr:route><fr:title>Enough Universe</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    We assume that there&apos;re <fr:strong>enough universe</fr:strong>, i.e.,
    for every finite list of types in context 
    <fr:tex display="block">          \Gamma _1 \vdash  A_1 \space \space \text {type} , \cdots , \Gamma _n \vdash  A_n \space \space \text {type}      </fr:tex>
    there is a universe <fr:tex>\mathcal {U}</fr:tex> that contains each <fr:tex>A_i</fr:tex> in the sense that <fr:tex>\mathcal {U}</fr:tex> comes equipped with
    <fr:tex display="block">          \Gamma _i \vdash \check {A_i}: \mathcal {U}      </fr:tex>
    for which the following judgement holds:
    <fr:tex display="block">          \Gamma _i  \vdash \mathcal {T} ( \check {A_i}) \equiv  A_i \space \space \text {type}      </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:p>
        Using the assumption we can obtain many specific universes.
    </fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>303</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-004F</fr:addr><fr:route>def-004F.xml</fr:route><fr:title>Base Universe</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>base universee</fr:strong> <fr:tex>\mathcal {U} _0</fr:tex> is defined using <fr:link href="thm-0013.xml" type="local" addr="thm-0013">universe postulate</fr:link>
    with empty context.
</fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>304</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-004G</fr:addr><fr:route>def-004G.xml</fr:route><fr:title>Successor Universe</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>successor universee</fr:strong> <fr:tex>\mathcal {U} ^+</fr:tex> of a universe <fr:tex>\mathcal {U}</fr:tex> is defined using <fr:link href="thm-0013.xml" type="local" addr="thm-0013">universe postulate</fr:link>
    with the following contexts:
    <fr:tex display="block">          \vdash \mathcal {U} \space \space \text {type} \quad  X: \mathcal {U} \vdash \mathcal {T} (X) \space \space \text {type}      </fr:tex>
    It therefore contains the type <fr:tex>\mathcal {U}</fr:tex> as well as type in <fr:tex>\mathcal {U}</fr:tex>, in the following sense
    <fr:tex display="block">          \begin {align*}             &amp; \vdash \check { \mathcal {U} }: \mathcal {U} ^+ \\               &amp; \vdash \mathcal {T} ^+( \check { \mathcal {U} }) \equiv \mathcal {U} \space \text {type} \\              &amp;X: \mathcal {U} \vdash \check { \mathcal {T} }(X): \mathcal {U} ^+ \\               &amp;X: \mathcal {U} \vdash \mathcal {T} ^+( \check { \mathcal {T} }(X)) \equiv \mathcal {T} (X) \space \text {type}            \end {align*}     </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:p>
        Using successor universes we can create an infinite tower of universes.
    </fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>308</fr:anchor><fr:title>Observational Equality</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:parent>tt-0006</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
        Now we give the example of <fr:strong>observational equality</fr:strong> of <fr:tex>\mathbb {N}</fr:tex>.
        The key idea is to define a recursive function that reduce the arguments.
        Observational equality an inductively defined relation, which gives us an algorithm for checking
        equality on  <fr:tex>\mathbb {N}</fr:tex>. It can be used to show that equality of natural numbers is <fr:strong>decidable</fr:strong>.
    </fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>307</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-004H</fr:addr><fr:route>def-004H.xml</fr:route><fr:title>Observational Equality of <fr:tex>\mathbb {N}</fr:tex></fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The observational equality of <fr:tex>\mathbb {N}</fr:tex> is a binary relation <fr:tex>\text {Eq} _ \mathbb {N} : \mathbb {N} \to ( \mathbb {N} \to \mathcal {U} _0)</fr:tex> satisfies
    <fr:tex display="block">          \begin {align*}              \text {Eq} _ \mathbb {N} (0)(0) &amp; \equiv   \textbf {1}   \\               \text {Eq} _ \mathbb {N} (0)( \text {succ} (n)) &amp; \equiv   \textbf {0}   \\               \text {Eq} _ \mathbb {N} ( \text {succ} (m))(0) &amp; \equiv   \textbf {0}   \\               \text {Eq} _ \mathbb {N} ( \text {succ} (m))( \text {succ} (n)) &amp; \equiv   \text {Eq} _ \mathbb {N} (m)(n)          \end {align*}     </fr:tex>
    
 
   
   <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>306</fr:anchor><fr:taxon>Proof</fr:taxon><fr:parent>def-004H</fr:parent></fr:frontmatter><fr:mainmatter>
        We define <fr:tex>\text {Eq}</fr:tex> by double induction on <fr:tex>\mathbb {N}</fr:tex>. By the first application of induction
        it suffices to provide
        <fr:tex display="block">              \begin {align*}                 &amp;E_0: \mathbb {N} \to \mathcal {U} _0  \\                   &amp;E_S: \mathbb {N} \to (( \mathbb {N} \to \mathcal {U} _0) \to ( \mathbb {N} \to \mathcal {U} _0))              \end {align*}         </fr:tex>
        we define <fr:tex>E_0</fr:tex> by induction:
        <fr:tex display="block">              \begin {align*}                 &amp;E_0(0)  \equiv \textbf {1} \\                   &amp;E_0( \text {succ} (n))  \equiv \textbf {0}               \end {align*}         </fr:tex>
        and also define <fr:tex>E_S</fr:tex> by induction:
        <fr:tex display="block">              \begin {align*}                 &amp;E_S(n,X,0) \equiv \textbf {0} \\                   &amp;E_S(n,X, \text {succ} (m)) \equiv  X(m)              \end {align*}         </fr:tex>
        Therefore we have by the computation rule for the first induction that 
        the following judgemental equality holds.
        <fr:tex display="block">              \begin {align*}                  \text {Eq} (0,m) &amp; \equiv  E_0(m)  \\                   \text {Eq} ( \text {succ} (n),m) &amp; \equiv  E_S(n, \text {Eq} (n),m)              \end {align*}         </fr:tex>
    </fr:mainmatter></fr:tree></fr:p></fr:mainmatter></fr:tree><fr:p>
        Observational equality of <fr:tex>\mathbb {N}</fr:tex> is a reflexive relation, i.e. we have
        <fr:tex display="block">              \text {refl-Eq}_ \mathbb {N} : \Pi _{(n: \mathbb {N} )} \text {Eq}_ \mathbb {N} (n,n)         </fr:tex>
        which is witnessed by induction on <fr:tex>n</fr:tex>.
        <fr:tex display="block">              \begin {align*}                  \text {refl-Eq}_ \mathbb {N} (0) &amp; \equiv \star   \\                    \text {refl-Eq}_ \mathbb {N} ( \text {succ} (n)) &amp; \equiv \text {refl-Eq}_ \mathbb {N} (n)              \end {align*}         </fr:tex></fr:p><fr:p>
        This leads to an interesting dual perspective on equality. 
        For any two natural numbers <fr:tex>m</fr:tex> and <fr:tex>n</fr:tex> we have
        <fr:tex display="block">             (m=n) \leftrightarrow \text {Eq}_ \mathbb {N} (m,n)         </fr:tex></fr:p><fr:p>
        Using the observational equality of <fr:tex>\mathbb {N}</fr:tex> we can prove Peano&apos;s seventh and eighth
        axioms.
        <fr:ul><fr:li>
                For any two natural numbers <fr:tex>m</fr:tex> and <fr:tex>n</fr:tex> we have 
                <fr:tex display="block">                     (m = n) \leftrightarrow ( \text {succ} (m) =  \text {succ} (n))                 </fr:tex></fr:li>
            <fr:li>
                For any natural number <fr:tex>n</fr:tex> we have <fr:tex>0  \not =  \text {succ} (n)</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false"><fr:frontmatter><fr:anchor>317</fr:anchor><fr:taxon>Quantum Mechanics</fr:taxon><fr:addr>phy-0002</fr:addr><fr:route>phy-0002.xml</fr:route><fr:title>The Wave Function</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
    This post introduces the concept of the wave function in quantum mechanics.
    Refer to <fr:link href="quantum-2018.xml" type="local" addr="quantum-2018">Introduction to Quantum Mechanics</fr:link>.
</fr:p><fr:p>
    Consider a particle of mass <fr:tex>m</fr:tex> moving along <fr:tex>x</fr:tex>-axis
    subject to force <fr:tex>F(x, t)</fr:tex>.
    With Newton&apos;s second law, we have:
    <fr:tex display="block">         F = ma     </fr:tex>
    For <fr:strong>conservative systems</fr:strong>, the force
    can be expressed as the derivative of a <fr:strong>potential energy</fr:strong>.
    <fr:tex display="block">         F = - \frac { \partial  V}{ \partial  x}     </fr:tex>
    Now the equation of motion becomes:
    <fr:tex display="block">         m  \frac {d^2x}{dt^2} = - \frac { \partial  V}{ \partial  x}     </fr:tex>
    With appropriate initial conditions we can determine the <fr:tex>x(t)</fr:tex>,
    this is what we normally do in classic mechanics.
</fr:p><fr:p>
    For <fr:strong>Quantum Mechanics</fr:strong>, we have a different perspective.
    We would like to look for the <fr:strong>wave function</fr:strong>, <fr:tex>\Psi (x, t)</fr:tex>.
    To determine it we need to solve the <fr:strong>Schrodinger equation</fr:strong>.
    <fr:tex display="block">         i \hbar \frac { \partial }{ \partial  t} \Psi (x,t) = - \frac { \hbar ^2}{2m} \frac { \partial ^2 \Psi (x,t)}{ \partial  x^2} + V(x,t) \Psi (x,t)     </fr:tex></fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>310</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0030</fr:addr><fr:route>def-0030.xml</fr:route><fr:title>Schrodinger&apos;s equation</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>Schrodinger equation</fr:strong> is a linear partial differential equation that describes the wave function of a quantum system.
    It is given by (the general form):
    <fr:tex display="block">         i \hbar \frac { \partial }{ \partial  t} \Psi ( \vec {r},t) =  \hat {H} \Psi ( \vec {r},t)     </fr:tex>
    where:
    <fr:ul><fr:li><fr:tex>\Psi ( \vec {r},t)</fr:tex> is the wave function of the quantum system.
        </fr:li>
        <fr:li><fr:tex>\hat {H}</fr:tex> is the <fr:strong>Hamiltonian operator</fr:strong>.
        </fr:li>
        <fr:li><fr:tex>\hbar  = 1.054573 \times10 ^{-34} \text {Js} </fr:tex> is the reduced <fr:strong>Planck constant</fr:strong>.
        </fr:li></fr:ul></fr:p></fr:mainmatter></fr:tree><fr:p>
    The role of Schrodinger equation is similar to the role of Newton&apos;s second law in classic mechanics.
    Given proper initial conditions,
    we can determine <fr:tex>\Psi (x, t)</fr:tex> for all the future time.
</fr:p><fr:p>
    The wave function is quite odd, what information does it carry?
    The wave function is <fr:em>spread out</fr:em> in space.
    How can this be related to the <fr:strong>state</fr:strong> of a particle.
</fr:p><fr:p><fr:strong>Born&apos;s statistical interpretation</fr:strong> of the wave function provides an answer.
    For a fixed time <fr:tex>t</fr:tex>, the probability of finding the particle in the interval <fr:tex>[a, b]</fr:tex> is given by:
    <fr:tex display="block">         P(a, b) =  \int _a^b |{ \Psi (x, t)}|^2 dx     </fr:tex></fr:p><fr:p>
    Here is where the quantum mechanics differs from classic mechanics and behaves weirdly.
    The wave function is not a deterministic function, but a <fr:em>statistical</fr:em> function, which 
    is an <fr:strong>indeterministic</fr:strong> interpretation.
</fr:p><fr:p>
    Suppose I do <fr:strong>measure</fr:strong> the position of the particle,
    and find it at <fr:tex>\vec {r}_0</fr:tex>.
    Then where it was before the measurement?
    There are many interpretations of this question,
    and I will explain three of them.
</fr:p><fr:p><fr:ul><fr:li><fr:strong>Realist interpretation</fr:strong>: The particle has a definite position before the measurement, just at <fr:tex>\vec {r}_0</fr:tex> but we just don&apos;t know it.</fr:li>
        <fr:li><fr:strong>Orthodox interpretation</fr:strong>: The particle doesn&apos;t have a <fr:em>definite</fr:em> position before the measurement, it is in a <fr:strong>superposition</fr:strong> of all possible positions.
        This is also called the <fr:strong>Copenhagen interpretation</fr:strong>.</fr:li>
        <fr:li><fr:strong>Agnostic interpretation</fr:strong>: The question is meaningless, refuse to answer.</fr:li></fr:ul></fr:p><fr:p>
    Nowadays, the Copenhagen interpretation is the most widely accepted interpretation.
    The particle does not have a definite position before the measurement.
    The operation of measurement <fr:strong>collapses</fr:strong> the wave function to a definite position.
</fr:p><fr:p>
    Probability is the key concept in quantum mechanics.
    Now I will introduce some terimnologies related to continuous probability.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>313</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0031</fr:addr><fr:route>def-0031.xml</fr:route><fr:title>Probability Density</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    A <fr:strong>probability density</fr:strong> is a function <fr:tex>p(x)</fr:tex> such that:
    <fr:ul><fr:li><fr:tex>p(x) \geq  0</fr:tex> for all <fr:tex>x</fr:tex>.
        </fr:li>
        <fr:li><fr:tex>\int _{- \infty }^{ \infty } p(x)dx = 1</fr:tex>.
        </fr:li></fr:ul>
    With this we can define the <fr:strong>probability function</fr:strong> in an interval <fr:tex>[a,b]</fr:tex> as:
    <fr:tex display="block">         P(a, b) =  \int _a^b p(x)dx     </fr:tex></fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>311</fr:anchor><fr:title>Expectation Value</fr:title><fr:parent>def-0031</fr:parent></fr:frontmatter><fr:mainmatter>
    The <fr:strong>expectation value</fr:strong> of a function <fr:tex>f(x)</fr:tex> with respect to the probability density <fr:tex>p(x)</fr:tex> is defined:
    <fr:tex display="block">          \langle  f(x)  \rangle  =  \int _{- \infty }^{ \infty } f(x)p(x)dx     </fr:tex>
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>312</fr:anchor><fr:title>Variance</fr:title><fr:parent>def-0031</fr:parent></fr:frontmatter><fr:mainmatter>
    The <fr:strong>variance</fr:strong> of a function <fr:tex>f(x)</fr:tex> with respect to the probability density <fr:tex>p(x)</fr:tex> is defined:
    <fr:tex display="block">          \sigma ^2 : \equiv   \langle  x^2  \rangle  -  \langle  x  \rangle ^2     </fr:tex>
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:p>
    Now go back to quantum mechanics.
    We have seen that the squared wave function <fr:tex>| \Psi (x,t)|^2</fr:tex> is a probability density.
    So it satisfies
    <fr:tex display="block">          \int _{- \infty }^{ \infty } | \Psi (x,t)|^2 dx = 1     </fr:tex></fr:p><fr:p>
    Solve the equations we will get a set of solutions.
    We should pick a proper factor to make the wave function <fr:strong>normalized</fr:strong>.
    But if I have normalized the wave function at time <fr:tex>t_0</fr:tex>,
    will it stay normalized at all future time?
    Fortunately the Schrodinger equation guarantees the normalization of 
    the wave function.
    
</fr:p>
 
   
   <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>314</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:parent>phy-0002</fr:parent></fr:frontmatter><fr:mainmatter>
        Differentiate the normalization condition with respect to time:
        <fr:tex display="block">              \frac {d}{dt} \int _{- \infty }^{ \infty } | \Psi (x,t)|^2 dx =               \int _{- \infty }^{ \infty }  \frac { \partial }{ \partial  t}| \Psi (x,t)|^2 dx         </fr:tex>
        With the product rule:
        <fr:tex display="block">              \frac { \partial }{ \partial  t}| \Psi (x,t)|^2 =               \frac { \partial }{ \partial  t} \Psi (x,t) \Psi ^*(x,t) +  \Psi (x,t) \frac { \partial }{ \partial  t} \Psi ^*(x,t)         </fr:tex>
        where <fr:tex>\Psi ^*(x,t)</fr:tex> is the <fr:strong>complex conjugate</fr:strong> of <fr:tex>\Psi (x,t)</fr:tex>.
        The Schrodinger equation gives
        <fr:tex display="block">              \frac { \partial \Psi }{ \partial  t} =  \frac {i \hbar }{2m} \frac { \partial ^2 \Psi }{ \partial  x^2} +  \frac {iV}{ \hbar } \Psi          </fr:tex>
        and also the complex conjugate
        <fr:tex display="block">              \frac { \partial \Psi ^*}{ \partial  t} = - \frac {i \hbar }{2m} \frac { \partial ^2 \Psi ^*}{ \partial  x^2} +  \frac {iV}{ \hbar } \Psi ^*         </fr:tex>
        so
        <fr:tex display="block">              \begin {align*}                  \frac { \partial }{ \partial  t}| \Psi (x,t)|^2 &amp;=                   \frac {i \hbar }{2m} \left (  \frac { \partial ^2 \Psi }{ \partial  x^2} \Psi ^* -  \frac { \partial ^2 \Psi ^*}{ \partial  x^2} \Psi   \right ) \\                  &amp;=  \frac {i \hbar }{2m} \frac { \partial }{ \partial  x} \left (  \frac { \partial \Psi }{ \partial  x} \Psi ^* -  \frac { \partial \Psi ^*}{ \partial  x} \Psi   \right )              \end {align*}         </fr:tex>
        Now the integral becomes:
        <fr:tex display="block">              \frac {d}{dt} \int _{- \infty }^{ \infty } | \Psi (x,t)|^2 dx =               \frac {i \hbar }{2m} \left (  \Psi \frac { \partial \Psi ^*}{ \partial  x} -  \Psi ^* \frac { \partial \Psi }{ \partial  x}  \right ) \Big |_{- \infty }^{ \infty }         </fr:tex>
        Because the <fr:strong>normalization condition</fr:strong>
        <fr:tex display="block">              \int _{- \infty }^{ \infty } | \Psi (x,t)|^2 dx = 1         </fr:tex>
        implies that the wave function vanishes at infinity,
        that is, converges to zero at infinity. Hence we have
        <fr:tex display="block">              \lim _{|x| \to \infty }| \Psi (x,t)| = 0         </fr:tex>
        this indicates that the integral is zero.
        <fr:tex display="block">              \frac {d}{dt} \int _{- \infty }^{ \infty } | \Psi (x,t)|^2 dx = 0         </fr:tex>
        Now we can conclude that the wave function stays normalized at all future time.
    </fr:mainmatter></fr:tree>
 
<fr:p>
    For a particle in state <fr:tex>\Psi</fr:tex>, we have defined its <fr:strong>expectation value</fr:strong>:
    <fr:tex display="block">          \langle  x  \rangle  =  \int _{- \infty }^{ \infty } x| \Psi (x,t)|^2 dx     </fr:tex>
    Can we give a meaning to it? Is it the <fr:strong>average</fr:strong> position of the particle? 
    No, the first measurement of the position of the particle will give a definite position,
    and the subsequent measurements will give the same result.
</fr:p><fr:p>
    Actually, the expectation value is the <fr:em>average</fr:em> of 
    repeated measurements on an ensemble of identical prepared systems,
    not the average of repeated measurements on a <fr:em>single</fr:em> system.
</fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>315</fr:anchor><fr:title><fr:strong>Construction.</fr:strong></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:parent>phy-0002</fr:parent></fr:frontmatter><fr:mainmatter>
    As times goes on, the expectation values varies.
    We naturally ask how fast it moves?
    Use simple calculus we can get the answer.
    <fr:tex display="block">          \begin {align*}              \frac {d}{dt} \langle  x  \rangle  &amp;=  \int _{- \infty }^{ \infty } x \frac { \partial }{ \partial  t}| \Psi (x,t)|^2 dx  \\              &amp;=  \frac {i \hbar }{2m} \int _{- \infty }^{ \infty } x \frac { \partial }{ \partial  x} ( \frac { \partial \Psi }{ \partial  x} \Psi ^* +  \Psi \frac { \partial \Psi ^*}{ \partial  x}) dx          \end {align*}     </fr:tex>
    Simplify using integration by parts, we get
    <fr:tex display="block">          \frac {d}{dt} \langle  x  \rangle  = - \frac {i \hbar }{2m} \int _{- \infty }^{ \infty }  \left (  \Psi ^* \frac { \partial \Psi }{ \partial  x} -  \Psi \frac { \partial \Psi ^*}{ \partial  x}  \right ) dx     </fr:tex>
    Note that the boundary term was eliminated because the wave function vanishes at infinity.
    Perform integration by parts again on the second term
    <fr:tex display="block">          \langle  v  \rangle  : \equiv \frac {d}{dt} \langle  x  \rangle  = - \frac {i \hbar }{m} \int _{- \infty }^{ \infty }  \Psi ^* \frac { \partial \Psi }{ \partial  x} dx     </fr:tex>
    Note that we give a name to the integral, <fr:tex>v</fr:tex>, indicating the <fr:strong>velocity</fr:strong> of the expectation value.
</fr:mainmatter></fr:tree>
<fr:p>
    To work with <fr:strong>momentum</fr:strong>, we can define:
    <fr:tex display="block">          \langle  p  \rangle  = m  \langle  v  \rangle  = -i \hbar \int _{- \infty }^{ \infty }  \Psi ^* \frac { \partial \Psi }{ \partial  x} dx     </fr:tex>
    Rewrite as an <fr:strong>operator</fr:strong> form:
    <fr:tex display="block">          \langle  p  \rangle  =  \int _{- \infty }^{ \infty }  \Psi ^* \left (  \frac { \hbar }{i} \frac { \partial }{ \partial  x}  \right ) \Psi  dx     </fr:tex>
    Compare with 
    <fr:tex display="block">          \langle  x  \rangle  =  \int _{- \infty }^{ \infty }  \Psi ^*(x) \Psi  dx     </fr:tex></fr:p><fr:p>
    That&apos;s interesting, an operator that acts on the wave function and gives position and momentum.
    We can generalize this to any function of position and momentum.
    Just simply do substitution:
    <fr:tex display="block">          \langle  Q(x,p)  \rangle  =           \int _{- \infty }^{ \infty }  \Psi ^*(x)Q \left ( x, -i \hbar \frac { \partial }{ \partial  x}  \right ) \Psi  dx     </fr:tex>
    Momentum and position are just special cases of this general formula.
    We will give a firmer theoretical foundation to this equation later.
    Now we just use it as an <fr:em>axiom</fr:em>.
</fr:p><fr:p>
    Now we discuss about the <fr:strong>uncertainty principle</fr:strong>.
    The more precise a wave&apos;s position is, the less precise its momentum (or the wavelength) is, and vice versa.
    A theorem in Fourier Analysis gives a precise statement of this principle (explain later).
    For this moment we only concerned with the qualitative argument.
</fr:p><fr:p>
    The wavelength of a wave function <fr:tex>\Psi</fr:tex> is related to the momentum of the particle.
    This result from the <fr:strong>de Broglie formula</fr:strong>.
    <fr:tex display="block">         p =  \frac {h}{ \lambda } =  \frac {2 \pi \hbar }{ \lambda }     </fr:tex>
    Now we can give a qualitative argument for the uncertainty principle.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>316</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0033</fr:addr><fr:route>def-0033.xml</fr:route><fr:title>Heisenberg Uncertainty Principle</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>Heisenberg Uncertainty Principle</fr:strong> states that
    it is impossible to measure simultaneously the position and the momentum of a particle
    with arbitrary precision.
    The product of the uncertainties in position and momentum is bounded by:
    <fr:tex display="block">          \Delta  x  \Delta  p  \geq   \frac { \hbar }{2}     </fr:tex>
    where <fr:tex>\Delta  x</fr:tex> and <fr:tex>\Delta  p</fr:tex> are the uncertainties in position and momentum, respectively.
    The constant <fr:tex>\hbar</fr:tex> is the reduced Planck constant.
</fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false"><fr:frontmatter><fr:anchor>321</fr:anchor><fr:taxon>Quantum Mechanics</fr:taxon><fr:addr>phy-0003</fr:addr><fr:route>phy-0003.xml</fr:route><fr:title>Time-independent Schrodinger Equation</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
    Refer to chapter 2 in <fr:link href="quantum-2018.xml" type="local" addr="quantum-2018">Introduction to Quantum Mechanics</fr:link></fr:p><fr:p>
    In previous section we use the <fr:link href="def-0030.xml" type="local" addr="def-0030">Schrodinger equation</fr:link> to compute things.
    The variable <fr:tex>t</fr:tex> is annoying which makes things complicated, and we would like to get rid of it.
    In this section we shall assume that the potential energy <fr:tex>V</fr:tex> is independent of time.
    In that case the Schrodinger equation becomes:
    <fr:tex display="block">         i \hbar \frac { \partial }{ \partial  t} \psi (x,t) = - \frac { \hbar ^2}{2m} \frac { \partial ^2 \psi (x,t)}{ \partial  x^2} + V(x) \psi (x,t)     </fr:tex>
    This equation can be solved by <fr:strong>separation of variables</fr:strong>.
    We assume the spatial and time dependencies of the solution can be separated.
    In other words we look for solutions of the <fr:em>product form</fr:em>:
    <fr:tex display="block">          \Psi (x,t) =  \psi (x) \phi (t)     </fr:tex>
    This is an absurd restriction, but it works and we can get interesting results.
</fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>318</fr:anchor><fr:title><fr:strong>Solve the equation</fr:strong></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:parent>phy-0003</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>
        Now substitute the product form into the Schrodinger equation:
        <fr:tex display="block">             i \hbar   \psi (x)  \frac { \partial }{ \partial  t}( \phi (t)) = - \frac { \hbar ^2}{2m} \phi (t) \frac { \partial ^2( \psi (x))}{ \partial  x^2} + V(x) \psi (x) \phi (t)         </fr:tex>
        Divide both sides by <fr:tex>\psi (x) \phi (t)</fr:tex>:
        <fr:tex display="block">             i \hbar   \frac {1}{ \phi (t)}  \frac { \partial }{ \partial  t}( \phi (t)) = - \frac { \hbar ^2}{2m \psi (x)} \frac { \partial ^2( \psi (x))}{ \partial  x^2} + V(x)         </fr:tex>
        Notice that the left side depends only on <fr:tex>t</fr:tex> and the right side depends only on <fr:tex>x</fr:tex>.
        They are equal if and only if they are both equal to a <fr:em>constant</fr:em>.
        Otherwise if I change the left side and level the right side unchanged, I get a contradiction.
        The constant is the energy of the system, and we denote it by <fr:tex>E</fr:tex>.
        <fr:tex display="block">             E: \equiv  i \hbar   \frac {1}{ \phi (t)}  \frac { \partial }{ \partial  t}( \phi (t))          </fr:tex>
        and 
        <fr:tex display="block">             E: \equiv  - \frac { \hbar ^2}{2m \psi (x)} \frac { \partial ^2( \psi (x))}{ \partial  x^2} + V(x)         </fr:tex>
        We have two equations:
        <fr:tex display="block">              \begin {align*}                  \frac {d \phi }{dt} &amp;= - \frac {iE}{ \hbar } \phi \\                  - \frac { \hbar ^2}{2m} \frac {d^2 \psi }{dx^2} + V \psi  &amp;= E \psi               \end {align*}         </fr:tex>
        Now the partial differential equation has been reduced to two <fr:strong>ordinary differential equations</fr:strong>.
        The first one is easy to solve:
        <fr:tex display="block">              \phi (t) =  \phi (0)e^{-iEt/ \hbar }         </fr:tex>
        Thus the complete solution is (note that the constant <fr:tex>\phi (0)</fr:tex> was absorbed into <fr:tex>\psi (x)</fr:tex>):
        <fr:tex display="block">              \Psi (x,t) =  \psi (x)e^{-iEt/ \hbar }         </fr:tex>
        The second one is the <fr:strong>time-independent Schrodinger equation</fr:strong>,
        we can&apos;t go further unless we know the potential energy <fr:tex>V(x)</fr:tex>.
    </fr:p>
</fr:mainmatter></fr:tree>
<fr:p>
    Now we give a name to the time-independent Schrodinger equation.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>319</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0034</fr:addr><fr:route>def-0034.xml</fr:route><fr:title>Stationary State</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    A <fr:strong>stationary state</fr:strong> is a quantum state with all observables independent of time.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    Thought the wave function is time-dependent,
    <fr:tex display="block">          \Psi (x,t) =  \psi (x)e^{-iEt/ \hbar }     </fr:tex>
    But if we compute the probability density, it is time-independent:
    <fr:tex display="block">         | \Psi (x,t)|^2 =  \psi ^*(x)e^{+iEt/ \hbar } \psi (x)e^{-iEt/ \hbar } = | \psi (x)|^2      </fr:tex>
    Hence the expectation value is constant in time. 
    Then <fr:tex>\langle  p  \rangle  = 0</fr:tex> all the time.
    Nothing happens in the stationary state.
</fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>320</fr:anchor><fr:title>
    <fr:strong>Conservation of energy</fr:strong>
</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:parent>phy-0003</fr:parent></fr:frontmatter><fr:mainmatter>
    This also means that the energy of the system is conserved.
    In classical mechanics, the <fr:strong>total energy</fr:strong> (kinetic + potential) of a system is called the <fr:strong>Hamiltonian</fr:strong>.
    <fr:tex display="block">         H(x,p) =  \frac {p^2}{2m} + V(x)     </fr:tex>
    In quantum mechanics, the Hamiltonian is an operator,
    obtained by substituting <fr:tex>p \to  -i \hbar \frac { \partial }{ \partial  x}</fr:tex>:
    <fr:tex display="block">          \hat {H} = - \frac { \hbar ^2}{2m} \frac { \partial ^2}{ \partial  x^2} + V(x)     </fr:tex>
    Thus the time-independent Schrodinger equation can be written as:
    <fr:tex display="block">          \hat {H} \psi (x) = E \psi (x)     </fr:tex>
    The expectation value of the total energy gives the energy of the system:
    <fr:tex display="block">          \begin {align*}              \langle  H  \rangle  &amp;=  \int   \psi ^*(x) \hat {H} \psi (x)dx               \\              &amp;=  \int   \psi ^*(x)E \psi (x)dx              \\              &amp;= E \int  | \psi (x)|^2dx              \\              &amp;= E \int  | \Psi (x)|^2dx              \\              &amp;= E                     \end {align*}     </fr:tex>
    and
    <fr:tex display="block">          \begin {align*}              \langle  H^2  \rangle  &amp;=               \int   \psi ^*(x) \hat {H}^2 \psi (x)dx              \\              &amp;= E^2 \int  | \psi (x)|^2 dx                    \\              &amp;= E^2                \end {align*}     </fr:tex>
    where 
    <fr:tex display="block">          \hat {H}^2 \psi  =  \hat {H}( \hat {H} \psi ) =  \hat {H}(E \psi ) = E( \hat {H} \psi ) = E^2 \psi      </fr:tex>
    Hence the variance of the energy is zero given by
    <fr:tex display="block">          \Delta  H =  \sqrt { \langle  H^2  \rangle  -  \langle  H  \rangle ^2} = 0     </fr:tex>
    This implies that the energy of the system is conserved.
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false"><fr:frontmatter><fr:anchor>330</fr:anchor><fr:taxon>String Theory</fr:taxon><fr:addr>phy-0001</fr:addr><fr:route>phy-0001.xml</fr:route><fr:title>Special Relativity and Extra Dimensions</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author>CAIMEO</fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>
    This is a summary of the first chapter of <fr:link href="string-theory-2009.xml" type="local" addr="string-theory-2009">A First Course in String Theory</fr:link> by Barton Zwiebach.
    I will make it as understandable as possible.
</fr:p><fr:p>
    Speical relativity is based on the exprimental fact that the speed of light is the same for all inertial observers.
    In comparing the coordinates of events, two inertial observers (<fr:strong>Lorentz observers</fr:strong>) find that the
    appropriate coordinate transformations mix space and time.   
</fr:p><fr:p>
    In special relativity events are characterized by their coordinates in space <fr:tex>(x,y,z)</fr:tex> and time (<fr:tex>t</fr:tex>).
    It&apos;s convenient to combine these into a four-vector where the <fr:tex>t</fr:tex> coordinate is multiplied by <fr:tex>c</fr:tex> (<fr:strong>Speed of light</fr:strong>): so 
    that all four coordinates have the same units (length).
    <fr:tex display="block">x^ \mu  = (x^0,x^1,x^2,x^3) = (ct,x,y,z)</fr:tex>
    The superscript <fr:tex>\mu</fr:tex> is called a <fr:strong>Lorentz index</fr:strong> and runs from 0 to 3.
</fr:p><fr:p>
    Consider a Lorentz frame <fr:tex>S</fr:tex> where two events are represented by the coordinates 
    <fr:tex>x^ \mu</fr:tex> and <fr:tex>x^ \mu  +  \Delta  x^ \mu</fr:tex>.
    Let <fr:tex>S&apos;</fr:tex> be another Lorentz frame where the same two events are represented by the coordinates
    <fr:tex>x&apos;^ \mu</fr:tex> and <fr:tex>x&apos;^ \mu  +  \Delta  x&apos;^ \mu</fr:tex>.
    The value of <fr:tex>x&apos;^ \mu</fr:tex> is different from <fr:tex>x^ \mu</fr:tex> and so as <fr:tex>\Delta  x&apos;^ \mu</fr:tex> from <fr:tex>\Delta  x^ \mu</fr:tex>.
    However there is an invariant <fr:strong>interval</fr:strong> <fr:tex>\Delta  s^2</fr:tex> defined by
    <fr:tex display="block">         - \Delta  s^2 = -( \Delta  x^0)^2 + ( \Delta  x^1)^2 + ( \Delta  x^2)^2 + ( \Delta  x^3)^2     </fr:tex>
    The minus sign in front of <fr:tex>(x^0)^2</fr:tex> encodes the fundamental difference between space and time coordinates.
</fr:p><fr:p>
    The invariant interval implies the following equation:
    <fr:tex display="block">          \Delta  s ^2 =  \Delta  s&apos;^2     </fr:tex>
    The minus sign on the left of <fr:tex>\Delta  s^2</fr:tex> implies that <fr:tex>\Delta  s^2 &gt;0</fr:tex> for events that are <fr:strong>timelike separated</fr:strong>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>322</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001H</fr:addr><fr:route>def-001H.xml</fr:route><fr:title>Timelike Separated Events</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    An event <fr:tex>S</fr:tex> is said to be timelike separated if
    <fr:tex display="block">         ( \Delta  x^0)^2 &gt; ( \Delta  x^1)^2 + ( \Delta  x^2)^2 + ( \Delta  x^3)^2     </fr:tex>
    or briefly <fr:tex>\Delta  s^2 &gt; 0</fr:tex>. The spatial separation is less than the distance light travels.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    The history of a particle is represented in spacetime as a curve called a <fr:strong>world-line</fr:strong>.
    Any two events on the world-line are timelike separated, because no particle can 
    move faster than light.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>323</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001I</fr:addr><fr:route>def-001I.xml</fr:route><fr:title>Lightlike Separated Events</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Events connected by the world-line of a <fr:strong>photon</fr:strong> are said to be <fr:strong>lightlike separated</fr:strong>.
    For which <fr:tex>\Delta  s^2 = 0</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>324</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001J</fr:addr><fr:route>def-001J.xml</fr:route><fr:title>Spacelike Separated Events</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Two events for which <fr:tex>\Delta  s^2 &lt; 0</fr:tex> are said to be <fr:strong>spacelike separated</fr:strong>.
    Events that are simultaneous in a Lorentz frame but in different position are spacelike separated.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    For timelike event we can define
    <fr:tex display="block">          \Delta  s  \equiv   \sqrt { \Delta  s^2}     </fr:tex></fr:p><fr:p>
    It is useful to consider events that are <fr:em>infinitesimally close</fr:em> to each other.
    Small coordinate difference are needed to define velocity.
    Infinitesimal coordinate differences are written as <fr:tex>dx^ \mu</fr:tex>.
    <fr:tex display="block">         -ds^2 = -(dx^0)^2 + (dx^1)^2 + (dx^2)^2 + (dx^3)^2     </fr:tex>
    The equality of intervals is the statement
    <fr:tex display="block">         ds^2 = ds&apos;^2     </fr:tex>
    Let&apos;s define a better notation:
    <fr:tex display="block">         dx_0  \equiv  -dx^0,         dx_1  \equiv  dx^1,         dx_2  \equiv  dx^2,         dx_3  \equiv  dx^3               </fr:tex>
    Notice that the inclusion of the minus sign in the definition of <fr:tex>dx_0</fr:tex> is a matter of convention.
    <fr:tex display="block">         dx_ \mu  = (dx_0,dx_1,dx_2,dx_3)     </fr:tex>
    Now rewrite <fr:tex>ds^2</fr:tex> in terms of <fr:tex>dx_ \mu</fr:tex> and <fr:tex>dx^ \mu</fr:tex>:
    <fr:tex display="block">         -ds^2 = dx_0dx^0 + dx_1dx^1 + dx_2dx^2 + dx_3dx^3 =  \sum _{ \mu =0}^3 dx_ \mu  dx^ \mu      </fr:tex>
    Using <fr:link href="def-001K.xml" type="local" addr="def-001K">Einstein&apos;s Summation Convention</fr:link> we can rewrite
    <fr:tex display="block">         ds^2 = dx_ \mu  dx^ \mu      </fr:tex>
    And for Infinitesimal timelike intervals we can define
    <fr:tex display="block">         ds  \equiv   \sqrt {ds^2}      </fr:tex>
    We can also express the interval <fr:tex>ds^2</fr:tex> using the <fr:strong>Minkowski Metric</fr:strong>:
    <fr:tex display="block">         -ds^2=  \eta _{ \mu \nu } dx^ \mu  dx^ \nu      </fr:tex>
    and the metric is defined by
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>325</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001L</fr:addr><fr:route>def-001L.xml</fr:route><fr:title>Minkowski Metric</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>Minkowski Metric</fr:strong>, aka <fr:strong>Minkowski Tensor</fr:strong>, is a tensor <fr:tex>\eta _{ \mu \nu }</fr:tex> whose elements are defined by the matrix
    <fr:tex display="block">          \eta _{ \mu \nu } =  \begin {pmatrix}             -1 &amp; 0 &amp; 0 &amp; 0  \\              0 &amp; 1 &amp; 0 &amp; 0  \\              0 &amp; 0 &amp; 1 &amp; 0  \\              0 &amp; 0 &amp; 0 &amp; 1           \end {pmatrix}     </fr:tex>
    where <fr:tex>\mu</fr:tex> and <fr:tex>\nu</fr:tex> are Lorentz indices run over <fr:tex>0,1,2,3</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    How can we derive the Minkowski Metric? First we require <fr:tex>\eta _{ \mu \nu }</fr:tex> to be a symmetric matrix,
    because any antisymmetric part would not contribute to the interval.
    <fr:tex display="block">          \eta _{ \mu \nu } =  \eta _{ \nu \mu }     </fr:tex>
    And for any two-indexed object <fr:tex>M_{ \mu \nu }</fr:tex> can be decomposed into symmetric and antisymmetric parts:
    <fr:tex display="block">         M_{ \mu \nu } =  \frac {1}{2}(M_{ \mu \nu } + M_{ \nu \mu }) +  \frac {1}{2}(M_{ \mu \nu } - M_{ \nu \mu })     </fr:tex>
    With the antisymmetric part (denoted <fr:tex>\delta</fr:tex>) which we can see
    <fr:tex display="block">          \delta _{ \mu \nu }dx^ \mu  dx^ \nu  = (- \delta _{ \nu \mu }) dx^ \mu  dx^ \nu  = - \delta _{ \mu \nu }dx^ \nu  dx^ \mu  = - \delta _{ \mu \nu }dx^ \mu  dx^ \nu      </fr:tex>
    Note that the second step relabeled the dummy indices <fr:tex>\mu</fr:tex> and <fr:tex>\nu</fr:tex>.
    The third step we swapped the order of the two terms. Hence the antisymmetric part is zero.
</fr:p><fr:p>
    The equation <fr:tex>dx_ \mu  = (dx_0,dx_1,dx_2,dx_3)</fr:tex> can be rewritten as
    <fr:tex display="block">         dx_ \mu  =  \eta _{ \mu \nu } dx^ \nu      </fr:tex>
    For more general case:
    <fr:tex display="block">         b_ \mu   \equiv   \eta _{ \mu \nu } b^ \nu      </fr:tex>
    Given <fr:tex>a^ \mu</fr:tex> and <fr:tex>b^ \mu</fr:tex> we can define the dot scalar product as 
    <fr:tex display="block">         a  \cdot  b  \equiv  a^ \mu  b_ \mu  = a^ \mu   \eta _{ \mu \nu } b^ \nu  = -a^0 b^0 + a^1 b^1 + a^2 b^2 + a^3 b^3     </fr:tex>
    Note that <fr:tex>a^ \mu  b_ \mu  = a_ \mu  b^ \mu</fr:tex> because <fr:tex>\eta _{ \mu \nu }</fr:tex> is symmetric.
</fr:p><fr:p>
    It&apos;s convenient to introduce the inverse matrix of <fr:tex>\eta _{ \mu \nu }</fr:tex>:
    <fr:tex display="block">          \eta ^{ \mu \nu } =           \begin {pmatrix}             -1 &amp; 0 &amp; 0 &amp; 0  \\              0 &amp; 1 &amp; 0 &amp; 0  \\              0 &amp; 0 &amp; 1 &amp; 0  \\              0 &amp; 0 &amp; 0 &amp; 1          \end {pmatrix}     </fr:tex>
    And the inverse property is
    <fr:tex display="block">          \eta ^{ \mu \rho }  \eta _{ \rho \nu } =  \delta ^ \mu _ \nu      </fr:tex>
    where <fr:tex>\delta ^ \mu _ \nu</fr:tex> is the <fr:link href="def-001P.xml" type="local" addr="def-001P">Kronecker Delta</fr:link>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>326</fr:anchor><fr:taxon>Trick</fr:taxon><fr:addr>thm-0004</fr:addr><fr:route>thm-0004.xml</fr:route><fr:title>Raise Indices</fr:title></fr:frontmatter><fr:mainmatter><fr:p><fr:tex display="block">          \eta ^{ \rho \mu }b_ \mu          =  \eta ^{ \rho \mu } ( \eta _{ \mu \nu } b^ \nu )         =  \eta ^{ \rho \mu }  \eta _{ \mu \nu } b^ \nu          =  \delta ^ \rho _ \nu  b^ \nu          = b^ \rho      </fr:tex>
    The lower index of <fr:tex>b_ \mu</fr:tex> is raised to <fr:tex>b^ \rho</fr:tex> by <fr:tex>\eta ^{ \rho \mu }</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p><fr:strong>Lorentz transformations</fr:strong> are the relations between coordinates in two different
    inertial frames.
    
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>327</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001Q</fr:addr><fr:route>def-001Q.xml</fr:route><fr:title>Lorentz Transformations</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Consider a frame <fr:tex>S</fr:tex> and <fr:tex>S&apos;</fr:tex> which is moving along the <fr:tex>+x</fr:tex> direction of the <fr:tex>S</fr:tex> frame
    with a velocity <fr:tex>v</fr:tex>.
    Assume that the origins of the two frames coincide at <fr:tex>t=t&apos;=0</fr:tex> and coordinate axes are parallel.

    We say that <fr:tex>S&apos;</fr:tex> is boosted along the <fr:tex>x</fr:tex> direction with velocity parameter <fr:tex>\beta \equiv \frac {v}{c}</fr:tex>.
    The <fr:strong>Lorentz transformations</fr:strong> are defined by a set of equations that relate the coordinates of an event in the two frames.
    <fr:tex display="block">          \begin {align*}             x&apos; &amp;=  \gamma (x- \beta  ct)  \\              y&apos; &amp;= y  \\              z&apos; &amp;= z  \\              ct&apos; &amp;=  \gamma (ct- \beta  x)          \end {align*}     </fr:tex>
    where <fr:tex>\gamma \equiv \dfrac {1}{ \sqrt {1- \beta ^2}} =  \dfrac {1}{ \sqrt {1- \frac {v^2}{c^2}}}</fr:tex> is the <fr:strong>Lorentz factor</fr:strong>.
    The coordinates orthogonal to the <fr:tex>x</fr:tex> direction remains unchanged.
</fr:p><fr:p>
    Lorentz transformations are the linear transformations of coordinates that remains the <fr:tex>\Delta  s^2</fr:tex> unchanged. 
    We can write the Lorentz transformations in matrix form:
    <fr:tex display="block">          \begin {pmatrix}             ct&apos;  \\              x&apos;  \\              y&apos;  \\              z&apos;           \end {pmatrix}         =          \begin {pmatrix}              \gamma  &amp; - \beta \gamma  &amp; 0 &amp; 0  \\              - \beta \gamma  &amp;  \gamma  &amp; 0 &amp; 0  \\              0 &amp; 0 &amp; 1 &amp; 0  \\              0 &amp; 0 &amp; 0 &amp; 1           \end {pmatrix}          \begin {pmatrix}             ct  \\              x  \\              y  \\              z           \end {pmatrix}     </fr:tex>
    Or in a more compact form:
    <fr:tex display="block">         x&apos;^ \mu  = L^ \mu _ \nu  x^ \nu      </fr:tex>
    where <fr:tex>L^ \mu _ \nu</fr:tex> is the <fr:strong>Lorentz transformation matrix</fr:strong> presented above.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    We now introduce a coordinate system that will be extremely useful in string theory,
    the <fr:strong>light-cone coordinates</fr:strong>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>328</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001R</fr:addr><fr:route>def-001R.xml</fr:route><fr:title>Light-cone Coordinates</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>light-cone coordinates</fr:strong> can be defined as
    two independent <fr:link href="def-000L.xml" type="local" addr="def-000L">linear combinations</fr:link> of the time 
    and a chosen spatial coordinate (conventionally <fr:tex>x^1</fr:tex>):
    <fr:tex display="block">          \begin {align*}             x^+  \equiv   \frac {1}{ \sqrt {2}} (X^0 + X^1)  \\              x^-  \equiv   \frac {1}{ \sqrt {2}} (X^0 - X^1)          \end {align*}     </fr:tex>
    while other spatial coordinates remain unchanged. Thus the complete set of 
    light-cone coordinates is <fr:tex>(x^+,x^-,x^2,x^3)</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    The name <fr:strong>light-cone coordinates</fr:strong> comes from the fact that the associated coordinates axes
    are the world-lines of beams of light emitted form the origin along the <fr:tex>x^1</fr:tex> axis.
    <fr:ul><fr:li>
            For a beam of light moving in the positive <fr:tex>x^1</fr:tex> direction,
            we have <fr:tex>x^1=ct=x^0</fr:tex> and thus <fr:tex>x^-=0</fr:tex>. By definition <fr:tex>x^-=0</fr:tex>
            is actually the <fr:tex>x^+</fr:tex> axis. 
        </fr:li>
        <fr:li>
            For a beam of light moving in the negative <fr:tex>x^1</fr:tex> direction,
            we have <fr:tex>x^1=-ct=-x^0</fr:tex> and thus <fr:tex>x^+=0</fr:tex>. By definition <fr:tex>x^+=0</fr:tex>
            is actually the <fr:tex>x^-</fr:tex> axis. 
        </fr:li></fr:ul>
    The <fr:tex>x^+</fr:tex> and <fr:tex>x^-</fr:tex> axes are perpendicular to each other and at <fr:tex>45^ \circ</fr:tex> to the <fr:tex>x^0</fr:tex> and <fr:tex>x^1</fr:tex> axis.
</fr:p><fr:p>
    Both <fr:tex>x^+</fr:tex> and <fr:tex>x^-</fr:tex> can be a time coordinate although neither is a time coordinate
    in the standard sense of the world (Not ordinary time).
    For definiteness we will take <fr:tex>x^+</fr:tex> as the light-cone time coordinate and <fr:tex>x^-</fr:tex> as the spatial coordinate.
</fr:p><fr:p>
    Take differentials and multiply of the light-cone coordinates:
    <fr:tex display="block">         2dx^+ dx^- = (dx^0 + dx^1)(dx^0 - dx^1) = (dx^0)^2 - (dx^1)^2     </fr:tex>
    which follows the invariant interval
    <fr:tex display="block">         -ds^2 = -2dx^+ dx^- + (dx^2)^2 + (dx^3)^2     </fr:tex>
    As we did before, we can represent this with index notation:
    <fr:tex display="block">         -ds^2 =  \hat { \eta }_{ \mu \nu } dx^ \mu  dx^ \nu      </fr:tex>
    where the <fr:strong>light-cone metric</fr:strong> is
    <fr:tex display="block">          \hat { \eta }_{ \mu \nu } =           \begin {pmatrix}             0 &amp; -1 &amp; 0 &amp; 0  \\              -1 &amp; 0 &amp; 0 &amp; 0  \\              0 &amp; 0 &amp; 1 &amp; 0  \\              0 &amp; 0 &amp; 0 &amp; 1          \end {pmatrix}     </fr:tex>
    This is easy to derive from the symmetric.
</fr:p><fr:p>
    The light-cone coordinates looks unusual but if you see some
    calculations you will find the results very surprising.
</fr:p><fr:p>
    Consider a particle moving in the <fr:tex>x^1</fr:tex> direction with velocity <fr:tex>v</fr:tex>.
    At the initial time the positions are all <fr:tex>0</fr:tex>.
    (The velocity parameter is denote <fr:tex>\beta</fr:tex>)
    <fr:tex display="block">          \begin {align*}             x^1 = vt =  \beta  x^0              \\              x^2(t) = x^3(t) = 0          \end {align*}     </fr:tex>
    Now compute the light-cone coordinates:
    <fr:tex display="block">          \begin {align*}             x^+ =  \frac {1}{ \sqrt {2}}(x^0 + x^1) =  \frac {1}{ \sqrt {2}}(x^0 +  \beta  x^0) =  \frac {1+ \beta }{ \sqrt {2}}x^0              \\              x^- =  \frac {1}{ \sqrt {2}}(x^0 - x^1) =  \frac {1}{ \sqrt {2}}(x^0 -  \beta  x^0) =  \frac {1- \beta }{ \sqrt {2}}x^0          \end {align*}     </fr:tex>
    And we identify the ratio 
    <fr:tex display="block">          \frac {dx^+}{dx^-} =  \frac {1+ \beta }{1- \beta }     </fr:tex>
    as the light-cone velocity of the particle. This looks strange:
    <fr:ul><fr:li>
            For <fr:tex>\beta =-1</fr:tex> the light-cone velocity is <fr:tex>\infty</fr:tex>.
        </fr:li>
        <fr:li>
            For a particle moving at the speed of light (<fr:tex>\beta =1</fr:tex>), the light-cone velocity is <fr:tex>0</fr:tex>.
        </fr:li>
        <fr:li>
            More interestingly, a static particle (<fr:tex>\beta =0</fr:tex>) is moving quite fast in the light-cone coordinates.
        </fr:li></fr:ul>
    Note that the light-cone coordinates can&apos;t be acquired by Lorentz transformation.
</fr:p><fr:p>
    Just get the idea of the light-cone coordinates, now let&apos;s dive into the relativistic energy and momentum.
    In special relativity there is relationship between energy and momentum.
    <fr:tex display="block">          \frac {E^2}{c^2}- \vec {p}^2 = m^2c^2     </fr:tex>
    where <fr:tex>m</fr:tex> is the rest mass of the particle, and <fr:tex>c</fr:tex> is the speed of light.
    <fr:tex display="block">         E =  \gamma  mc^2,          \quad            \vec {p} =  \gamma  m \vec {v}     </fr:tex>
    The energy and momentum can be used to define a momentum four-vector
    <fr:tex display="block">         p^ \mu  = ( \frac {E}{c},p_x, p_y, p_z)     </fr:tex>
    or shortly
    <fr:tex display="block">         p^ \mu  = ( \frac {E}{c}, \vec {p}) = m \gamma  (c,  \vec {v})     </fr:tex>
    Using operator <fr:tex>\eta _{ \mu \nu }</fr:tex> to lower the index:
    <fr:tex display="block">         p_ \mu  = (p_0, p_1, p_2, p_3) =  \eta _{ \mu \nu } p^ \nu  = (- \frac {E}{c},p_x, p_y, p_z)     </fr:tex>
    And make use of the relationship above.
    <fr:tex display="block">         p_ \mu  p^ \mu  =  \eta _{ \mu \nu } p^ \mu  p^ \nu  = - \frac {E^2}{c^2} + p_x^2 + p_y^2 + p_z^2 = -m^2c^2     </fr:tex>
    Using the relativistic scalar product notation:
    <fr:tex display="block">         p ^2  \equiv  p  \cdot  p = p_ \mu  p^ \mu  = -m^2c^2     </fr:tex></fr:p><fr:p>
    A central concept in special relativity is <fr:strong>proper time</fr:strong>,
    which is a Lorentz invariant measure of time.
    Consider a world-line and two events <fr:tex>A</fr:tex> and <fr:tex>B</fr:tex> on the world-line.
    Different Lorentz observers will measure different time intervals between the two events.
    But imagine a clock that moves along the world-line.
    The time measured by the clock is called the <fr:strong>proper time</fr:strong> between the two events.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>329</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001S</fr:addr><fr:route>def-001S.xml</fr:route><fr:title>Proper Time</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>proper time</fr:strong> along a timelike world-line is defined as the
    time as measured by a clock following that line. 
</fr:p></fr:mainmatter></fr:tree><fr:p>
    By this definition, proper time is a invariant. Consider an invariant interval 
    for the motion of a particle along <fr:tex>x</fr:tex> axis:
    <fr:tex display="block">         -ds^2 = -c^2 dt^2 + dx^2 = -c^2 dt^2 (1 -  \beta ^2)     </fr:tex>
    Now attach a Lorentz frame to the particle does not move
    and the time is recorded by the clock that is moving with the particle.
    Hence <fr:tex>dx=0</fr:tex> and <fr:tex>dt=dt_p</fr:tex> is the proper time.
    <fr:tex display="block">         -ds^2 = -c^2 dt_p^2      </fr:tex>
    Cancel the minus sign and the square root
    <fr:tex display="block">         dt_p = c dt_p     </fr:tex>
    This shows that for timelike intervals,
    the <fr:strong>proper time interval</fr:strong> is <fr:tex>\frac {ds}{c}</fr:tex>.
    Similarly, 
    <fr:tex display="block">         ds = cdt  \sqrt {1- \beta ^2}  \implies   \frac {dt}{ds} =  \frac { \gamma }{c}     </fr:tex>
    The invariant <fr:tex>ds</fr:tex> can be used to construct nre Lorentz vectors.
    For instance, we can construct velocity four-vector:
    <fr:tex display="block">         u^ \mu  = c  \frac {dx^ \mu }{ds} = c ( \frac {d(ct)}{ds},  \frac {dx}{ds},  \frac {dy}{ds},  \frac {dz}{ds})     </fr:tex>
    This can be simplified by using the definition of proper time:
    <fr:tex display="block">          \frac {dx}{ds} =  \frac {dx}{dt}  \frac {dt}{ds} =  \frac {v_x \gamma }{c}     </fr:tex>
    Hence we find
    <fr:tex display="block">         u^ \mu  = ( \gamma  c,  \gamma  v_x,  \gamma  v_y,  \gamma  v_z) =  \gamma  (c,  \vec {v})     </fr:tex>
    We see that the momentum four-vector is just the velocity four-vector multiplied by the rest mass.
    <fr:tex display="block">         p^ \mu  = m u^ \mu      </fr:tex></fr:p><fr:p>
    The light-cone components <fr:tex>p^+</fr:tex> and <fr:tex>p^-</fr:tex> of the momentum Lorentz vector are obtained:
    <fr:tex display="block">          \begin {align*}             p^+ =  \frac {1}{ \sqrt {2}}(p^0+p^1) = -p_-              \\              p^- =  \frac {1}{ \sqrt {2}}(p^0-p^1) = -p_+          \end {align*}     </fr:tex>
    Note that light-cone coordinates do not transform as Lorentz ones do. 
    Both <fr:tex>p^ \pm</fr:tex> are energy-like since both are positive for physical particles.
    <fr:tex display="block">         p^0 =  \frac {E}{c}  \sqrt { \vec {p}^2 + m^2c^2} &gt; | \vec {p}| \geq  |p^1|     </fr:tex>
    Hence <fr:tex>p^0 \pm  p^1 &gt; 0</fr:tex> and <fr:tex>p^ \pm &gt;0</fr:tex>, which both are possible candidates for energy.
    We finally choose <fr:tex>p^-</fr:tex> as the component, we explain this later. 
</fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:context><fr:related></fr:related><fr:backlinks></fr:backlinks><fr:references><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>648</fr:anchor><fr:taxon>Reference</fr:taxon><fr:addr>hott-2022</fr:addr><fr:route>hott-2022.xml</fr:route><fr:title>Introduction to Homotopy Type Theory</fr:title><fr:authors><fr:author>Egbert Rijke</fr:author></fr:authors><fr:meta name="doi">10.48550/arXiv.2212.11082</fr:meta><fr:meta name="venue">Logic, Category Theory</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>
    This is an introductory textbook to univalent mathematics and homotopy type theory, a mathematical foundation that takes advantage of the structural nature of mathematical definitions and constructions. 
</fr:p></fr:mainmatter></fr:tree></fr:references></fr:backmatter></fr:tree>