<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1602</fr:anchor><fr:addr type="user">about</fr:addr><fr:route>about.xml</fr:route><fr:title text="Rabbit Hole">Rabbit Hole</fr:title><fr:taxon>About</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:tex display="block">         i\hbar  \frac {\partial }{\partial  t} \Psi (x, t) = \hat {H} \Psi (x, t)     </fr:tex></fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1077</fr:anchor><fr:addr type="machine">#371</fr:addr><fr:route>unstable-371.xml</fr:route><fr:title text="
    What is this website about?
">
    <fr:strong>What is this website about?</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>about</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>This website is a collection of my notes and posts on various topics in 
        <fr:strong>computer science, mathematics, physics, and programming language theory</fr:strong>.
        It is a place where I can organize my thoughts and share my understanding of these topics.
        I hope it can be helpful to others who are interested in these subjects.</fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1078</fr:anchor><fr:addr type="machine">#372</fr:addr><fr:route>unstable-372.xml</fr:route><fr:title text="
    What is the meaning of &quot;Rabbit Hole&quot;?
">
    <fr:strong>What is the meaning of &quot;Rabbit Hole&quot;?</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>about</fr:parent></fr:frontmatter><fr:mainmatter>
    The name of this website &quot;<fr:strong>Rabbit Hole</fr:strong>&quot; carries a metaphorical significance inspired by Lewis Carroll&apos;s 
    <fr:em>Alice&apos;s Adventures in Wonderland</fr:em>, 
    meaning to delve into a topic or pursue a line of thought that leads to unexpected or complex places.
    It can refer to getting deeply involved in researching a subject, exploring a particular interest, or going through 
    a series of trees in the forest that leads to a chain of related topics.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1079</fr:anchor><fr:addr type="machine">#373</fr:addr><fr:route>unstable-373.xml</fr:route><fr:title text="
    How to navigate?
">
    <fr:strong>How to navigate?</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>about</fr:parent></fr:frontmatter><fr:mainmatter>    <fr:p>This website is a “<fr:em>forest</fr:em>” created using the <fr:strong>Forester</fr:strong> tool.
        To navigate my forest, press <fr:code>Ctrl-K</fr:code> to search for specific topics or definitions.
        Or click the nodes to expand the trees of various subjects.</fr:p>
    <fr:p>A tree in Forester is associated to an unique address of the form <fr:code>xxx-NNNN</fr:code>,
        where <fr:code>xxx</fr:code> is the <fr:strong>namespace</fr:strong> and <fr:code>NNNN</fr:code> is the <fr:strong>ID</fr:strong> (A base-36 number of 4 digits) of the tree.
        The namespace implies the category of the tree node, for instance,
        <fr:code>tt</fr:code> for Type Theory and <fr:code>math</fr:code> for Mathematics.</fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title text="Context">Context</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="true" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1603</fr:anchor><fr:addr type="user">index</fr:addr><fr:route>index.xml</fr:route><fr:title text="The Rabbit Hole">The Rabbit Hole</fr:title><fr:authors><fr:author>CAIMEO</fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    
    
    <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1148</fr:anchor><fr:addr type="user">caimeo</fr:addr><fr:route>caimeo.xml</fr:route><fr:title text="CAIMEO">CAIMEO</fr:title><fr:taxon>Person</fr:taxon><fr:authors></fr:authors><fr:meta name="position">Student</fr:meta><fr:meta name="external">https://github.com/CAIMEOX</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>A student interested in math, physics and computer science.</fr:p><fr:p><fr:ul><fr:li>Learning Programming Language Theory and Type Theory</fr:li>
        <fr:li>Attend in writing articles about String Theory</fr:li>
        <fr:li>Reading Type Theory and Formal Proof and Homotopy Type Theory</fr:li>
        <fr:li>Working on CommandLisp</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
    
    <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1149</fr:anchor><fr:addr type="user">about</fr:addr><fr:route>about.xml</fr:route><fr:title text="Rabbit Hole">Rabbit Hole</fr:title><fr:taxon>About</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:tex display="block">         i\hbar  \frac {\partial }{\partial  t} \Psi (x, t) = \hat {H} \Psi (x, t)     </fr:tex></fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1077</fr:anchor><fr:addr type="machine">#371</fr:addr><fr:route>unstable-371.xml</fr:route><fr:title text="
    What is this website about?
">
    <fr:strong>What is this website about?</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>about</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>This website is a collection of my notes and posts on various topics in 
        <fr:strong>computer science, mathematics, physics, and programming language theory</fr:strong>.
        It is a place where I can organize my thoughts and share my understanding of these topics.
        I hope it can be helpful to others who are interested in these subjects.</fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1078</fr:anchor><fr:addr type="machine">#372</fr:addr><fr:route>unstable-372.xml</fr:route><fr:title text="
    What is the meaning of &quot;Rabbit Hole&quot;?
">
    <fr:strong>What is the meaning of &quot;Rabbit Hole&quot;?</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>about</fr:parent></fr:frontmatter><fr:mainmatter>
    The name of this website &quot;<fr:strong>Rabbit Hole</fr:strong>&quot; carries a metaphorical significance inspired by Lewis Carroll&apos;s 
    <fr:em>Alice&apos;s Adventures in Wonderland</fr:em>, 
    meaning to delve into a topic or pursue a line of thought that leads to unexpected or complex places.
    It can refer to getting deeply involved in researching a subject, exploring a particular interest, or going through 
    a series of trees in the forest that leads to a chain of related topics.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1079</fr:anchor><fr:addr type="machine">#373</fr:addr><fr:route>unstable-373.xml</fr:route><fr:title text="
    How to navigate?
">
    <fr:strong>How to navigate?</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>about</fr:parent></fr:frontmatter><fr:mainmatter>    <fr:p>This website is a “<fr:em>forest</fr:em>” created using the <fr:strong>Forester</fr:strong> tool.
        To navigate my forest, press <fr:code>Ctrl-K</fr:code> to search for specific topics or definitions.
        Or click the nodes to expand the trees of various subjects.</fr:p>
    <fr:p>A tree in Forester is associated to an unique address of the form <fr:code>xxx-NNNN</fr:code>,
        where <fr:code>xxx</fr:code> is the <fr:strong>namespace</fr:strong> and <fr:code>NNNN</fr:code> is the <fr:strong>ID</fr:strong> (A base-36 number of 4 digits) of the tree.
        The namespace implies the category of the tree node, for instance,
        <fr:code>tt</fr:code> for Type Theory and <fr:code>math</fr:code> for Mathematics.</fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1150</fr:anchor><fr:addr type="user">posts</fr:addr><fr:route>posts.xml</fr:route><fr:title text="Blog posts">Blog posts</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>718</fr:anchor><fr:addr type="user">tt-0002</fr:addr><fr:route>tt-0002.xml</fr:route><fr:title text="Introduction to Type Theory">Introduction to Type Theory</fr:title><fr:taxon>Type Theory</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is a note on dependent type theory. Refer to <fr:link type="local" href="hott-book-2013.xml" addr="hott-book-2013" title="Homotopy Type Theory: Univalent Foundations of Mathematics">HoTT Book</fr:link> and <fr:link type="local" href="hott-2022.xml" addr="hott-2022" title="Introduction to Homotopy Type Theory">Egbert Rijke&apos;s</fr:link>.</fr:p><fr:p><fr:strong>Homotopy type theory</fr:strong> is a foundational language for mathematics, an alternative to Zermelo-Fraenkel set theory.
    The set-theoretic foundation has two two layers:
    <fr:ul><fr:li>the deductive system of first-order logic</fr:li>
        <fr:li>the theory of a particular theory, such as ZFC</fr:li></fr:ul> 
    Type theory itself is a deductive system, which has one basic notation: <fr:em>types</fr:em>.
    Propositions are identified with types.
    
    Thus, the activity of proving a theorem is identified with 
    constructing a <fr:em>inhabitant</fr:em> of a certain type.</fr:p><fr:p>Informally, a deductive system is a collection of rules for deriving <fr:strong>judgments</fr:strong>. 
    The judgment is considered to be the external of the theory, living in the <fr:strong>metatheory</fr:strong>.</fr:p><fr:p>In first order logic, there is only one kind of judgment: a proposition has a proof.
    A proposition <fr:tex display="inline">P</fr:tex> gives rise to a judgment &quot;<fr:tex display="inline">P</fr:tex> has a proof&quot;.
    The proposition <fr:tex display="inline">P</fr:tex> lives inside the theory, while the judgment &quot;<fr:tex display="inline">P</fr:tex> has a proof&quot; lives in the metatheory.</fr:p><fr:p>In type theory, analogous to first order logic,
    &quot;<fr:tex display="inline">P</fr:tex> has a proof&quot; is written as &quot;<fr:tex display="inline">p:P</fr:tex>&quot; (Type <fr:tex display="inline">P</fr:tex> has a term <fr:tex display="inline">p</fr:tex>).
    <fr:ul><fr:li>If <fr:tex display="inline">P</fr:tex> is a proposition, then <fr:tex display="inline">p</fr:tex> is a <fr:strong>witness</fr:strong> to the provability of <fr:tex display="inline">P</fr:tex>, 
        or <fr:strong>evidence</fr:strong> of the truth of <fr:tex display="inline">P</fr:tex>.</fr:li>
        <fr:li><fr:tex display="inline">p:P</fr:tex> can also be interpreted as <fr:tex display="inline">p\in  P</fr:tex>,
        but <fr:tex display="inline">p:P</fr:tex> is a judgment while <fr:tex display="inline">p\in  P</fr:tex> is a proposition.</fr:li></fr:ul>
    Working inside type theory we can&apos;t write down statements like
    &quot;if <fr:tex display="inline">p:P</fr:tex> then ...&quot; nor can we disprove the judgment &quot;<fr:tex display="inline">p:P</fr:tex>&quot;.</fr:p><fr:p>A key difference between type theory and set theory is the equality.
    The notion of equality in set theory is simply a proposition.
    Howerver, in type theory, there are two kinds of equality.
    <fr:ul><fr:li>The first kind is the <fr:strong>propositional equality</fr:strong> <fr:tex display="inline">a=_Ab</fr:tex>.
        This is a proposition</fr:li>
        <fr:li>The second kind is the <fr:strong>judgmental equality</fr:strong> <fr:tex display="inline">a\equiv  b:A</fr:tex>.
        This is a judgment</fr:li></fr:ul>
    Two terms <fr:tex display="inline">a:A</fr:tex> and <fr:tex display="inline">b:A</fr:tex> are propositionally equal if you can prove <fr:tex display="inline">a =_A b</fr:tex> , 
    or equivalently if you can construct a term <fr:tex display="inline">h : a =_A b</fr:tex>.</fr:p>
    <fr:p>In type theory there is also a requirement for a judgment-level equality.
        This is called <fr:strong>judgmental equality</fr:strong>, meaning &quot;equal by definition&quot;.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>719</fr:anchor><fr:addr type="user">def-0015</fr:addr><fr:route>def-0015.xml</fr:route><fr:title text="Judgemental Equality">Judgemental Equality</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Judgemental equality</fr:strong> of terms is given by the following judgement:
    <fr:tex display="block">         \Gamma \vdash  a\equiv  a&apos;:A     </fr:tex>
    <fr:tex display="inline">a</fr:tex> and <fr:tex display="inline">a&apos;</fr:tex> are judgementally equal terms of type <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>.</fr:p><fr:p>Note that the notation <fr:tex display="inline">\equiv </fr:tex> binds more loosely than anything else.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
    <fr:p>judgments may depend on <fr:em>assumptions</fr:em> of the form <fr:tex display="inline">x:A</fr:tex> where <fr:tex display="inline">x</fr:tex> is a
        variable and <fr:tex display="inline">A</fr:tex> is a type. And the collection (actually ordered list) of such assumptions is called 
        the <fr:strong>context</fr:strong>, denoted <fr:tex display="inline">\Gamma </fr:tex>. (from a topological point of view it 
        may be thought of as a <fr:strong>parameters space</fr:strong>).
        The role of a context is to declare what <fr:strong>hypothetical terms</fr:strong> are assumed, 
        along with their types.
        The notation <fr:tex display="inline">\vdash </fr:tex> means making conclusion from assumptions.</fr:p>
<fr:p>Remember the difference between axiom and (inference) rules.
    <fr:ul><fr:li>Rules allow us to conclude one judgment from a collection of other judgments.</fr:li>
        <fr:li>Axioms are judgments that are assumed to be true without proof.</fr:li></fr:ul></fr:p><fr:p>We start by introduction to Matrin Lof&apos;s dependent type theory.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>720</fr:anchor><fr:addr type="user">def-0017</fr:addr><fr:route>def-0017.xml</fr:route><fr:title text="Dependent type theory: Judgments">Dependent type theory: Judgments</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>There are four kinds of judgments in Martin Lof&apos;s dependent type theory:</fr:p>
    <fr:ul><fr:li><fr:tex display="inline">A</fr:tex> is a well-formed type in context <fr:tex display="inline">\Gamma </fr:tex>
            <fr:tex display="block">                 \Gamma  \vdash  A \space \text {type}             </fr:tex></fr:li>
        <fr:li><fr:tex display="inline">A</fr:tex> and <fr:tex display="inline">B</fr:tex> are judgmentally equal types in context <fr:tex display="inline">\Gamma </fr:tex>
            <fr:tex display="block">                 \Gamma  \vdash  A \equiv  B \space \text {type}             </fr:tex></fr:li>
        <fr:li><fr:tex display="inline">a</fr:tex> is a term of type <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>
            <fr:tex display="block">                 \Gamma  \vdash  a : A             </fr:tex></fr:li>
        <fr:li><fr:tex display="inline">a</fr:tex> and <fr:tex display="inline">b</fr:tex> are judgmentally equal terms of type <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>
            <fr:tex display="block">                 \Gamma  \vdash  a \equiv  b : A             </fr:tex></fr:li></fr:ul>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>All judgments are context dependent, 
    and indeed that even the types of the variables in a context
    may depend on any previous declared variables.

    To introduce types dependent on terms, 
    we need the notation of type families.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>721</fr:anchor><fr:addr type="user">def-0018</fr:addr><fr:route>def-0018.xml</fr:route><fr:title text="Type Family">Type Family</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Consider a type <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>.
    A <fr:strong>family</fr:strong> of types over <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>
    is a type <fr:tex display="inline">B(x)</fr:tex> in context <fr:tex display="inline">\Gamma , x:A</fr:tex>.
    <fr:tex display="block">         \Gamma , x:A \vdash  B(x) \space \text {type}     </fr:tex>
    <fr:tex display="inline">B</fr:tex> is a family of types over <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>.
    Alternatively, we say that <fr:tex display="inline">B(x)</fr:tex> is a type <fr:strong>indexed</fr:strong> by <fr:tex display="inline">x:A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now we can define a term of a type family, that is, a section of a type family.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>722</fr:anchor><fr:addr type="user">def-0019</fr:addr><fr:route>def-0019.xml</fr:route><fr:title text="Section of Type Family">Section of Type Family</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">B</fr:tex> be a <fr:link type="local" href="def-0018.xml" addr="def-0018" title="Type Family">type family</fr:link> over <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>.
    A <fr:strong>section</fr:strong> of <fr:tex display="inline">B</fr:tex> is a term <fr:tex display="inline">b</fr:tex> of type <fr:tex display="inline">B(x)</fr:tex> in context <fr:tex display="inline">\Gamma ,x:A</fr:tex>.
    <fr:tex display="block">         \Gamma , x:A \vdash  b : B(x)     </fr:tex>
    Alternatively, we say that <fr:tex display="inline">b</fr:tex> is a term of <fr:tex display="inline">B(x)</fr:tex> indexed by <fr:tex display="inline">x:A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We now ready to present the inference rules for dependent type theory.
    These rules are known as the <fr:strong>structual rules</fr:strong> of the theory.
    There are 6 sets of rules:
    <fr:ul><fr:li>Formation contexts, types and terms</fr:li>
        <fr:li>Postulating that judgmental equality is an equivalence relation</fr:li>
        <fr:li>Vairable conversion</fr:li>
        <fr:li>Substitution</fr:li>
        <fr:li>Weakening</fr:li>
        <fr:li>Generic element</fr:li></fr:ul></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>723</fr:anchor><fr:addr type="user">def-001A</fr:addr><fr:route>def-001A.xml</fr:route><fr:title text="
    Formation of contexts, types and terms
">
    Formation of contexts, types and terms
</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The following rules follow from the presuppotion
    about contexts, types and terms, can be used freely.</fr:p><fr:ul><fr:li><fr:tex display="block">             \frac {                 \Gamma ,x:A\vdash  B(x)\space \text {type}             }{                 \Gamma \vdash  A\space \text {type}             }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">             \frac {                 \Gamma \vdash  A\equiv  B\space \text {type}             }{                 \Gamma \vdash  A\space \text {type}             }             \quad              \frac {                 \Gamma \vdash  A\equiv  B\space \text {type}             }{                 \Gamma \vdash  B\space \text {type}             }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">             \frac {                 \Gamma \vdash  a:A             }{                 \Gamma \vdash  A\space \text {type}             }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">             \frac {                 \Gamma \vdash  a\equiv  b:A             }{                 \Gamma \vdash  a:A             }             \quad               \frac {                 \Gamma \vdash  a\equiv  b:A             }{                 \Gamma \vdash  b:A             }         </fr:tex></fr:li></fr:ul></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>724</fr:anchor><fr:addr type="user">def-001B</fr:addr><fr:route>def-001B.xml</fr:route><fr:title text="
    Judgmental equality is equivalence relation
">
    Judgmental equality is equivalence relation
</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Judgmental equality on types and on elements is an <fr:link type="local" href="def-000X.xml" addr="def-000X" title="Equivalence Relation">equivalence relation</fr:link> 
    simply postulate that these relations are reflexive, symmetric, and transitive:</fr:p><fr:ul><fr:li><fr:tex display="block">             \frac {                 \Gamma \vdash  a:A             }{                 \Gamma \vdash  a\equiv  a:A             }             \quad              \frac {                 \Gamma \vdash  a\equiv  b:A             }{                 \Gamma \vdash  b\equiv  a:A             }             \quad              \frac {                 \Gamma \vdash  a\equiv  b:A                 \quad                  \Gamma \vdash  b\equiv  c:A             }{                 \Gamma \vdash  a\equiv  c:A             }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">             \frac {                 \Gamma \vdash  A\space \text {type}             }{                 \Gamma \vdash  A\equiv  A\space \text {type}             }             \quad              \frac {                 \Gamma \vdash  A\equiv  B\space \text {type}             }{                 \Gamma \vdash  B\equiv  A\space \text {type}             }             \quad              \frac {                 \Gamma \vdash  A\equiv  B\space \text {type}                 \quad                  \Gamma \vdash  B\equiv  C\space \text {type}             }{                 \Gamma \vdash  A\equiv  C\space \text {type}             }         </fr:tex></fr:li></fr:ul></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>725</fr:anchor><fr:addr type="user">def-001C</fr:addr><fr:route>def-001C.xml</fr:route><fr:title text="Variable Conversion">Variable Conversion</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This rule postulates that we can
    convert the type of a variable to a judgmentally equal type.
    <fr:tex display="block">         \frac {             \Gamma \vdash  A\equiv  A&apos;\space \text {type}             \quad              \Gamma ,x:A,\Delta \vdash  B(x)\space \text {type}         }{             \Gamma ,x:A&apos;,\Delta \vdash  B(x)\space \text {type}         }     </fr:tex>
    Similarly, we can convert judgmental equality of types and terms.
    We state all of them at once using a <fr:em>generic judgment thesis</fr:em> <fr:tex display="inline">\mathcal {J}</fr:tex>.
    <fr:tex display="block">         \frac {             \Gamma \vdash  A\equiv  A&apos;\space \text {type}             \quad              \Gamma ,x:A,\Delta \vdash  \mathcal {J}         }{             \Gamma ,x:A&apos;,\Delta \vdash  \mathcal {J}         }VC     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Consider a term <fr:tex display="inline">f:B(x)</fr:tex> indexed by <fr:tex display="inline">x:A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>,
    and we also have a term <fr:tex display="inline">a:A</fr:tex>.
    We can simultaneously substitute <fr:tex display="inline">a</fr:tex> for all occurrences of <fr:tex display="inline">x</fr:tex> in <fr:tex display="inline">f</fr:tex>
    to obtain a new term <fr:tex display="inline">f[x:=a]:B(a)</fr:tex>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>726</fr:anchor><fr:addr type="user">def-001D</fr:addr><fr:route>def-001D.xml</fr:route><fr:title text="Substitution">Substitution</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The substitution rule postulates that we can substitute a term for a variable.
    <fr:tex display="block">         \frac {             \Gamma \vdash  a:A             \quad              \Gamma ,x:A,\Delta \vdash  \mathcal {J}         }{             \Gamma ,\Delta [x:=a]\vdash  \mathcal {J}[x:=a]         }S     </fr:tex>
    The notation <fr:tex display="inline">\Gamma ,\Delta [x:=a]</fr:tex> means that we substitute <fr:tex display="inline">a</fr:tex> for <fr:tex display="inline">x</fr:tex> in <fr:tex display="inline">\Delta </fr:tex>.</fr:p><fr:p>With the substitution rule, we need two more <fr:em>congruence rules</fr:em> to
    convert judgmental equality of terms and types.
    <fr:tex display="block">         \frac {             \Gamma \vdash  a\equiv  a&apos;:A             \quad              \Gamma ,x:A,\Delta \vdash  B \space \text {type}         }{             \Gamma ,\Delta [x:=a]\vdash  B[x:=a]\equiv  B[x:=a&apos;] \space \text {type}         }     </fr:tex>

    <fr:tex display="block">         \frac {             \Gamma \vdash  A\equiv  A&apos;\space \text {type}             \quad              \Gamma ,x:A,\Delta \vdash  b:A         }{             \Gamma ,\Delta [x:=a]\vdash  b[x:=a]\equiv  b[x:=a&apos;]:A&apos;[x:=a] \space \text {type}         }     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>727</fr:anchor><fr:addr type="user">def-001G</fr:addr><fr:route>def-001G.xml</fr:route><fr:title text="Fiber and Value">Fiber and Value</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">B</fr:tex> be a <fr:link type="local" href="def-0018.xml" addr="def-0018" title="Type Family">type family</fr:link> over <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>,
    an a well-formed term <fr:tex display="inline">a:A</fr:tex>,
    then we say that <fr:tex display="inline">B[x:=a]</fr:tex> is the <fr:strong>fiber</fr:strong> of <fr:tex display="inline">B</fr:tex> at <fr:tex display="inline">a</fr:tex>, denoted <fr:tex display="inline">B(a)</fr:tex>.</fr:p><fr:p>Let <fr:tex display="inline">b</fr:tex> a <fr:link type="local" href="def-0019.xml" addr="def-0019" title="Section of Type Family">section</fr:link> of <fr:tex display="inline">B</fr:tex> over <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>,
    then we say that <fr:tex display="inline">b(a):\equiv  b[x:=a]</fr:tex> is the <fr:strong>value</fr:strong> of <fr:tex display="inline">b</fr:tex> at <fr:tex display="inline">a</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The process of expanding the context by a fresh variable of type <fr:tex display="inline">A</fr:tex> is called weakening (by <fr:tex display="inline">A</fr:tex>).
    Intuitively, weakening is the process of adding a new hypothesis to the context.
    And the hypothesis will weaken the conclusion.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>728</fr:anchor><fr:addr type="user">def-001E</fr:addr><fr:route>def-001E.xml</fr:route><fr:title text="Weakening">Weakening</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Weakening rule asserts that we can add a variable to the context.
    <fr:tex display="block">         \frac {             \Gamma \vdash  A\space \text {type}             \quad               \Gamma ,\Delta \vdash  \mathcal {J}         }{             \Gamma ,x:A,\Delta \vdash  \mathcal {J}         }W      </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Finally, the generic elemets rule ensures that
    the variables declared in a context.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>729</fr:anchor><fr:addr type="user">def-001F</fr:addr><fr:route>def-001F.xml</fr:route><fr:title text="Generic Elements">Generic Elements</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The rule for the generic element asserts that 
    any hypothetical element <fr:tex display="inline">x:A</fr:tex> in context <fr:tex display="inline">\Gamma ,x:A</fr:tex>
    is also an element of <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma ,x:A</fr:tex>.
    <fr:tex display="block">         \frac {             \Gamma \vdash  A\space \text {type}         }{             \Gamma ,x:A\vdash  x:A         }\delta      </fr:tex>
    This rule is also called the <fr:strong>variable rule</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The next topic is the dependent function type, a fundamental concept of dependent type theory.
    Simply put, a dependent function type is a function whose type of output may depend on the input.</fr:p><fr:p>Consider a section <fr:tex display="inline">b</fr:tex> of a family <fr:tex display="inline">B</fr:tex> over <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>:
    <fr:tex display="block">         \Gamma ,x:A\vdash  b(x):B(x)     </fr:tex>
    Such a section <fr:tex display="inline">b</fr:tex> is an operation or assignment <fr:tex display="inline">x\mapsto  b(x)</fr:tex> that assigns to each element <fr:tex display="inline">x:A</fr:tex>
    to a term <fr:tex display="inline">b(x):B(x)</fr:tex>.
    We may see <fr:tex display="inline">b</fr:tex> as a function takes <fr:tex display="inline">x:A</fr:tex> to <fr:tex display="inline">b(x):B(x)</fr:tex>.
    The function <fr:tex display="inline">x\mapsto  b(x)</fr:tex> is called a <fr:strong>dependent function</fr:strong>.
    The type of all dependent functions from <fr:tex display="inline">A</fr:tex> to <fr:tex display="inline">B</fr:tex> is called the <fr:strong>dependent function type</fr:strong>.
    <fr:tex display="block">         \Pi _{(x:A)}B(x) \text { or } (x:A)\to  B(x)     </fr:tex></fr:p><fr:p>To introduce a type we need the following four rules:
    <fr:ul><fr:li>Formation rule</fr:li>
        <fr:li>Introduction rule</fr:li>
        <fr:li>Elimination rule</fr:li>
        <fr:li>Computation rule</fr:li></fr:ul>
    Besides these we also need the <fr:strong>congruence rule</fr:strong> for judgmental equality.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>730</fr:anchor><fr:addr type="user">def-001T</fr:addr><fr:route>def-001T.xml</fr:route><fr:title text="Dependent Function Type">Dependent Function Type</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Formation Rule</fr:strong>
    For any type family <fr:tex display="inline">B</fr:tex> over <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>:
    <fr:tex display="block">         \frac {             \Gamma ,x:A\vdash  B(x)\space \text {type}         }{             \Gamma \vdash  \Pi _{(x:A)}B(x)\space \text {type}         }\Pi      </fr:tex>
    We also require that the operation of forming dependent function types
    respects judgmental equality.
    <fr:tex display="block">         \frac {             \Gamma \vdash  A\equiv  A&apos;\space \text {type}             \quad              \Gamma ,x:A\vdash  B(x)\equiv  B&apos;(x)\space \text {type}         }{             \Gamma \vdash  \Pi _{(x:A)}B(x)\equiv  \Pi _{(x:A&apos;)}B&apos;(x)\space \text {type}         }\Pi \text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Introduction Rule (<fr:tex display="inline">\lambda </fr:tex>-abstraction)</fr:strong>
    In order to construct a dependent function we have to
    construct a term <fr:tex display="inline">f(x):B(x)</fr:tex> indexed by <fr:tex display="inline">x:A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>:
    <fr:tex display="block">         \frac {             \Gamma ,x:A\vdash  b(x):B(x)         }{             \Gamma \vdash  \lambda  x.b(x):\Pi _{(x:A)}B(x)         }\lambda      </fr:tex>
    And the congruence rule:
    <fr:tex display="block">         \frac {             \Gamma ,x:A\vdash  b(x)\equiv  b&apos;(x):B(x)         }{             \Gamma \vdash  \lambda  x.b(x)\equiv  \lambda  x.b&apos;(x):\Pi _{(x:A)}B(x)         }\lambda \text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Elimination Rule (Evaluation Rule)</fr:strong>
    In order to use dependent function we need to provide an argument of the domain type.
    <fr:tex display="block">         \frac {             \Gamma \vdash  f:\Pi _{(x:A)}B(x)         }{             \Gamma ,x:A\vdash  f(x):B(x)         }ev     </fr:tex>
    Again we require the judgmental equality to be respected:
    <fr:tex display="block">         \frac {             \Gamma \vdash  f\equiv  f&apos;:\Pi _{(x:A)}B(x)         }{             \Gamma ,x:A\vdash  f(x)\equiv  f&apos;(x):B(x)         }ev\text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Computation Rule (<fr:tex display="inline">\beta </fr:tex>-reduction)</fr:strong>
    <fr:tex display="block">         \frac {             \Gamma ,x:A\vdash  b(x):B(x)         }{             \Gamma ,x:A\vdash  (\lambda  y.b(y))(x)\equiv  b(x):B(x)         }\beta      </fr:tex>
    We postulate that all elements of a dependent function type are dependent functions.
    <fr:tex display="block">         \frac {             \Gamma \vdash  f:\Pi _{(x:A)}B(x)         }{             \Gamma \vdash  f\equiv  \lambda  x.f(x):\Pi _{(x:A)}B(x)         }\eta      </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>A degenrated case of dependent function type is the ordinary function type.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>731</fr:anchor><fr:addr type="user">def-001U</fr:addr><fr:route>def-001U.xml</fr:route><fr:title text="Ordinary Function Type">Ordinary Function Type</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A special case of <fr:link type="local" href="def-001T.xml" addr="def-001T" title="Dependent Function Type"><fr:tex display="inline">\Pi </fr:tex>-type</fr:link> is the <fr:strong>ordinary function type</fr:strong>.
    Using weakening rule we can obtain thee type <fr:tex display="inline">A\to  B</fr:tex> of ordinary function from <fr:tex display="inline">A</fr:tex> to <fr:tex display="inline">B</fr:tex>
    <fr:tex display="block">         \frac {             \Gamma \vdash  A\space \text {type}             \quad              \Gamma \vdash  B\space \text {type}         }{\dfrac {             \Gamma ,x:A\vdash  B\space \text {type}         }{             \Gamma \vdash  \Pi _{(x:A)}B\space \text {type}         }\Pi }W     </fr:tex>
    A term <fr:tex display="inline">f: \Pi _{(x:A)}B</fr:tex> is an ordinary function. The type <fr:tex display="inline">A \to  B</fr:tex> is defined:
    <fr:tex display="block">         A\to  B := \Pi _{(x:A)}B     </fr:tex>
    The type <fr:tex display="inline">A</fr:tex> is called <fr:strong>domain</fr:strong> of <fr:tex display="inline">f</fr:tex>,
    and type <fr:tex display="inline">B</fr:tex> is called <fr:strong>codomain</fr:strong> of <fr:tex display="inline">f</fr:tex>.
    The notation <fr:tex display="inline">:=</fr:tex> here means to make a definition.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>732</fr:anchor><fr:addr type="user">tt-0003</fr:addr><fr:route>tt-0003.xml</fr:route><fr:title text="Natural Numbers {N}">Natural Numbers <fr:tex display="inline">\mathbb {N}</fr:tex></fr:title><fr:taxon>Type Theory</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In previous post, we have seen the basic inference rules of type theory.
    Now we will see the definition of natural numbers as an inductive type.
    Refer to <fr:link type="local" href="hott-book-2013.xml" addr="hott-book-2013" title="Homotopy Type Theory: Univalent Foundations of Mathematics">HoTT Book</fr:link> and <fr:link type="local" href="hott-2022.xml" addr="hott-2022" title="Introduction to Homotopy Type Theory">Egbert Rijke&apos;s</fr:link>.</fr:p><fr:p>In classical mathematics, the <fr:strong>Peano axioms</fr:strong> are a set of axioms for the natural numbers,
    an important object in mathematics.</fr:p><fr:p>In type theory, the type <fr:tex display="inline">\mathbb {N}</fr:tex> of natural number is an <fr:link type="local" href="def-001X.xml" addr="def-001X" title="Inductive Type"><fr:strong>inductive type</fr:strong></fr:link>.
    Just like in dependent function type, we need four inference rules to define the natural numbers.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>733</fr:anchor><fr:addr type="user">def-001Y</fr:addr><fr:route>def-001Y.xml</fr:route><fr:title text="Natural Number">Natural Number</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In type theory, <fr:strong>natural number</fr:strong> is defined using <fr:strong>peano encoding</fr:strong>.
    The type <fr:tex display="inline">\mathbb {N}</fr:tex> is formed by the formation rule:
    <fr:tex display="block">         \frac {}{\vdash \mathbb {N}\space \text {type}}\mathbb {N}\text {-form}     </fr:tex></fr:p><fr:p>Peano&apos;s first axiom postulates the existence of a natural number <fr:tex display="inline">0</fr:tex>.
    The introduction rule for <fr:tex display="inline">\mathbb {N}</fr:tex> has a <fr:tex display="inline">0</fr:tex> constructor and a <fr:strong>successor</fr:strong> function.
    <fr:tex display="block">         \frac {}{\vdash 0:\mathbb {N}}\mathbb {N}\text {-intro-0}         \quad          \frac {}{\vdash \text {succ}:\mathbb {N}\to \mathbb {N}} \mathbb {N}\text {-intro-succ}     </fr:tex></fr:p><fr:p>The <fr:strong>elimination rule</fr:strong> is actually the type theoretical <fr:strong>induction principle</fr:strong> of <fr:tex display="inline">\mathbb {N}</fr:tex>:
    In order to show that <fr:tex display="inline">\forall  n:\mathbb {N}.P(n)</fr:tex> holds, it suffices to show that <fr:tex display="inline">P(0)</fr:tex> holds and that <fr:tex display="inline">\forall  n:\mathbb {N}.P(n)\to  P(\text {succ}(n))</fr:tex> holds.
    The type theoretical induction principle is therefore formulated using a type family <fr:tex display="inline">P</fr:tex> over <fr:tex display="inline">\mathbb {N}</fr:tex>:
    <fr:tex display="block">         \frac {             \begin {align*}                 \Gamma &amp;,\,n:\mathbb {N}\vdash  P(n)\space \text {type}                 \\                 \Gamma &amp;\vdash  p_0:P(0)                 \\                 \Gamma &amp;\vdash  p_S:\Pi _{(n:\mathbb {N})}P(n)\to  P(\text {succ}(n))             \end {align*}         }{             \Gamma \vdash \text {ind}_\mathbb {N}(p_0,p_S):\Pi _{(n:\mathbb {N})}P(n)         }(\mathbb {N} \text {-ind})     </fr:tex>
    The induction principle tells us what we need to do in order to construct a dependent function <fr:tex display="inline">\text {ind}_\mathbb {N}</fr:tex> of type <fr:tex display="inline">\Pi _{(n:\mathbb {N})}P(n)</fr:tex>.
    We might alternatively write the induction principle as:
    <fr:tex display="block">         \frac {             \Gamma ,n:\mathbb {N}\vdash  P(n)\space \text {type}         }{             \Gamma \vdash \text {ind}_\mathbb {N}:\left (P(0)\to \left (\Pi _{(n:\mathbb {N})}P(n)\to  P(\text {succ}(n))\right )\to \Pi _{(n:\mathbb {N})}P(n)\right )         }(\mathbb {N} \text {-ind})     </fr:tex></fr:p><fr:p>The <fr:strong>computation rule</fr:strong> asserts that the dependent function <fr:tex display="inline">\text {ind}_\mathbb {N}</fr:tex> behaves as expected:
    <fr:tex display="block">         \frac {             \begin {align*}                 \Gamma &amp;,n:\mathbb {N}\vdash  P(n)\space \text {type}                 \\                 \Gamma &amp;\vdash  p_0:P(0)                 \\                 \Gamma &amp;\vdash  p_S:\Pi _{(n:\mathbb {N})}P(n)\to  P(\text {succ}(n))             \end {align*}         }{             \text {ind}_\mathbb {N}(p_0,p_S,m)\equiv              \begin {cases}                 p_0&amp;\text {if }m=0                 \\                 p_S(n,\text {ind}_\mathbb {N}(p_0,p_S,n))&amp;\text {if }m=\text {succ}(n)             \end {cases}         }(\mathbb {N} \text {-comp})     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now let&apos;s use the type theoretical induction principle of <fr:tex display="inline">\mathbb {N}</fr:tex> to
    perform some basic construction over <fr:tex display="inline">\mathbb {N}</fr:tex>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>734</fr:anchor><fr:addr type="user">def-001Z</fr:addr><fr:route>def-001Z.xml</fr:route><fr:title text="Addition over {N}">Addition over <fr:tex display="inline">\mathbb {N}</fr:tex></fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We define addition over <fr:tex display="inline">\mathbb {N}</fr:tex> using the type theoretical induction principle of <fr:tex display="inline">\mathbb {N}</fr:tex>.
    <fr:tex display="block">         \text {add}_\mathbb {N} : \mathbb {N} \to  (\mathbb {N} \to  \mathbb {N})     </fr:tex>
    which satisfies the following specification:
    <fr:tex display="block">         \begin {align*}             \text {add}_\mathbb {N}(n, 0)&amp;:\equiv  n             \\             \text {add}_\mathbb {N}(m,\text {succ}(n))&amp;:\equiv \text {succ}(\text {add}_\mathbb {N}(m,n))         \end {align*}     </fr:tex>
    abbreviated as <fr:tex display="inline">m + n</fr:tex> for <fr:tex display="inline">\text {add}_\mathbb {N}(m,n)</fr:tex>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>735</fr:anchor><fr:addr type="machine">#335</fr:addr><fr:route>unstable-335.xml</fr:route><fr:title text="Construction"><fr:strong>Construction</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>def-001Z</fr:parent></fr:frontmatter><fr:mainmatter>
    
        <fr:p>We construct the additon by perform induction over the second variable <fr:tex display="inline">n</fr:tex>.
            That is, to construct an element
            <fr:tex display="block">                 m:\mathbb {N} \vdash  \text {add}_\mathbb {N}(m):\mathbb {N} \to  \mathbb {N}             </fr:tex>
            The context <fr:tex display="inline">\Gamma  \equiv  m:\mathbb {N}</fr:tex> is fixed.</fr:p>
        Therefore we need to construct:
        <fr:tex display="block">             \begin {align*}                 \Gamma &amp;\vdash  \text {add-zero}_\mathbb {N}(m):\mathbb {N}                 \\                 \Gamma &amp;\vdash  \text {add-succ}_\mathbb {N}(m):\mathbb {N}\to \mathbb {N}                             \end {align*}            </fr:tex>
        The <fr:tex display="inline">\text {add-zero}_\mathbb {N}</fr:tex> is defined to be identity function trivially. To see how <fr:tex display="inline">\text {add-succ}_\mathbb {N}</fr:tex> is defined, we need to perform induction:
        <fr:tex display="block">             \begin {align*}                 \text {add}_\mathbb {N}(m, \text {succ}(n))&amp;\equiv                  \text {ind}_\mathbb {N}(\text {add-zero}_\mathbb {N}(m), \text {add-succ}_\mathbb {N}(m), \text {succ}(n))                 \\                 &amp;\equiv  \text {add-succ}_\mathbb {N}(m,n, \text {add}_\mathbb {N}(m,n))                 \\                 &amp;\equiv  \text {succ}(\text {add}_\mathbb {N}(m,n))             \end {align*}         </fr:tex>
        Hence <fr:tex display="inline">\text {add-succ}_\mathbb {N}</fr:tex> is defined as:
        <fr:tex display="block">             \text {add-succ}_\mathbb {N}(m,n,x) \equiv  \text {succ}(x)         </fr:tex>
        A formal construction of <fr:tex display="inline">\text {add-succ}_\mathbb {N}</fr:tex> is as follows:
        <fr:tex display="block">             \dfrac {                 \dfrac {                     \dfrac {                         \dfrac {}{\vdash \mathbb {N}\space \text {type}}                         \quad                          \dfrac {                             \dfrac {}{\vdash  \mathbb {N}\space \text {type}}                             \quad                              \dfrac {}{\vdash  \text {succ}:\mathbb {N}\to \mathbb {N}}                         }{                             n:\mathbb {N}\vdash \text {succ}:\mathbb {N}\to \mathbb {N}                         }                     }{                         m:\mathbb {N}, n:\mathbb {N}\vdash  \text {succ}:\mathbb {N}\to \mathbb {N}                     }                  }{                     m:\mathbb {N}\vdash \lambda  n.\text {succ} : \mathbb {N}\to (\mathbb {N}\to \mathbb {N})                 }             }{                 m:\mathbb {N}\vdash  \text {add-succ}_\mathbb {N}(m):\equiv \lambda  m.\text {succ} : \mathbb {N}\to (\mathbb {N}\to \mathbb {N})             }\text {Block-1}         </fr:tex>
        Finally we combine the derivation together:
        <fr:tex display="block">             \dfrac {                 \dfrac {                     \dfrac {                         \dfrac {                             \vdash  \mathbb {N}\space \text {type}                         }{                             m:\mathbb {N}\vdash  m:\mathbb {N}                         }                     }{                         m:\mathbb {N}\vdash \text {add-zero}_\mathbb {N}(m):\equiv  m:\mathbb {N}                     }                     \quad                       \dfrac {\text {Block-1}}{                         m:\mathbb {N}\vdash \text {add-succ}_\mathbb {N}(m):\mathbb {N}\to (\mathbb {N}\to \mathbb {N})                     }                 }{                     m:\mathbb {N}\vdash \text {ind}_\mathbb {N} (\text {add-zero}_\mathbb {N}(m), \text {add-succ}_\mathbb {N}(m)):\mathbb {N}\to \mathbb {N}                 }             }{                 m:\mathbb {N}\vdash \text {add}_\mathbb {N}(m):\equiv \text {ind}_\mathbb {N} (\text {add-zero}_\mathbb {N}(m), \text {add-succ}_\mathbb {N}(m)):\mathbb {N}\to \mathbb {N}             }         </fr:tex>
    
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Recall the definition of addition function <fr:tex display="inline">\text {add}: \mathbb {N}\to (\mathbb {N}\to \mathbb {N})</fr:tex> satisfying the specification:
    <fr:tex display="block">         \begin {align*}             m + 0 &amp; :\equiv  m             \\              m + \text {succ}(n) &amp; :\equiv  \text {succ}(m + n)         \end {align*}     </fr:tex>
    Such definition is enough to characterize the addition function.
    Because it postulates te <fr:em>behavior</fr:em> of <fr:tex display="inline">\text {add}_\mathbb {N}</fr:tex> at the constructor of <fr:tex display="inline">\mathbb {N}</fr:tex></fr:p><fr:p>More generally, we can define a dependent function <fr:tex display="inline">f:\Pi  n:\mathbb {N}.P(n)</fr:tex> by induction on <fr:tex display="inline">n</fr:tex> using
    <fr:tex display="block">         \begin {align*}             p_0 &amp; : P(0)             \\             p_S &amp; : \Pi _{(n:\mathbb {N})}P(n)\to  P(\text {succ}(n))         \end {align*}     </fr:tex>
    Just present the definition by writing
    <fr:tex display="block">         \begin {align*}             f(0) &amp; :\equiv  p_0             \\             f(\text {succ}(n)) &amp; :\equiv  p_S(n,f(n))         \end {align*}     </fr:tex>
    <fr:tex display="inline">f</fr:tex> is said to be defined by <fr:strong>pattern matching</fr:strong> on the variable <fr:tex display="inline">n</fr:tex>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>736</fr:anchor><fr:addr type="user">eg-0001</fr:addr><fr:route>eg-0001.xml</fr:route><fr:title text="Fibonacci Function">Fibonacci Function</fr:title><fr:taxon>Example</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>Fibonacci function</fr:strong> is a well-known function in mathematics.
    It is defined by pattern matching on the variable <fr:tex display="inline">n</fr:tex> as follows:
    <fr:tex display="block">         \begin {align*}             \text {fib}(0) &amp; :\equiv  0             \\             \text {fib}(1) &amp; :\equiv  1             \\             \text {fib}(n+2) &amp; :\equiv  \text {fib}(n) + \text {fib}(n+1)         \end {align*}     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>737</fr:anchor><fr:addr type="user">tt-0004</fr:addr><fr:route>tt-0004.xml</fr:route><fr:title text="Inductive Types">Inductive Types</fr:title><fr:taxon>Type Theory</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In previous post, we have seen the definition of natural numbers as an inductive type.
    In this post, we will see more examples of inductive types, such as 
    unit type, empty type, product type, sum type and etc.
    Refer to <fr:link type="local" href="hott-2022.xml" addr="hott-2022" title="Introduction to Homotopy Type Theory">Egbert Rijke&apos;s Book</fr:link>.</fr:p><fr:p>This section is much more informal than the previous one.
    Without displaying the inference rules, we will just present the <fr:strong>constructor</fr:strong>
    and <fr:strong>induction principle</fr:strong> of each inductive type.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>738</fr:anchor><fr:addr type="machine">#272</fr:addr><fr:route>unstable-272.xml</fr:route><fr:title text="General Inductive Type"><fr:strong>General Inductive Type</fr:strong></fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors></fr:authors><fr:parent>tt-0004</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>Just like <fr:tex display="inline">\mathbb {N}</fr:tex>, other inductive types can be defined by 
    their constructors and induction principles (and computation rules).</fr:p>
    <fr:ul><fr:li>The constructors specify the structure of the type equipped.</fr:li>
        <fr:li>The induction principle specifies the data required to construct 
            a section of an arbitrary type family over the inductive type.</fr:li>
        <fr:li>The computation rules specify the behavior of the constructors.</fr:li></fr:ul>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>739</fr:anchor><fr:addr type="user">def-0020</fr:addr><fr:route>def-0020.xml</fr:route><fr:title text="Unit Type">Unit Type</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>unit type</fr:strong> is the simplest inductive type.
        It has only one constructor, denoted by <fr:tex display="inline">\star :\textbf {1}</fr:tex>.</fr:p><fr:p>The induction principle of the unit type is trivial.
        It says that to define a dependent function <fr:tex display="inline">f:\Pi  _{(x:\textbf {1})} P(x)</fr:tex>, 
        it suffices to give a value <fr:tex display="inline">p:P(\star )</fr:tex>.
        <fr:tex display="block">             f (\star ) :\equiv  p         </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>A degenrate inductive type is the <fr:strong>empty type</fr:strong>.
    It has no constructor, and its induction principle is trivial.
    Empty type is connected to the <fr:strong>exfalso quodlibet principle</fr:strong> in logic.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>740</fr:anchor><fr:addr type="user">def-0021</fr:addr><fr:route>def-0021.xml</fr:route><fr:title text="Empty Type">Empty Type</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>empty type</fr:strong> is a degenerate inductive type <fr:tex display="inline">\emptyset </fr:tex> satisfying 
    the following induction principle:
    <fr:tex display="block">         \text {ind}_\emptyset  : \Pi _{(x:\emptyset )}P(x)     </fr:tex>
    And a special case is <fr:strong>exfalso</fr:strong>:
    <fr:tex display="block">         \text {exfalso} :\equiv  \text {ind}_\emptyset  : \empty  \to  A      </fr:tex>
    which can draw any conclusion.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>With the empty type we can define the <fr:strong>negation</fr:strong> of a type
    and the <fr:strong>proof of negation</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>741</fr:anchor><fr:addr type="user">def-0022</fr:addr><fr:route>def-0022.xml</fr:route><fr:title text="Type Negation">Type Negation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>negation</fr:strong> of type <fr:tex display="inline">A</fr:tex> is defined as
    <fr:tex display="block">         \neg  A :\equiv  A \to  \emptyset      </fr:tex>
    A type <fr:tex display="inline">A</fr:tex> is said to be <fr:strong>empty</fr:strong> if and only if <fr:tex display="inline">\neg  A</fr:tex> is inhabited.
    <fr:tex display="block">         \text {empty}(A) :\equiv  \neg  A     </fr:tex></fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>742</fr:anchor><fr:addr type="machine">#334</fr:addr><fr:route>unstable-334.xml</fr:route><fr:title text="Proof of negation"><fr:strong>Proof of negation</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>def-0022</fr:parent></fr:frontmatter><fr:mainmatter>
        <fr:p>To prove <fr:tex display="inline">\neg  A</fr:tex>, we need to show that <fr:tex display="inline">A</fr:tex> implies a contradiction.
            In other words, constructing a function of type <fr:tex display="inline">A \to  \emptyset </fr:tex>.</fr:p>
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>743</fr:anchor><fr:addr type="user">def-0023</fr:addr><fr:route>def-0023.xml</fr:route><fr:title text="Coproduct Type">Coproduct Type</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">A</fr:tex> and <fr:tex display="inline">B</fr:tex> be types. The <fr:strong>coproduct (disjoint sum)</fr:strong> <fr:tex display="inline">A+B</fr:tex> is a typed defined by the following constructors:
    <fr:ul><fr:li><fr:tex display="inline">\text {inl}:A\to  A+B</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">\text {inr}:B\to  A+B</fr:tex></fr:li></fr:ul>
    For any type family indexed by <fr:tex display="inline">x:A+B</fr:tex>, satisfies the following induction principle:
    <fr:tex display="block">         \text {ind}_+: (\Pi _{(x:A)}P(\text {inl}(x)))\to (\Pi _{(y:B)}P(\text {inr}(y)))\to \Pi _{(z:A+B)}P(z)     </fr:tex>
    (Note that sometimes we denoted <fr:tex display="inline">\text {ind}_+(f,g)</fr:tex> as <fr:tex display="inline">[f,g]</fr:tex>) And the computation rule:
    <fr:tex display="block">         \begin {align*}             \text {ind}_+(f,g,\text {inl}(x))&amp;\equiv  f(x)\\             \text {ind}_+(f,g,\text {inr}(y))&amp;\equiv  g(y)         \end {align*}     </fr:tex>
    where <fr:tex display="inline">f</fr:tex> and <fr:tex display="inline">g</fr:tex> are defined:
    <fr:tex display="block">         \begin {align*}             f&amp;:\Pi _{(x:A)}P(\text {inl}(x))\\             g&amp;:\Pi _{(y:B)}P(\text {inr}(y))         \end {align*}     </fr:tex>
    This can be presented by pattern matching to define a function <fr:tex display="inline">h:\Pi  _{(z:A+B)}.P(z)</fr:tex>:
    <fr:tex display="block">         \begin {align*}             h(\text {inl}(x))&amp;:\equiv  f(x)\\             h(\text {inr}(y))&amp;:\equiv  g(y)         \end {align*}     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>744</fr:anchor><fr:addr type="machine">#273</fr:addr><fr:route>unstable-273.xml</fr:route><fr:title text="Special Case of Coproduct"><fr:strong>Special Case of Coproduct</fr:strong></fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors></fr:authors><fr:parent>tt-0004</fr:parent></fr:frontmatter><fr:mainmatter>
    The special case of coproduct type is also called the <fr:strong>sum type</fr:strong>.
    <fr:tex display="block">         \text {ind}_+: (A \to  X) \to  (B \to  X) \to  (A+B \to  X)     </fr:tex>
    which is very similar to the <fr:strong>elimination rule</fr:strong> of disjunction in logic.
    <fr:tex display="block">         (P\to  Q) \to  (R\to  Q) \to  (P\vee  R\to  Q)     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:p>The dependent version of sum type is called the <fr:strong>dependent sum type (dependent coproduct)</fr:strong> traditionally.
    Its terms are ordered pairs.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>745</fr:anchor><fr:addr type="user">def-0024</fr:addr><fr:route>def-0024.xml</fr:route><fr:title text="Dependent Pair Type">Dependent Pair Type</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>dependent pair type</fr:strong> is a inductive type <fr:tex display="inline">\Sigma _{(x:A)}B(x)</fr:tex> (<fr:tex display="inline">(x:A) \times  B(x)</fr:tex>)</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>746</fr:anchor><fr:addr type="machine">#329</fr:addr><fr:route>unstable-329.xml</fr:route><fr:title text="
    Formation Rule
">
    <fr:strong>Formation Rule</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>Given a type family <fr:tex display="inline">B</fr:tex> over <fr:tex display="inline">A</fr:tex>, we can form the dependent pair type <fr:tex display="inline">\Sigma _{(x:A)}B(x)</fr:tex>.</fr:p>
    <fr:tex display="block">         \frac {             \Gamma \vdash  A\space \text {type}             \quad              \Gamma ,x:A\vdash  B(x)\space \text {type}         }{             \Gamma \vdash  (x:A) \times  B(x)\space \text {type}         }     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>747</fr:anchor><fr:addr type="machine">#330</fr:addr><fr:route>unstable-330.xml</fr:route><fr:title text="
    Introduction Rule
">
    <fr:strong>Introduction Rule</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>Given a term <fr:tex display="inline">a:A</fr:tex> and a term <fr:tex display="inline">b(a):B(a)</fr:tex>, we can form a term <fr:tex display="inline">\text {pair}(a,b):(x:A)\times  B(x)</fr:tex>.</fr:p>
    <fr:tex display="block">         \frac {             \Gamma \vdash  a:A             \quad              \Gamma \vdash  b(a):B(a)         }{             \Gamma \vdash  (a,b):(x:A)\times  B(x)         }     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>748</fr:anchor><fr:addr type="machine">#331</fr:addr><fr:route>unstable-331.xml</fr:route><fr:title text="
    Elimination Rule
">
    <fr:strong>Elimination Rule</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>The elimination rule is formed with two projections.
        <fr:tex display="block">             \frac {                 \Gamma \vdash  p:(x:A)\times  B(x)             }{                 \begin {align*}                     \Gamma &amp;\vdash  \text {pr}_A(p):A\\                     \Gamma &amp;\vdash  \text {pr}_B(p):B(\text {pr}_A(p))                 \end {align*}             }         </fr:tex></fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>749</fr:anchor><fr:addr type="machine">#332</fr:addr><fr:route>unstable-332.xml</fr:route><fr:title text="
    Computation Rule
">
    <fr:strong>Computation Rule</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p><fr:tex display="block">             \frac {                 \Gamma \vdash  x:A                  \quad                   \Gamma \vdash  y:B(x)             }{                 \begin {align*}                     \Gamma &amp;\vdash  \text {pr}_A((x,y))=x:A\\                     \Gamma &amp;\vdash  \text {pr}_B((x,y))=y:B(x)                 \end {align*}             }         </fr:tex></fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>750</fr:anchor><fr:addr type="machine">#333</fr:addr><fr:route>unstable-333.xml</fr:route><fr:title text="
    Special Case
">
    <fr:strong>Special Case</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>def-0024</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:ul><fr:li>In the special case that <fr:tex display="inline">B(x) = B</fr:tex> is independent of <fr:tex display="inline">A</fr:tex>,
            this reduces to the <fr:strong>product type</fr:strong> <fr:tex display="inline">A\times  B</fr:tex>.</fr:li>
        <fr:li>In the special case that <fr:tex display="inline">D \equiv  \text {Boolean}</fr:tex>,
            this reduces to a <fr:link type="local" href="def-0023.xml" addr="def-0023" title="Coproduct Type">coproduct type</fr:link>.</fr:li></fr:ul>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>751</fr:anchor><fr:addr type="user">tt-0005</fr:addr><fr:route>tt-0005.xml</fr:route><fr:title text="Identity Types">Identity Types</fr:title><fr:taxon>Type Theory</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>31</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This post discuss the identity types in type theory.
    Refer to <fr:link type="local" href="hott-2022.xml" addr="hott-2022" title="Introduction to Homotopy Type Theory">Introduction to Homotopy Type Theory</fr:link>.</fr:p><fr:p>How can we think of <fr:strong>equality</fr:strong> in type theory?
    Mentioned before, given a type <fr:tex display="inline">A</fr:tex> and two its elements <fr:tex display="inline">a,b:A</fr:tex>
    we can define a new type <fr:tex display="inline">a=_Ab</fr:tex> which is called the <fr:strong>identity type</fr:strong>.
    In this case, a term of <fr:tex display="inline">a=_Ab</fr:tex> is said to be a <fr:em>witness</fr:em> of the equality of <fr:tex display="inline">a</fr:tex> and <fr:tex display="inline">b</fr:tex>.
    And this witness is itself a type.
    We can then define their equality.
    This gives every type a <fr:strong>groupoid structure</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>752</fr:anchor><fr:addr type="user">def-002N</fr:addr><fr:route>def-002N.xml</fr:route><fr:title text="Identity Type">Identity Type</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>identity type</fr:strong> is an inductive type,
    generated by just a <fr:strong>reflexivity</fr:strong> <fr:em>identification</fr:em>
    that providing an equality of a term with itself.</fr:p><fr:p>Consider a type <fr:tex display="inline">A</fr:tex> and let <fr:tex display="inline">a:A</fr:tex> be an element.
    The identity type of <fr:tex display="inline">A</fr:tex> at <fr:tex display="inline">a</fr:tex> is an inductive family of types <fr:tex display="inline">a=_Ax</fr:tex> 
    indexed by <fr:tex display="inline">x:A</fr:tex>.
    <fr:tex display="block">         \frac {             \Gamma \vdash  a:A         }{             \Gamma ,x:A\vdash  a=_Ax\space \text {type}         }     </fr:tex>
    The only constructor is the refl:
    <fr:tex display="block">         \frac {             \Gamma \vdash  a:A         }{             \Gamma \vdash  \text {refl}_a:a=_Ax         }     </fr:tex></fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>753</fr:anchor><fr:addr type="machine">#327</fr:addr><fr:route>unstable-327.xml</fr:route><fr:title text="Path Induction / Identification Elimination"><fr:strong>Path Induction / Identification Elimination</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>def-002N</fr:parent></fr:frontmatter><fr:mainmatter>
    The induction principle of the identity type states that
    for any type family <fr:tex display="inline">P(x,p)</fr:tex> indexed by <fr:tex display="inline">x:A</fr:tex> and <fr:tex display="inline">p:a=_Ax</fr:tex>,
    <fr:tex display="block">         \text {ind-eq}_{a}:P(a, \text {refl}_a)\to  (x:A)\to  (p:a=_Ax)\to  P(x,p)     </fr:tex>
    satisfies <fr:tex display="inline">\text {ind-eq}_{a}(u,a,\text {refl}_a)\equiv  u</fr:tex> where <fr:tex display="inline">u:P(a,\text {refl}_a)</fr:tex>.
    Formally we can write:
    <fr:tex display="block">         \frac {             \Gamma \vdash  a:A,\quad  \Gamma ,x:A,p:a=_Ax\vdash  P(x,p)\space \text {type}         }{             \Gamma \vdash  \text {ind-eq}_{a}(a,\text {refl}_a): P(a,\text {refl}_a) \to  (x:A)\to  (p:a=_Ax)\to  P(x,p)         }\text {eq-elim}     </fr:tex>
    <fr:tex display="block">         \frac {             \Gamma \vdash  a:A,\quad  \Gamma ,x:A,p:a=_Ax\vdash  P(x,p)\space \text {type}         }{             \Gamma ,u:P(a,\text {refl}_a)\vdash  \text {ind-eq}_{a}(u,a,\text {refl}_a)\equiv  u:P(a,\text {refl}_a)         }\text {eq-comp}     </fr:tex>

</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:p>A term of <fr:tex display="inline">a=_Ax</fr:tex> is called a <fr:strong>identification</fr:strong> of <fr:tex display="inline">a</fr:tex> and <fr:tex display="inline">x</fr:tex>,
    or the <fr:strong>path</fr:strong> from <fr:tex display="inline">a</fr:tex> to <fr:tex display="inline">x</fr:tex>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>754</fr:anchor><fr:addr type="machine">#328</fr:addr><fr:route>unstable-328.xml</fr:route><fr:title text="Variable Version"><fr:strong>Variable Version</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>def-002N</fr:parent></fr:frontmatter><fr:mainmatter>
    We can form an identity type with variables of <fr:tex display="inline">A</fr:tex>.
    <fr:tex display="block">         \Gamma ,x:A,y:A\vdash  x=_Ay\space \text {type}     </fr:tex>
    with the following introduction rule:
    <fr:tex display="block">         \frac {             \Gamma ,x:A\vdash  x:A         }{             \Gamma ,x:A\vdash  \text {refl}_x:x=_Ax         }     </fr:tex>
    and similarly the elimination rule and computation rule.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>755</fr:anchor><fr:addr type="machine">#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:title text="The groupoid structure of types">The groupoid structure of types</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>31</fr:day></fr:date><fr:authors></fr:authors><fr:parent>tt-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The identifications can be <fr:strong>concatenated</fr:strong> and <fr:strong>inverted</fr:strong>,
        which implies the <fr:em>transitivity</fr:em> and <fr:em>symmetry</fr:em> of the identity type.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>756</fr:anchor><fr:addr type="user">def-002O</fr:addr><fr:route>def-002O.xml</fr:route><fr:title text="Concatenation Operation">Concatenation Operation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">A</fr:tex> be a type.
    The <fr:strong>Concatenation</fr:strong> operation is defined:
    <fr:tex display="block">         \text {concat}: (x:A)\to  (y:A)\to  (z:A)\to  (x=_Ay)\to  (y=_Az)\to  (x=_Az)     </fr:tex></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>757</fr:anchor><fr:addr type="machine">#326</fr:addr><fr:route>unstable-326.xml</fr:route><fr:title text="Construction of Concatenation">Construction of Concatenation</fr:title><fr:authors></fr:authors><fr:parent>def-002O</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>We can first construct:
        <fr:tex display="block">             f(x):(y:A)\to  (x=_Ay)\to (z:A)\to  (y=_Az)\to (x=_Az)         </fr:tex>
        For any <fr:tex display="inline">x:A</fr:tex>, it suffices to construct
        <fr:tex display="block">             f(x,x,\text {refl}_x) : (z:A) \to  (x=_Az)\to (x=_Az)         </fr:tex>
        That is the identity function <fr:tex display="inline">\lambda  z. \text {id}_{x=_Az}</fr:tex>.
        Then we can define by induction:
        <fr:tex display="block">             f(x) :\equiv  \text {ind-eq}_{x}(\lambda  z.\text {id})         </fr:tex>
        Finally:
        <fr:tex display="block">             \text {concat}_{x,y,z}(p,q) :\equiv  f(x,y,p,z,q)         </fr:tex>
        Or simply we denote <fr:tex display="inline">\text {concat}(p,q)</fr:tex> as <fr:tex display="inline">p \cdot  q</fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>758</fr:anchor><fr:addr type="user">def-002P</fr:addr><fr:route>def-002P.xml</fr:route><fr:title text="Inverse Operation">Inverse Operation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">A</fr:tex> be a type. The <fr:strong>inverse oepration</fr:strong> is defined:
    <fr:tex display="block">         \text {inv}: (x:A)\to  (y:A)\to  (x=_Ay)\to  (y=_Ax)     </fr:tex>
    Most of the time we write <fr:tex display="inline">p^{-1}</fr:tex> for <fr:tex display="inline">\text {inv}(p)</fr:tex>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>759</fr:anchor><fr:addr type="machine">#325</fr:addr><fr:route>unstable-325.xml</fr:route><fr:title text="Construction of Inverse">Construction of Inverse</fr:title><fr:authors></fr:authors><fr:parent>def-002P</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>By induction, it suffices to construct:
        <fr:tex display="block">             \text {inv}(x,x,\text {refl}_x) : (x=_Ax)         </fr:tex>
        for any <fr:tex display="inline">x:A</fr:tex>. And trivially we have <fr:tex display="inline">\text {inv}(x,x,\text {refl}_x)\equiv \text {refl}_x</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>It is natural to ask whether the identity type is <fr:em>reflexive</fr:em>.
        In the case of associativity we should ask to compare the identifications:
        <fr:tex display="block">             (p\cdot  q)\cdot  r \quad \text {and}\quad  p\cdot (q\cdot  r)         </fr:tex>
        for any <fr:tex display="inline">p:x=y</fr:tex>, <fr:tex display="inline">q:y=z</fr:tex> and <fr:tex display="inline">r:z=w</fr:tex> in a type <fr:tex display="inline">A</fr:tex>. Both <fr:tex display="inline"> (p\cdot  q)\cdot  r</fr:tex> and 
        <fr:tex display="inline">p\cdot (q\cdot  r)</fr:tex> are elements of type <fr:tex display="inline">x=w</fr:tex>. We can ask whether there is an
        identification
        <fr:tex display="block">             (p\cdot  q)\cdot  r = p\cdot (q\cdot  r)         </fr:tex></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>760</fr:anchor><fr:addr type="user">def-002W</fr:addr><fr:route>def-002W.xml</fr:route><fr:title text="Associator">Associator</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">A</fr:tex> be a type.
    These are 3 consecutive identifications
    <fr:tex display="block">         p:x=_Ay,q:y=_Az, r:z=_Aw     </fr:tex>
    we define the <fr:strong>associator</fr:strong>:
    <fr:tex display="block">         \text {assoc}: (p,q,r): (p\cdot  q)\cdot  r = p\cdot  (q\cdot  r)     </fr:tex></fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>761</fr:anchor><fr:addr type="machine">#320</fr:addr><fr:route>unstable-320.xml</fr:route><fr:title text="
    Construction of Associator
">
    <fr:strong>Construction of Associator</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>def-002W</fr:parent></fr:frontmatter><fr:mainmatter>
    By definition it suffices to show that
    <fr:tex display="block">         \Pi _{(z:A)}\Pi _{(q:x=_Az)}         \Pi _{(w:A)}\Pi _{(r:z=_Aw)}         (\text {refl}_x\cdot  q)\cdot  r = \text {refl}_x\cdot  (q\cdot  r)     </fr:tex>
    Let <fr:tex display="inline">q:x=_Az</fr:tex> and <fr:tex display="inline">r:z=_Aw</fr:tex>. By computation rule of identity types
    <fr:tex display="block">         \text {refl}_x\cdot  q \equiv  q     </fr:tex>
    Then we can conclude that
    <fr:tex display="block">         (\text {refl}_x\cdot  q)\cdot  r \equiv  q\cdot  r     </fr:tex>
    similarly <fr:tex display="inline">\text {refl}_x\cdot  (q\cdot  r) \equiv  q\cdot  r</fr:tex>.
    Hence we have the left and right side
    <fr:tex display="block">         (\text {refl}_x\cdot  q)\cdot  r = \text {refl}_x\cdot  (q\cdot  r)     </fr:tex>
    are judgementally equal, 
    so we can simply define the associator as
    <fr:tex display="block">         \text {assoc}(\text {refl}_x,q,r) :\equiv  \text {refl}_{q\cdot  r}     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>762</fr:anchor><fr:addr type="user">def-002X</fr:addr><fr:route>def-002X.xml</fr:route><fr:title text="Unit Law Operations">Unit Law Operations</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">A</fr:tex> be a type.
    We defined the <fr:strong>unit law</fr:strong> operations for <fr:tex display="inline">x=_Ay</fr:tex>:
    <fr:tex display="block">         \begin {align*}             \text {left-unit} &amp; : (x=_Ay)\to  (\text {refl}_x\cdot  x = x) \\             \text {right-unit} &amp; : (x=_Ay)\to  (x\cdot \text {refl}_y = x)         \end {align*}     </fr:tex></fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>763</fr:anchor><fr:addr type="machine">#319</fr:addr><fr:route>unstable-319.xml</fr:route><fr:title text="
    Construction of Unit Law
">
    <fr:strong>Construction of Unit Law</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>def-002X</fr:parent></fr:frontmatter><fr:mainmatter>
    By elimination it suffices to construct:
    <fr:tex display="block">         \begin {align*}             \text {left-unit}(\text {refl}_x) &amp;: \text {refl}_x \cdot  \text {refl}_x = \text {refl}_x \\             \text {right-unit}(\text {refl}_x) &amp;: \text {refl}_x \cdot  \text {refl}_x = \text {refl}_x         \end {align*}     </fr:tex>
    In both cases we need only to construct <fr:tex display="inline">\text {refl}_{\text {refl}_x}</fr:tex>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>764</fr:anchor><fr:addr type="machine">#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:title text="The action on identifications of functions">The action on identifications of functions</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>31</fr:day></fr:date><fr:authors></fr:authors><fr:parent>tt-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Every function preserves identifications.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>765</fr:anchor><fr:addr type="user">def-004C</fr:addr><fr:route>def-004C.xml</fr:route><fr:title text="Action on Paths">Action on Paths</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">f:A\to  B</fr:tex> be a map. We define the <fr:strong>action on paths</fr:strong> of <fr:tex display="inline">f</fr:tex> as an operation:
    <fr:tex display="block">         \text {ap}_f : \prod _{x,y:A} (x=y) \to  (f(x)=f(y))     </fr:tex>
    This can be defined by induction principle of identity types:
    <fr:tex display="block">         \text {ap}_f(\text {refl}_x) \equiv  \text {refl}_{f(x)}     </fr:tex>
    And there are operations:
    <fr:tex display="block">         \text {ap-id}_A:       \prod _{(x,y:A)}\prod _{(p:x=y)} p = \text {ap}_{\text {id}_A}(p)     </fr:tex>
    Taking
    <fr:tex display="block">         \text {ap-id}_A(\text {refl}_x) \equiv  \text {refl}_{\text {refl}_x}     </fr:tex>
    Finally we can construct
    <fr:tex display="block">         \text {ap-comp}(f, g): \prod _{(x,y:A)}\prod _{(p:x=y)} \text {ap}_{f\circ  g}(p) = \text {ap}_f(\text {ap}_g(p))     </fr:tex>
    by taking
    <fr:tex display="block">         \text {ap-comp}(f,g,\text {refl}_x) \equiv  \text {refl}_{\text {refl}_{g(f(x))}}     </fr:tex>
    There are identifications:
    <fr:ul><fr:li>Notice that we have <fr:tex display="inline">\text {ap-id}_A(\text {refl}_x) \equiv  \text {refl}_{\text {refl}_x}</fr:tex> so
            <fr:tex display="block">                 \begin {align*}                     \text {ap-refl}(f,x) &amp;:\text {ap}_f(\text {refl}_x) = \text {refl}_{f(x)} \\                     \text {ap-refl}(f,x) &amp;\equiv  \text {refl}_{\text {refl}_{f(x)}}                 \end {align*}             </fr:tex></fr:li>
        <fr:li>The <fr:tex display="inline">\text {ap-inv}</fr:tex> can be constructed by identification elimination on <fr:tex display="inline">p</fr:tex>.
            <fr:tex display="block">                 \begin {align*}                     &amp;\text {ap-inv}(f,p):\text {ap}_f(p^{-1}) = \text {ap}_f(p)^{-1}\\                     &amp;\text {ap-inv}(f,\text {refl}_x)\equiv  \text {refl}_{\text {ap}_f(\text {refl}_x)}                 \end {align*}             </fr:tex></fr:li>
        <fr:li>Similarly, the <fr:tex display="inline">\text {ap-concat}</fr:tex> can be constructed by identification elimination on <fr:tex display="inline">p</fr:tex>.
            <fr:tex display="block">                 \begin {align*}                     &amp;\text {ap-concat}(f,p,q):\text {ap}_f(p\cdot  q) = \text {ap}_f(p)\cdot  \text {ap}_f(q) \\                     &amp;\text {ap-concat}(f,\text {refl}_x,q)\equiv  \text {refl}_{\text {ap}_f(q)}                 \end {align*}             </fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>To construct dependent action on paths if a dependent function <fr:tex display="inline">f:\Pi _{(x:A)}B(x)</fr:tex>.
        We need a <fr:strong>transport</fr:strong> because type theory can not distinguish between identified 
        elements from different types.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>766</fr:anchor><fr:addr type="user">def-004D</fr:addr><fr:route>def-004D.xml</fr:route><fr:title text="Transport">Transport</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">A</fr:tex> be a type and let <fr:tex display="inline">B</fr:tex> be a type family over <fr:tex display="inline">A</fr:tex>.
    The <fr:strong>transport</fr:strong> operation is defined:
    <fr:tex display="block">         \text {tr}_B:\Pi _{(x,y:A)}(x=y)\to  B(x)\to  B(y)     </fr:tex>
    Simply induction on <fr:tex display="inline">p:x=y</fr:tex> we can construct:
    <fr:tex display="block">         \text {tr}_B(\text {refl}_x) \equiv  \text {id}_{B(x)}     </fr:tex></fr:p><fr:p>Now for a given dependent function <fr:tex display="inline">f:\Pi _{(a:A)}B(a)</fr:tex> and an identification
    <fr:tex display="inline">p:x=y</fr:tex> in <fr:tex display="inline">A</fr:tex> we can construct
    <fr:tex display="block">         \text {apd}_f(p) : \text {tr}_B(p,f(x)) = f(y)     </fr:tex>
    this can be constructed by the induction principle for identity types,
    it suffices to construct an identification:
    <fr:tex display="block">         \text {apd}_f(\text {refl}_x) : \text {tr}_B(\text {refl}_x,f(x)) = f(x)     </fr:tex>
    which is simply done by taking <fr:tex display="inline">\text {apd}_f(\text {refl}_x)\equiv \text {refl}_{f(x)}</fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>767</fr:anchor><fr:addr type="machine">#270</fr:addr><fr:route>unstable-270.xml</fr:route><fr:title text="Uniqueness of refl">Uniqueness of refl</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>31</fr:day></fr:date><fr:authors></fr:authors><fr:parent>tt-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The identity type is an inductive family of types.
        For instance, while the type <fr:tex display="inline">a=x</fr:tex> indexed by <fr:tex display="inline">x:A</fr:tex> is inductively generated by <fr:tex display="inline">\text {refl}_a</fr:tex>,
        the type <fr:tex display="inline">a=a</fr:tex> is <fr:strong>not</fr:strong>, because the endpoint of <fr:tex display="inline">p:a=a</fr:tex> is not free. 
        We want to show that <fr:tex display="inline">p=\text {refl}_a</fr:tex> for all <fr:tex display="inline">p:a=a</fr:tex>.</fr:p><fr:p>Nevertheless the identity type <fr:tex display="inline">a=x</fr:tex> is generated by a single element <fr:tex display="inline">\text {refl}_a:a=a</fr:tex>,
        so it is natural to wonder in <fr:em>what sense</fr:em> the reflexivity identification is unique.
        We prove that only one pair <fr:tex display="inline">(a,\text {refl}_a)</fr:tex> is unique in the type of all pairs:
        <fr:tex display="block">             (x,p):\Sigma _(x:A) a = x          </fr:tex>
        We restate this as a proposition: Consider an element <fr:tex display="inline">a:A</fr:tex>. Then there is an identification
        <fr:tex display="inline">(a, \text {refl}_a = y)</fr:tex> in the type <fr:tex display="inline">\Sigma _(x:A) a = x</fr:tex> for any <fr:tex display="inline">y:\Sigma _(x:A) a = x </fr:tex></fr:p>
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>768</fr:anchor><fr:addr type="machine">#271</fr:addr><fr:route>unstable-271.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>31</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#270</fr:parent></fr:frontmatter><fr:mainmatter>
        By <fr:tex display="inline">\Sigma </fr:tex> induction it suffices to show that there is an identification
        <fr:tex display="block">             (a, \text {refl}_a) = (x, p)         </fr:tex>
        forall <fr:tex display="inline">x:A</fr:tex> and <fr:tex display="inline">p:a=x</fr:tex>. Then perform the induction principle of identity types.
        It suffices to show that
        <fr:tex display="block">             (a,\text {refl}_a) = (a, \text {refl}_a)         </fr:tex>
        which can be obtained by reflexivity.
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>769</fr:anchor><fr:addr type="user">tt-0006</fr:addr><fr:route>tt-0006.xml</fr:route><fr:title text="Universe">Universe</fr:title><fr:taxon>Type Theory</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This post discuss the universe in type theory,
    based on Egbert Rijke&apos;s <fr:link type="local" href="hott-2022.xml" addr="hott-2022" title="Introduction to Homotopy Type Theory">Introduction to Homotopy Type Theory</fr:link> and <fr:link type="local" href="ncatlab.xml" addr="ncatlab" title="NLab">NLab</fr:link>.
    In this post, we regard universe as the representation of types in an internal model 
    of the type theory (<fr:strong>Tarski universe</fr:strong> or <fr:strong>universe à la Tarski</fr:strong>).</fr:p><fr:p>A universe consist of a type <fr:tex display="inline">\mathcal {U}</fr:tex> with a type family <fr:tex display="inline">\mathcal {T}</fr:tex> over <fr:tex display="inline">\mathcal {U}</fr:tex>.
    Forall <fr:tex display="inline">X:\mathcal {U}</fr:tex> we think of <fr:tex display="inline">X</fr:tex> as an <fr:strong>encoding</fr:strong> (representation) of the actual type <fr:tex display="inline">\mathcal {T}(X)</fr:tex>.
    The type family <fr:tex display="inline">\mathcal {T}</fr:tex> is therefore called a <fr:strong>unversal type family</fr:strong>.</fr:p><fr:p>There several reasons to equip type theory with universes.
    It enables us to define new type families over inductive types, using induction principle.
    For instance, we can define <fr:strong>relations</fr:strong> over <fr:tex display="inline">\mathbb {N}</fr:tex>, such as ordering relations <fr:tex display="inline">\leq </fr:tex>.
    We will soon meet the idea of <fr:strong>observational equality</fr:strong> for a particular type, different from identity types.
    Another reason is that it allows us to define types equipped with structure such as group.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>704</fr:anchor><fr:addr type="machine">#266</fr:addr><fr:route>unstable-266.xml</fr:route><fr:title text="Specification">Specification</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors></fr:authors><fr:parent>tt-0006</fr:parent></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>705</fr:anchor><fr:addr type="user">def-004E</fr:addr><fr:route>def-004E.xml</fr:route><fr:title text="Tarski Universe">Tarski Universe</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>universe</fr:strong> consists of a type <fr:tex display="inline">\mathcal {U}</fr:tex> of which the elements are representations of types.
    It is equipped with a type family <fr:tex display="inline">\mathcal {T}</fr:tex> indexed by <fr:tex display="inline">\mathcal {U}</fr:tex> called <fr:strong>universal type family</fr:strong>.
    The universe is closed under all the type constructors in the sense that it comes equipped with the following structure:
    <fr:ul><fr:li><fr:tex display="inline">\mathcal {U}</fr:tex> is closed under <fr:tex display="inline">\Pi </fr:tex>, equipped with a function
            <fr:tex display="block">                 \check {\Pi }:\Pi _{(X:\mathcal {U})}(\mathcal {T}(X)\to \mathcal {U})\to \mathcal {U}             </fr:tex>
            for which the judgemental equality
            <fr:tex display="block">                 \mathcal {T}(\check {\Pi }(X,P))\equiv \Pi _{(x:\mathcal {T}(X))}\mathcal {T}(P(x))             </fr:tex>
            holds forall <fr:tex display="inline">X:\mathcal {U}</fr:tex> and <fr:tex display="inline">P:\mathcal {T}(X)\to \mathcal {U}</fr:tex>.</fr:li>
        <fr:li><fr:tex display="inline">\mathcal {U}</fr:tex> is closed under <fr:tex display="inline">\Sigma </fr:tex>, equipped with a function
            <fr:tex display="block">                 \check {\Sigma }:\Pi _{(X:\mathcal {U})}(\mathcal {T}(X)\to \mathcal {U})\to \mathcal {U}             </fr:tex>
            for which the judgemental equality
            <fr:tex display="block">                 \mathcal {T}(\check {\Sigma }(X,P))\equiv \Sigma _{(x:\mathcal {T}(X))}\mathcal {T}(P(x))             </fr:tex>
            holds forall <fr:tex display="inline">X:\mathcal {U}</fr:tex> and <fr:tex display="inline">P:\mathcal {T}(X)\to \mathcal {U}</fr:tex>.</fr:li>
        <fr:li><fr:tex display="inline">\mathcal {U}</fr:tex> is closed under identity types, equipped with a function
            <fr:tex display="block">                 \check {I}:\Pi _{(X:\mathcal {U})}\mathcal {T}(X)\to \mathcal {T}(X)\to \mathcal {U}             </fr:tex>
            for which the judgemental equality
            <fr:tex display="block">                 \mathcal {T}(\check {I}(X,x,y))\equiv  (x=y)             </fr:tex>
            holds forall <fr:tex display="inline">X:\mathcal {U}</fr:tex> and <fr:tex display="inline">x,y:\mathcal {T}(X)</fr:tex>.</fr:li>
        <fr:li><fr:tex display="inline">\mathcal {U}</fr:tex> is closed under coproducts, equipped with a function
            <fr:tex display="block">                 \check {+}:\Pi _{(X:\mathcal {U})}(\mathcal {T}(X)\to \mathcal {U})\to \mathcal {U}             </fr:tex>
            that satisfies the judgemental equality <fr:tex display="inline">\mathcal {T}(X\check {+}P)\equiv \mathcal {T}(X)+\mathcal {T}(P)</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">\mathcal {U}</fr:tex> contains elements <fr:tex display="inline">\check {\textbf {1}}, \check {\textbf {0}}, \check {\mathbb {N}} : \mathcal {U}</fr:tex> that satisfies the judgemental equality
            <fr:tex display="block">                 \mathcal {T}(\check {\textbf {0}})\equiv  \textbf {0},                 \\ \mathcal {T}(\check {\textbf {1}})\equiv  \textbf {1},                 \\ \mathcal {T}(\check {\mathbb {N}})\equiv \mathbb {N}             </fr:tex></fr:li></fr:ul>
    Consider a universe <fr:tex display="inline">\mathcal {U}</fr:tex> and a type <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>.
    We say that <fr:tex display="inline">A</fr:tex> is a type in <fr:tex display="inline">\mathcal {U}</fr:tex> or that <fr:tex display="inline">\mathcal {U}</fr:tex> contains <fr:tex display="inline">A</fr:tex>,
    if there is an element <fr:tex display="inline">\check {A}:\mathcal {U}</fr:tex> such that <fr:tex display="inline">\Gamma \vdash \mathcal {T}(\check {A})\equiv  A\space \space \text {type}</fr:tex> holds.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>706</fr:anchor><fr:addr type="machine">#314</fr:addr><fr:route>unstable-314.xml</fr:route><fr:title text="Enough Universe">Enough Universe</fr:title><fr:authors></fr:authors><fr:parent>def-004E</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Sometimes we may consider the universe <fr:tex display="inline">\mathcal {U}</fr:tex> itself to be a type in some universes.
        If we have only one <fr:tex display="inline">\mathcal {U}</fr:tex>, the <fr:strong>Russell Paradox</fr:strong> may arise.
        Therefore we assume that there are <fr:strong>enough universes</fr:strong></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>707</fr:anchor><fr:addr type="user">thm-0013</fr:addr><fr:route>thm-0013.xml</fr:route><fr:title text="Enough Universe">Enough Universe</fr:title><fr:taxon>Postulate</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We assume that there&apos;re <fr:strong>enough universe</fr:strong>, i.e.,
    for every finite list of types in context 
    <fr:tex display="block">         \Gamma _1\vdash  A_1\space \space \text {type},\cdots ,\Gamma _n\vdash  A_n\space \space \text {type}     </fr:tex>
    there is a universe <fr:tex display="inline">\mathcal {U}</fr:tex> that contains each <fr:tex display="inline">A_i</fr:tex> in the sense that <fr:tex display="inline">\mathcal {U}</fr:tex> comes equipped with
    <fr:tex display="block">         \Gamma _i\vdash \check {A_i}:\mathcal {U}     </fr:tex>
    for which the following judgement holds:
    <fr:tex display="block">         \Gamma _i \vdash \mathcal {T}(\check {A_i})\equiv  A_i\space \space \text {type}     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Using the assumption we can obtain many specific universes.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>708</fr:anchor><fr:addr type="user">def-004F</fr:addr><fr:route>def-004F.xml</fr:route><fr:title text="Base Universe">Base Universe</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>base universee</fr:strong> <fr:tex display="inline">\mathcal {U}_0</fr:tex> is defined using <fr:link type="local" href="thm-0013.xml" addr="thm-0013" title="Enough Universe">universe postulate</fr:link>
    with empty context.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>709</fr:anchor><fr:addr type="user">def-004G</fr:addr><fr:route>def-004G.xml</fr:route><fr:title text="Successor Universe">Successor Universe</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>successor universee</fr:strong> <fr:tex display="inline">\mathcal {U}^+</fr:tex> of a universe <fr:tex display="inline">\mathcal {U}</fr:tex> is defined using <fr:link type="local" href="thm-0013.xml" addr="thm-0013" title="Enough Universe">universe postulate</fr:link>
    with the following contexts:
    <fr:tex display="block">         \vdash \mathcal {U}\space \space \text {type}\quad  X:\mathcal {U}\vdash \mathcal {T}(X)\space \space \text {type}     </fr:tex>
    It therefore contains the type <fr:tex display="inline">\mathcal {U}</fr:tex> as well as type in <fr:tex display="inline">\mathcal {U}</fr:tex>, in the following sense
    <fr:tex display="block">         \begin {align*}             &amp;\vdash \check {\mathcal {U}}:\mathcal {U}^+\\              &amp;\vdash \mathcal {T}^+(\check {\mathcal {U}})\equiv \mathcal {U}\space \text {type}\\             &amp;X:\mathcal {U}\vdash \check {\mathcal {T}}(X):\mathcal {U}^+\\              &amp;X:\mathcal {U}\vdash \mathcal {T}^+(\check {\mathcal {T}}(X))\equiv \mathcal {T}(X)\space \text {type}          \end {align*}     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Using successor universes we can create an infinite tower of universes.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>710</fr:anchor><fr:addr type="machine">#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:title text="Observational Equality">Observational Equality</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors></fr:authors><fr:parent>tt-0006</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Now we give the example of <fr:strong>observational equality</fr:strong> of <fr:tex display="inline">\mathbb {N}</fr:tex>.
        The key idea is to define a recursive function that reduce the arguments.
        Observational equality an inductively defined relation, which gives us an algorithm for checking
        equality on  <fr:tex display="inline">\mathbb {N}</fr:tex>. It can be used to show that equality of natural numbers is <fr:strong>decidable</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>701</fr:anchor><fr:addr type="user">def-004H</fr:addr><fr:route>def-004H.xml</fr:route><fr:title text="Observational Equality of {N}">Observational Equality of <fr:tex display="inline">\mathbb {N}</fr:tex></fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The observational equality of <fr:tex display="inline">\mathbb {N}</fr:tex> is a binary relation <fr:tex display="inline">\text {Eq}_\mathbb {N}:\mathbb {N}\to (\mathbb {N}\to \mathcal {U}_0)</fr:tex> satisfies
    <fr:tex display="block">         \begin {align*}             \text {Eq}_\mathbb {N}(0)(0) &amp;\equiv  \textbf {1} \\             \text {Eq}_\mathbb {N}(0)(\text {succ}(n)) &amp;\equiv  \textbf {0} \\             \text {Eq}_\mathbb {N}(\text {succ}(m))(0) &amp;\equiv  \textbf {0} \\             \text {Eq}_\mathbb {N}(\text {succ}(m))(\text {succ}(n)) &amp;\equiv  \text {Eq}_\mathbb {N}(m)(n)         \end {align*}     </fr:tex>
    
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>702</fr:anchor><fr:addr type="machine">#313</fr:addr><fr:route>unstable-313.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:authors></fr:authors><fr:parent>def-004H</fr:parent></fr:frontmatter><fr:mainmatter>
        We define <fr:tex display="inline">\text {Eq}</fr:tex> by double induction on <fr:tex display="inline">\mathbb {N}</fr:tex>. By the first application of induction
        it suffices to provide
        <fr:tex display="block">             \begin {align*}                 &amp;E_0:\mathbb {N}\to \mathcal {U}_0 \\                  &amp;E_S:\mathbb {N}\to ((\mathbb {N}\to \mathcal {U}_0)\to (\mathbb {N}\to \mathcal {U}_0))             \end {align*}         </fr:tex>
        we define <fr:tex display="inline">E_0</fr:tex> by induction:
        <fr:tex display="block">             \begin {align*}                 &amp;E_0(0) \equiv \textbf {1}\\                  &amp;E_0(\text {succ}(n)) \equiv \textbf {0}             \end {align*}         </fr:tex>
        and also define <fr:tex display="inline">E_S</fr:tex> by induction:
        <fr:tex display="block">             \begin {align*}                 &amp;E_S(n,X,0)\equiv \textbf {0}\\                  &amp;E_S(n,X,\text {succ}(m))\equiv  X(m)             \end {align*}         </fr:tex>
        Therefore we have by the computation rule for the first induction that 
        the following judgemental equality holds.
        <fr:tex display="block">             \begin {align*}                 \text {Eq}(0,m) &amp;\equiv  E_0(m) \\                 \text {Eq}(\text {succ}(n),m) &amp;\equiv  E_S(n,\text {Eq}(n),m)             \end {align*}         </fr:tex>
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Observational equality of <fr:tex display="inline">\mathbb {N}</fr:tex> is a reflexive relation, i.e. we have
        <fr:tex display="block">             \text {refl-Eq}_\mathbb {N}:\Pi _{(n:\mathbb {N})}\text {Eq}_\mathbb {N}(n,n)         </fr:tex>
        which is witnessed by induction on <fr:tex display="inline">n</fr:tex>.
        <fr:tex display="block">             \begin {align*}                 \text {refl-Eq}_\mathbb {N}(0) &amp;\equiv \star  \\                  \text {refl-Eq}_\mathbb {N}(\text {succ}(n)) &amp;\equiv \text {refl-Eq}_\mathbb {N}(n)             \end {align*}         </fr:tex></fr:p><fr:p>This leads to an interesting dual perspective on equality. 
        For any two natural numbers <fr:tex display="inline">m</fr:tex> and <fr:tex display="inline">n</fr:tex> we have
        <fr:tex display="block">             (m=n)\leftrightarrow \text {Eq}_\mathbb {N}(m,n)         </fr:tex></fr:p><fr:p>Using the observational equality of <fr:tex display="inline">\mathbb {N}</fr:tex> we can prove Peano&apos;s seventh and eighth
        axioms.
        <fr:ul><fr:li>For any two natural numbers <fr:tex display="inline">m</fr:tex> and <fr:tex display="inline">n</fr:tex> we have 
                <fr:tex display="block">                     (m = n)\leftrightarrow (\text {succ}(m) = \text {succ}(n))                 </fr:tex></fr:li>
            <fr:li>For any natural number <fr:tex display="inline">n</fr:tex> we have <fr:tex display="inline">0 \not = \text {succ}(n)</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>770</fr:anchor><fr:addr type="user">phy-0002</fr:addr><fr:route>phy-0002.xml</fr:route><fr:title text="The Wave Function">The Wave Function</fr:title><fr:taxon>Quantum Mechanics</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This post introduces the concept of the wave function in quantum mechanics.
    Refer to <fr:link type="local" href="quantum-2018.xml" addr="quantum-2018" title="Introduction to Quantum Mechanics">Introduction to Quantum Mechanics</fr:link>.</fr:p><fr:p>Consider a particle of mass <fr:tex display="inline">m</fr:tex> moving along <fr:tex display="inline">x</fr:tex>-axis
    subject to force <fr:tex display="inline">F(x, t)</fr:tex>.
    With Newton&apos;s second law, we have:
    <fr:tex display="block">         F = ma     </fr:tex>
    For <fr:strong>conservative systems</fr:strong>, the force
    can be expressed as the derivative of a <fr:strong>potential energy</fr:strong>.
    <fr:tex display="block">         F = -\frac {\partial  V}{\partial  x}     </fr:tex>
    Now the equation of motion becomes:
    <fr:tex display="block">         m \frac {d^2x}{dt^2} = -\frac {\partial  V}{\partial  x}     </fr:tex>
    With appropriate initial conditions we can determine the <fr:tex display="inline">x(t)</fr:tex>,
    this is what we normally do in classic mechanics.</fr:p><fr:p>For <fr:strong>Quantum Mechanics</fr:strong>, we have a different perspective.
    We would like to look for the <fr:strong>wave function</fr:strong>, <fr:tex display="inline">\Psi (x, t)</fr:tex>.
    To determine it we need to solve the <fr:strong>Schrodinger equation</fr:strong>.
    <fr:tex display="block">         i\hbar \frac {\partial }{\partial  t}\Psi (x,t) = -\frac {\hbar ^2}{2m}\frac {\partial ^2\Psi (x,t)}{\partial  x^2} + V(x,t)\Psi (x,t)     </fr:tex></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>771</fr:anchor><fr:addr type="user">def-0030</fr:addr><fr:route>def-0030.xml</fr:route><fr:title text="Schrodinger&apos;s equation">Schrodinger&apos;s equation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>Schrodinger equation</fr:strong> is a linear partial differential equation that describes the wave function of a quantum system.
    It is given by (the general form):
    <fr:tex display="block">         i\hbar \frac {\partial }{\partial  t}\Psi (\vec {r},t) = \hat {H}\Psi (\vec {r},t)     </fr:tex>
    where:
    <fr:ul><fr:li><fr:tex display="inline">\Psi (\vec {r},t)</fr:tex> is the wave function of the quantum system.</fr:li>
        <fr:li><fr:tex display="inline">\hat {H}</fr:tex> is the <fr:strong>Hamiltonian operator</fr:strong>.</fr:li>
        <fr:li><fr:tex display="inline">\hbar  = 1.054573\times 10^{-34}\text {Js} </fr:tex> is the reduced <fr:strong>Planck constant</fr:strong>.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The role of Schrodinger equation is similar to the role of Newton&apos;s second law in classic mechanics.
    Given proper initial conditions,
    we can determine <fr:tex display="inline">\Psi (x, t)</fr:tex> for all the future time.</fr:p><fr:p>The wave function is quite odd, what information does it carry?
    The wave function is <fr:em>spread out</fr:em> in space.
    How can this be related to the <fr:strong>state</fr:strong> of a particle.</fr:p><fr:p><fr:strong>Born&apos;s statistical interpretation</fr:strong> of the wave function provides an answer.
    For a fixed time <fr:tex display="inline">t</fr:tex>, the probability of finding the particle in the interval <fr:tex display="inline">[a, b]</fr:tex> is given by:
    <fr:tex display="block">         P(a, b) = \int _a^b |{\Psi (x, t)}|^2 dx     </fr:tex></fr:p><fr:p>Here is where the quantum mechanics differs from classic mechanics and behaves weirdly.
    The wave function is not a deterministic function, but a <fr:em>statistical</fr:em> function, which 
    is an <fr:strong>indeterministic</fr:strong> interpretation.</fr:p><fr:p>Suppose I do <fr:strong>measure</fr:strong> the position of the particle,
    and find it at <fr:tex display="inline">\vec {r}_0</fr:tex>.
    Then where it was before the measurement?
    There are many interpretations of this question,
    and I will explain three of them.</fr:p><fr:p><fr:ul><fr:li><fr:strong>Realist interpretation</fr:strong>: The particle has a definite position before the measurement, just at <fr:tex display="inline">\vec {r}_0</fr:tex> but we just don&apos;t know it.</fr:li>
        <fr:li><fr:strong>Orthodox interpretation</fr:strong>: The particle doesn&apos;t have a <fr:em>definite</fr:em> position before the measurement, it is in a <fr:strong>superposition</fr:strong> of all possible positions.
        This is also called the <fr:strong>Copenhagen interpretation</fr:strong>.</fr:li>
        <fr:li><fr:strong>Agnostic interpretation</fr:strong>: The question is meaningless, refuse to answer.</fr:li></fr:ul></fr:p><fr:p>Nowadays, the Copenhagen interpretation is the most widely accepted interpretation.
    The particle does not have a definite position before the measurement.
    The operation of measurement <fr:strong>collapses</fr:strong> the wave function to a definite position.</fr:p><fr:p>Probability is the key concept in quantum mechanics.
    Now I will introduce some terimnologies related to continuous probability.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>772</fr:anchor><fr:addr type="user">def-0031</fr:addr><fr:route>def-0031.xml</fr:route><fr:title text="Probability Density">Probability Density</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>probability density</fr:strong> is a function <fr:tex display="inline">p(x)</fr:tex> such that:
    <fr:ul><fr:li><fr:tex display="inline">p(x)\geq  0</fr:tex> for all <fr:tex display="inline">x</fr:tex>.</fr:li>
        <fr:li><fr:tex display="inline">\int _{-\infty }^{\infty } p(x)dx = 1</fr:tex>.</fr:li></fr:ul>
    With this we can define the <fr:strong>probability function</fr:strong> in an interval <fr:tex display="inline">[a,b]</fr:tex> as:
    <fr:tex display="block">         P(a, b) = \int _a^b p(x)dx     </fr:tex></fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>773</fr:anchor><fr:addr type="machine">#317</fr:addr><fr:route>unstable-317.xml</fr:route><fr:title text="Expectation Value">Expectation Value</fr:title><fr:authors></fr:authors><fr:parent>def-0031</fr:parent></fr:frontmatter><fr:mainmatter>
    The <fr:strong>expectation value</fr:strong> of a function <fr:tex display="inline">f(x)</fr:tex> with respect to the probability density <fr:tex display="inline">p(x)</fr:tex> is defined:
    <fr:tex display="block">         \langle  f(x) \rangle  = \int _{-\infty }^{\infty } f(x)p(x)dx     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>774</fr:anchor><fr:addr type="machine">#318</fr:addr><fr:route>unstable-318.xml</fr:route><fr:title text="Variance">Variance</fr:title><fr:authors></fr:authors><fr:parent>def-0031</fr:parent></fr:frontmatter><fr:mainmatter>
    The <fr:strong>variance</fr:strong> of a function <fr:tex display="inline">f(x)</fr:tex> with respect to the probability density <fr:tex display="inline">p(x)</fr:tex> is defined:
    <fr:tex display="block">         \sigma ^2 :\equiv  \langle  x^2 \rangle  - \langle  x \rangle ^2     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now go back to quantum mechanics.
    We have seen that the squared wave function <fr:tex display="inline">|\Psi (x,t)|^2</fr:tex> is a probability density.
    So it satisfies
    <fr:tex display="block">         \int _{-\infty }^{\infty } |\Psi (x,t)|^2 dx = 1     </fr:tex></fr:p><fr:p>Solve the equations we will get a set of solutions.
    We should pick a proper factor to make the wave function <fr:strong>normalized</fr:strong>.
    But if I have normalized the wave function at time <fr:tex display="inline">t_0</fr:tex>,
    will it stay normalized at all future time?
    Fortunately the Schrodinger equation guarantees the normalization of 
    the wave function.</fr:p>
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>775</fr:anchor><fr:addr type="machine">#297</fr:addr><fr:route>unstable-297.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>phy-0002</fr:parent></fr:frontmatter><fr:mainmatter>
        Differentiate the normalization condition with respect to time:
        <fr:tex display="block">             \frac {d}{dt}\int _{-\infty }^{\infty } |\Psi (x,t)|^2 dx =              \int _{-\infty }^{\infty } \frac {\partial }{\partial  t}|\Psi (x,t)|^2 dx         </fr:tex>
        With the product rule:
        <fr:tex display="block">             \frac {\partial }{\partial  t}|\Psi (x,t)|^2 =              \frac {\partial }{\partial  t}\Psi (x,t)\Psi ^*(x,t) + \Psi (x,t)\frac {\partial }{\partial  t}\Psi ^*(x,t)         </fr:tex>
        where <fr:tex display="inline">\Psi ^*(x,t)</fr:tex> is the <fr:strong>complex conjugate</fr:strong> of <fr:tex display="inline">\Psi (x,t)</fr:tex>.
        The Schrodinger equation gives
        <fr:tex display="block">             \frac {\partial \Psi }{\partial  t} = \frac {i\hbar }{2m}\frac {\partial ^2\Psi }{\partial  x^2} + \frac {iV}{\hbar }\Psi          </fr:tex>
        and also the complex conjugate
        <fr:tex display="block">             \frac {\partial \Psi ^*}{\partial  t} = -\frac {i\hbar }{2m}\frac {\partial ^2\Psi ^*}{\partial  x^2} + \frac {iV}{\hbar }\Psi ^*         </fr:tex>
        so
        <fr:tex display="block">             \begin {align*}                 \frac {\partial }{\partial  t}|\Psi (x,t)|^2 &amp;=                  \frac {i\hbar }{2m}\left ( \frac {\partial ^2\Psi }{\partial  x^2}\Psi ^* - \frac {\partial ^2\Psi ^*}{\partial  x^2}\Psi  \right )\\                 &amp;= \frac {i\hbar }{2m}\frac {\partial }{\partial  x}\left ( \frac {\partial \Psi }{\partial  x}\Psi ^* - \frac {\partial \Psi ^*}{\partial  x}\Psi  \right )             \end {align*}         </fr:tex>
        Now the integral becomes:
        <fr:tex display="block">             \frac {d}{dt}\int _{-\infty }^{\infty } |\Psi (x,t)|^2 dx =              \frac {i\hbar }{2m}\left ( \Psi \frac {\partial \Psi ^*}{\partial  x} - \Psi ^*\frac {\partial \Psi }{\partial  x} \right )\Big |_{-\infty }^{\infty }         </fr:tex>
        Because the <fr:strong>normalization condition</fr:strong>
        <fr:tex display="block">             \int _{-\infty }^{\infty } |\Psi (x,t)|^2 dx = 1         </fr:tex>
        implies that the wave function vanishes at infinity,
        that is, converges to zero at infinity. Hence we have
        <fr:tex display="block">             \lim _{|x|\to \infty }|\Psi (x,t)| = 0         </fr:tex>
        this indicates that the integral is zero.
        <fr:tex display="block">             \frac {d}{dt}\int _{-\infty }^{\infty } |\Psi (x,t)|^2 dx = 0         </fr:tex>
        Now we can conclude that the wave function stays normalized at all future time.
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 
<fr:p>For a particle in state <fr:tex display="inline">\Psi </fr:tex>, we have defined its <fr:strong>expectation value</fr:strong>:
    <fr:tex display="block">         \langle  x \rangle  = \int _{-\infty }^{\infty } x|\Psi (x,t)|^2 dx     </fr:tex>
    Can we give a meaning to it? Is it the <fr:strong>average</fr:strong> position of the particle? 
    No, the first measurement of the position of the particle will give a definite position,
    and the subsequent measurements will give the same result.</fr:p><fr:p>Actually, the expectation value is the <fr:em>average</fr:em> of 
    repeated measurements on an ensemble of identical prepared systems,
    not the average of repeated measurements on a <fr:em>single</fr:em> system.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>776</fr:anchor><fr:addr type="machine">#298</fr:addr><fr:route>unstable-298.xml</fr:route><fr:title text="Construction."><fr:strong>Construction.</fr:strong></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>phy-0002</fr:parent></fr:frontmatter><fr:mainmatter>
    As times goes on, the expectation values varies.
    We naturally ask how fast it moves?
    Use simple calculus we can get the answer.
    <fr:tex display="block">         \begin {align*}             \frac {d}{dt}\langle  x \rangle  &amp;= \int _{-\infty }^{\infty } x\frac {\partial }{\partial  t}|\Psi (x,t)|^2 dx \\             &amp;= \frac {i\hbar }{2m}\int _{-\infty }^{\infty } x\frac {\partial }{\partial  x} (\frac {\partial \Psi }{\partial  x}\Psi ^* + \Psi \frac {\partial \Psi ^*}{\partial  x}) dx         \end {align*}     </fr:tex>
    Simplify using integration by parts, we get
    <fr:tex display="block">         \frac {d}{dt}\langle  x \rangle  = -\frac {i\hbar }{2m}\int _{-\infty }^{\infty } \left ( \Psi ^*\frac {\partial \Psi }{\partial  x} - \Psi \frac {\partial \Psi ^*}{\partial  x} \right ) dx     </fr:tex>
    Note that the boundary term was eliminated because the wave function vanishes at infinity.
    Perform integration by parts again on the second term
    <fr:tex display="block">         \langle  v \rangle  :\equiv \frac {d}{dt}\langle  x \rangle  = -\frac {i\hbar }{m}\int _{-\infty }^{\infty } \Psi ^*\frac {\partial \Psi }{\partial  x} dx     </fr:tex>
    Note that we give a name to the integral, <fr:tex display="inline">v</fr:tex>, indicating the <fr:strong>velocity</fr:strong> of the expectation value.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:p>To work with <fr:strong>momentum</fr:strong>, we can define:
    <fr:tex display="block">         \langle  p \rangle  = m \langle  v \rangle  = -i\hbar \int _{-\infty }^{\infty } \Psi ^*\frac {\partial \Psi }{\partial  x} dx     </fr:tex>
    Rewrite as an <fr:strong>operator</fr:strong> form:
    <fr:tex display="block">         \langle  p \rangle  = \int _{-\infty }^{\infty } \Psi ^*\left ( \frac {\hbar }{i}\frac {\partial }{\partial  x} \right )\Psi  dx     </fr:tex>
    Compare with 
    <fr:tex display="block">         \langle  x \rangle  = \int _{-\infty }^{\infty } \Psi ^*(x)\Psi  dx     </fr:tex></fr:p><fr:p>That&apos;s interesting, an operator that acts on the wave function and gives position and momentum.
    We can generalize this to any function of position and momentum.
    Just simply do substitution:
    <fr:tex display="block">         \langle  Q(x,p) \rangle  =          \int _{-\infty }^{\infty } \Psi ^*(x)Q\left ( x, -i\hbar \frac {\partial }{\partial  x} \right )\Psi  dx     </fr:tex>
    Momentum and position are just special cases of this general formula.
    We will give a firmer theoretical foundation to this equation later.
    Now we just use it as an <fr:em>axiom</fr:em>.</fr:p><fr:p>Now we discuss about the <fr:strong>uncertainty principle</fr:strong>.
    The more precise a wave&apos;s position is, the less precise its momentum (or the wavelength) is, and vice versa.
    A theorem in Fourier Analysis gives a precise statement of this principle (explain later).
    For this moment we only concerned with the qualitative argument.</fr:p><fr:p>The wavelength of a wave function <fr:tex display="inline">\Psi </fr:tex> is related to the momentum of the particle.
    This result from the <fr:strong>de Broglie formula</fr:strong>.
    <fr:tex display="block">         p = \frac {h}{\lambda } = \frac {2\pi \hbar }{\lambda }     </fr:tex>
    Now we can give a qualitative argument for the uncertainty principle.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>777</fr:anchor><fr:addr type="user">def-0033</fr:addr><fr:route>def-0033.xml</fr:route><fr:title text="Heisenberg Uncertainty Principle">Heisenberg Uncertainty Principle</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>Heisenberg Uncertainty Principle</fr:strong> states that
    it is impossible to measure simultaneously the position and the momentum of a particle
    with arbitrary precision.
    The product of the uncertainties in position and momentum is bounded by:
    <fr:tex display="block">         \Delta  x \Delta  p \geq  \frac {\hbar }{2}     </fr:tex>
    where <fr:tex display="inline">\Delta  x</fr:tex> and <fr:tex display="inline">\Delta  p</fr:tex> are the uncertainties in position and momentum, respectively.
    The constant <fr:tex display="inline">\hbar </fr:tex> is the reduced Planck constant.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>778</fr:anchor><fr:addr type="user">phy-0003</fr:addr><fr:route>phy-0003.xml</fr:route><fr:title text="Time-independent Schrodinger Equation">Time-independent Schrodinger Equation</fr:title><fr:taxon>Quantum Mechanics</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Refer to chapter 2 in <fr:link type="local" href="quantum-2018.xml" addr="quantum-2018" title="Introduction to Quantum Mechanics">Introduction to Quantum Mechanics</fr:link></fr:p><fr:p>In previous section we use the <fr:link type="local" href="def-0030.xml" addr="def-0030" title="Schrodinger&apos;s equation">Schrodinger equation</fr:link> to compute things.
    The variable <fr:tex display="inline">t</fr:tex> is annoying which makes things complicated, and we would like to get rid of it.
    In this section we shall assume that the potential energy <fr:tex display="inline">V</fr:tex> is independent of time.
    In that case the Schrodinger equation becomes:
    <fr:tex display="block">         i\hbar \frac {\partial }{\partial  t}\psi (x,t) = -\frac {\hbar ^2}{2m}\frac {\partial ^2\psi (x,t)}{\partial  x^2} + V(x)\psi (x,t)     </fr:tex>
    This equation can be solved by <fr:strong>separation of variables</fr:strong>.
    We assume the spatial and time dependencies of the solution can be separated.
    In other words we look for solutions of the <fr:em>product form</fr:em>:
    <fr:tex display="block">         \Psi (x,t) = \psi (x)\phi (t)     </fr:tex>
    This is an absurd restriction, but it works and we can get interesting results.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>779</fr:anchor><fr:addr type="machine">#295</fr:addr><fr:route>unstable-295.xml</fr:route><fr:title text="Solve the equation"><fr:strong>Solve the equation</fr:strong></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors></fr:authors><fr:parent>phy-0003</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>Now substitute the product form into the Schrodinger equation:
        <fr:tex display="block">             i\hbar  \psi (x) \frac {\partial }{\partial  t}(\phi (t)) = -\frac {\hbar ^2}{2m}\phi (t)\frac {\partial ^2(\psi (x))}{\partial  x^2} + V(x)\psi (x)\phi (t)         </fr:tex>
        Divide both sides by <fr:tex display="inline">\psi (x)\phi (t)</fr:tex>:
        <fr:tex display="block">             i\hbar  \frac {1}{\phi (t)} \frac {\partial }{\partial  t}(\phi (t)) = -\frac {\hbar ^2}{2m\psi (x)}\frac {\partial ^2(\psi (x))}{\partial  x^2} + V(x)         </fr:tex>
        Notice that the left side depends only on <fr:tex display="inline">t</fr:tex> and the right side depends only on <fr:tex display="inline">x</fr:tex>.
        They are equal if and only if they are both equal to a <fr:em>constant</fr:em>.
        Otherwise if I change the left side and level the right side unchanged, I get a contradiction.
        The constant is the energy of the system, and we denote it by <fr:tex display="inline">E</fr:tex>.
        <fr:tex display="block">             E:\equiv  i\hbar  \frac {1}{\phi (t)} \frac {\partial }{\partial  t}(\phi (t))          </fr:tex>
        and 
        <fr:tex display="block">             E:\equiv  -\frac {\hbar ^2}{2m\psi (x)}\frac {\partial ^2(\psi (x))}{\partial  x^2} + V(x)         </fr:tex>
        We have two equations:
        <fr:tex display="block">             \begin {align*}                 \frac {d\phi }{dt} &amp;= -\frac {iE}{\hbar }\phi \\                 -\frac {\hbar ^2}{2m}\frac {d^2\psi }{dx^2} + V\psi  &amp;= E\psi              \end {align*}         </fr:tex>
        Now the partial differential equation has been reduced to two <fr:strong>ordinary differential equations</fr:strong>.
        The first one is easy to solve:
        <fr:tex display="block">             \phi (t) = \phi (0)e^{-iEt/\hbar }         </fr:tex>
        Thus the complete solution is (note that the constant <fr:tex display="inline">\phi (0)</fr:tex> was absorbed into <fr:tex display="inline">\psi (x)</fr:tex>):
        <fr:tex display="block">             \Psi (x,t) = \psi (x)e^{-iEt/\hbar }         </fr:tex>
        The second one is the <fr:strong>time-independent Schrodinger equation</fr:strong>,
        we can&apos;t go further unless we know the potential energy <fr:tex display="inline">V(x)</fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:p>Now we give a name to the time-independent Schrodinger equation.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>780</fr:anchor><fr:addr type="user">def-0034</fr:addr><fr:route>def-0034.xml</fr:route><fr:title text="Stationary State">Stationary State</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>stationary state</fr:strong> is a quantum state with all observables independent of time.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Thought the wave function is time-dependent,
    <fr:tex display="block">         \Psi (x,t) = \psi (x)e^{-iEt/\hbar }     </fr:tex>
    But if we compute the probability density, it is time-independent:
    <fr:tex display="block">         |\Psi (x,t)|^2 = \psi ^*(x)e^{+iEt/\hbar }\psi (x)e^{-iEt/\hbar } = |\psi (x)|^2      </fr:tex>
    Hence the expectation value is constant in time. 
    Then <fr:tex display="inline">\langle  p \rangle  = 0</fr:tex> all the time.
    Nothing happens in the stationary state.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>781</fr:anchor><fr:addr type="machine">#296</fr:addr><fr:route>unstable-296.xml</fr:route><fr:title text="
    Conservation of energy
">
    <fr:strong>Conservation of energy</fr:strong>
</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors></fr:authors><fr:parent>phy-0003</fr:parent></fr:frontmatter><fr:mainmatter>
    This also means that the energy of the system is conserved.
    In classical mechanics, the <fr:strong>total energy</fr:strong> (kinetic + potential) of a system is called the <fr:strong>Hamiltonian</fr:strong>.
    <fr:tex display="block">         H(x,p) = \frac {p^2}{2m} + V(x)     </fr:tex>
    In quantum mechanics, the Hamiltonian is an operator,
    obtained by substituting <fr:tex display="inline">p\to  -i\hbar \frac {\partial }{\partial  x}</fr:tex>:
    <fr:tex display="block">         \hat {H} = -\frac {\hbar ^2}{2m}\frac {\partial ^2}{\partial  x^2} + V(x)     </fr:tex>
    Thus the time-independent Schrodinger equation can be written as:
    <fr:tex display="block">         \hat {H}\psi (x) = E\psi (x)     </fr:tex>
    The expectation value of the total energy gives the energy of the system:
    <fr:tex display="block">         \begin {align*}             \langle  H \rangle  &amp;= \int  \psi ^*(x)\hat {H}\psi (x)dx              \\             &amp;= \int  \psi ^*(x)E\psi (x)dx             \\             &amp;= E\int  |\psi (x)|^2dx             \\             &amp;= E\int  |\Psi (x)|^2dx             \\             &amp;= E                    \end {align*}     </fr:tex>
    and
    <fr:tex display="block">         \begin {align*}             \langle  H^2 \rangle  &amp;=              \int  \psi ^*(x)\hat {H}^2\psi (x)dx             \\             &amp;= E^2\int  |\psi (x)|^2 dx                   \\             &amp;= E^2               \end {align*}     </fr:tex>
    where 
    <fr:tex display="block">         \hat {H}^2\psi  = \hat {H}(\hat {H}\psi ) = \hat {H}(E\psi ) = E(\hat {H}\psi ) = E^2\psi      </fr:tex>
    Hence the variance of the energy is zero given by
    <fr:tex display="block">         \Delta  H = \sqrt {\langle  H^2 \rangle  - \langle  H \rangle ^2} = 0     </fr:tex>
    This implies that the energy of the system is conserved.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>782</fr:anchor><fr:addr type="user">phy-0001</fr:addr><fr:route>phy-0001.xml</fr:route><fr:title text="Special Relativity and Extra Dimensions">Special Relativity and Extra Dimensions</fr:title><fr:taxon>String Theory</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author>CAIMEO</fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is a summary of the first chapter of <fr:link type="local" href="string-theory-2009.xml" addr="string-theory-2009" title="A First Course in String Theory">A First Course in String Theory</fr:link> by Barton Zwiebach.
    I will make it as understandable as possible.</fr:p><fr:p>Speical relativity is based on the exprimental fact that the speed of light is the same for all inertial observers.
    In comparing the coordinates of events, two inertial observers (<fr:strong>Lorentz observers</fr:strong>) find that the
    appropriate coordinate transformations mix space and time.</fr:p><fr:p>In special relativity events are characterized by their coordinates in space <fr:tex display="inline">(x,y,z)</fr:tex> and time (<fr:tex display="inline">t</fr:tex>).
    It&apos;s convenient to combine these into a four-vector where the <fr:tex display="inline">t</fr:tex> coordinate is multiplied by <fr:tex display="inline">c</fr:tex> (<fr:strong>Speed of light</fr:strong>): so 
    that all four coordinates have the same units (length).
    <fr:tex display="block">x^\mu  = (x^0,x^1,x^2,x^3) = (ct,x,y,z)</fr:tex>
    The superscript <fr:tex display="inline">\mu </fr:tex> is called a <fr:strong>Lorentz index</fr:strong> and runs from 0 to 3.</fr:p><fr:p>Consider a Lorentz frame <fr:tex display="inline">S</fr:tex> where two events are represented by the coordinates 
    <fr:tex display="inline">x^\mu </fr:tex> and <fr:tex display="inline">x^\mu  + \Delta  x^\mu </fr:tex>.
    Let <fr:tex display="inline">S&apos;</fr:tex> be another Lorentz frame where the same two events are represented by the coordinates
    <fr:tex display="inline">x&apos;^\mu </fr:tex> and <fr:tex display="inline">x&apos;^\mu  + \Delta  x&apos;^\mu </fr:tex>.
    The value of <fr:tex display="inline">x&apos;^\mu </fr:tex> is different from <fr:tex display="inline">x^\mu </fr:tex> and so as <fr:tex display="inline">\Delta  x&apos;^\mu </fr:tex> from <fr:tex display="inline">\Delta  x^\mu </fr:tex>.
    However there is an invariant <fr:strong>interval</fr:strong> <fr:tex display="inline">\Delta  s^2</fr:tex> defined by
    <fr:tex display="block">         -\Delta  s^2 = -(\Delta  x^0)^2 + (\Delta  x^1)^2 + (\Delta  x^2)^2 + (\Delta  x^3)^2     </fr:tex>
    The minus sign in front of <fr:tex display="inline">(x^0)^2</fr:tex> encodes the fundamental difference between space and time coordinates.</fr:p><fr:p>The invariant interval implies the following equation:
    <fr:tex display="block">         \Delta  s ^2 = \Delta  s&apos;^2     </fr:tex>
    The minus sign on the left of <fr:tex display="inline">\Delta  s^2</fr:tex> implies that <fr:tex display="inline">\Delta  s^2 &gt;0</fr:tex> for events that are <fr:strong>timelike separated</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>784</fr:anchor><fr:addr type="user">def-001H</fr:addr><fr:route>def-001H.xml</fr:route><fr:title text="Timelike Separated Events">Timelike Separated Events</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An event <fr:tex display="inline">S</fr:tex> is said to be timelike separated if
    <fr:tex display="block">         (\Delta  x^0)^2 &gt; (\Delta  x^1)^2 + (\Delta  x^2)^2 + (\Delta  x^3)^2     </fr:tex>
    or briefly <fr:tex display="inline">\Delta  s^2 &gt; 0</fr:tex>. The spatial separation is less than the distance light travels.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The history of a particle is represented in spacetime as a curve called a <fr:strong>world-line</fr:strong>.
    Any two events on the world-line are timelike separated, because no particle can 
    move faster than light.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>785</fr:anchor><fr:addr type="user">def-001I</fr:addr><fr:route>def-001I.xml</fr:route><fr:title text="Lightlike Separated Events">Lightlike Separated Events</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Events connected by the world-line of a <fr:strong>photon</fr:strong> are said to be <fr:strong>lightlike separated</fr:strong>.
    For which <fr:tex display="inline">\Delta  s^2 = 0</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>786</fr:anchor><fr:addr type="user">def-001J</fr:addr><fr:route>def-001J.xml</fr:route><fr:title text="Spacelike Separated Events">Spacelike Separated Events</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Two events for which <fr:tex display="inline">\Delta  s^2 &lt; 0</fr:tex> are said to be <fr:strong>spacelike separated</fr:strong>.
    Events that are simultaneous in a Lorentz frame but in different position are spacelike separated.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>For timelike event we can define
    <fr:tex display="block">         \Delta  s \equiv  \sqrt {\Delta  s^2}     </fr:tex></fr:p><fr:p>It is useful to consider events that are <fr:em>infinitesimally close</fr:em> to each other.
    Small coordinate difference are needed to define velocity.
    Infinitesimal coordinate differences are written as <fr:tex display="inline">dx^\mu </fr:tex>.
    <fr:tex display="block">         -ds^2 = -(dx^0)^2 + (dx^1)^2 + (dx^2)^2 + (dx^3)^2     </fr:tex>
    The equality of intervals is the statement
    <fr:tex display="block">         ds^2 = ds&apos;^2     </fr:tex>
    Let&apos;s define a better notation:
    <fr:tex display="block">         dx_0 \equiv  -dx^0,         dx_1 \equiv  dx^1,         dx_2 \equiv  dx^2,         dx_3 \equiv  dx^3              </fr:tex>
    Notice that the inclusion of the minus sign in the definition of <fr:tex display="inline">dx_0</fr:tex> is a matter of convention.
    <fr:tex display="block">         dx_\mu  = (dx_0,dx_1,dx_2,dx_3)     </fr:tex>
    Now rewrite <fr:tex display="inline">ds^2</fr:tex> in terms of <fr:tex display="inline">dx_\mu </fr:tex> and <fr:tex display="inline">dx^\mu </fr:tex>:
    <fr:tex display="block">         -ds^2 = dx_0dx^0 + dx_1dx^1 + dx_2dx^2 + dx_3dx^3 = \sum _{\mu =0}^3 dx_\mu  dx^\mu      </fr:tex>
    Using <fr:link type="local" href="def-001K.xml" addr="def-001K" title="Einstein&apos;s Summation Convention">Einstein&apos;s Summation Convention</fr:link> we can rewrite
    <fr:tex display="block">         ds^2 = dx_\mu  dx^\mu      </fr:tex>
    And for Infinitesimal timelike intervals we can define
    <fr:tex display="block">         ds \equiv  \sqrt {ds^2}      </fr:tex>
    We can also express the interval <fr:tex display="inline">ds^2</fr:tex> using the <fr:strong>Minkowski Metric</fr:strong>:
    <fr:tex display="block">         -ds^2= \eta _{\mu \nu } dx^\mu  dx^\nu      </fr:tex>
    and the metric is defined by</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>787</fr:anchor><fr:addr type="user">def-001L</fr:addr><fr:route>def-001L.xml</fr:route><fr:title text="Minkowski Metric">Minkowski Metric</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>Minkowski Metric</fr:strong>, aka <fr:strong>Minkowski Tensor</fr:strong>, is a tensor <fr:tex display="inline">\eta _{\mu \nu }</fr:tex> whose elements are defined by the matrix
    <fr:tex display="block">         \eta _{\mu \nu } = \begin {pmatrix}             -1 &amp; 0 &amp; 0 &amp; 0 \\             0 &amp; 1 &amp; 0 &amp; 0 \\             0 &amp; 0 &amp; 1 &amp; 0 \\             0 &amp; 0 &amp; 0 &amp; 1          \end {pmatrix}     </fr:tex>
    where <fr:tex display="inline">\mu </fr:tex> and <fr:tex display="inline">\nu </fr:tex> are Lorentz indices run over <fr:tex display="inline">0,1,2,3</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>How can we derive the Minkowski Metric? First we require <fr:tex display="inline">\eta _{\mu \nu }</fr:tex> to be a symmetric matrix,
    because any antisymmetric part would not contribute to the interval.
    <fr:tex display="block">         \eta _{\mu \nu } = \eta _{\nu \mu }     </fr:tex>
    And for any two-indexed object <fr:tex display="inline">M_{\mu \nu }</fr:tex> can be decomposed into symmetric and antisymmetric parts:
    <fr:tex display="block">         M_{\mu \nu } = \frac {1}{2}(M_{\mu \nu } + M_{\nu \mu }) + \frac {1}{2}(M_{\mu \nu } - M_{\nu \mu })     </fr:tex>
    With the antisymmetric part (denoted <fr:tex display="inline">\delta </fr:tex>) which we can see
    <fr:tex display="block">         \delta _{\mu \nu }dx^\mu  dx^\nu  = (-\delta _{\nu \mu }) dx^\mu  dx^\nu  = -\delta _{\mu \nu }dx^\nu  dx^\mu  = -\delta _{\mu \nu }dx^\mu  dx^\nu      </fr:tex>
    Note that the second step relabeled the dummy indices <fr:tex display="inline">\mu </fr:tex> and <fr:tex display="inline">\nu </fr:tex>.
    The third step we swapped the order of the two terms. Hence the antisymmetric part is zero.</fr:p><fr:p>The equation <fr:tex display="inline">dx_\mu  = (dx_0,dx_1,dx_2,dx_3)</fr:tex> can be rewritten as
    <fr:tex display="block">         dx_\mu  = \eta _{\mu \nu } dx^\nu      </fr:tex>
    For more general case:
    <fr:tex display="block">         b_\mu  \equiv  \eta _{\mu \nu } b^\nu      </fr:tex>
    Given <fr:tex display="inline">a^\mu </fr:tex> and <fr:tex display="inline">b^\mu </fr:tex> we can define the dot scalar product as 
    <fr:tex display="block">         a \cdot  b \equiv  a^\mu  b_\mu  = a^\mu  \eta _{\mu \nu } b^\nu  = -a^0 b^0 + a^1 b^1 + a^2 b^2 + a^3 b^3     </fr:tex>
    Note that <fr:tex display="inline">a^\mu  b_\mu  = a_\mu  b^\mu </fr:tex> because <fr:tex display="inline">\eta _{\mu \nu }</fr:tex> is symmetric.</fr:p><fr:p>It&apos;s convenient to introduce the inverse matrix of <fr:tex display="inline">\eta _{\mu \nu }</fr:tex>:
    <fr:tex display="block">         \eta ^{\mu \nu } =          \begin {pmatrix}             -1 &amp; 0 &amp; 0 &amp; 0 \\             0 &amp; 1 &amp; 0 &amp; 0 \\             0 &amp; 0 &amp; 1 &amp; 0 \\             0 &amp; 0 &amp; 0 &amp; 1         \end {pmatrix}     </fr:tex>
    And the inverse property is
    <fr:tex display="block">         \eta ^{\mu \rho } \eta _{\rho \nu } = \delta ^\mu _\nu      </fr:tex>
    where <fr:tex display="inline">\delta ^\mu _\nu </fr:tex> is the <fr:link type="local" href="def-001P.xml" addr="def-001P" title="Kronecker Delta">Kronecker Delta</fr:link>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>788</fr:anchor><fr:addr type="user">thm-0004</fr:addr><fr:route>thm-0004.xml</fr:route><fr:title text="Raise Indices">Raise Indices</fr:title><fr:taxon>Trick</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:tex display="block">         \eta ^{\rho \mu }b_\mu          = \eta ^{\rho \mu } (\eta _{\mu \nu } b^\nu )         = \eta ^{\rho \mu } \eta _{\mu \nu } b^\nu          = \delta ^\rho _\nu  b^\nu          = b^\rho      </fr:tex>
    The lower index of <fr:tex display="inline">b_\mu </fr:tex> is raised to <fr:tex display="inline">b^\rho </fr:tex> by <fr:tex display="inline">\eta ^{\rho \mu }</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p><fr:strong>Lorentz transformations</fr:strong> are the relations between coordinates in two different
    inertial frames.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>789</fr:anchor><fr:addr type="user">def-001Q</fr:addr><fr:route>def-001Q.xml</fr:route><fr:title text="Lorentz Transformations">Lorentz Transformations</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Consider a frame <fr:tex display="inline">S</fr:tex> and <fr:tex display="inline">S&apos;</fr:tex> which is moving along the <fr:tex display="inline">+x</fr:tex> direction of the <fr:tex display="inline">S</fr:tex> frame
    with a velocity <fr:tex display="inline">v</fr:tex>.
    Assume that the origins of the two frames coincide at <fr:tex display="inline">t=t&apos;=0</fr:tex> and coordinate axes are parallel.

    We say that <fr:tex display="inline">S&apos;</fr:tex> is boosted along the <fr:tex display="inline">x</fr:tex> direction with velocity parameter <fr:tex display="inline">\beta \equiv \frac {v}{c}</fr:tex>.
    The <fr:strong>Lorentz transformations</fr:strong> are defined by a set of equations that relate the coordinates of an event in the two frames.
    <fr:tex display="block">         \begin {align*}             x&apos; &amp;= \gamma (x-\beta  ct) \\             y&apos; &amp;= y \\             z&apos; &amp;= z \\             ct&apos; &amp;= \gamma (ct-\beta  x)         \end {align*}     </fr:tex>
    where <fr:tex display="inline">\gamma \equiv \dfrac {1}{\sqrt {1-\beta ^2}} = \dfrac {1}{\sqrt {1-\frac {v^2}{c^2}}}</fr:tex> is the <fr:strong>Lorentz factor</fr:strong>.
    The coordinates orthogonal to the <fr:tex display="inline">x</fr:tex> direction remains unchanged.</fr:p><fr:p>Lorentz transformations are the linear transformations of coordinates that remains the <fr:tex display="inline">\Delta  s^2</fr:tex> unchanged. 
    We can write the Lorentz transformations in matrix form:
    <fr:tex display="block">         \begin {pmatrix}             ct&apos; \\             x&apos; \\             y&apos; \\             z&apos;          \end {pmatrix}         =         \begin {pmatrix}             \gamma  &amp; -\beta \gamma  &amp; 0 &amp; 0 \\             -\beta \gamma  &amp; \gamma  &amp; 0 &amp; 0 \\             0 &amp; 0 &amp; 1 &amp; 0 \\             0 &amp; 0 &amp; 0 &amp; 1          \end {pmatrix}         \begin {pmatrix}             ct \\             x \\             y \\             z          \end {pmatrix}     </fr:tex>
    Or in a more compact form:
    <fr:tex display="block">         x&apos;^\mu  = L^\mu _\nu  x^\nu      </fr:tex>
    where <fr:tex display="inline">L^\mu _\nu </fr:tex> is the <fr:strong>Lorentz transformation matrix</fr:strong> presented above.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We now introduce a coordinate system that will be extremely useful in string theory,
    the <fr:strong>light-cone coordinates</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>790</fr:anchor><fr:addr type="user">def-001R</fr:addr><fr:route>def-001R.xml</fr:route><fr:title text="Light-cone Coordinates">Light-cone Coordinates</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>light-cone coordinates</fr:strong> can be defined as
    two independent <fr:link type="local" href="def-000L.xml" addr="def-000L" title="Linear Combination">linear combinations</fr:link> of the time 
    and a chosen spatial coordinate (conventionally <fr:tex display="inline">x^1</fr:tex>):
    <fr:tex display="block">         \begin {align*}             x^+ \equiv  \frac {1}{\sqrt {2}} (X^0 + X^1) \\             x^- \equiv  \frac {1}{\sqrt {2}} (X^0 - X^1)         \end {align*}     </fr:tex>
    while other spatial coordinates remain unchanged. Thus the complete set of 
    light-cone coordinates is <fr:tex display="inline">(x^+,x^-,x^2,x^3)</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The name <fr:strong>light-cone coordinates</fr:strong> comes from the fact that the associated coordinates axes
    are the world-lines of beams of light emitted form the origin along the <fr:tex display="inline">x^1</fr:tex> axis.
    <fr:ul><fr:li>For a beam of light moving in the positive <fr:tex display="inline">x^1</fr:tex> direction,
            we have <fr:tex display="inline">x^1=ct=x^0</fr:tex> and thus <fr:tex display="inline">x^-=0</fr:tex>. By definition <fr:tex display="inline">x^-=0</fr:tex>
            is actually the <fr:tex display="inline">x^+</fr:tex> axis.</fr:li>
        <fr:li>For a beam of light moving in the negative <fr:tex display="inline">x^1</fr:tex> direction,
            we have <fr:tex display="inline">x^1=-ct=-x^0</fr:tex> and thus <fr:tex display="inline">x^+=0</fr:tex>. By definition <fr:tex display="inline">x^+=0</fr:tex>
            is actually the <fr:tex display="inline">x^-</fr:tex> axis.</fr:li></fr:ul>
    The <fr:tex display="inline">x^+</fr:tex> and <fr:tex display="inline">x^-</fr:tex> axes are perpendicular to each other and at <fr:tex display="inline">45^\circ </fr:tex> to the <fr:tex display="inline">x^0</fr:tex> and <fr:tex display="inline">x^1</fr:tex> axis.</fr:p><fr:p>Both <fr:tex display="inline">x^+</fr:tex> and <fr:tex display="inline">x^-</fr:tex> can be a time coordinate although neither is a time coordinate
    in the standard sense of the world (Not ordinary time).
    For definiteness we will take <fr:tex display="inline">x^+</fr:tex> as the light-cone time coordinate and <fr:tex display="inline">x^-</fr:tex> as the spatial coordinate.</fr:p><fr:p>Take differentials and multiply of the light-cone coordinates:
    <fr:tex display="block">         2dx^+ dx^- = (dx^0 + dx^1)(dx^0 - dx^1) = (dx^0)^2 - (dx^1)^2     </fr:tex>
    which follows the invariant interval
    <fr:tex display="block">         -ds^2 = -2dx^+ dx^- + (dx^2)^2 + (dx^3)^2     </fr:tex>
    As we did before, we can represent this with index notation:
    <fr:tex display="block">         -ds^2 = \hat {\eta }_{\mu \nu } dx^\mu  dx^\nu      </fr:tex>
    where the <fr:strong>light-cone metric</fr:strong> is
    <fr:tex display="block">         \hat {\eta }_{\mu \nu } =          \begin {pmatrix}             0 &amp; -1 &amp; 0 &amp; 0 \\             -1 &amp; 0 &amp; 0 &amp; 0 \\             0 &amp; 0 &amp; 1 &amp; 0 \\             0 &amp; 0 &amp; 0 &amp; 1         \end {pmatrix}     </fr:tex>
    This is easy to derive from the symmetric.</fr:p><fr:p>The light-cone coordinates looks unusual but if you see some
    calculations you will find the results very surprising.</fr:p><fr:p>Consider a particle moving in the <fr:tex display="inline">x^1</fr:tex> direction with velocity <fr:tex display="inline">v</fr:tex>.
    At the initial time the positions are all <fr:tex display="inline">0</fr:tex>.
    (The velocity parameter is denote <fr:tex display="inline">\beta </fr:tex>)
    <fr:tex display="block">         \begin {align*}             x^1 = vt = \beta  x^0             \\             x^2(t) = x^3(t) = 0         \end {align*}     </fr:tex>
    Now compute the light-cone coordinates:
    <fr:tex display="block">         \begin {align*}             x^+ = \frac {1}{\sqrt {2}}(x^0 + x^1) = \frac {1}{\sqrt {2}}(x^0 + \beta  x^0) = \frac {1+\beta }{\sqrt {2}}x^0             \\             x^- = \frac {1}{\sqrt {2}}(x^0 - x^1) = \frac {1}{\sqrt {2}}(x^0 - \beta  x^0) = \frac {1-\beta }{\sqrt {2}}x^0         \end {align*}     </fr:tex>
    And we identify the ratio 
    <fr:tex display="block">         \frac {dx^+}{dx^-} = \frac {1+\beta }{1-\beta }     </fr:tex>
    as the light-cone velocity of the particle. This looks strange:
    <fr:ul><fr:li>For <fr:tex display="inline">\beta =-1</fr:tex> the light-cone velocity is <fr:tex display="inline">\infty </fr:tex>.</fr:li>
        <fr:li>For a particle moving at the speed of light (<fr:tex display="inline">\beta =1</fr:tex>), the light-cone velocity is <fr:tex display="inline">0</fr:tex>.</fr:li>
        <fr:li>More interestingly, a static particle (<fr:tex display="inline">\beta =0</fr:tex>) is moving quite fast in the light-cone coordinates.</fr:li></fr:ul>
    Note that the light-cone coordinates can&apos;t be acquired by Lorentz transformation.</fr:p><fr:p>Just get the idea of the light-cone coordinates, now let&apos;s dive into the relativistic energy and momentum.
    In special relativity there is relationship between energy and momentum.
    <fr:tex display="block">         \frac {E^2}{c^2}-\vec {p}^2 = m^2c^2     </fr:tex>
    where <fr:tex display="inline">m</fr:tex> is the rest mass of the particle, and <fr:tex display="inline">c</fr:tex> is the speed of light.
    <fr:tex display="block">         E = \gamma  mc^2,         \quad           \vec {p} = \gamma  m\vec {v}     </fr:tex>
    The energy and momentum can be used to define a momentum four-vector
    <fr:tex display="block">         p^\mu  = (\frac {E}{c},p_x, p_y, p_z)     </fr:tex>
    or shortly
    <fr:tex display="block">         p^\mu  = (\frac {E}{c},\vec {p}) = m\gamma  (c, \vec {v})     </fr:tex>
    Using operator <fr:tex display="inline">\eta _{\mu \nu }</fr:tex> to lower the index:
    <fr:tex display="block">         p_\mu  = (p_0, p_1, p_2, p_3) = \eta _{\mu \nu } p^\nu  = (-\frac {E}{c},p_x, p_y, p_z)     </fr:tex>
    And make use of the relationship above.
    <fr:tex display="block">         p_\mu  p^\mu  = \eta _{\mu \nu } p^\mu  p^\nu  = -\frac {E^2}{c^2} + p_x^2 + p_y^2 + p_z^2 = -m^2c^2     </fr:tex>
    Using the relativistic scalar product notation:
    <fr:tex display="block">         p ^2 \equiv  p \cdot  p = p_\mu  p^\mu  = -m^2c^2     </fr:tex></fr:p><fr:p>A central concept in special relativity is <fr:strong>proper time</fr:strong>,
    which is a Lorentz invariant measure of time.
    Consider a world-line and two events <fr:tex display="inline">A</fr:tex> and <fr:tex display="inline">B</fr:tex> on the world-line.
    Different Lorentz observers will measure different time intervals between the two events.
    But imagine a clock that moves along the world-line.
    The time measured by the clock is called the <fr:strong>proper time</fr:strong> between the two events.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>791</fr:anchor><fr:addr type="user">def-001S</fr:addr><fr:route>def-001S.xml</fr:route><fr:title text="Proper Time">Proper Time</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>proper time</fr:strong> along a timelike world-line is defined as the
    time as measured by a clock following that line.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>By this definition, proper time is a invariant. Consider an invariant interval 
    for the motion of a particle along <fr:tex display="inline">x</fr:tex> axis:
    <fr:tex display="block">         -ds^2 = -c^2 dt^2 + dx^2 = -c^2 dt^2 (1 - \beta ^2)     </fr:tex>
    Now attach a Lorentz frame to the particle does not move
    and the time is recorded by the clock that is moving with the particle.
    Hence <fr:tex display="inline">dx=0</fr:tex> and <fr:tex display="inline">dt=dt_p</fr:tex> is the proper time.
    <fr:tex display="block">         -ds^2 = -c^2 dt_p^2      </fr:tex>
    Cancel the minus sign and the square root
    <fr:tex display="block">         dt_p = c dt_p     </fr:tex>
    This shows that for timelike intervals,
    the <fr:strong>proper time interval</fr:strong> is <fr:tex display="inline">\frac {ds}{c}</fr:tex>.
    Similarly, 
    <fr:tex display="block">         ds = cdt \sqrt {1-\beta ^2} \implies  \frac {dt}{ds} = \frac {\gamma }{c}     </fr:tex>
    The invariant <fr:tex display="inline">ds</fr:tex> can be used to construct nre Lorentz vectors.
    For instance, we can construct velocity four-vector:
    <fr:tex display="block">         u^\mu  = c \frac {dx^\mu }{ds} = c (\frac {d(ct)}{ds}, \frac {dx}{ds}, \frac {dy}{ds}, \frac {dz}{ds})     </fr:tex>
    This can be simplified by using the definition of proper time:
    <fr:tex display="block">         \frac {dx}{ds} = \frac {dx}{dt} \frac {dt}{ds} = \frac {v_x\gamma }{c}     </fr:tex>
    Hence we find
    <fr:tex display="block">         u^\mu  = (\gamma  c, \gamma  v_x, \gamma  v_y, \gamma  v_z) = \gamma  (c, \vec {v})     </fr:tex>
    We see that the momentum four-vector is just the velocity four-vector multiplied by the rest mass.
    <fr:tex display="block">         p^\mu  = m u^\mu      </fr:tex></fr:p><fr:p>The light-cone components <fr:tex display="inline">p^+</fr:tex> and <fr:tex display="inline">p^-</fr:tex> of the momentum Lorentz vector are obtained:
    <fr:tex display="block">         \begin {align*}             p^+ = \frac {1}{\sqrt {2}}(p^0+p^1) = -p_-             \\             p^- = \frac {1}{\sqrt {2}}(p^0-p^1) = -p_+         \end {align*}     </fr:tex>
    Note that light-cone coordinates do not transform as Lorentz ones do. 
    Both <fr:tex display="inline">p^\pm </fr:tex> are energy-like since both are positive for physical particles.
    <fr:tex display="block">         p^0 = \frac {E}{c} \sqrt {\vec {p}^2 + m^2c^2} &gt; |\vec {p}|\geq  |p^1|     </fr:tex>
    Hence <fr:tex display="inline">p^0\pm  p^1 &gt; 0</fr:tex> and <fr:tex display="inline">p^\pm &gt;0</fr:tex>, which both are possible candidates for energy.
    We finally choose <fr:tex display="inline">p^-</fr:tex> as the component, we explain this later.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1151</fr:anchor><fr:addr type="user">notes</fr:addr><fr:route>notes.xml</fr:route><fr:title text="Notes">Notes</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>401</fr:anchor><fr:addr type="user">tt-0001</fr:addr><fr:route>tt-0001.xml</fr:route><fr:title text="Untyped Lambda Calculus">Untyped Lambda Calculus</fr:title><fr:taxon>Type Theory</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Refer to <fr:link type="local" href="ttafp-2014.xml" addr="ttafp-2014" title="Type Theory and Formal Proofs">Type Theory and Formal Proof</fr:link>.</fr:p><fr:p>The idea to generalize the behavior of functions in mathematics and logic led to the development of the lambda calculus.
    The lambda calculus is a formal system for expressing computation based on function abstraction and application using <fr:em>variable binding</fr:em> and <fr:em>substitution</fr:em>. 
    In dealing with functions there are two <fr:strong>construction principles</fr:strong> and one <fr:strong>evalutaion rule</fr:strong>.
    <fr:ul><fr:li><fr:strong>Construction Principles</fr:strong>: note that expressions do not force to be meaningful.</fr:li>
        <fr:ul><fr:li>Function Abstraction: <fr:tex display="inline">\lambda  x.M</fr:tex></fr:li>
            <fr:li>Function Application: <fr:tex display="inline">M N</fr:tex>, this only produces a new expression,
            in which the function has not yet been executed.</fr:li></fr:ul>
    <fr:li><fr:strong>Evaluation Rule</fr:strong></fr:li>
        <fr:ul><fr:li>Beta Reduction: <fr:tex display="inline">(\lambda  x.M)N\to  M[x:=N]</fr:tex></fr:li></fr:ul></fr:ul>
    The beta reduction makes use of the <fr:strong>substitution</fr:strong> <fr:tex display="inline">M[x:=N]</fr:tex> which represents the result of replacing all free occurrences of <fr:tex display="inline">x</fr:tex> in <fr:tex display="inline">M</fr:tex> with <fr:tex display="inline">N</fr:tex>.
    Note that the application is <fr:strong>left associative</fr:strong>, that is, <fr:tex display="inline">MNP</fr:tex> means <fr:tex display="inline">(MN)P</fr:tex>.
    And application has the highest precedence, that is, <fr:tex display="inline">\lambda  x.MN</fr:tex> means <fr:tex display="inline">\lambda  x.(MN)</fr:tex>.</fr:p><fr:p>The multi-argument function <fr:tex display="inline">\lambda  x_1\ldots  x_n.M</fr:tex> is defined as <fr:tex display="inline">\lambda  x_1.(\lambda  x_2.(\ldots (\lambda  x_n.M)\ldots ))</fr:tex> (right associative),
    that is, simulated by a sequence of single-argument functions. The later function is called <fr:strong>curried function</fr:strong> and the
    process of transforming a multi-argument function into a sequence of single-argument functions is called <fr:strong>currying</fr:strong>.</fr:p>
    <fr:strong>Lambda Terms</fr:strong>
    <fr:p>Expressions in the lambda calculus is called <fr:strong>terms</fr:strong>. The set of terms is denoted <fr:tex display="inline">\Lambda </fr:tex>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>402</fr:anchor><fr:addr type="user">def-000F</fr:addr><fr:route>def-000F.xml</fr:route><fr:title text="Set of Lambda Terms">Set of Lambda Terms</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">\Lambda </fr:tex> be the set of lambda terms. Then <fr:tex display="inline">\Lambda </fr:tex> is defined inductively as follows:
(<fr:tex display="inline">V</fr:tex> is the set of variables)
<fr:ul><fr:li>Variable: <fr:tex display="inline">\forall  x\in  V, x\in  \Lambda </fr:tex></fr:li>
<fr:li>Abstraction: <fr:tex display="inline">\forall  x\in  V, M\in  \Lambda , \lambda  x.M\in  \Lambda </fr:tex></fr:li>
<fr:li>Application: <fr:tex display="inline">\forall  M,N\in  \Lambda , (MN)\in  \Lambda </fr:tex></fr:li></fr:ul></fr:p><fr:p>Another way to define <fr:tex display="inline">\Lambda </fr:tex> is to use the following grammar (The 3 possibilities are separated by <fr:code>|</fr:code>):
<fr:tex display="block">\Lambda  = V | \lambda  V.\Lambda  | \Lambda \Lambda </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:p>With the following recursive definition we can determine 
    what the <fr:strong>subterms</fr:strong> of a give <fr:tex display="inline">\lambda \text {-term}</fr:tex> are. Here we use 
    a concept named <fr:link type="local" href="def-0035.xml" addr="def-0035" title="Multiset">multiset</fr:link>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>403</fr:anchor><fr:addr type="user">def-0036</fr:addr><fr:route>def-0036.xml</fr:route><fr:title text="Multiset of Subterms">Multiset of Subterms</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We define a map <fr:tex display="inline">\text {Sub}</fr:tex>:
    <fr:ul><fr:li><fr:strong>Basis</fr:strong>: <fr:tex display="inline">\forall  x\in  V,\text {Sub}(x) =\{ x \}</fr:tex></fr:li>
        <fr:li><fr:strong>Application</fr:strong>: <fr:tex display="inline">\forall  M,N\in \Lambda ,\text {Sub}(MN) = \text {Sub}(M)\cup \text {Sub}(N)\cup \{ MN \}</fr:tex></fr:li>
        <fr:li><fr:strong>Abstraction</fr:strong>: <fr:tex display="inline">\forall  x\in  V,M\in \Lambda ,\text {Sub}(\lambda  x.M) = \text {Sub}(M)\cup \{ \lambda  x.M \}</fr:tex></fr:li></fr:ul>
    <fr:tex display="inline">L</fr:tex> is a subterm of <fr:tex display="inline">M</fr:tex> if <fr:tex display="inline">L\in \text {Sub}(M)</fr:tex>.
    If <fr:tex display="inline">L\not \equiv  M</fr:tex> then we say <fr:tex display="inline">L</fr:tex> is a <fr:strong>proper subterm</fr:strong> of <fr:tex display="inline">M</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The definition above uses a notation <fr:tex display="inline">\equiv </fr:tex> which means <fr:em>syntactic equality</fr:em> here.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>404</fr:anchor><fr:addr type="user">eg-0006</fr:addr><fr:route>eg-0006.xml</fr:route><fr:title text="Subterms">Subterms</fr:title><fr:taxon>Example</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:ul><fr:li><fr:tex display="inline">\text {Sub}((x\space z))</fr:tex> = <fr:tex display="inline">\{ x,z,(x\space z) \}</fr:tex></fr:li>
    <fr:li><fr:tex display="inline">             \text {Sub}(\lambda  x.(x\space x))              = \{ \lambda  x.(x\space x),(x\space x),x,x \}         </fr:tex></fr:li></fr:ul></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The substerm mapping satisfies the following lemma.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>405</fr:anchor><fr:addr type="user">thm-000W</fr:addr><fr:route>thm-000W.xml</fr:route><fr:title text="Lemma of subterms">Lemma of subterms</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:ul><fr:li><fr:strong>Reflexivity</fr:strong>: <fr:tex display="inline">\forall  M\in \Lambda ,M\in \text {Sub}(M)</fr:tex></fr:li>
        <fr:li><fr:strong>Transitivity</fr:strong>: <fr:tex display="inline">\forall  L,M,N\in \Lambda ,L\in \text {Sub}(M)\land  M\in \text {Sub}(N)\implies  L\in \text {Sub}(N)</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Variable occurrences in a <fr:tex display="inline">\lambda \text {-term}</fr:tex> can be divided into 3 categories:
    <fr:ul><fr:li>Bound Occurrences: <fr:tex display="inline">x</fr:tex> is bound in <fr:tex display="inline">M</fr:tex> if <fr:tex display="inline">x</fr:tex> is the argument of an <fr:strong>abstraction</fr:strong> in <fr:tex display="inline">M</fr:tex>.</fr:li>
        <fr:li>Free Occurrences: <fr:tex display="inline">x</fr:tex> is free in <fr:tex display="inline">M</fr:tex> if <fr:tex display="inline">x</fr:tex> is not bound by any <fr:strong>abstraction</fr:strong> in <fr:tex display="inline">M</fr:tex>.</fr:li>
        <fr:li>Binding Occurrences: something after a lambda notation <fr:tex display="inline">\lambda </fr:tex></fr:li></fr:ul>
    We mainly focus on the <fr:strong>free variables</fr:strong> of a term.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>406</fr:anchor><fr:addr type="user">def-0037</fr:addr><fr:route>def-0037.xml</fr:route><fr:title text="Set of Free Variables">Set of Free Variables</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">FV(L)</fr:tex> be the set of free variables in a term <fr:tex display="inline">L</fr:tex>.
    <fr:ul><fr:li><fr:strong>Variable</fr:strong>: <fr:tex display="inline">\forall  x\in  V,\text {FV}(x) = \{ x \}</fr:tex></fr:li>
        <fr:li><fr:strong>Application</fr:strong>: <fr:tex display="inline">\forall  M,N\in \Lambda ,\text {FV}(MN) = \text {FV}(M)\cup \text {FV}(N)</fr:tex></fr:li>
        <fr:li><fr:strong>Abstraction</fr:strong>: <fr:tex display="inline">\forall  x\in  V,M\in \Lambda ,\text {FV}(\lambda  x.M) = \text {FV}(M)\setminus \{ x \}</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>407</fr:anchor><fr:addr type="user">def-0038</fr:addr><fr:route>def-0038.xml</fr:route><fr:title text="Closed Lambda Terms">Closed Lambda Terms</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:tex display="inline">\lambda \text {-term}</fr:tex> <fr:tex display="inline">M</fr:tex> is <fr:strong>closed</fr:strong> if <fr:tex display="inline">\text {FV}(M) = \emptyset </fr:tex>.
    A closed <fr:tex display="inline">\lambda \text {-term}</fr:tex> is also called a <fr:strong>combinator</fr:strong>.
    The set of all combinators is denoted by <fr:tex display="inline">\Lambda ^0</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>408</fr:anchor><fr:addr type="machine">#274</fr:addr><fr:route>unstable-274.xml</fr:route><fr:title text="Alpha conversion">Alpha conversion</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors><fr:parent>tt-0001</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Functions in <fr:tex display="inline">\lambda \text {-calculus}</fr:tex> have the property that the name of 
    the binding variables is irrelevant.
    In order to describe this equality we need to define a relation
    called <fr:tex display="inline">\alpha \text {-conversion}</fr:tex> or <fr:tex display="inline">\alpha \text {-equivalence}</fr:tex>,
    which is based on the process of renaming binding variables.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>409</fr:anchor><fr:addr type="user">def-0039</fr:addr><fr:route>def-0039.xml</fr:route><fr:title text="Renaming">Renaming</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">M^{x\to y}</fr:tex> be the result of replacing all free occurrences of <fr:tex display="inline">x</fr:tex> in <fr:tex display="inline">M</fr:tex> with <fr:tex display="inline">y</fr:tex>.
    The relation <fr:strong>renaming</fr:strong> is expression with the symbol <fr:tex display="inline">=_\alpha </fr:tex>:
    <fr:tex display="inline">\lambda  x.M=_\alpha \lambda  y.M^{x\to y}</fr:tex> if <fr:tex display="inline">y\not \in \text {FV}(M)</fr:tex> and <fr:tex display="inline">y</fr:tex> is not a binding variable in <fr:tex display="inline">M</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The definition of <fr:strong>renaming</fr:strong> should be extended to more general terms.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>410</fr:anchor><fr:addr type="user">def-003A</fr:addr><fr:route>def-003A.xml</fr:route><fr:title text="Alpha Equivalence">Alpha Equivalence</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:tex display="inline">\alpha </fr:tex> equivalence is a relation between <fr:tex display="inline">\lambda \text {-term}</fr:tex>, defined as follows:
    <fr:ul><fr:li><fr:strong>Renaming</fr:strong>: <fr:tex display="inline">\lambda  x. M =_\alpha  \lambda  y. M^{x\to y}</fr:tex> if <fr:tex display="inline">y\not \in \text {FV}(M)</fr:tex> and <fr:tex display="inline">y</fr:tex> is not a binding variable in <fr:tex display="inline">M</fr:tex>.</fr:li>
        <fr:li><fr:strong>Compatibility</fr:strong>: If <fr:tex display="inline">M=_\alpha  N</fr:tex> then <fr:tex display="inline">\lambda  x.M=_\alpha \lambda  x.N</fr:tex> and <fr:tex display="inline">ML =_\alpha  NL, LM =_\alpha  LN</fr:tex>.</fr:li>
        <fr:li><fr:strong>Reflexivity</fr:strong>: <fr:tex display="inline">M=_\alpha  M</fr:tex>.</fr:li>
        <fr:li><fr:strong>Symmetry</fr:strong>: If <fr:tex display="inline">M=_\alpha  N</fr:tex> then <fr:tex display="inline">N=_\alpha  M</fr:tex>.</fr:li>
        <fr:li><fr:strong>Transitivity</fr:strong>: If <fr:tex display="inline">M=_\alpha  N</fr:tex> and <fr:tex display="inline">N=_\alpha  L</fr:tex> then <fr:tex display="inline">M=_\alpha  L</fr:tex>.</fr:li></fr:ul>
    The first principle is the basis of alpha equivalence, which is the same as <fr:link type="local" href="def-0039.xml" addr="def-0039" title="Renaming">renaming</fr:link>.
    The last 3 properties ensures that <fr:tex display="inline">=_\alpha </fr:tex> is an <fr:link type="local" href="def-000X.xml" addr="def-000X" title="Equivalence Relation">equivalence relation</fr:link>.</fr:p><fr:p>If <fr:tex display="inline">M=_\alpha  N</fr:tex> then we say <fr:tex display="inline">M</fr:tex> and <fr:tex display="inline">N</fr:tex> are <fr:tex display="inline">\alpha \text {-equivalent}</fr:tex> or <fr:tex display="inline">\alpha \text {-convertible}</fr:tex>.
    <fr:tex display="inline">M</fr:tex> is an <fr:tex display="inline">\alpha \text {-variant}</fr:tex> of <fr:tex display="inline">N</fr:tex> and vice versa.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>In previous sections we informally mentioned the concept of <fr:strong>substitution</fr:strong>.
    Now we give a precise formulation</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>411</fr:anchor><fr:addr type="user">def-003B</fr:addr><fr:route>def-003B.xml</fr:route><fr:title text="Substitution">Substitution</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>substitution</fr:strong> is defined by the following rules:
    <fr:ul><fr:li><fr:tex display="inline">M[x:=N]:\equiv  N</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">y[x:=N]:\equiv  y</fr:tex> if <fr:tex display="inline">y\not \equiv  x</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">(PQ)[x:=N]:\equiv (P[x:=N])(Q[x:=N])</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">(\lambda  y.P)[x:=N]:\equiv \lambda  z.P^{y\to z}[x:=N]</fr:tex> 
            if <fr:tex display="inline">\lambda  z.P^{y\to z} =_\alpha  \lambda  y.P</fr:tex> and <fr:tex display="inline">z\not \in \text {FV}(N)</fr:tex></fr:li></fr:ul>
    The terms with form <fr:tex display="inline">P[x:=N]</fr:tex> are not <fr:tex display="inline">\lambda \text {-term}</fr:tex>,
    but we can regard them as a <fr:em>meta notation</fr:em> that appears
    in the substitution process and the result contains no such terms.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Renaming can be considered as a special case of substitution.
    We can show that <fr:tex display="inline">M^{x\to u}=_\alpha M[x:=u]</fr:tex> if the conditions of renaming are satisfied.</fr:p><fr:p>We may do <fr:strong>sequential substitution</fr:strong> in a term,
    that is, doing a number of substitutions consecutively.
    And we have the following lemma, which states that the order of substitution is important.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>412</fr:anchor><fr:addr type="user">thm-000X</fr:addr><fr:route>thm-000X.xml</fr:route><fr:title text="Substitution is not commutative">Substitution is not commutative</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">x\not \equiv  y</fr:tex> and assume <fr:tex display="inline">x\not \in \text {FV}(L)</fr:tex>.
    Then <fr:tex display="inline">L[y:=N][x:=M] \equiv  L[x:=M][y:=N[x:=M]]</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>413</fr:anchor><fr:addr type="machine">#275</fr:addr><fr:route>unstable-275.xml</fr:route><fr:title text="{-Term} modulo {-equivalence}"><fr:tex display="inline">\lambda \text {-term}</fr:tex> modulo <fr:tex display="inline">\alpha \text {-equivalence}</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors><fr:parent>tt-0001</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>As we have seen, the relation <fr:tex display="inline">=_\alpha </fr:tex> is an equivalence relation.
    Hence we can define the set of equivalence classes of terms with respect to <fr:tex display="inline">=_\alpha </fr:tex>.
    Now we can identify a term with its equivalence class.
    We still use <fr:tex display="inline">\equiv </fr:tex> for syntactic equality modulo <fr:tex display="inline">\alpha \text {-equivalence}</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p><fr:tex display="inline">\alpha \text {-equivalence}</fr:tex> is a congruence relation, which means that it is conserved by elementary process of term construction.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>414</fr:anchor><fr:addr type="user">thm-000Y</fr:addr><fr:route>thm-000Y.xml</fr:route><fr:title text="Congruence Property of Substitution">Congruence Property of Substitution</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">L=_\alpha  M</fr:tex> and <fr:tex display="inline">N=_\alpha  P</fr:tex>.
    <fr:ul><fr:li><fr:tex display="inline">                 LN =_\alpha  MP             </fr:tex></fr:li>
        <fr:li><fr:tex display="inline">                 \lambda  x.L =_\alpha  \lambda  x.M             </fr:tex></fr:li>
        <fr:li><fr:tex display="inline">                 L[x:=N] =_\alpha  M[x:=P]             </fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>415</fr:anchor><fr:addr type="machine">#276</fr:addr><fr:route>unstable-276.xml</fr:route><fr:title text="Barendregt Convention">Barendregt Convention</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors><fr:parent>tt-0001</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The Barendregt Convention states that we should avoid using the same variable name in different abstractions.
    This is to avoid the confusion of free variables. It states that 
    we choose the names for the binding variables in a <fr:tex display="inline">\lambda \text {-term}</fr:tex> in such a manner
    that they are all different, and each of them differs from 
    all free variables occurring in the term.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>416</fr:anchor><fr:addr type="machine">#277</fr:addr><fr:route>unstable-277.xml</fr:route><fr:title text="Beta Reduction">Beta Reduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors><fr:parent>tt-0001</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Since we have formally defined the <fr:strong>substitution</fr:strong>,
        we can rephrase the reduction as a relation on <fr:tex display="inline">\lambda \text {-term}</fr:tex>, namely <fr:tex display="inline">\beta \text {-reduction}</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>417</fr:anchor><fr:addr type="user">def-003C</fr:addr><fr:route>def-003C.xml</fr:route><fr:title text="One Step Beta Reduction">One Step Beta Reduction</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>One step beta reduction</fr:strong> (<fr:tex display="inline">\to _\beta </fr:tex>) is defined as follows:
    <fr:ul><fr:li><fr:strong>Basis</fr:strong>:
            <fr:tex display="inline">                 (\lambda  x.M)N\to _\beta M[x:=N]             </fr:tex></fr:li>
        <fr:li><fr:strong>Compatibility</fr:strong>:
            If <fr:tex display="inline">M\to _\beta  N</fr:tex> then <fr:tex display="inline">\lambda  x.M\to _\beta \lambda  x.N</fr:tex>,
            <fr:tex display="inline">ML\to _\beta  NL</fr:tex> and <fr:tex display="inline">LM\to _\beta  LN</fr:tex>.</fr:li></fr:ul></fr:p><fr:p>The term of the form <fr:tex display="inline">(\lambda  x.M)N</fr:tex> is called a <fr:strong>redex (reducible expression)</fr:strong>.
    The term of the form <fr:tex display="inline">M[x:=N]</fr:tex> is called the <fr:strong>contractum</fr:strong> (of the redex).</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>418</fr:anchor><fr:addr type="user">eg-0007</fr:addr><fr:route>eg-0007.xml</fr:route><fr:title text="Divergent Combinator">Divergent Combinator</fr:title><fr:taxon>Example</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An interesting example named <fr:strong>omega combinator</fr:strong> of beta reduction is the following:
    <fr:tex display="block">         ((\lambda  x.(x\space x))\space (\lambda  x.(x\space x)))         \to _\beta          ((\lambda  x.(x\space x))\space (\lambda  x.(x\space x)))     </fr:tex>
    The result of the beta reduction is the same term as the original term,
    and never terminates.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We can often perform a sequence of beta reductions. This leads to the definition.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>419</fr:anchor><fr:addr type="user">def-003D</fr:addr><fr:route>def-003D.xml</fr:route><fr:title text="Beta Reduction">Beta Reduction</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>(zero-or-more-step) beta reduction</fr:strong> (<fr:tex display="inline">\twoheadrightarrow _{\beta }</fr:tex>) is a
    generalized version of the <fr:link type="local" href="def-003C.xml" addr="def-003C" title="One Step Beta Reduction">one step beta reduction</fr:link>.
    <fr:tex display="inline">M\twoheadrightarrow _{\beta } N</fr:tex> if there exists <fr:tex display="inline">n\geq  0</fr:tex> and there are terms <fr:tex display="inline">M_0,M_1,\ldots ,M_n</fr:tex>
    such that <fr:tex display="inline">M_0=M</fr:tex>, <fr:tex display="inline">M_n=N</fr:tex> and <fr:tex display="inline">M_i\to _\beta  M_{i+1}</fr:tex> for <fr:tex display="inline">0\leq  i&lt;n</fr:tex>.
    In other words there exists a chain of one-step beta reductions from <fr:tex display="inline">M</fr:tex> to <fr:tex display="inline">N</fr:tex>.
    <fr:tex display="block">         M\equiv  M_0\to _\beta  M_1\to _\beta \cdots \to _\beta  M_n\equiv  N     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>420</fr:anchor><fr:addr type="user">thm-000Z</fr:addr><fr:route>thm-000Z.xml</fr:route><fr:title text="Properties of Beta Reduction">Properties of Beta Reduction</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:ul><fr:li><fr:strong>Compatibility</fr:strong>:
            <fr:tex display="inline">\twoheadrightarrow _{\beta }</fr:tex> extends <fr:tex display="inline">\to _\beta </fr:tex>, i.e. if <fr:tex display="inline">M\to _\beta  N</fr:tex> then <fr:tex display="inline">M\twoheadrightarrow _{\beta } N</fr:tex>.</fr:li>
        <fr:li><fr:strong>Reflixivity</fr:strong>:
            <fr:tex display="inline">                 M\twoheadrightarrow _{\beta } M             </fr:tex></fr:li>
        <fr:li><fr:strong>Transitivity</fr:strong>:
            <fr:tex display="inline">                 M\twoheadrightarrow _{\beta } N \land  N\twoheadrightarrow _{\beta } P \implies  M\twoheadrightarrow _{\beta } P             </fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>421</fr:anchor><fr:addr type="user">tt-0007</fr:addr><fr:route>tt-0007.xml</fr:route><fr:title text="Contextual Modal Type Theory">Contextual Modal Type Theory</fr:title><fr:taxon>Type Theory</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Recently I have been studying some work on <fr:strong>Hole</fr:strong>, and found some interesting things.
    As stated in <fr:link type="local" href="smpe.xml" addr="smpe" title="Toward Semantic Foundations for Program Editors">Semantic Foundations for Program Editors</fr:link>, expression hole can be seen as
    <fr:strong>metavariables</fr:strong> of <fr:strong>contextual modal type theory (CMTT)</fr:strong>. That is, expression 
    holes can have types and are surrounded by contexts, just as metavariables in CMTT are 
    associated with types and contexts. This note is a brief summary of the paper <fr:link type="local" href="cmtt.xml" addr="cmtt" title="Contextual Modal Type Theory">Contextual Modal Type Theory</fr:link>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>379</fr:anchor><fr:addr type="machine">#248</fr:addr><fr:route>unstable-248.xml</fr:route><fr:title text="Introduction and Motivation">Introduction and Motivation</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>tt-0007</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>Contextual modal type theory provides an elegant and uniform foundation for understanding metavariables and explicit
        substitutions. Context is common in logic because the truth of a proposition can depend on the context we consider it in
        rather than being absolute. Narrowing our scope we may think of a context as consisting of the hypothesis that we made
        to establish a final conclusion.</fr:p>
    <fr:p>There arre two main approaches to intuitionistic modal logic.
        <fr:ul><fr:li><fr:strong>Nominal</fr:strong>: Assign names to contexts and includes explicit judgments to relate them.</fr:li>
            <fr:li><fr:strong>Structural</fr:strong>: Identifies the context with propositions it contains. In this article we
            carry this idea further which allows arbitrary contexts to be captured within  a proposition.</fr:li></fr:ul></fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>380</fr:anchor><fr:addr type="machine">#249</fr:addr><fr:route>unstable-249.xml</fr:route><fr:title text="Contextual Modal Logic">Contextual Modal Logic</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>tt-0007</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The philosophical foundation of our development is MLTT approaches of separating 
        judgments and propositions. The most basic judgment is the truth of a proposition,
        <fr:tex display="inline">A\space \text {true}</fr:tex>. We explain the <fr:em>meaning</fr:em> of a proposition by 
        presenting the means of inferring its truth via introduction rules, and exploiting
        the knowledge of its truth via elimination rules. In this section we assume there are
        some atomic proposition <fr:tex display="inline">P</fr:tex> and we define implication <fr:tex display="inline">A\to  B</fr:tex> and a contextual
        modal operator <fr:tex display="inline">[\Psi ]A</fr:tex> where <fr:tex display="inline">\Psi </fr:tex> is a context.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>381</fr:anchor><fr:addr type="machine">#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:title text="Hypothesis judgments">Hypothesis judgments</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
        <fr:p>We write 
            <fr:tex display="block">                 x_1:A_1\space \text {true}, \ldots , x_n:A_n\space \text {true}\vdash  A\space \text {true}             </fr:tex>
            to express that <fr:tex display="inline">A</fr:tex> is true if all hypotheses <fr:tex display="inline">x_1:A_1,\ldots ,x_n:A_n</fr:tex> are true.
            At this moment we can view contexts as unordered, later contexts are reified in 
            modal operators and may even be <fr:strong>internally dependent</fr:strong>, at which point the
            order is important.</fr:p>
        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>382</fr:anchor><fr:addr type="machine">#250</fr:addr><fr:route>unstable-250.xml</fr:route><fr:title text="Hypothesis Rule">Hypothesis Rule</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
            <fr:p><fr:tex display="block">                     \frac {}{                         \Gamma , x:A\space \text {true}, \Gamma &apos; \vdash  A\space \text {true}                     }(\text {hyp}_x)                 </fr:tex>
                The distinct labels for assumptions are necessary (?)</fr:p>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>383</fr:anchor><fr:addr type="machine">#251</fr:addr><fr:route>unstable-251.xml</fr:route><fr:title text="Substitution Rule">Substitution Rule</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
            If <fr:tex display="inline">\Gamma \vdash  A\space \text {true}</fr:tex> and <fr:tex display="inline">\Gamma ,x:A\space \text {true},\Gamma &apos;\vdash  C\space \space \text {true}</fr:tex>
            then <fr:tex display="inline">\Gamma ,\Gamma &apos;\vdash  C\space \text {true}</fr:tex>. (Note that this rule is <fr:em>admissible</fr:em>)
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>384</fr:anchor><fr:addr type="machine">#252</fr:addr><fr:route>unstable-252.xml</fr:route><fr:title text="Implication Introduction">Implication Introduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                 \frac {                     \Gamma , x:A\space \text {true}\vdash  B\space \text {true}                 }{                     \Gamma \vdash  A\to  B\space \text {true}                 }(\to \text {I}^x)             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>385</fr:anchor><fr:addr type="machine">#253</fr:addr><fr:route>unstable-253.xml</fr:route><fr:title text="Implication Elimination">Implication Elimination</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                 \frac {                     \Gamma \vdash  A\to  B\space \text {true}\quad \Gamma \vdash  A\space \text {true}                 }{                     \Gamma \vdash  B\space \text {true}                 }(\to \text {E})             </fr:tex>
            It implies that elimination rule cannot extract more knowledge from 
            a proposition than contributed by its proof (Soundness). 
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>386</fr:anchor><fr:addr type="machine">#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:title text="Local Reduction for Implication (Computational Rule)">Local Reduction for Implication (Computational Rule)</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                 \frac {                     \dfrac {                         \Gamma , x:A\space \text {true}\vdash  B\space \text {true}                     }{                         \Gamma \vdash  A\to  B\space \text {true}                     }(\to \text {I}^x)                     \quad                      \Gamma \vdash  A\space \text {true}                 }{                     \Gamma \vdash  B\space \text {true}                 }(\to \text {E})                 \mapsto  _R \Gamma \vdash  B\space \text {true}             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>387</fr:anchor><fr:addr type="machine">#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:title text="Local Expansion for Implication">Local Expansion for Implication</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                 \Gamma \vdash  A\to  B\space \text {true} \mapsto _E                 \frac {                     \Gamma ,x:A\space \text {true}\vdash  A\to  B\space \text {true}\quad  \dfrac {}{\Gamma ,x:A\space \text {true}\vdash  A\space \text {true}}(\text {hyp}_x)                 }{                     \dfrac {\Gamma ,x:A\space \text {true}\vdash  B\space \text {true}}{\Gamma \vdash  A\to  B\space \text {true}}(\to \text {I}^x)                 }             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>388</fr:anchor><fr:addr type="machine">#259</fr:addr><fr:route>unstable-259.xml</fr:route><fr:title text="Categorical judgments">Categorical judgments</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
        <fr:p><fr:tex display="inline">A</fr:tex> is <fr:strong>categorically true</fr:strong> or valid if its truth does not depend on any hypotheses
            about the truth of other propositions. Instead it may depend on the validity of other proposition,
            because their validity may not depend on truth assumptions.</fr:p>
        <fr:p>We weite <fr:tex display="inline">\Delta </fr:tex> for a labeled list <fr:tex display="inline">u_1 :: A_1\space \text {valid},\ldots ,u_n :: A_n\space \text {valid}</fr:tex> of assumptions
            about the validity of propositions. We separate validity and truth:
            <fr:tex display="block">                 \Delta ;\Gamma \vdash  \mathcal {J}             </fr:tex>
            where <fr:tex display="inline">\mathcal {J}</fr:tex> is a judgment <fr:tex display="inline">A\space \text {true}</fr:tex> or <fr:tex display="inline">A\space \text {valid}</fr:tex>.</fr:p>
        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>376</fr:anchor><fr:addr type="machine">#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:title text="Contextual Modal Type Theory › Contextual Modal Logic › Validity"><fr:link type="local" href="unstable-249.xml" addr="#249" title="Contextual Modal Type Theory › Contextual Modal Logic"><fr:link type="local" href="tt-0007.xml" addr="tt-0007" title="Contextual Modal Type Theory">Contextual Modal Type Theory</fr:link> › Contextual Modal Logic</fr:link> › Validity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
            <fr:p><fr:tex display="block">                     \frac {\Delta ;\cdot \vdash  A\space \text {true}}{\Delta ;\Gamma \vdash  A\space \text {valid}}                 </fr:tex></fr:p>
            
            <fr:p>Conversely if <fr:tex display="inline">A</fr:tex> is valid we can conclude that it is true</fr:p>
            <fr:tex display="block">                 \frac {}{                     (\Delta ,u::A\space \text {valid},\Delta &apos;);\Gamma \vdash  A\space \text {true}                 }(\text {vldhyp}_u)             </fr:tex>
            <fr:p>In terms of a multiple world semantics, we say taht <fr:tex display="inline">A</fr:tex> is valid if <fr:tex display="inline">A</fr:tex> is
                true in <fr:strong>every</fr:strong> possible world. We require that <fr:tex display="inline">A</fr:tex> must be true in a 
                world about which we assume nothing (<fr:tex display="inline">\Gamma  = \cdot </fr:tex>), except the constant-true
                propositions <fr:tex display="inline">\Delta </fr:tex>.</fr:p>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>377</fr:anchor><fr:addr type="machine">#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:title text="Contextual Modal Type Theory › Contextual Modal Logic › Substitution Principle for Validity"><fr:link type="local" href="unstable-249.xml" addr="#249" title="Contextual Modal Type Theory › Contextual Modal Logic"><fr:link type="local" href="tt-0007.xml" addr="tt-0007" title="Contextual Modal Type Theory">Contextual Modal Type Theory</fr:link> › Contextual Modal Logic</fr:link> › Substitution Principle for Validity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
            <fr:p>Note that by the definition of validity we can immediately reduce the goal
                of proving <fr:tex display="inline">A\space \text {valid}</fr:tex> into proving <fr:tex display="inline">A\space \text {true}</fr:tex>, which is captured by the principle
                of substitution.</fr:p>
            <fr:p>If <fr:tex display="inline">\Delta ;\cdot \vdash  A\space \text {true}</fr:tex> and <fr:tex display="inline">(\Delta ,u::A\space \text {valid},\Delta &apos;);\Gamma \vdash  C\space \text {true}</fr:tex>,
                then <fr:tex display="inline">(\Delta ,\Delta &apos;);\Gamma \vdash  C\space \text {true}</fr:tex>.</fr:p>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        <fr:p>With the categorical judgment we can introduce the <fr:strong>modal operator</fr:strong> for necessary
            truth <fr:tex display="inline">\square  A</fr:tex>.</fr:p>
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>389</fr:anchor><fr:addr type="machine">#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:title text="Contextual Validity">Contextual Validity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
        <fr:p><fr:tex display="inline">A\space \text {valid}</fr:tex> expresses that <fr:tex display="inline">A</fr:tex> is true in <fr:strong>any</fr:strong> world.
            In this section we <fr:strong>relativize</fr:strong> this judgment:
            let <fr:tex display="inline">\Psi  = y_1:B_1\space \text {true}, \cdots , y_n:B_n\space \text {true}</fr:tex> be a list of assumptions.
            We say that <fr:tex display="inline">A</fr:tex> is <fr:strong>valid relative</fr:strong> <fr:tex display="inline">\Psi </fr:tex> (denoted <fr:tex display="inline">A\space \text {valid}[\Psi ]</fr:tex>) if <fr:tex display="inline">A</fr:tex> is true in every
            world in which <fr:tex display="inline">B_1,\cdots ,B_n</fr:tex> are true.
            Similarly we generalized assumptions about validity so that <fr:tex display="inline">\Delta </fr:tex> 
            now has the form <fr:tex display="inline">u_1::A_1\space \text {valid}[\Psi _1], \cdots , u_n::A_n\space \text {valid}[\Psi _n]</fr:tex>.</fr:p>
        <fr:p>As common in PL, we refer to <fr:tex display="inline">\Psi </fr:tex> as a context and to the judgment 
            <fr:tex display="inline">A\space \text {valid}[\Psi ]</fr:tex> as <fr:strong>contextual validity</fr:strong>.</fr:p>
        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>390</fr:anchor><fr:addr type="machine">#260</fr:addr><fr:route>unstable-260.xml</fr:route><fr:title text="Contextual Validity">Contextual Validity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
            <fr:p>To prove <fr:tex display="inline">A\space \text {valid}[\Psi ]</fr:tex> we only required to prove <fr:tex display="inline">A</fr:tex> using only <fr:tex display="inline">\Psi </fr:tex>
                without any hypotheses about the truth:</fr:p>
            <fr:tex display="block">                 \frac {                     \Delta ;\Psi \vdash  A\space \text {true}                 }{                     \Delta ;\Gamma \vdash  A\space \text {valid}[\Psi ]                 }             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>391</fr:anchor><fr:addr type="machine">#261</fr:addr><fr:route>unstable-261.xml</fr:route><fr:title text="Contextual Entailment">Contextual Entailment</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
            We write
            <fr:tex display="block">                 \Delta ;\Gamma \vdash \Psi              </fr:tex>
            to express that all the propositions in <fr:tex display="inline">\Psi </fr:tex> are true using the assumptions from <fr:tex display="inline">\Gamma </fr:tex>.
            <fr:tex display="block">                 \frac {                     \Delta ;\Gamma \vdash  B_1\space \text {true} \quad \cdot \quad  \Delta ;\Gamma \vdash  B_n\space \text {true}                 }{                     \Delta ;\Gamma \vdash  y_1:B_1\space \text {true},\ldots ,y_n:B_n\space \text {true}                 }(\text {ctx})             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>392</fr:anchor><fr:addr type="machine">#262</fr:addr><fr:route>unstable-262.xml</fr:route><fr:title text="Contextual Hypothesis Rule">Contextual Hypothesis Rule</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                 \frac {                     (\Delta ,u::A\space \text {valid}[\Psi ],\Delta &apos;);\Gamma \vdash \Psi                  }{                     (\Delta ,u::A\space \text {valid}[\Psi ],\Delta &apos;);\Gamma \vdash  A\space \text {true}                 }(\text {ctxhyp}_u)             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>393</fr:anchor><fr:addr type="machine">#263</fr:addr><fr:route>unstable-263.xml</fr:route><fr:title text="Contextual Substitution Principle">Contextual Substitution Principle</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
            <fr:p>If <fr:tex display="inline">\Delta ;\Psi \vdash  A\space \text {true}</fr:tex> and <fr:tex display="inline">(\Delta ,u::A\space \text {valid}[\Psi ],\Delta &apos;);\Gamma \vdash  C\space \text {true}</fr:tex>
                then <fr:tex display="inline">(\Delta ,\Delta &apos;);\Gamma \vdash  C\space \text {true}</fr:tex>.</fr:p>
            <fr:p>The precondition implies <fr:tex display="inline">\Delta ;\Gamma \vdash  A\space \text {valid}[\Psi ]</fr:tex> and by the substitution principle
                of hypotheses judgments we can justify this rule.</fr:p>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>394</fr:anchor><fr:addr type="machine">#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:title text="Contextual Identity Principle">Contextual Identity Principle</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#249</fr:parent></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                 \Delta ;\Psi \vdash \Psi              </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>422</fr:anchor><fr:addr type="user">math-0003</fr:addr><fr:route>math-0003.xml</fr:route><fr:title text="Set Theory">Set Theory</fr:title><fr:taxon>Set Theory</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Refer to <fr:link type="local" href="cat-sci-2013.xml" addr="cat-sci-2013" title="Category theory for scientists">Category Theory for Scientists</fr:link>.</fr:p><fr:p><fr:strong>Set</fr:strong> is a common concept in mathematics.
    This post is a brief introduction to set theory aimed at 
    complete all basic knowledge of set theory.
    The following topics will be covered
    <fr:ul><fr:li><fr:strong>Zermelo-Fraenkel Axioms</fr:strong> and <fr:strong>Axiom of Choice</fr:strong></fr:li>
        <fr:li>Cardinality</fr:li>
        <fr:li>Set theory constructions</fr:li></fr:ul></fr:p><fr:p>In this post, we use the Zermelo-Fraenkel set theory with the Axiom of Choice (<fr:strong>ZFC</fr:strong>).</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>423</fr:anchor><fr:addr type="user">def-000S</fr:addr><fr:route>def-000S.xml</fr:route><fr:title text="ZFC Set">ZFC Set</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>ZFC</fr:strong> is the abbreviation of Zermelo-Fraenkel set theory with the Axiom of Choice.
    The axioms of ZFC are listed below.
    <fr:ul><fr:li><fr:strong>Axiom of Extensionality</fr:strong>:
            Two sets are equal if and only if they have the same elements.</fr:li>
        <fr:li><fr:strong>Axiom of Pairing</fr:strong>:
            For any two sets <fr:tex display="inline">a</fr:tex> and <fr:tex display="inline">b</fr:tex>,
            there exists a set <fr:tex display="inline">\{ a,b \}</fr:tex> whose elements are exactly <fr:tex display="inline">a</fr:tex> and <fr:tex display="inline">b</fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom schema of Separation</fr:strong>:
            Let <fr:tex display="inline">P</fr:tex> is a property of sets.
            <fr:tex display="inline">P(u)</fr:tex> means <fr:tex display="inline">u</fr:tex> satisfies the property <fr:tex display="inline">P</fr:tex>.
            then for any set <fr:tex display="inline">X</fr:tex> exists <fr:tex display="inline">Y = \{ u \in  X | P(u) \}</fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom of Union</fr:strong>:
            For any set <fr:tex display="inline">X</fr:tex> (a family of sets), exists union set <fr:tex display="inline">\bigcup  X :\equiv  \{                  u:\exists  v\in  X \text { such that } u\in  v              \}</fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom of Power Set</fr:strong>:
            For any set <fr:tex display="inline">X</fr:tex>, exists the power <fr:tex display="inline">P(X) :\equiv  \{ Y:Y\subseteq  X \}</fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom of Infinity</fr:strong>:
            There exists a set <fr:tex display="inline">\omega </fr:tex> such that <fr:tex display="inline">\emptyset \in \omega </fr:tex> and for any <fr:tex display="inline">x\in \omega </fr:tex>, <fr:tex display="inline">x\cup \{ x \}\in \omega </fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom of Regularity</fr:strong>:
            For any non-empty set there is a minimal element with respect to the membership relation.</fr:li>
        <fr:li><fr:strong>Axiom schema of Replacement</fr:strong>:
            Let <fr:tex display="inline">F</fr:tex> be a function where <fr:tex display="inline">\text {dom } f = X</fr:tex>, then for any set <fr:tex display="inline">X</fr:tex> exists a set <fr:tex display="inline">Y = \{ F(x):x\in  X \}</fr:tex>.
            <fr:p>This function is not the normal function but some logical stuff.</fr:p></fr:li>
        <fr:li><fr:strong>Axiom of Choice</fr:strong>:
            For any family of non-empty sets <fr:tex display="inline">X</fr:tex>, there exists a function <fr:tex display="inline">f:X\to \bigcup  X</fr:tex> such that for any <fr:tex display="inline">x\in  X</fr:tex>, <fr:tex display="inline">f(x)\in  x</fr:tex>.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>424</fr:anchor><fr:addr type="user">def-002V</fr:addr><fr:route>def-002V.xml</fr:route><fr:title text="Set Operations">Set Operations</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">(X_i)_{i\in  I}</fr:tex> be a family of sets.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>425</fr:anchor><fr:addr type="machine">#238</fr:addr><fr:route>unstable-238.xml</fr:route><fr:title text="Union">Union</fr:title><fr:authors></fr:authors><fr:parent>def-002V</fr:parent></fr:frontmatter><fr:mainmatter><fr:p><fr:tex display="block">         \bigcup _{i\in  I}X_i = \set {x:\exists  i\in  I \text { such that } x\in  X_i}     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>426</fr:anchor><fr:addr type="machine">#239</fr:addr><fr:route>unstable-239.xml</fr:route><fr:title text="Intersection">Intersection</fr:title><fr:authors></fr:authors><fr:parent>def-002V</fr:parent></fr:frontmatter><fr:mainmatter><fr:p><fr:tex display="block">         \bigcap _{i\in  I}X_i = \set {x:\forall  i\in  I, x\in  X_i}     </fr:tex>
    Note that <fr:tex display="inline">I \neq  \emptyset </fr:tex> here.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>427</fr:anchor><fr:addr type="machine">#240</fr:addr><fr:route>unstable-240.xml</fr:route><fr:title text="Disjoint Union">Disjoint Union</fr:title><fr:authors></fr:authors><fr:parent>def-002V</fr:parent></fr:frontmatter><fr:mainmatter><fr:p><fr:tex display="block">         \bigsqcup _{i\in  I}X_i = \set {(x,i):x\in  X_i, i\in  I}     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>428</fr:anchor><fr:addr type="machine">#241</fr:addr><fr:route>unstable-241.xml</fr:route><fr:title text="Product">Product</fr:title><fr:authors></fr:authors><fr:parent>def-002V</fr:parent></fr:frontmatter><fr:mainmatter><fr:p><fr:tex display="block">         \prod _{i\in  I}X_i = \set {(x_i)_{i\in  I}:\forall  i\in  I, x_i\in  X_i}     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>And principles of set theory</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>429</fr:anchor><fr:addr type="user">def-000T</fr:addr><fr:route>def-000T.xml</fr:route><fr:title text="Principle of Extensionality">Principle of Extensionality</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Two sets are equal if and only if they have the same elements.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>430</fr:anchor><fr:addr type="user">def-000U</fr:addr><fr:route>def-000U.xml</fr:route><fr:title text="Principle of Comprehension">Principle of Comprehension</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a set <fr:tex display="inline">A</fr:tex> and a property <fr:tex display="inline">P(x)</fr:tex>, there exists a set <fr:tex display="inline">B</fr:tex> such that
    <fr:tex display="inline">x\in  B \iff  x\in  A \land  P(x)</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We then define the Cartesian product of two sets</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>431</fr:anchor><fr:addr type="user">def-000V</fr:addr><fr:route>def-000V.xml</fr:route><fr:title text="Cartesian product">Cartesian product</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two sets <fr:tex display="inline">A</fr:tex> and <fr:tex display="inline">B</fr:tex>, the Cartesian product <fr:tex display="inline">A\times  B</fr:tex> is the set
    of all ordered pairs <fr:tex display="inline">(a,b)</fr:tex> where <fr:tex display="inline">a\in  A</fr:tex> and <fr:tex display="inline">b\in  B</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>With the Cartesian product, we can define the relation</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>432</fr:anchor><fr:addr type="user">def-000W</fr:addr><fr:route>def-000W.xml</fr:route><fr:title text="Relation">Relation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>relation</fr:strong> <fr:tex display="inline">R</fr:tex> is a subset of the Cartesian product of two sets <fr:tex display="inline">A</fr:tex> and
    <fr:tex display="inline">B</fr:tex>, i.e. <fr:tex display="inline">R\subseteq  A\times  B</fr:tex>.
    If <fr:tex display="inline">(a,b)\in  R</fr:tex>, we write <fr:tex display="inline">aRb</fr:tex>.

    A relation that between <fr:tex display="inline">X</fr:tex> and itself is called <fr:strong>homogeneous relation</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>433</fr:anchor><fr:addr type="user">def-000X</fr:addr><fr:route>def-000X.xml</fr:route><fr:title text="Equivalence Relation">Equivalence Relation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An equivalence relation <fr:tex display="inline">R</fr:tex> on a set <fr:tex display="inline">A</fr:tex> is a <fr:link type="local" href="def-000W.xml" addr="def-000W" title="Relation">relation</fr:link> that is reflexive,
    symmetric, and transitive.
    <fr:ul><fr:li>Reflexive:
            <fr:tex display="inline">\forall  x\in  A, xRx</fr:tex></fr:li>
        <fr:li>Symmetric:
            <fr:tex display="inline">\forall  x,y\in  A, xRy\implies  yRx</fr:tex></fr:li>
        <fr:li>Transitive:
            <fr:tex display="inline">\forall  x,y,z\in  A, xRy\land  yRz\implies  xRz</fr:tex></fr:li></fr:ul>
    We often denote the equivalence relation by <fr:tex display="inline">\sim </fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>434</fr:anchor><fr:addr type="user">def-002U</fr:addr><fr:route>def-002U.xml</fr:route><fr:title text="Equivalence Class">Equivalence Class</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">\sim </fr:tex> be an <fr:link type="local" href="def-000X.xml" addr="def-000X" title="Equivalence Relation">equivalence relation</fr:link> on a set <fr:tex display="inline">A</fr:tex>.
    For any element <fr:tex display="inline">a\in  A</fr:tex>, the <fr:strong>equivalence class</fr:strong> of <fr:tex display="inline">a</fr:tex> is the set
    <fr:tex display="inline">[a] = \set {b\in  A:b\sim  a}</fr:tex>.
    The set of all equivalence classes is denoted by <fr:tex display="inline">A/\sim </fr:tex>,
    which is called the <fr:strong>quotient set</fr:strong> of <fr:tex display="inline">A</fr:tex> by <fr:tex display="inline">\sim </fr:tex>.
    <fr:p>The equivalence class of <fr:tex display="inline">a</fr:tex> is also denoted by <fr:tex display="inline">\overline {a}</fr:tex>.</fr:p></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>One of the most important relations is the order relation.
    The basic order relation is the preorder.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>435</fr:anchor><fr:addr type="user">def-000Z</fr:addr><fr:route>def-000Z.xml</fr:route><fr:title text="Preorder">Preorder</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>preorder</fr:strong> is a relation <fr:tex display="inline">\leq </fr:tex> that is reflexive and transitive.
    <fr:ul><fr:li>Reflexive: <fr:tex display="inline">a\leq  a</fr:tex></fr:li>
        <fr:li>Transitive: <fr:tex display="inline">a\leq  b</fr:tex> and <fr:tex display="inline">b\leq  c</fr:tex> implies <fr:tex display="inline">a\leq  c</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>436</fr:anchor><fr:addr type="user">def-000Y</fr:addr><fr:route>def-000Y.xml</fr:route><fr:title text="Partial Order">Partial Order</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>(non-strict) partial order</fr:strong> is a relation <fr:tex display="inline">\leq </fr:tex> that is reflexive, antisymmetric and transitive.
    <fr:ul><fr:li>Reflexive: <fr:tex display="inline">a\leq  a</fr:tex></fr:li>
        <fr:li>Antisymmetric: <fr:tex display="inline">a\leq  b</fr:tex> and <fr:tex display="inline">b\leq  a</fr:tex> implies <fr:tex display="inline">a=b</fr:tex></fr:li>
        <fr:li>Transitive: <fr:tex display="inline">a\leq  b</fr:tex> and <fr:tex display="inline">b\leq  c</fr:tex> implies <fr:tex display="inline">a\leq  c</fr:tex></fr:li></fr:ul>
    A non-strict partial order is also known as an antisymmetric <fr:link type="local" href="def-000Z.xml" addr="def-000Z" title="Preorder">preorder</fr:link>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>And the strict partial order (notice the difference between asymmetric and antisymmetric)</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>437</fr:anchor><fr:addr type="user">def-0010</fr:addr><fr:route>def-0010.xml</fr:route><fr:title text="Strict partial orders">Strict partial orders</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A strict partial order is a relation <fr:tex display="inline">&lt;</fr:tex> that is irreflexive, asymmetric and transitive.
    <fr:ul><fr:li>Irreflexive: <fr:tex display="inline">\neg (a&lt;a)</fr:tex></fr:li>
        <fr:li>Asymmetric: <fr:tex display="inline">a&lt;b</fr:tex> implies <fr:tex display="inline">\neg (b&lt;a)</fr:tex></fr:li>
        <fr:li>Transitive: <fr:tex display="inline">a&lt;b</fr:tex> and <fr:tex display="inline">b&lt;c</fr:tex> implies <fr:tex display="inline">a&lt;c</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>With the definition of order, we can define the upper bound and lower bound</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>438</fr:anchor><fr:addr type="user">def-0011</fr:addr><fr:route>def-0011.xml</fr:route><fr:title text="Upper Bound and Lower Bound">Upper Bound and Lower Bound</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let a subset <fr:tex display="inline">S</fr:tex> of a <fr:link type="local" href="def-000Y.xml" addr="def-000Y" title="Partial Order">partially ordered</fr:link> set <fr:tex display="inline">(P, \leq )</fr:tex>,
    <fr:tex display="inline">S</fr:tex> is bounded above if there exists <fr:tex display="inline">x \in  P</fr:tex> such that <fr:tex display="inline">\forall  y \in  S, y \leq  x</fr:tex>. And <fr:tex display="inline">x</fr:tex> is called an <fr:strong>upper bound</fr:strong> of <fr:tex display="inline">S</fr:tex>.
    Dually, <fr:tex display="inline">S</fr:tex> is bounded below if there exists <fr:tex display="inline">x \in  P</fr:tex> such that <fr:tex display="inline">\forall  y \in  S, x \leq  y</fr:tex>. And <fr:tex display="inline">x</fr:tex> is called a <fr:strong>lower bound</fr:strong> of <fr:tex display="inline">S</fr:tex>.</fr:p>
    <fr:p><fr:strong>Supremum (least upper bound)</fr:strong></fr:p>
    <fr:p>An element <fr:tex display="inline">x\in  P</fr:tex> is a supremum of <fr:tex display="inline">S</fr:tex>,
    if for all upper bounds <fr:tex display="inline">z \in  P</fr:tex> of <fr:tex display="inline">S</fr:tex>, <fr:tex display="inline">x \leq  z</fr:tex>.
    Denoted as <fr:tex display="inline">x = \sup  S</fr:tex>.</fr:p>
    <fr:p><fr:strong>Infimum (greatest lower bound)</fr:strong></fr:p>
    <fr:p>An element <fr:tex display="inline">x\in  P</fr:tex> is a infimum of <fr:tex display="inline">S</fr:tex>,
    if for all lower bounds <fr:tex display="inline">z \in  P</fr:tex> of <fr:tex display="inline">S</fr:tex>, <fr:tex display="inline">z \leq  x</fr:tex>.
    Denoted as <fr:tex display="inline">x = \inf  S</fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>439</fr:anchor><fr:addr type="user">def-002G</fr:addr><fr:route>def-002G.xml</fr:route><fr:title text="Function">Function</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets then a <fr:strong>function</fr:strong> <fr:tex display="inline">f:X \to  Y</fr:tex>
    is a mapping that sends each element of <fr:tex display="inline">X</fr:tex> to a unique element of <fr:tex display="inline">Y</fr:tex>,
    denoted by <fr:tex display="inline">f(x) = y</fr:tex>.
    Function is a special case of <fr:link type="local" href="def-000W.xml" addr="def-000W" title="Relation">relation</fr:link>, and it is a relation that is left-total and right-unique.
    <fr:tex display="block">         f \in  X \times  Y \text { and } \forall  x \in  X, \exists ! y \in  Y, (x,y) \in  f     </fr:tex>
    <fr:tex display="inline">X</fr:tex> is said to be the <fr:strong>domain</fr:strong> of <fr:tex display="inline">f</fr:tex> and <fr:tex display="inline">Y</fr:tex> is said to be the <fr:strong>codomain</fr:strong> of <fr:tex display="inline">f</fr:tex>,
    where we denote <fr:tex display="inline">X = \text {dom } f</fr:tex> and <fr:tex display="inline">Y = \text {cod } f</fr:tex>.</fr:p><fr:p>Two functions <fr:tex display="inline">f:X\to  Y</fr:tex> and <fr:tex display="inline">g:Y\to  Z</fr:tex> can be <fr:strong>composed</fr:strong> to form a new function <fr:tex display="inline">g \circ  f : X \to  Z</fr:tex>,
    where the composition is defined by
    <fr:tex display="block">         (g \circ  f)(x) = g(f(x))      </fr:tex></fr:p><fr:p>The set of all functions from <fr:tex display="inline">X</fr:tex> to <fr:tex display="inline">Y</fr:tex> is denoted by <fr:tex display="inline">\hom _\text {set}(X, Y)</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The isomorphism function is defined as follows</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>440</fr:anchor><fr:addr type="user">def-002H</fr:addr><fr:route>def-002H.xml</fr:route><fr:title text="Set Isomorphism">Set Isomorphism</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets and <fr:tex display="inline">f: X \to  Y</fr:tex> be a function.
    The function <fr:tex display="inline">f</fr:tex> is called an <fr:strong>isomorphism</fr:strong> if it is both <fr:link type="local" href="def-002D.xml" addr="def-002D" title="Injective">injective</fr:link> and <fr:link type="local" href="def-002F.xml" addr="def-002F" title="Surjective">surjective</fr:link>.
    In other words, there exists a function <fr:tex display="inline">g: Y \to  X</fr:tex> such that
    <fr:tex display="block">         g \circ  f = \text {id}_X \text { and } f \circ  g = \text {id}_Y     </fr:tex>
    where <fr:tex display="inline">\text {id}_X</fr:tex> and <fr:tex display="inline">\text {id}_Y</fr:tex> are the <fr:strong>identity functions</fr:strong> on <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> respectively.
    And we say <fr:tex display="inline">f</fr:tex> is <fr:strong>invertible</fr:strong> and <fr:tex display="inline">g</fr:tex> is the <fr:strong>inverse</fr:strong> of <fr:tex display="inline">f</fr:tex>.
    If there is a isomorphism between <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex>, we say <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> are <fr:strong>isomorphic</fr:strong>,
    denoted by <fr:tex display="inline">X \cong  Y</fr:tex>.
    Isomorphism is an <fr:link type="local" href="def-000X.xml" addr="def-000X" title="Equivalence Relation">equivalence relation</fr:link>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>With isomorphism, we can define the cardinality of a set.
    Two isomorphic sets have the same cardinality.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>441</fr:anchor><fr:addr type="user">def-002I</fr:addr><fr:route>def-002I.xml</fr:route><fr:title text="Cardinality">Cardinality</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">X</fr:tex> be a set and <fr:tex display="inline">n \in  \mathbb {N}</fr:tex>. 
    <fr:tex display="inline">A</fr:tex> si said to have <fr:strong>cardinality</fr:strong> <fr:tex display="inline">n</fr:tex>, denoted by <fr:tex display="inline"> |A|= n</fr:tex>,
    if there exists an isomorphism between <fr:tex display="inline">A</fr:tex> and <fr:tex display="inline">S_n = \{ 1,2,\cdots ,n \}</fr:tex>.
    If <fr:tex display="inline">A</fr:tex> has finite cardinality, we say <fr:tex display="inline">A</fr:tex> is <fr:strong>finite</fr:strong>, otherwise
    we say <fr:tex display="inline">A</fr:tex> is <fr:strong>infinite</fr:strong>, denoted by <fr:tex display="inline">|A| \geq  \infty </fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The next topic is the product of sets</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>442</fr:anchor><fr:addr type="user">def-002J</fr:addr><fr:route>def-002J.xml</fr:route><fr:title text="Product of Sets">Product of Sets</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets, then the <fr:strong>Cartesian product</fr:strong> of <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> is the set
    <fr:tex display="block">         X \times  Y = \set {(x,y) \mid  x \in  X \text { and } y \in  Y}     </fr:tex>
    There are two natural projections from the Cartesian product to the original sets, namely
    <fr:tex display="block">         \pi _1 : X \times  Y \to  X \text { and } \pi _2 : X \times  Y \to  Y     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>This leads to an improtant concept named <fr:strong>universal property</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>443</fr:anchor><fr:addr type="user">thm-000J</fr:addr><fr:route>thm-000J.xml</fr:route><fr:title text="Universal Property for Product of Sets">Universal Property for Product of Sets</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets.
    For any set <fr:tex display="inline">A</fr:tex> and function
    <fr:tex display="inline">f: A \to  X</fr:tex> and <fr:tex display="inline">g: A \to  Y</fr:tex>,
    there exists a <fr:em>unique</fr:em> function <fr:tex display="inline">h: A \to  X \times  Y</fr:tex> such that
    the following diagram commutes:
    
    <fr:embedded-tex hash="ca22432ab48562e3683dbca83f028b9b"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            &amp; {X\times  Y} \\
            X &amp;&amp; Y \\
            &amp; A
            \arrow [&quot;{\pi _1}&quot;&apos;, from=1-2, to=2-1]
            \arrow [&quot;{\pi _2}&quot;, from=1-2, to=2-3]
            \arrow [&quot;f&quot;, from=3-2, to=2-1]
            \arrow [&quot;g&quot;&apos;, from=3-2, to=2-3]
            \arrow [&quot;{\exists !}&quot;, dashed, from=3-2, to=1-2]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex>

    We might denote the unique function by <fr:tex display="inline">\langle  f,g \rangle : A \to  X \times  Y</fr:tex>.
    It is sufficient to define <fr:tex display="inline">\langle  f,g \rangle (a) = (f(a),g(a))</fr:tex> for all <fr:tex display="inline">a\in  A</fr:tex> as the unique function.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Dual to the product of sets, we have the coproduct of sets</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>444</fr:anchor><fr:addr type="user">def-002K</fr:addr><fr:route>def-002K.xml</fr:route><fr:title text="Coproduct of Sets">Coproduct of Sets</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets, then the <fr:strong>coproduct</fr:strong> of <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> is 
    defined as the <fr:strong>disjoint union</fr:strong> of <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex>, denoted by <fr:tex display="inline">X \sqcup  Y</fr:tex>.
    There are two natural injections from the original sets to the coproduct, namely
    <fr:tex display="block">         i_1 : X \to  X \sqcup  Y \text { and } i_2 : Y \to  X \sqcup  Y     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>445</fr:anchor><fr:addr type="user">thm-000K</fr:addr><fr:route>thm-000K.xml</fr:route><fr:title text="Universal Property for Coproduct of Sets">Universal Property for Coproduct of Sets</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets. For any set <fr:tex display="inline">A</fr:tex> and function
    <fr:tex display="inline">f : X \to  A</fr:tex> and <fr:tex display="inline">g : Y \to  A</fr:tex>, there exists a <fr:em>unique</fr:em> function
    <fr:tex display="inline">h : X \sqcup  Y \to  A</fr:tex> such that the following diagram commutes:
    
    <fr:embedded-tex hash="d3e6535ccb6ae8bc37951bc260782fc4"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            &amp; A \\
            X &amp;&amp; Y \\
            &amp; {X\sqcup  Y}
            \arrow [&quot;{i_1}&quot;&apos;, from=2-1, to=3-2]
            \arrow [&quot;{i_2}&quot;, from=2-3, to=3-2]
            \arrow [&quot;f&quot;, from=2-1, to=1-2]
            \arrow [&quot;g&quot;&apos;, from=2-3, to=1-2]
            \arrow [&quot;{\exists !}&quot;, dashed, from=3-2, to=1-2]
        \end {tikzcd}   
    
    </fr:embedded-tex-body></fr:embedded-tex>

    We might denote the unique as <fr:tex display="inline">f\sqcup  g: X \sqcup  Y \to  A</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>In this section we discuss the <fr:em>limits</fr:em> of variously-shaped diagrams of sets.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>446</fr:anchor><fr:addr type="user">def-002L</fr:addr><fr:route>def-002L.xml</fr:route><fr:title text="Pullback of Sets">Pullback of Sets</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose we have sets <fr:tex display="inline">X</fr:tex>, <fr:tex display="inline">Y</fr:tex>, and <fr:tex display="inline">Z</fr:tex> and functions
    <fr:tex display="inline">f : X \to  Z</fr:tex> and <fr:tex display="inline">g : Y \to  Z</fr:tex>.
    
    <fr:embedded-tex hash="1be7e77d25bf550ee218bc4d0cc863ed"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            &amp; Y \\
            X &amp; Z
            \arrow [&quot;f&quot;&apos;, from=2-1, to=2-2]
            \arrow [&quot;g&quot;, from=1-2, to=2-2]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex>

    Its <fr:strong>fiber product</fr:strong> is the set
    <fr:tex display="block">         X \times _Z Y = \{ (x,w,y) \mid  f(x) = w = g(y) \}     </fr:tex>
    There are obvious projections 
    <fr:tex display="inline">         \pi _1 : X \times _Z Y \to  X \text { and } \pi _2 : X \times _Z Y \to  Y     </fr:tex>
    such that the following diagram commutes (<fr:tex display="inline">W = X \times _Z Y</fr:tex>):
    
    <fr:embedded-tex hash="cec2c02008ffeb510d502730d67fd941"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            W &amp; Y \\
            X &amp; Z
            \arrow [&quot;f&quot;&apos;, from=2-1, to=2-2]
            \arrow [&quot;g&quot;, from=1-2, to=2-2]
            \arrow [&quot;{\pi _2}&quot;, from=1-1, to=1-2]
            \arrow [&quot;{\pi _1}&quot;&apos;, from=1-1, to=2-1]
            \arrow [&quot;\lrcorner &quot;{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex>

    The <fr:strong>pullback</fr:strong> is defined to be any set <fr:tex display="inline">W \cong  X\times _Z Y</fr:tex>
    The corner symbol indicates <fr:tex display="inline">W</fr:tex> is a <fr:em>pullback</fr:em></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The pullback also satisfies the universal property.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>447</fr:anchor><fr:addr type="user">thm-000L</fr:addr><fr:route>thm-000L.xml</fr:route><fr:title text="Universal Property for Pullback">Universal Property for Pullback</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose the given diagram:
    
    <fr:embedded-tex hash="fa8c405224a924702821602d8d9b2b33"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            &amp; Y \\
            X &amp; Z
            \arrow [&quot;t&quot;&apos;, from=2-1, to=2-2]
            \arrow [&quot;u&quot;, from=1-2, to=2-2]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex>

    For any set <fr:tex display="inline">A</fr:tex> and commutative solid arrow diagram as below
    (functions <fr:tex display="inline">f:A\to  X</fr:tex> and <fr:tex display="inline">g:A\to  Y</fr:tex> such that <fr:tex display="inline">t\circ  f = u\circ  g</fr:tex>):
    
    <fr:embedded-tex hash="120ca276e03c2c627c0c01aefff25d90"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \usetikzlibrary {arrows}
        \begin {tikzcd}
            &amp; {X\times _ZY} \\
            \\
            &amp; A \\
            X &amp;&amp; Y \\
            &amp; Z
            \arrow [&quot;f&quot;&apos;, from=3-2, to=4-1]
            \arrow [&quot;g&quot;, from=3-2, to=4-3]
            \arrow [&quot;t&quot;&apos;, from=4-1, to=5-2]
            \arrow [&quot;u&quot;, from=4-3, to=5-2]
            \arrow [&quot;{\exists !}&quot;, dashed, from=3-2, to=1-2]
            \arrow [&quot;{\pi _1}&quot;&apos;, bend right, from=1-2, to=4-1]
	        \arrow [&quot;{\pi _2}&quot;, bend left, from=1-2, to=4-3]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex>

    there exists a <fr:em>unique</fr:em> arrow <fr:tex display="inline">\langle  f,g \rangle _Z: A\to  X\times _Z Y</fr:tex> such that
    <fr:tex display="block">         \pi _1\circ \langle  f,g \rangle _Z = f \text { and } \pi _2\circ \langle  f,g \rangle _Z = g     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>448</fr:anchor><fr:addr type="user">math-0004</fr:addr><fr:route>math-0004.xml</fr:route><fr:title text="The Construction of {R}">The Construction of <fr:tex display="inline">\mathbb {R}</fr:tex></fr:title><fr:taxon>Math Analysis</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We start constructing <fr:tex display="inline">\mathbb {R}</fr:tex> from <fr:tex display="inline">\mathbb {Q}</fr:tex> by a way that it satisfies the existence theorem,
    the core of construction.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>449</fr:anchor><fr:addr type="user">thm-0003</fr:addr><fr:route>thm-0003.xml</fr:route><fr:title text="Existence theorem">Existence theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>There exists an ordered field <fr:tex display="inline">\mathbb {R}</fr:tex> that satisfies the <fr:link type="local" href="def-0012.xml" addr="def-0012" title="Least upper bound property">least upper bound property</fr:link>.
    Moreover <fr:tex display="inline">\mathbb {R}</fr:tex> contains <fr:tex display="inline">\mathbb {Q}</fr:tex> as a subfield.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The least-upper-bound property mentioned above is defined:</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>450</fr:anchor><fr:addr type="user">def-0012</fr:addr><fr:route>def-0012.xml</fr:route><fr:title text="Least upper bound property">Least upper bound property</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A set <fr:tex display="inline">S</fr:tex> has the least upper bound property if every non-empty subset <fr:tex display="inline">T</fr:tex> of <fr:tex display="inline">S</fr:tex> that is bounded above has a least upper bound <fr:tex display="inline">\sup  T</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Why do we need the least-upper-bound property?
    Consider the set <fr:tex display="inline">S = \{x \in  \mathbb {Q} | x^2 &lt; 2\}</fr:tex>.
    <fr:tex display="inline">S</fr:tex> is bounded above by <fr:tex display="inline">2</fr:tex>, but it does not have a least upper bound in <fr:tex display="inline">\mathbb {Q}</fr:tex>.
    Therefore we can&apos;t express <fr:tex display="inline">\sqrt {2}</fr:tex> in field <fr:tex display="inline">\mathbb {Q}</fr:tex> since some &quot;gaps&quot; exist.
    This fact motivates us to construct a more complete field <fr:tex display="inline">\mathbb {R}</fr:tex>.
    We have constructed <fr:tex display="inline">\mathbb {Q}</fr:tex> from <fr:tex display="inline">\mathbb {Z}</fr:tex>, and now we construct <fr:tex display="inline">\mathbb {R}</fr:tex> from <fr:tex display="inline">\mathbb {Q}</fr:tex>.</fr:p><fr:p>Then we should find a way to express &quot;<fr:tex display="inline">\sqrt {2}</fr:tex>&quot; using <fr:tex display="inline">\mathbb {Q}</fr:tex>.
    A crucial idea is <fr:strong>approximating</fr:strong> <fr:tex display="inline">\sqrt {2}</fr:tex> by a sequence of rational numbers.
    <fr:tex display="block">         \sqrt {2} := \{ p^2&lt;2 \lor  p&lt;0, p\in \mathbb {Q} \}     </fr:tex>
    We can cut the number axis into two pieces by <fr:tex display="inline">\sqrt {2}</fr:tex>, such cut is called a <fr:strong>Dedekind cut</fr:strong>. 
    A cut should be well-defined rather than just an intuitive concept.</fr:p><fr:p>As we use set theory to construct <fr:tex display="inline">\mathbb {R}</fr:tex>, it motivates us to define Dedekind cut as a set.
    It should satisfies some properties:
    <fr:ul><fr:li>Can&apos;t be empty or the whole <fr:tex display="inline">\mathbb {Q}</fr:tex></fr:li>
        <fr:li>Closed downward</fr:li>
        <fr:li>Contains not the largest number</fr:li></fr:ul>
    A formal definition is given below:</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>451</fr:anchor><fr:addr type="user">def-0013</fr:addr><fr:route>def-0013.xml</fr:route><fr:title text="Dedekind cuts">Dedekind cuts</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A Dedekind cut is a partition of the rationals <fr:tex display="inline">\mathbb {Q}</fr:tex> into two non-empty sets <fr:tex display="inline">L</fr:tex> and <fr:tex display="inline">R</fr:tex> such that:
    <fr:ul><fr:li><fr:tex display="inline">L\neq \emptyset </fr:tex></fr:li>
        <fr:li><fr:tex display="inline">R\neq \emptyset </fr:tex></fr:li>
        <fr:li>if <fr:tex display="inline">x,y\in \mathbb {Q}, x&lt;y</fr:tex> and <fr:tex display="inline">y\in  L</fr:tex> then <fr:tex display="inline">x\in  L</fr:tex></fr:li>
        <fr:li>if <fr:tex display="inline">p\in  L</fr:tex> then exists <fr:tex display="inline">q\in  L</fr:tex> such that <fr:tex display="inline">p&lt;q</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now we can defined the real number as a set of Dedekind cuts.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>452</fr:anchor><fr:addr type="user">def-0014</fr:addr><fr:route>def-0014.xml</fr:route><fr:title text="Real Number System">Real Number System</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The element of <fr:tex display="inline">\mathbb {R}</fr:tex> is a <fr:link type="local" href="def-0013.xml" addr="def-0013" title="Dedekind cuts">Dedekind Cut</fr:link> in <fr:tex display="inline">\mathbb {Q}</fr:tex>.
    <fr:tex display="block">         \mathbb {R} := \{ L | (L,R) \text { is a Dedekind Cut} \}     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now define the order relation on <fr:tex display="inline">\mathbb {R}</fr:tex>.
    We have defined <fr:tex display="inline">\mathbb {R}</fr:tex> as the set of Dedekind cuts, so we can define the strict partial order relation <fr:tex display="inline">&lt;</fr:tex> on <fr:tex display="inline">\mathbb {R}</fr:tex> by the set operation <fr:tex display="inline">\subset </fr:tex>.
    The irreflexive, asymmetric and transitive properties are trivial.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>453</fr:anchor><fr:addr type="user">math-0001</fr:addr><fr:route>math-0001.xml</fr:route><fr:title text="Introduction to Vector Space">Introduction to Vector Space</fr:title><fr:taxon>Linear Algebra</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This note introduces the concept of vector space.
    Refer to <fr:link type="local" href="linear-algebra-2015.xml" addr="linear-algebra-2015" title="Linear Algebra Done Right">Linear Algebra Done Right</fr:link>.</fr:p><fr:p>The motivation for the definition of a vector space comes from the properties
    of vectors in Euclidean space <fr:tex display="inline">\mathbb {R}^n</fr:tex> and <fr:tex display="inline">\mathbb {C}^n</fr:tex>.
    The definition abstracts and generalizes these properties.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>454</fr:anchor><fr:addr type="user">def-000H</fr:addr><fr:route>def-000H.xml</fr:route><fr:title text="Vector Space">Vector Space</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A vector space over a <fr:link type="local" href="def-0006.xml" addr="def-0006" title="Field">field</fr:link> <fr:tex display="inline">F</fr:tex> is a non-empty set <fr:tex display="inline">V</fr:tex> together with a binary operation and a binary function that satisfy the axioms listed below. 
    In this context, the elements of <fr:tex display="inline">V</fr:tex> are commonly called <fr:strong>vectors</fr:strong>, and the elements of <fr:tex display="inline">F</fr:tex> are called <fr:strong>scalars</fr:strong>.
    <fr:ul><fr:li>Commutativity: <fr:tex display="inline">             \forall  x, y \in  V, x + y = y + x         </fr:tex></fr:li>
        <fr:li>Associativity: <fr:tex display="inline">             \forall  x, y, z \in  V, (x + y) + z = x + (y + z)         </fr:tex></fr:li>
        <fr:li>Additive Identity: <fr:tex display="inline">             \exists  0 \in  V \text { such that } \forall  x \in  V, x + 0 = x         </fr:tex></fr:li>
        <fr:li>Multiplicative Identity: <fr:tex display="inline">             \forall  x \in  V, 1x = x         </fr:tex></fr:li>
        <fr:li>Additive Inverse: <fr:tex display="inline">             \forall  x \in  V, \exists  y \in  V \text { such that } x + y = 0         </fr:tex></fr:li>
        <fr:li>Distributivity: <fr:tex display="inline">             \forall  x, y \in  V, \forall  c, d \in  F, c(x + y) = cx + cy, (c + d)x = cx + dx         </fr:tex></fr:li></fr:ul></fr:p><fr:p>Elements of a vector space are called <fr:strong>vectors</fr:strong> or <fr:strong>points</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>When dealing with vector spaces, we usually interested only in subspaces.
    And the union of subspaces is rarely a subspace, thus
    we are more interested with sums of subspaces.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>455</fr:anchor><fr:addr type="user">def-000I</fr:addr><fr:route>def-000I.xml</fr:route><fr:title text="Linear Subspace">Linear Subspace</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A subset <fr:tex display="inline">U</fr:tex> of a vector space <fr:tex display="inline">V</fr:tex> over a field <fr:tex display="inline">F</fr:tex> is called a <fr:strong>subspace</fr:strong> of <fr:tex display="inline">V</fr:tex> if <fr:tex display="inline">U</fr:tex> is itself a <fr:strong>vector space</fr:strong> over <fr:tex display="inline">F</fr:tex> with the operations of addition and scalar multiplication on <fr:tex display="inline">V</fr:tex>.
    The subset also satisfies the following axioms (vice versa):
    <fr:ul><fr:li>Additive identity: <fr:tex display="inline">0\in  U</fr:tex></fr:li>
        <fr:li>Closure: <fr:tex display="inline">\forall  u,v\in  U, u+v\in  U</fr:tex></fr:li>
        <fr:li>Closed Scalar multiplication: <fr:tex display="inline">\forall  u\in  U, \forall  c\in  F, cu\in  U</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>After that we can define the sum of subsets.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>456</fr:anchor><fr:addr type="user">def-000J</fr:addr><fr:route>def-000J.xml</fr:route><fr:title text="Sum of subsets">Sum of subsets</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">U_1, \dots , U_n</fr:tex> be subsets of a vector space <fr:tex display="inline">V</fr:tex>.
    The <fr:strong>sum</fr:strong> of <fr:tex display="inline">U_1, \dots , U_n</fr:tex> is defined as
    <fr:tex display="block">U_1 + \dots  + U_n = \{u_1 + \dots  + u_n \mid  u_i \in  U_i\}</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The sum of subspaces is the smallest subspace that contains all the subspaces.</fr:p><fr:p>Every element in <fr:tex display="inline">U_1 + \dots  + U_n</fr:tex> can be written as a sum of elements <fr:tex display="inline">u_i</fr:tex> in <fr:tex display="inline">U_i</fr:tex>:
    <fr:tex display="block">         u_1+\cdots +u_n     </fr:tex>
    We will interested in cases where each vector in <fr:tex display="inline">U_1 + \dots  + U_n</fr:tex> can be represented in the form above
    in only one way. This leads to the definition of direct sum.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>457</fr:anchor><fr:addr type="user">def-000K</fr:addr><fr:route>def-000K.xml</fr:route><fr:title text="Direct Sum">Direct Sum</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">U_1, \dots , U_n</fr:tex> be subspaces of a vector space <fr:tex display="inline">V</fr:tex>.
    The <fr:strong>direct sum</fr:strong> of <fr:tex display="inline">U_1, \dots , U_n</fr:tex> is defined as
    <fr:tex display="block">         U_1 \oplus  \dots  \oplus  U_n = \{u_1 + \dots  + u_n \mid  u_i \in  U_i\}     </fr:tex>
    if every element in <fr:tex display="inline">U_1 \oplus  \dots  \oplus  U_n</fr:tex> can be written as <fr:tex display="inline">u_1 + \dots  + u_n </fr:tex> in only one way.
    This definition requires every vector in the sum have a unique representation.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>458</fr:anchor><fr:addr type="user">math-0002</fr:addr><fr:route>math-0002.xml</fr:route><fr:title text="Finite Dimensional Vector Space">Finite Dimensional Vector Space</fr:title><fr:taxon>Linear Algebra</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This note introduces the concept of finite-dimensional vector space.
    Refer to <fr:link type="local" href="linear-algebra-2015.xml" addr="linear-algebra-2015" title="Linear Algebra Done Right">Linear Algebra Done Right</fr:link>.</fr:p><fr:p>Adding up scalar mulitples of vectors in a list gives a linear combination.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>459</fr:anchor><fr:addr type="user">def-000L</fr:addr><fr:route>def-000L.xml</fr:route><fr:title text="Linear Combination">Linear Combination</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">V</fr:tex> be a <fr:link type="local" href="def-000H.xml" addr="def-000H" title="Vector Space">vector space</fr:link> over a field <fr:tex display="inline">F</fr:tex>.
    Let <fr:tex display="inline">v_1, \dots , v_n</fr:tex> be vectors in <fr:tex display="inline">V</fr:tex>.
    A <fr:strong>linear combination</fr:strong> of <fr:tex display="inline">v_1, \dots , v_n</fr:tex> is an expression of the form
    <fr:tex display="block">         a_1 v_1 + \dots  + a_n v_n     </fr:tex>
    where <fr:tex display="inline">a_1, \dots , a_n \in  F</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>To talk about a structure, we usually define a collection of this structure.
    Hence we have span for linear combinations.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>460</fr:anchor><fr:addr type="user">def-000M</fr:addr><fr:route>def-000M.xml</fr:route><fr:title text="Linear Span">Linear Span</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">V</fr:tex> be a vector space over a field <fr:tex display="inline">F</fr:tex>.
    Let <fr:tex display="inline">v_1, \dots , v_n</fr:tex> be vectors in <fr:tex display="inline">V</fr:tex>.
    The <fr:strong>span</fr:strong> of <fr:tex display="inline">v_1, \dots , v_n</fr:tex> is defined as
    <fr:tex display="block">         \text {span}(v_1, \dots , v_n) = \{a_1 v_1 + \dots  + a_n v_n \mid  a_i \in  F\}     </fr:tex>
    The span of empty set is defined to be <fr:tex display="inline">\{0\}</fr:tex>.</fr:p><fr:p>If <fr:tex display="inline">\text {span}(v_1, \dots , v_n) = V</fr:tex>, we say that <fr:tex display="inline">v_1, \dots , v_n</fr:tex> <fr:strong>spans</fr:strong> <fr:tex display="inline">V</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Suppose we have span <fr:tex display="inline">S=\text {span}(v_1, \dots , v_n)</fr:tex>. (Span is trivially a subspace.)
    Obviously for all <fr:tex display="inline">v_j (1 \leq  j \leq  n)</fr:tex>, <fr:tex display="inline">v_j \in  S</fr:tex>.
    Because subspaces are closed under scalar multiplication and addition, every
    subspace of <fr:tex display="inline">V</fr:tex> containing <fr:tex display="inline">v_1, \dots , v_n</fr:tex> must contain <fr:tex display="inline">S</fr:tex>.
    Thus we conclude that <fr:tex display="inline">S</fr:tex> is the smallest subspace containing <fr:tex display="inline">v_1, \dots , v_n</fr:tex>.</fr:p><fr:p>The discussion about <fr:strong>spans</fr:strong> leads to a key definition in linear algebra.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>461</fr:anchor><fr:addr type="user">def-000N</fr:addr><fr:route>def-000N.xml</fr:route><fr:title text="Finite-Dimensional Vector Space">Finite-Dimensional Vector Space</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link type="local" href="def-000H.xml" addr="def-000H" title="Vector Space">vector space</fr:link> <fr:tex display="inline">V</fr:tex> is called <fr:strong>finite-dimensional</fr:strong> if some <fr:link type="local" href="def-000G.xml" addr="def-000G" title="List">list</fr:link> of vectors <fr:tex display="inline">v_1, \dots , v_n</fr:tex> <fr:link type="local" href="def-000M.xml" addr="def-000M" title="Linear Span">spans</fr:link> <fr:tex display="inline">V</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The opposite of finite-dimensional is infinite-dimensional.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>462</fr:anchor><fr:addr type="user">def-000O</fr:addr><fr:route>def-000O.xml</fr:route><fr:title text="Infinite-dimensional vector space">Infinite-dimensional vector space</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A vector space <fr:tex display="inline">V</fr:tex> is called <fr:strong>infinite-dimensional</fr:strong> if it is not <fr:link type="local" href="def-000N.xml" addr="def-000N" title="Finite-Dimensional Vector Space">finite-dimensional</fr:link>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Consider the situation that there is only one way to
    express a vector <fr:tex display="inline">v</fr:tex> as a linear combination of vectors in a list <fr:tex display="inline">v_1, \dots , v_n</fr:tex>.
    What property of the list <fr:tex display="inline">v_1, \dots , v_n</fr:tex> does this situation imply? The answer is
    linear independence.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>463</fr:anchor><fr:addr type="user">def-000P</fr:addr><fr:route>def-000P.xml</fr:route><fr:title text="Linearly independent">Linearly independent</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A set of vectors <fr:tex display="inline">\{v_1, \dots , v_n\}</fr:tex> is called <fr:strong>linearly independent</fr:strong> if
    <fr:tex display="block">a_1 v_1 + \dots  + a_n v_n = 0</fr:tex>
    implies that <fr:tex display="inline">a_1 = \dots  = a_n = 0</fr:tex>.
    The trivial case of <fr:tex display="inline">\{0\}</fr:tex> is also considered linearly independent.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>If some vectors are not linearly independent, then there are more than one way to
    express a vector as a linear combination of vectors in the list. This leads to 
    the following definition.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>464</fr:anchor><fr:addr type="user">def-000Q</fr:addr><fr:route>def-000Q.xml</fr:route><fr:title text="Linearly dependent">Linearly dependent</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A set of vectors <fr:tex display="inline">\{v_1, \dots , v_n\}</fr:tex> is called <fr:strong>linearly dependent</fr:strong> if
    <fr:tex display="block">a_1 v_1 + \dots  + a_n v_n = 0</fr:tex>
    for some <fr:tex display="inline">a_1, \dots , a_n \in  \mathbb {F}</fr:tex> with at least one <fr:tex display="inline">a_i \neq  0</fr:tex> (not all <fr:tex display="inline">0</fr:tex>).</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The following lemma is a direct consequence of the definition of linear independence.
    It states that for a given linearly dependent list, we can always remove a vector
    without changing the span.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>465</fr:anchor><fr:addr type="user">thm-0001</fr:addr><fr:route>thm-0001.xml</fr:route><fr:title text="Linear Dependence Lemma">Linear Dependence Lemma</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">v_1, \dots , v_n</fr:tex> be vectors in a vector space <fr:tex display="inline">V</fr:tex> over a field <fr:tex display="inline">\mathbb {F}</fr:tex>.
    If <fr:tex display="inline">v_1, \dots , v_n</fr:tex> are linearly dependent, then there exists <fr:tex display="inline">1 \leq  i \leq  n</fr:tex> such that
    <fr:ul><fr:li><fr:tex display="inline">v_i \in  \text {span}(v_1, \dots , v_{i-1})</fr:tex></fr:li>
        <fr:li>Remove <fr:tex display="inline">v_i</fr:tex> from the list <fr:tex display="inline">v_1, \dots , v_n</fr:tex> and the span does not change</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>466</fr:anchor><fr:addr type="user">thm-0002</fr:addr><fr:route>thm-0002.xml</fr:route><fr:title text="Length of linearly independent list  length of spanning list">Length of linearly independent list <fr:tex display="inline">\leq </fr:tex> length of spanning list</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In a finite dimensional vector space, the length of a linearly independent list is less than or equal to the length of a spanning list.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We have discussed linear independent lists and spanning lists.
    Now we are ready to define a basis.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>467</fr:anchor><fr:addr type="user">def-000R</fr:addr><fr:route>def-000R.xml</fr:route><fr:title text="Basis">Basis</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A basis of <fr:tex display="inline">V</fr:tex> is a list of vectors in <fr:tex display="inline">V</fr:tex>
    that is linearly independent and spans <fr:tex display="inline">V</fr:tex>.</fr:p><fr:p><fr:strong>Criterion for basis</fr:strong>
    A list of vectors <fr:tex display="inline">\{v_1, \dots , v_n\}</fr:tex> is a basis of <fr:tex display="inline">V</fr:tex> if and only if
    every <fr:tex display="inline">v \in  V</fr:tex> can be written <fr:strong>uniquely</fr:strong> as a linear combination of <fr:tex display="inline">v_1, \dots , v_n</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>For instance, we have standard basis <fr:tex display="inline">\{e_1, \dots , e_n\}</fr:tex> for <fr:tex display="inline">\mathbb {F}^n</fr:tex>,
    where <fr:tex display="inline">e_i</fr:tex> is the vector with <fr:tex display="inline">1</fr:tex> at <fr:tex display="inline">i</fr:tex>-th position and <fr:tex display="inline">0</fr:tex> elsewhere.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>468</fr:anchor><fr:addr type="user">thm-0005</fr:addr><fr:route>thm-0005.xml</fr:route><fr:title text="Spanning List contains a basis">Spanning List contains a basis</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Every spanning list in a vector space can be reduced to a basis.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>From the <fr:link type="local" href="thm-0005.xml" addr="thm-0005" title="Spanning List contains a basis">theorem</fr:link> we can infer a corollary.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>469</fr:anchor><fr:addr type="user">thm-0006</fr:addr><fr:route>thm-0006.xml</fr:route><fr:title text="Basis of finite-dimensional vector space">Basis of finite-dimensional vector space</fr:title><fr:taxon>Corollary</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Every finite-dimensional vector space has a basis.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The next result states for a spanning list can be reduced to a basis.
    We can adjoin one or more vectors to a linearly independent list to form a basis.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>470</fr:anchor><fr:addr type="user">thm-0007</fr:addr><fr:route>thm-0007.xml</fr:route><fr:title text="Linearly dependent list extends to a basis">Linearly dependent list extends to a basis</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Every linearly independent list of vectors in  a finite-dimensional vector space can be extended to a basis.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Remind the definition of <fr:link type="external" href="der-000K">direct sum</fr:link>, we can now show that
    every subspace of a finite-dimensional vecrtor space can be paired
    with another subspace to form a direct sum of the whole space.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>471</fr:anchor><fr:addr type="user">thm-0008</fr:addr><fr:route>thm-0008.xml</fr:route><fr:title text="Direct Sum of Subspaces of V">Direct Sum of Subspaces of <fr:tex display="inline">V</fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose <fr:tex display="inline">V</fr:tex> is a finite dimensional vector space,
    and <fr:tex display="inline">U</fr:tex> is a subspace of <fr:tex display="inline">V</fr:tex>.
    Then there exists a subspace <fr:tex display="inline">W</fr:tex> of <fr:tex display="inline">V</fr:tex> such that
    <fr:tex display="inline">V = U \oplus  W</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>This post discusses about <fr:em>finite-dimensional vector space</fr:em>.
    But we have not yet defined what is dimension.
    We tempted to define the dimension as the length of basis intuitively.
    With this definition we should prove its well-definedness.
    That is, every basis has the same length.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>472</fr:anchor><fr:addr type="user">thm-0009</fr:addr><fr:route>thm-0009.xml</fr:route><fr:title text="Basis length is invariant">Basis length is invariant</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">V</fr:tex> be a finite-dimensional vector space.
    Then every basis of <fr:tex display="inline">V</fr:tex> has the same length.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>This can be proved by <fr:link type="local" href="thm-0002.xml" addr="thm-0002" title="Length of linearly independent list  length of spanning list">Lemma 8</fr:link>.
    Now we can formally define the dimension of such spaces.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>473</fr:anchor><fr:addr type="user">def-001V</fr:addr><fr:route>def-001V.xml</fr:route><fr:title text="Dimension">Dimension</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>dimension</fr:strong> of a finite-dimensional vector space <fr:tex display="inline">V</fr:tex> is the length of any basis of the vector space.
    Denoted by <fr:tex display="inline">\dim  V</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Every subspace of a finite-dimensional vector space is also finite-dimensional.
    Hence we can talk about the dimension of a subspace.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>474</fr:anchor><fr:addr type="user">thm-000A</fr:addr><fr:route>thm-000A.xml</fr:route><fr:title text="Dimension of a subspace">Dimension of a subspace</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">V</fr:tex> be a finite-dimensional vector space,
    and <fr:tex display="inline">U</fr:tex> be a subspace of <fr:tex display="inline">V</fr:tex>.
    Then <fr:tex display="inline">\dim  U \leq  \dim  V</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>According to the definition of <fr:link type="local" href="def-000P.xml" addr="def-000P" title="Linearly independent">linearly independent</fr:link>,
    to show a list of vectors is a basis, we only need to show it is linearly independent,
    and it spans the whole space.
    The next theorems simplifies the task:</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>475</fr:anchor><fr:addr type="user">thm-000B</fr:addr><fr:route>thm-000B.xml</fr:route><fr:title text="Linearly independent list of the right length is a basis">Linearly independent list of the right length is a basis</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">V</fr:tex> be a finite-dimensional vector space.
    Then every <fr:link type="local" href="def-000P.xml" addr="def-000P" title="Linearly independent">linearly independent</fr:link> list of vectors in <fr:tex display="inline">V</fr:tex> with length equal to <fr:tex display="inline">\dim  V</fr:tex> is a basis of <fr:tex display="inline">V</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>476</fr:anchor><fr:addr type="user">thm-000C</fr:addr><fr:route>thm-000C.xml</fr:route><fr:title text="Spanning list of the right length is a basis">Spanning list of the right length is a basis</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">V</fr:tex> be a finite-dimensional vector space.
    Then every <fr:link type="local" href="def-000M.xml" addr="def-000M" title="Linear Span">spanning</fr:link> list of vectors in <fr:tex display="inline">V</fr:tex> with length equal to <fr:tex display="inline">\dim  V</fr:tex> is a basis of <fr:tex display="inline">V</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now we move to the discussion of the dimension of the sum of two subspaces.
    This is analogous to the <fr:link type="local" href="thm-000E.xml" addr="thm-000E" title="Inclusion-Exclusion Principle">inclusion-exclusion principle</fr:link>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>477</fr:anchor><fr:addr type="user">thm-000D</fr:addr><fr:route>thm-000D.xml</fr:route><fr:title text="Dimension of a sum">Dimension of a sum</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">V</fr:tex> be a finite-dimensional vector space,
    and <fr:tex display="inline">U</fr:tex> and <fr:tex display="inline">W</fr:tex> be subspaces of <fr:tex display="inline">V</fr:tex>.
    Then
    <fr:tex display="block">         \dim (U + W) = \dim  U + \dim  W - \dim (U \cap  W).     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>478</fr:anchor><fr:addr type="user">math-0005</fr:addr><fr:route>math-0005.xml</fr:route><fr:title text="Linear Maps">Linear Maps</fr:title><fr:taxon>Linear Algebra</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>31</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This note introduces the concept of linear maps.
    Refer to <fr:link type="local" href="linear-algebra-2015.xml" addr="linear-algebra-2015" title="Linear Algebra Done Right">Linear Algebra Done Right</fr:link>.</fr:p><fr:p>Now we arrive at the main topic of this chapter: linear maps. 
    In classic mathematics, to understand the properties of the structure or space,
    we often study the maps between them.
    For vector spaces we study the <fr:strong>linear maps</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>479</fr:anchor><fr:addr type="user">def-0025</fr:addr><fr:route>def-0025.xml</fr:route><fr:title text="Linear Map">Linear Map</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>linear map</fr:strong> is a function between two vector spaces that preserves the operations of addition and scalar multiplication.
    In other words, a function <fr:tex display="inline">T: V \to  W</fr:tex> where <fr:tex display="inline">V,W</fr:tex> are vector spaces if the following conditions are satisfied:
    <fr:ul><fr:li>Additivity: <fr:tex display="inline">T(u+v) = T(u) + T(v)</fr:tex> for all <fr:tex display="inline">u,v \in  V</fr:tex></fr:li>
        <fr:li>Homogeneity: <fr:tex display="inline">T(\alpha  v) = \alpha  T(v)</fr:tex> for all <fr:tex display="inline">\alpha  \in  \mathbb {F}</fr:tex> and <fr:tex display="inline">v \in  V</fr:tex></fr:li></fr:ul>
    Sometimes we ignore the brackets and write <fr:tex display="inline">T v</fr:tex> instead of <fr:tex display="inline">T(v)</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now we can talk about the set of all linear maps between two vector spaces.
    <fr:tex display="block">         \mathcal {L}(V,W) = \{  T: V \to  W | T \text { is a linear map} \}     </fr:tex></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>480</fr:anchor><fr:addr type="user">eg-0002</fr:addr><fr:route>eg-0002.xml</fr:route><fr:title text="Differentiation is linear map">Differentiation is linear map</fr:title><fr:taxon>Example</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Define <fr:tex display="inline">D\in \mathcal {L}(\mathcal {P}(\mathbb {R}),\mathcal {P}(\mathbb {R}))</fr:tex> (recall that <fr:tex display="inline">\mathcal {P}</fr:tex> means <fr:link type="local" href="def-0027.xml" addr="def-0027" title="Polynomial">set of polynomials</fr:link>) by
    <fr:tex display="block">         D(f) = f&apos;     </fr:tex>
    We can see that <fr:tex display="inline">D</fr:tex> a linear map.
    <fr:ul><fr:li>Additivity: <fr:tex display="inline">D(f+g) = (f+g)&apos; = f&apos; + g&apos; = D(f) + D(g)</fr:tex></fr:li>
        <fr:li>Homogeneity: <fr:tex display="inline">D(\alpha  f) = (\alpha  f)&apos; = \alpha  f&apos; = \alpha  D(f)</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>481</fr:anchor><fr:addr type="user">eg-0003</fr:addr><fr:route>eg-0003.xml</fr:route><fr:title text="Integration is linear map">Integration is linear map</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">V</fr:tex> be the vector space of all continuous functions on the interval <fr:tex display="inline">[a,b]</fr:tex>.
    The map <fr:tex display="inline">I: V \to  V</fr:tex> defined by
    <fr:tex display="block">         I(f) = \int _a^x f(t) dt     </fr:tex>
    is a <fr:strong>linear map</fr:strong>.
    In other words, <fr:tex display="inline">I</fr:tex> preserves the operations of addition and scalar multiplication:
    For all <fr:tex display="inline">f,g \in  V</fr:tex> and all <fr:tex display="inline">\alpha  \in  \mathbb {R}</fr:tex>,
    <fr:tex display="block">         I(f+g) = I(f) + I(g) \quad  \text {and} \quad  I(\alpha  f) = \alpha  I(f)     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We can find a linear map that takes on <fr:em>whatever values we wish</fr:em> on the 
    vectors in a basis by the following theorem.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>482</fr:anchor><fr:addr type="user">thm-000F</fr:addr><fr:route>thm-000F.xml</fr:route><fr:title text="Linear maps and basis of domain">Linear maps and basis of domain</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">v_1, v_2, \ldots , v_n</fr:tex> be a basis of vector space <fr:tex display="inline">V</fr:tex>.
    Then for any vector space <fr:tex display="inline">W</fr:tex> and any vectors <fr:tex display="inline">w_1, w_2, \ldots , w_n</fr:tex> in <fr:tex display="inline">W</fr:tex>,
    there exists a unique linear map <fr:tex display="inline">T: V \to  W</fr:tex> such that
    <fr:tex display="block">         T(v_i) = w_i \quad  \text {for all} \quad  i = 1,2,\ldots ,n     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now let&apos;s turn to the algebraic operations over the set of linear maps <fr:tex display="inline">\mathcal {L}(V,W)</fr:tex>.
    We begin by defining the addition and scalar multiplication of linear maps.
    This leads to a surprising result: the set of linear maps is actually a vector space.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>483</fr:anchor><fr:addr type="user">def-0029</fr:addr><fr:route>def-0029.xml</fr:route><fr:title text="Addition and scalar multiplication over {L}(V,W)">Addition and scalar multiplication over <fr:tex display="inline">\mathcal {L}(V,W)</fr:tex></fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">T_1, T_2 \in  \mathcal {L}(V,W)</fr:tex>.
    We define the <fr:strong>addition</fr:strong> of <fr:tex display="inline">T_1</fr:tex> and <fr:tex display="inline">T_2</fr:tex> as the linear map <fr:tex display="inline">T_1 + T_2: V \to  W</fr:tex> such that
    <fr:tex display="block">         (T_1 + T_2)(v) = T_1(v) + T_2(v) \quad  \text {for all} \quad  v \in  V     </fr:tex>
    The scalar multiplication of a linear map <fr:tex display="inline">T \in  \mathcal {L}(V,W)</fr:tex> by a scalar <fr:tex display="inline">c \in  \mathbb {F}</fr:tex> is the linear map <fr:tex display="inline">cT: V \to  W</fr:tex> such that
    <fr:tex display="block">         (cT)(v) = cT(v) \quad  \text {for all} \quad  v \in  V     </fr:tex>
    With these operations, <fr:tex display="inline">\mathcal {L}(V,W)</fr:tex> is a <fr:link type="local" href="def-000H.xml" addr="def-000H" title="Vector Space"><fr:strong>vector space</fr:strong></fr:link> over the field <fr:tex display="inline">\mathbb {F}</fr:tex>.
    Note that the additive identity of <fr:tex display="inline">\mathcal {L}(V,W)</fr:tex> is the <fr:strong>zero map</fr:strong> <fr:tex display="inline">0: V \to  W</fr:tex> such that
    <fr:tex display="block">         0(v) = 0 \quad  \text {for all} \quad  v \in  V     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Usually it makes no sense to multiply two linear maps. But we can define
    an operation called the <fr:strong>product</fr:strong> of linear maps, which is just the composition of the two functions.
    This can form a <fr:strong>monoid</fr:strong> or even a <fr:strong>group</fr:strong> under certain conditions.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>484</fr:anchor><fr:addr type="user">def-002A</fr:addr><fr:route>def-002A.xml</fr:route><fr:title text="Product of Linear Maps">Product of Linear Maps</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">T_1: V \to  W</fr:tex> and <fr:tex display="inline">T_2: W \to  U</fr:tex> be linear maps.
    We define the <fr:strong>product</fr:strong> of <fr:tex display="inline">T_1</fr:tex> and <fr:tex display="inline">T_2</fr:tex> as the linear map <fr:tex display="inline">T_2 \circ  T_1: V \to  U</fr:tex> such that
    <fr:tex display="block">         (T_2 \circ  T_1)(v) = T_2(T_1(v)) \quad  \text {for all} \quad  v \in  V     </fr:tex>
    Note that this is just the composition of the two functions <fr:tex display="inline">T_1</fr:tex> and <fr:tex display="inline">T_2</fr:tex>. 
    And we usually denote <fr:tex display="inline">T_2 \circ  T_1</fr:tex> by <fr:tex display="inline">T_2T_1</fr:tex>.
    The product of linear maps is associative, that is,
    <fr:tex display="block">         (T_3 \circ  T_2) \circ  T_1 = T_3 \circ  (T_2 \circ  T_1)     </fr:tex>
    for any linear maps <fr:tex display="inline">T_1: V \to  W</fr:tex>, <fr:tex display="inline">T_2: W \to  U</fr:tex>, and <fr:tex display="inline">T_3: U \to  X</fr:tex>.
    The identity map <fr:tex display="inline">I_V: V \to  V</fr:tex> is the identity element of the set of linear maps <fr:tex display="inline">\mathcal {L}(V,V)</fr:tex> under the product operation.
    That is, for any linear map <fr:tex display="inline">T: V \to  V</fr:tex>,
    <fr:tex display="block">         I_V \circ  T = T \circ  I_V = T     </fr:tex>
    where <fr:tex display="inline">I_V</fr:tex> is the identity map on <fr:tex display="inline">V</fr:tex>.
    The set of all linear maps from a vector space to itself, <fr:tex display="inline">\mathcal {L}(V,V)</fr:tex>, forms a <fr:link type="local" href="def-0007.xml" addr="def-0007" title="Monoid"><fr:strong>monoid</fr:strong></fr:link> under the product operation.
    The set of all invertible linear maps from a vector space to itself, <fr:tex display="inline">\mathcal {L}(V,V)^*</fr:tex>, forms a group under the product operation.
    The identity map is the identity element of the <fr:link type="local" href="def-0001.xml" addr="def-0001" title="Group"><fr:strong>group</fr:strong></fr:link> <fr:tex display="inline">\mathcal {L}(V,V)^*</fr:tex>.</fr:p><fr:p>With addition we also have the distributive law for the product of linear maps.
    That is, for any linear maps <fr:tex display="inline">S,S_1,S_2: V \to  W</fr:tex> and <fr:tex display="inline">T,T_1,T_2: U\to  V</fr:tex>:
    <fr:tex display="block">         (S_1 + S_2)T = S_1T + S_2T \quad  \text {and} \quad  T(S_1 + S_2) = TS_1 + TS_2     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>In algebra, we have a structure named <fr:strong>kernel</fr:strong>, which is the set of all elements that are mapped to the zero element.
    For linear maps, the kernel is the <fr:strong>null space</fr:strong></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>485</fr:anchor><fr:addr type="user">def-002C</fr:addr><fr:route>def-002C.xml</fr:route><fr:title text="Null Space">Null Space</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For <fr:tex display="inline">T: V \to  W</fr:tex>, the <fr:strong>null space</fr:strong> of <fr:tex display="inline">T</fr:tex> is the set of all vectors in <fr:tex display="inline">V</fr:tex> that are mapped to <fr:tex display="inline">0</fr:tex> in <fr:tex display="inline">W</fr:tex>.
    <fr:tex display="block">         \text {null } T = \{ v \in  V | T(v) = 0 \}     </fr:tex>
    The null space of <fr:tex display="inline">T</fr:tex> is a subspace of <fr:tex display="inline">V</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The injective linear map is defined like normal <fr:link type="local" href="def-002D.xml" addr="def-002D" title="Injective">injective</fr:link> functions.
    To check whether a linear map is injective, we can just check whether the null space is trivial.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>486</fr:anchor><fr:addr type="user">thm-000G</fr:addr><fr:route>thm-000G.xml</fr:route><fr:title text="Injectivity equivalent to Kernel Triviality">Injectivity equivalent to Kernel Triviality</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">T: V \to  W</fr:tex> be a linear map. Then <fr:tex display="inline">T</fr:tex> is injective if and only if <fr:tex display="inline">\text {null } T = \{ 0 \}</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The image of a linear map is the set of all elements that are mapped to by some element in the domain.
    This is called the <fr:strong>range</fr:strong> of the linear map, just like <fr:link type="local" href="def-002E.xml" addr="def-002E" title="Range">range</fr:link> of normal function.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>487</fr:anchor><fr:addr type="user">thm-000H</fr:addr><fr:route>thm-000H.xml</fr:route><fr:title text="Range is a subspace">Range is a subspace</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex display="inline">T: V \to  W</fr:tex> is a linear map, then the range of <fr:tex display="inline">T</fr:tex> is a subspace of <fr:tex display="inline">W</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The next theorem plays a crucial role in the study of linear maps.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>488</fr:anchor><fr:addr type="user">thm-000I</fr:addr><fr:route>thm-000I.xml</fr:route><fr:title text="Fundamental Theorems of Linear Maps">Fundamental Theorems of Linear Maps</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">V</fr:tex> be finite-dimensional vector space and <fr:tex display="inline">T : V \to  W</fr:tex> be a linear map. 
    Then <fr:tex display="inline">\text {range } T</fr:tex> is finite-dimensional and 
    <fr:tex display="block">         \dim  V = \dim  \text {range } T + \dim  \text {null } T     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now we can show that no linear map from a finite-dimensional vector space
    to a <fr:em>smaller</fr:em> (In dimension) vector space can be <fr:link type="local" href="def-002D.xml" addr="def-002D" title="Injective">injective</fr:link>.
    This can be easily proved by the fundamental theorem of linear maps.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>489</fr:anchor><fr:addr type="user">thm-000M</fr:addr><fr:route>thm-000M.xml</fr:route><fr:title text="Map to smaller dimension is not injective">Map to smaller dimension is not injective</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">V</fr:tex> and <fr:tex display="inline">W</fr:tex> be finite-dimensional vector spaces, 
    and <fr:tex display="inline">\dim  V &gt; \dim  W</fr:tex>.
    Then no linear map <fr:tex display="inline">T:V\to  W</fr:tex> is injective.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Similarly, we can show that no linear map from a finite-dimensional vector space
    to a <fr:em>larger</fr:em> (In dimension) vector space can be <fr:link type="local" href="def-002F.xml" addr="def-002F" title="Surjective">surjective</fr:link>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>490</fr:anchor><fr:addr type="user">thm-000N</fr:addr><fr:route>thm-000N.xml</fr:route><fr:title text="Map to bigger dimension is not surjective">Map to bigger dimension is not surjective</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">V</fr:tex> and <fr:tex display="inline">W</fr:tex> be finite-dimensional vector spaces, 
    and <fr:tex display="inline">\dim  V &lt; \dim  W</fr:tex>.
    Then no linear map <fr:tex display="inline">T:V\to  W</fr:tex> is surjective.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>These two lemmas are very important in the study of linear equations.
    The idea here is to express linear equations system in terms of linear maps.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>491</fr:anchor><fr:addr type="user">eg-0004</fr:addr><fr:route>eg-0004.xml</fr:route><fr:title text="Homogeneous Linear Equations System">Homogeneous Linear Equations System</fr:title><fr:taxon>Example</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Reprase in terms of a linear map the question of whether a <fr:link type="local" href="def-002Q.xml" addr="def-002Q" title="Homogeneous Linear Equations">homogeneous system linear equations</fr:link> has a nonzero solution.</fr:p><fr:p>Let <fr:tex display="inline">A</fr:tex> be the coefficient matrix of a homogeneous linear system.
        <fr:tex display="block">             A = \begin {bmatrix}                 a_{11} &amp; a_{12} &amp; \cdots  &amp; a_{1n} \\                 a_{21} &amp; a_{22} &amp; \cdots  &amp; a_{2n} \\                 \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                 a_{m1} &amp; a_{m2} &amp; \cdots  &amp; a_{mn}             \end {bmatrix}         </fr:tex>
        The equation <fr:tex display="inline">A\vec {x} = \vec {0}</fr:tex> has a trivial solution <fr:tex display="inline">\vec {x} = \vec {0}</fr:tex>.
        The question here is whether there is a nontrivial solution.</fr:p><fr:p>Define <fr:tex display="inline">T: \mathbb {F}^n \to  \mathbb {F}^m</fr:tex> by
        <fr:tex display="block">             T(\vec {x}) = A\vec {x}         </fr:tex>
        Then the question of whether the homogeneous linear system has a nontrivial solution is equivalent to 
        asking <fr:tex display="inline">\text {null } T</fr:tex> is nontrivial.
        That is, <fr:tex display="inline">T</fr:tex> is <fr:link type="local" href="thm-000G.xml" addr="thm-000G" title="Injectivity equivalent to Kernel Triviality">not injective</fr:link>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>492</fr:anchor><fr:addr type="user">thm-000O</fr:addr><fr:route>thm-000O.xml</fr:route><fr:title text="Homogeneous system of linear equations">Homogeneous system of linear equations</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A homogeneous system of linear equations
    with more variables than equations has 
    a nontrivial solution.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We have seen that <fr:link type="local" href="thm-000M.xml" addr="thm-000M" title="Map to smaller dimension is not injective">map to smaller dimension is not injective</fr:link>.
    <fr:tex display="inline">T</fr:tex> is not injective if <fr:tex display="inline">n &gt; m</fr:tex>. This results the theorem above.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>493</fr:anchor><fr:addr type="user">eg-0005</fr:addr><fr:route>eg-0005.xml</fr:route><fr:title text="Inhomogeneous Linear Equations System">Inhomogeneous Linear Equations System</fr:title><fr:taxon>Example</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Rephrase in terms of a linear map the question of whether a inhomogeneous system linear equations has no solutions
        for some choice of constant terms.</fr:p><fr:p>Let <fr:tex display="inline">A</fr:tex> be the coefficient matrix of a inhomogeneous linear system.
    <fr:tex display="block">         A = \begin {bmatrix}             a_{11} &amp; a_{12} &amp; \cdots  &amp; a_{1n} \\             a_{21} &amp; a_{22} &amp; \cdots  &amp; a_{2n} \\             \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\             a_{m1} &amp; a_{m2} &amp; \cdots  &amp; a_{mn}         \end {bmatrix}     </fr:tex>
    The equation <fr:tex display="inline">A\vec {x} = \vec {b}</fr:tex> has a solution <fr:tex display="inline">\vec {x} = A^{-1}\vec {b}</fr:tex>.</fr:p><fr:p>Define <fr:tex display="inline">T: \mathbb {F}^n \to  \mathbb {F}^m</fr:tex> by
        <fr:tex display="block">             T(\vec {x}) = A\vec {x}         </fr:tex>
        Then the statement that inhomogeneous linear system has no solutions is equivalent to 
        <fr:tex display="inline">\vec {b} \not \in  \text {range } T</fr:tex>.
        Thus the question is rephrased as not having a solution for some choice of <fr:tex display="inline">\vec {b}</fr:tex>.
        What condition ensures <fr:tex display="inline">T</fr:tex> is not surjective.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>494</fr:anchor><fr:addr type="user">thm-000P</fr:addr><fr:route>thm-000P.xml</fr:route><fr:title text="Inhomogeneous system of linear equations">Inhomogeneous system of linear equations</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An inhomogeneous system of linear equations
    with more equations than variables has 
    no solution for some choice of the constant term.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Let <fr:tex display="inline">v_1, v_2, \cdots , v_n</fr:tex> be a basis of <fr:tex display="inline">V</fr:tex>.
    We know that for any value of a linear map <fr:tex display="inline">T:V\to  W</fr:tex>,
    can be determined by values <fr:tex display="inline">\{ T(v_1), T(v_2), \cdots , T(v_n) \}</fr:tex>.
    This leads to the definition of the matrix representation of a linear map.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>495</fr:anchor><fr:addr type="user">def-002R</fr:addr><fr:route>def-002R.xml</fr:route><fr:title text="Matrix">Matrix</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">m,n\in  \mathbb {Z}^+</fr:tex>.
    A <fr:tex display="inline">m\times  n</fr:tex> matrix is a rectangular array of elements of a field <fr:tex display="inline">\mathbb {F}</fr:tex>
    with <fr:tex display="inline">m</fr:tex> <fr:strong>rows</fr:strong> and <fr:tex display="inline">n</fr:tex> <fr:strong>columns</fr:strong>.
    <fr:tex display="block">         A = \begin {bmatrix}             a_{11} &amp; a_{12} &amp; \cdots  &amp; a_{1n} \\             a_{21} &amp; a_{22} &amp; \cdots  &amp; a_{2n} \\             \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\             a_{m1} &amp; a_{m2} &amp; \cdots  &amp; a_{mn}         \end {bmatrix}     </fr:tex>
    The notation <fr:tex display="inline">A_{jk}</fr:tex> refers to the element in the <fr:tex display="inline">j</fr:tex>-th row and <fr:tex display="inline">k</fr:tex>-th column.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now we can define the matrix representation of a linear map.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>496</fr:anchor><fr:addr type="user">def-002S</fr:addr><fr:route>def-002S.xml</fr:route><fr:title text="Matrix of Linear Maps">Matrix of Linear Maps</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">T\in  \mathcal {L}(V,W)</fr:tex>,
    <fr:tex display="inline">\{ v_1,\ldots ,v_n \}\subset  V</fr:tex> be a basis of <fr:tex display="inline">V</fr:tex>,
    and <fr:tex display="inline">\{ w_1,\ldots ,w_m \}\subset  W</fr:tex> be a basis of <fr:tex display="inline">W</fr:tex>.
    The <fr:strong>matrix of <fr:tex display="inline">T</fr:tex></fr:strong> with respect to these bases is
    the <fr:tex display="inline">m\times  n</fr:tex> matrix <fr:tex display="inline">\mathcal {M}(T)</fr:tex> such that
    <fr:tex display="block">         T(v_j) = \sum _{i=1}^m \mathcal {M}(T)_{ij}w_i     </fr:tex>
    Or we denote <fr:tex display="inline">\mathcal {M}(T)</fr:tex> as <fr:tex display="inline">\mathcal {M}(T, (v_1,\ldots ,v_n), (w_1,\ldots ,w_m))</fr:tex>.</fr:p><fr:p>If <fr:tex display="inline">T</fr:tex> maps <fr:tex display="inline">n</fr:tex>-dimensional vector space to <fr:tex display="inline">m</fr:tex>-dimensional vector space,
    then <fr:tex display="inline">\mathcal {M}(T)</fr:tex> is a <fr:tex display="inline">m\times  n</fr:tex> matrix.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>497</fr:anchor><fr:addr type="machine">#322</fr:addr><fr:route>unstable-322.xml</fr:route><fr:title text="
    Addition
">
    <fr:strong>Addition</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>def-002S</fr:parent></fr:frontmatter><fr:mainmatter>
    For two same-size matrix <fr:tex display="inline">A,B</fr:tex>,
    the sum of <fr:tex display="inline">A</fr:tex> and <fr:tex display="inline">B</fr:tex> is the matrix <fr:tex display="inline">C</fr:tex> such that
    <fr:tex display="block">         C_{ij} = A_{ij} + B_{ij}     </fr:tex>
    In the language of linear maps <fr:tex display="inline">S,T\in  \mathcal {L}(V,W)</fr:tex>,
    <fr:tex display="block">         \mathcal {M}(T+S) = \mathcal {M}(T) + \mathcal {M}(S)     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>498</fr:anchor><fr:addr type="machine">#323</fr:addr><fr:route>unstable-323.xml</fr:route><fr:title text="
    Scalar Multiplication
">
    <fr:strong>Scalar Multiplication</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>def-002S</fr:parent></fr:frontmatter><fr:mainmatter>
    For a scalar <fr:tex display="inline">c</fr:tex> and a matrix <fr:tex display="inline">A</fr:tex>,
    the product of <fr:tex display="inline">c</fr:tex> and <fr:tex display="inline">A</fr:tex> is the matrix <fr:tex display="inline">B</fr:tex> such that
    <fr:tex display="block">         B_{ij} = cA_{ij}     </fr:tex>
    In the language of linear maps <fr:tex display="inline">T\in  \mathcal {L}(V,W)</fr:tex>,
    <fr:tex display="block">         \mathcal {M}(cT) = c\mathcal {M}(T)     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>499</fr:anchor><fr:addr type="machine">#324</fr:addr><fr:route>unstable-324.xml</fr:route><fr:title text="
    Set of Matrices
">
    <fr:strong>Set of Matrices</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>def-002S</fr:parent></fr:frontmatter><fr:mainmatter>
    The set of all <fr:tex display="inline">m\times  n</fr:tex> matrices with elements in <fr:tex display="inline">\mathbb {F}</fr:tex> is denoted as <fr:tex display="inline">\mathcal {M}_{m\times  n}(\mathbb {F})</fr:tex>
    or <fr:tex display="inline">\mathbb {F}^{m\times  n}</fr:tex>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We can see that <fr:tex display="inline">\mathbb {F}^{m\times  n}</fr:tex> is itself a vector space.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>500</fr:anchor><fr:addr type="user">thm-000Q</fr:addr><fr:route>thm-000Q.xml</fr:route><fr:title text="{F}^{m n} = mn"><fr:tex display="inline">\dim \mathbb {F}^{m\times  n} = mn</fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:tex display="inline">\mathbb {F}^{m\times  n}</fr:tex> is a vector space with dimension <fr:tex display="inline">mn</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Consider linear maps <fr:tex display="inline">T:U\to  V</fr:tex> and <fr:tex display="inline">S:V\to  W</fr:tex>.
    The composition of linear maps is <fr:tex display="inline">ST</fr:tex>.
    Does the composition of linear maps have a matrix representation?
    <fr:tex display="block">         \mathcal {M}(ST) = \mathcal {M}(S)\mathcal {M}(T)     </fr:tex>
    This makes no sense now but indicates the definition of <fr:strong>matrix multiplication</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>501</fr:anchor><fr:addr type="user">def-002T</fr:addr><fr:route>def-002T.xml</fr:route><fr:title text="Matrix Multiplication">Matrix Multiplication</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">A</fr:tex> be a <fr:tex display="inline">m\times  n</fr:tex> matrix and <fr:tex display="inline">B</fr:tex> be a <fr:tex display="inline">n\times  p</fr:tex> matrix.
    Then <fr:tex display="inline">AC</fr:tex> is defined as the <fr:tex display="inline">m\times  p</fr:tex> matrix <fr:tex display="inline">C</fr:tex> such that
    <fr:tex display="block">         C_{ij} = \sum _{k=1}^n A_{ik}B_{kj}     </fr:tex></fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>502</fr:anchor><fr:addr type="machine">#321</fr:addr><fr:route>unstable-321.xml</fr:route><fr:title text="
    Derivation
">
    <fr:strong>Derivation</fr:strong>
</fr:title><fr:authors></fr:authors><fr:parent>def-002T</fr:parent></fr:frontmatter><fr:mainmatter>
    Let <fr:tex display="inline">T:U\to  V</fr:tex> and <fr:tex display="inline">S:V\to  W</fr:tex> be linear maps.
    Denote <fr:tex display="inline">A = \mathcal {M}(S)</fr:tex> and <fr:tex display="inline">C = \mathcal {M}(T)</fr:tex>.
    Then the composition of linear maps <fr:tex display="inline">ST</fr:tex> is computed
    <fr:tex display="block">         \begin {align*}             (ST)(u)_k &amp;= S(\sum _{r=1}^n C_{rk}v_r) \\             &amp;= \sum _{r=1}^n C_{rk}S(v_r) \\             &amp;= \sum _{r=1}^n C_{rk}\sum _{s=1}^m A _{sr}w_s \\             &amp;= \sum _{s=1}^m\left (\sum _{r=1}^n C_{rk}A_{sr}\right )w_s \\         \end {align*}     </fr:tex>
    Thus <fr:tex display="inline">\mathcal {M}(ST)</fr:tex> is the <fr:tex display="inline">m\times  p</fr:tex> whose entries are
    <fr:tex display="block">         \mathcal {M}(ST)_{sk} = \sum _{r=1}^n A_{sr}C_{rk}     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now we see that the desired matrix multiplication holds.
    Matrix multiplication is not commutative in general.
    However, it satisfies the associative law and the distributive law.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>503</fr:anchor><fr:addr type="user">def-002Y</fr:addr><fr:route>def-002Y.xml</fr:route><fr:title text="A_{j} and A_{ j}"><fr:tex display="inline">A_{j\cdot }</fr:tex> and <fr:tex display="inline">A_{\cdot  j}</fr:tex></fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">A</fr:tex> be a <fr:tex display="inline">m\times  n</fr:tex> matrix.
    <fr:ul><fr:li>If <fr:tex display="inline">1\leq  j\leq  m</fr:tex> then <fr:tex display="inline">A_{j\cdot }</fr:tex> is the <fr:tex display="inline">j</fr:tex>-th row of <fr:tex display="inline">A</fr:tex>,
            defined as a <fr:tex display="inline">1\times  n</fr:tex> matrix. (A row vector)</fr:li>
        <fr:li>If <fr:tex display="inline">1\leq  j\leq  n</fr:tex> then <fr:tex display="inline">A_{\cdot  j}</fr:tex> is the <fr:tex display="inline">j</fr:tex>-th column of <fr:tex display="inline">A</fr:tex>,
            defined as a <fr:tex display="inline">m\times  1</fr:tex> matrix. (A column vector)</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>With the notation we can think of matrix multiplication in another perspective.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>504</fr:anchor><fr:addr type="user">thm-000R</fr:addr><fr:route>thm-000R.xml</fr:route><fr:title text="Entry pf matrix product">Entry pf matrix product</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose <fr:tex display="inline">A</fr:tex> is an <fr:tex display="inline">m\times  n</fr:tex> matrix and <fr:tex display="inline">B</fr:tex> is an <fr:tex display="inline">n\times  p</fr:tex> matrix.
    Then the entry of the product <fr:tex display="inline">AB</fr:tex> is:
    <fr:tex display="block">         (AB)_{ij} = A_{i\cdot }B_{\cdot  j}     </fr:tex>
    for <fr:tex display="inline">1\leq  i\leq  m</fr:tex> and <fr:tex display="inline">1\leq  j\leq  p</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We have an interesting observation.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>505</fr:anchor><fr:addr type="user">thm-000S</fr:addr><fr:route>thm-000S.xml</fr:route><fr:title text="Linear Combination of columns">Linear Combination of columns</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">A</fr:tex> be an <fr:tex display="inline">m\times  n</fr:tex> matrix,
    and <fr:tex display="inline">c</fr:tex> is a <fr:tex display="inline">1\times  1</fr:tex> matrix.
    <fr:tex display="block">         c = \begin {pmatrix} c_1 \\ c_2 \\ \vdots  \\ c_n \end {pmatrix}     </fr:tex>
    Then <fr:tex display="inline">Ac = c_1A_{\cdot  1} + c_2A_{\cdot  2} + \cdots  + c_nA_{\cdot  n}</fr:tex>.
    In other words, <fr:tex display="inline">Ac</fr:tex> is a linear Combination of the columns of <fr:tex display="inline">A</fr:tex>,
    with the scalars that multiply the columns coming from <fr:tex display="inline">c</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now we begin the study the invertibility of linear maps.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>506</fr:anchor><fr:addr type="user">def-002Z</fr:addr><fr:route>def-002Z.xml</fr:route><fr:title text="Inverse">Inverse</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A linear map <fr:tex display="inline">T\in \mathcal {L}(V,W)</fr:tex> is said to be <fr:tex display="inline">invertible</fr:tex> if 
    there exists a linear map <fr:tex display="inline">S\in \mathcal {L}(W,V)</fr:tex> such that:
    <fr:tex display="block">         \begin {align*}             T\cdot  S &amp;= \text {id}_V \\             S\cdot  T &amp;= \text {id}_W         \end {align*}     </fr:tex>
    where <fr:tex display="inline">\text {id}</fr:tex> is the identity map.
    If a linear map <fr:tex display="inline">T</fr:tex> is invertible, 
    then the map <fr:tex display="inline">S</fr:tex> is <fr:strong>unique</fr:strong> and is called the <fr:strong>inverse</fr:strong> of <fr:tex display="inline">T</fr:tex>, denoted <fr:tex display="inline">T^{-1}</fr:tex>.</fr:p><fr:p>An <fr:strong>isomorphism</fr:strong> is a linear map that is invertible.
    Two vector spaces are said to be <fr:strong>isomorphic</fr:strong> if there exists an isomorphism between them.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>A linear map is invertible if and only if
    it is <fr:strong>bijective</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>507</fr:anchor><fr:addr type="user">thm-000T</fr:addr><fr:route>thm-000T.xml</fr:route><fr:title text="Isomorphism of equal dimensions">Isomorphism of equal dimensions</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Two finite-dimensional vector spaces over <fr:tex display="inline">\mathbb {F}</fr:tex>
    are isomorphic iff they have the same <fr:link type="local" href="def-001V.xml" addr="def-001V" title="Dimension">dimension</fr:link>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>508</fr:anchor><fr:addr type="user">thm-000U</fr:addr><fr:route>thm-000U.xml</fr:route><fr:title text="{L}(V,W) is isomorphic to {F}^{m n}"><fr:tex display="inline">\mathcal {L}(V,W)</fr:tex> is isomorphic to <fr:tex display="inline">\mathbb {F}^{m\times  n}</fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">v_1, v_2, \ldots , v_n</fr:tex> be a basis for <fr:tex display="inline">V</fr:tex>,
    and <fr:tex display="inline">w_1, w_2, \ldots , w_m</fr:tex> be a basis for <fr:tex display="inline">W</fr:tex>.
    Then <fr:tex display="inline">\mathcal {M}</fr:tex> is an isomorphism between <fr:tex display="inline">\mathcal {L}(V,W)</fr:tex> and <fr:tex display="inline">\mathbb {F}^{m\times  n}</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>This has a trivial corollary.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>509</fr:anchor><fr:addr type="user">thm-000V</fr:addr><fr:route>thm-000V.xml</fr:route><fr:title text="Dimension product">Dimension product</fr:title><fr:taxon>Corollary</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">V</fr:tex> and <fr:tex display="inline">W</fr:tex> be finite-dimensional vector spaces.
    Then <fr:tex display="inline">\mathcal {L}(V,W)</fr:tex> is finite-dimensional and
    <fr:tex display="block">         \dim (\mathcal {L}(V,W)) = \dim (V)\dim (W).     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>510</fr:anchor><fr:addr type="user">math-0006</fr:addr><fr:route>math-0006.xml</fr:route><fr:title text="Category Theory of Utilitarianism">Category Theory of Utilitarianism</fr:title><fr:taxon>Category Theory</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This note is about the category theory and its applications.
    Instead of reading a well-organized book, I prefer to write down the things I learned
    from <fr:link type="local" href="ncatlab.xml" addr="ncatlab" title="NLab">ncatlab</fr:link> and papers.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>511</fr:anchor><fr:addr type="machine">#312</fr:addr><fr:route>unstable-312.xml</fr:route><fr:title text="
    Ideas">
    <fr:strong>Ideas</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>math-0006</fr:parent></fr:frontmatter><fr:mainmatter>
        Intuitively, a category is a collection of objects and arrows between them,
        such arrows can be composed and there is an identity arrow for each object.
    <fr:p>There are commonly two ways to define a category, which are equivalent in usual 
        foundations of mathematics. One of them generalizes the notion of <fr:strong>internal category</fr:strong>
        nicely while the other one is more convenient for <fr:strong>enriched category</fr:strong>.</fr:p>
    <fr:p>The major difference is whether they use a single collection of all morphisms or
        several collections of morphisms (<fr:strong>family of collections</fr:strong> indexed by pairs of objects)</fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>512</fr:anchor><fr:addr type="user">def-003E</fr:addr><fr:route>def-003E.xml</fr:route><fr:title text="Category">Category</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>513</fr:anchor><fr:addr type="machine">#315</fr:addr><fr:route>unstable-315.xml</fr:route><fr:title text="With one collection"><fr:strong>With one collection</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>def-003E</fr:parent></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex display="inline">C</fr:tex> consists
    <fr:ul><fr:li>A collection of <fr:strong>objects</fr:strong> <fr:tex display="inline">C_0</fr:tex> (<fr:tex display="inline">\text {Ob}(C)</fr:tex>).</fr:li>
        <fr:li>A collection <fr:tex display="inline">C_1</fr:tex> (<fr:tex display="inline">\text {Mor}(C)</fr:tex>) of <fr:strong>morphisms</fr:strong> (arrows).</fr:li>
        <fr:li>For every morphism <fr:tex display="inline">f</fr:tex> there are an object <fr:tex display="inline">s(f)</fr:tex> (<fr:strong>source</fr:strong>, domain) and an object <fr:tex display="inline">t(f)</fr:tex> (<fr:strong>target</fr:strong>, codomain).</fr:li>
        <fr:li>For every pair of morphisms <fr:tex display="inline">f, g</fr:tex> such that <fr:tex display="inline">t(f) = s(g)</fr:tex>, there is a morphism <fr:tex display="inline">g \circ  f</fr:tex> (<fr:strong>composition</fr:strong>) (Also written <fr:tex display="inline">gf</fr:tex> or <fr:tex display="inline">f;g</fr:tex>).</fr:li>
        <fr:li>For every object <fr:tex display="inline">x</fr:tex>, there is a morphism <fr:tex display="inline">\text {id}_x</fr:tex> (or <fr:tex display="inline">1_x</fr:tex>) called <fr:strong>identity</fr:strong>.</fr:li>
        <fr:li>The following properties hold:
            <fr:ul><fr:li><fr:tex display="inline">s(g \circ  f) = s(f)</fr:tex> and <fr:tex display="inline">t(g \circ  f) = t(g)</fr:tex>.</fr:li>
                <fr:li><fr:tex display="inline">s(1_x) = x</fr:tex> and <fr:tex display="inline">t(1_x) = x</fr:tex>.</fr:li>
                <fr:li>Composition is <fr:strong>associative</fr:strong>: <fr:tex display="inline">h \circ  (g \circ  f) = (h \circ  g) \circ  f</fr:tex> when <fr:tex display="inline">t(f) = s(g)</fr:tex>, and <fr:tex display="inline">t(g) = s(h)</fr:tex>.</fr:li>
                <fr:li>Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex display="inline">f \circ  \text {id}_x = f</fr:tex> and <fr:tex display="inline">\text {id}_y \circ  f = f</fr:tex></fr:li></fr:ul></fr:li></fr:ul>
    If the identity map and its axioms are omitted then one speaks of a <fr:strong>semicategory</fr:strong>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>514</fr:anchor><fr:addr type="machine">#316</fr:addr><fr:route>unstable-316.xml</fr:route><fr:title text="With a family of collections of morphisms"><fr:strong>With a family of collections of morphisms</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>def-003E</fr:parent></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex display="inline">C</fr:tex> consists
    <fr:ul><fr:li>A collection of <fr:strong>objects</fr:strong> <fr:tex display="inline">C_0</fr:tex> (<fr:tex display="inline">\text {Ob}(C)</fr:tex>).</fr:li>
        <fr:li>For every pair of objects <fr:tex display="inline">x, y</fr:tex>, a collection <fr:tex display="inline">C_1(x, y)</fr:tex> (<fr:tex display="inline">\hom _C(x,y)</fr:tex>) of <fr:strong>morphisms</fr:strong> from <fr:tex display="inline">x</fr:tex> to <fr:tex display="inline">y</fr:tex>.</fr:li>
        <fr:li>For each pair of morphisms <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex> and <fr:tex display="inline">g</fr:tex> in <fr:tex display="inline">C_1(y,z)</fr:tex>, a morphism <fr:tex display="inline">g \circ  f</fr:tex> in <fr:tex display="inline">C_1(x,z)</fr:tex>.
            called their <fr:strong>composition</fr:strong>.</fr:li>
        <fr:li>For each object <fr:tex display="inline">x</fr:tex>, a morphism <fr:tex display="inline">\text {id}_x</fr:tex> in <fr:tex display="inline">C_1(x,x)</fr:tex> called the <fr:strong>identity</fr:strong> on <fr:tex display="inline">x</fr:tex>.</fr:li>
        <fr:li>The following properties hold:
            <fr:ul><fr:li>Composition is <fr:strong>associative</fr:strong>: <fr:tex display="inline">h \circ  (g \circ  f) = (h \circ  g) \circ  f</fr:tex> for all <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex>, <fr:tex display="inline">g</fr:tex> in <fr:tex display="inline">C_1(y,z)</fr:tex>, and <fr:tex display="inline">h</fr:tex> in <fr:tex display="inline">C_1(z,w)</fr:tex>.</fr:li>
                <fr:li>Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex display="inline">f \circ  \text {id}_x = f</fr:tex> and <fr:tex display="inline">\text {id}_y \circ  f = f</fr:tex> for all <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex>.</fr:li></fr:ul></fr:li></fr:ul>
    Usually we write <fr:tex display="inline">\text {Mor}(C)</fr:tex> for the disjoint union <fr:tex display="inline">\bigsqcup _{x,y \in  C_0} C_1(x,y)</fr:tex>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Its common to talk about some objects and their morphisms.
    Informally, a <fr:strong>diagram</fr:strong> in a category <fr:tex display="inline">C</fr:tex> consists of some 
    objects of <fr:tex display="inline">C</fr:tex> connected by some morphisms of <fr:tex display="inline">C</fr:tex>.</fr:p><fr:p>This terminology is often used when speaking about <fr:strong>limits</fr:strong> or 
    <fr:strong>colimits</fr:strong> of a diagram.</fr:p><fr:p>One formal way to define a diagram is to use a <fr:strong>functor</fr:strong> from a (very) small category to <fr:tex display="inline">C</fr:tex>.
    That is, a functor whose domain is a small category.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>515</fr:anchor><fr:addr type="user">def-003F</fr:addr><fr:route>def-003F.xml</fr:route><fr:title text="Small Category">Small Category</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link type="local" href="def-003E.xml" addr="def-003E" title="Category">category</fr:link> is said to be <fr:strong>small</fr:strong> 
    if it has a <fr:strong>samll set</fr:strong> (i.e. a set but not a proper class) of objects and morphisms.
    In other words a small category is an <fr:strong>internal category</fr:strong> in category of sets.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We did not explain what a <fr:strong>functor</fr:strong> is, but it is very natural thought.
    Briefly, a functor is a <fr:strong>homomorphism</fr:strong> between two categories.
    It maps objects to objects and morphisms to morphisms, preserving the structure of the categories.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>516</fr:anchor><fr:addr type="user">def-003G</fr:addr><fr:route>def-003G.xml</fr:route><fr:title text="Functor">Functor</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>functor</fr:strong> <fr:tex display="inline">F</fr:tex> from a category <fr:tex display="inline">C</fr:tex> to a category <fr:tex display="inline">D</fr:tex> is a map
    sending each <fr:tex display="inline">x\in  C</fr:tex> to an object <fr:tex display="inline">F(x)\in  D</fr:tex> and each morphism
    <fr:tex display="inline">f:x\to  y</fr:tex> in <fr:tex display="inline">C</fr:tex> to morphism <fr:tex display="inline">F(f):F(x)\to  F(y)</fr:tex> in <fr:tex display="inline">D</fr:tex>, such that 
    <fr:ul><fr:li>Composition is preserved: <fr:tex display="inline">F(g\circ  f) = F(g)\circ  F(f)</fr:tex>.</fr:li>
        <fr:li>Identity is preserved: <fr:tex display="inline">F(\text {id}_x) = \text {id}_{F(x)}</fr:tex>.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>For the sake of completeness, we state the definition of the <fr:strong>functor category</fr:strong>
    and the <fr:strong>natural transformations</fr:strong> between functors.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>517</fr:anchor><fr:addr type="user">def-003I</fr:addr><fr:route>def-003I.xml</fr:route><fr:title text="Functor Category">Functor Category</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex> be categories, the functor category <fr:tex display="inline">D^C</fr:tex> 
    (or <fr:tex display="inline">[C,D]</fr:tex>) is the category whose
    <fr:ul><fr:li>objects are functors from <fr:tex display="inline">C</fr:tex> to <fr:tex display="inline">D</fr:tex>.</fr:li>
        <fr:li>morphisms are <fr:strong>natural transformations</fr:strong> between functors.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>518</fr:anchor><fr:addr type="user">def-003J</fr:addr><fr:route>def-003J.xml</fr:route><fr:title text="Natural Transformation">Natural Transformation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex> be categories and <fr:tex display="inline">F,G:C\to  D</fr:tex> be functors.
    A <fr:strong>natural transformation</fr:strong> <fr:tex display="inline">\alpha :F\Rightarrow   G</fr:tex> is 
    an assignment to every object <fr:tex display="inline">x\in  C</fr:tex> of a morphism <fr:tex display="inline">\alpha _x:F(x)\to  G(x)</fr:tex> in <fr:tex display="inline">D</fr:tex>,
    (called the <fr:strong>component</fr:strong> of <fr:tex display="inline">\alpha </fr:tex> at <fr:tex display="inline">x</fr:tex>)
    the following diagram commutes in <fr:tex display="inline">D</fr:tex>:
    
    <fr:embedded-tex hash="9e8c6059143e8cbd6e00022532ed04e2"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            {F(x)} &amp;&amp; {F(y)} \\
            \\
            {G(x)} &amp;&amp; {G(y)}
            \arrow [&quot;{F(f)}&quot;, from=1-1, to=1-3]
            \arrow [&quot;{G(f)}&quot;, from=3-1, to=3-3]
            \arrow [&quot;{\alpha _x}&quot;, from=1-1, to=3-1]
            \arrow [&quot;{\alpha _y}&quot;, from=1-3, to=3-3]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We state the concise functorial definition of diagrams of the shape of categories.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>519</fr:anchor><fr:addr type="user">def-003H</fr:addr><fr:route>def-003H.xml</fr:route><fr:title text="Diagram">Diagram</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">C</fr:tex> be a category and <fr:tex display="inline">J</fr:tex> be a small category.
    A <fr:strong>diagram</fr:strong> of shape <fr:tex display="inline">J</fr:tex> in <fr:tex display="inline">C</fr:tex> is a functor <fr:tex display="inline">X:J\to  C</fr:tex>.
    The category of <fr:tex display="inline">J</fr:tex>-shaped diagrams in <fr:tex display="inline">C</fr:tex> is the <fr:link type="local" href="def-003I.xml" addr="def-003I" title="Functor Category">functor category</fr:link> <fr:tex display="inline">C^J</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>A limit of a diagram <fr:tex display="inline">F:D\to  C</fr:tex> is an object <fr:tex display="inline">\lim  F</fr:tex> of <fr:tex display="inline">C</fr:tex>
    equipped with morphisms to the objects <fr:tex display="inline">F(d)</fr:tex> for all <fr:tex display="inline">d\in  D</fr:tex>,
    such that everything in sight commutes.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>520</fr:anchor><fr:addr type="user">cs-0001</fr:addr><fr:route>cs-0001.xml</fr:route><fr:title text="Is JavaScript an untyped language?">Is JavaScript an untyped language?</fr:title><fr:taxon>Compute Science</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>29</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is a note about the the argument that JavaScript is an untyped language.
    Most opinions came from the References.</fr:p><fr:p>The first thing I want to classify is the word <fr:strong>strong typing</fr:strong> and <fr:strong>weak typing</fr:strong> are meaningless.
    In a limit case we can compare two languages that have similar type system, and talk about which one is <fr:em>stronger</fr:em>.
    But for the common case, it&apos;s totally nonsense.</fr:p><fr:p>Static and dynamic typing is a meaningful classsification. But the discussion about dynamic and static languages is mostly wrong on the Internet.
    Dynamic language is a popular concept, however, it is rather a <fr:strong>marketing</fr:strong> than a well-defined terminology.
    It&apos;s designed to confuse rather than inform.</fr:p><fr:p>In fact, dynamic typing is just a special case of static typing.
    It limits more than contributes.The root of the problem is the confusion 
    between type and class. It&apos;s very useful to have multiple classes of values
    of a same type.
    They are interchangeable because they represent values of the same type.
    Only the form of presentation differs.</fr:p><fr:p>The distinction between two classes of the same type is dynamic.
    But this does not conflict with the fact that only one static type.
    In type theory this is what we called <fr:strong>Sum Type</fr:strong>.
    Being a sum type we can dispatch on the class of the value of the type,
    and decide what to do at runtime.</fr:p><fr:p>This characteristics is same to dynamic language where values can be classified into
    various forms that can be distinguished at runtime.
    The answer is now clear: dynamic language classifies all values in this way.
    What they do just merge all values of the language into a single type.
    The so-called <fr:strong>untyped</fr:strong> language is just <fr:strong>unityped</fr:strong>.</fr:p><fr:p>Therefore, JavaScript is definitely untyped.</fr:p>
    <fr:p><fr:strong>References</fr:strong></fr:p>
    <fr:ul><fr:li><fr:link type="external" href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/">Dynamic and static language</fr:link></fr:li>
        <fr:li><fr:link type="external" href="https://stackoverflow.com/questions/964910/is-javascript-an-untyped-language">stackoverflow</fr:link></fr:li>
        <fr:li><fr:link type="external" href="https://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">What to know before debating type systems</fr:link></fr:li>
        <fr:li><fr:em>Practical Foundations for Programming Languages</fr:em>, Robert Harper</fr:li></fr:ul>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>521</fr:anchor><fr:addr type="user">cs-0002</fr:addr><fr:route>cs-0002.xml</fr:route><fr:title text="Primitive Recursion in Lambda Calculus">Primitive Recursion in Lambda Calculus</fr:title><fr:taxon>Compute Science</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We begin with the <fr:strong>schema of iteration</fr:strong> and then proceed 
    the more complex schema of primitive recursion and general recursion.
    Refer to <fr:link type="local" href="tapl.xml" addr="tapl" title="Types and Programming Languages">TAPL</fr:link>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>522</fr:anchor><fr:addr type="machine">#360</fr:addr><fr:route>unstable-360.xml</fr:route><fr:title text="Function Composition"><fr:strong>Function Composition</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
    Giving two functions <fr:tex display="inline">f, g</fr:tex> we can compose then to get a new function <fr:tex display="inline">f\circ  g = f(g(x))</fr:tex>.
    Using <fr:tex display="inline">\lambda </fr:tex>-notation, we can define the composition of two functions as follows:
    <fr:tex display="block">         f\circ  g = \lambda  x.f(g(x))     </fr:tex>
    And the composition operation is also a lambda abstraction.
    <fr:tex display="block">         \circ  = B = \lambda  f.\lambda  g.\lambda  x.f(g(x))     </fr:tex>
    Composing identity function with any function does not change the function.
    We expect the following equation to hold:
    <fr:tex display="block">         f\circ  I = f = I\circ  f     </fr:tex>
    where <fr:tex display="inline">I</fr:tex> is the identity function. This can be verified by the following calculation:
    <fr:tex display="block">         \begin {align*}             B\space  f\space  I &amp;= (\lambda  f.\lambda  g.\lambda  x.f(g(x)))\space  f\space  I \\             &amp;\to _\beta  \lambda  g.\lambda  x.f(g(x))\space  I \\             &amp;\to _\beta  \lambda  x.f(I(x)) \\             &amp;\to _\beta  \lambda  x.f(x) \\             &amp;=_\eta  f         \end {align*}     </fr:tex>
    The last step requires an extensional equality, which is the called <fr:strong>eta-conversion</fr:strong>.
    <fr:tex display="block">         \text {for}\space  x\not \in \text {FV}(f) ,\lambda  x.f(x) =_\eta  f     </fr:tex>
    It makes more sense to use the equation from right to left called <fr:strong>eta-expansion</fr:strong> 
    (And more discipline has to be imposed or expansion does not terminate).
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>523</fr:anchor><fr:addr type="machine">#361</fr:addr><fr:route>unstable-361.xml</fr:route><fr:title text="Non-termination"><fr:strong>Non-termination</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>The well-known <fr:link type="local" href="eg-0007.xml" addr="eg-0007" title="Divergent Combinator"><fr:strong>divergent combinator</fr:strong></fr:link> implies that 
        the lambda calculus is not strongly normalizing.</fr:p>
    <fr:p>However, we can always compute a normal form if one exists.
        Though there are many reduction strategies,
        there is a complete one for expressions that have normal form.
        This kind of reduction strategy is called <fr:strong>normal order reduction</fr:strong> or
        <fr:strong>leftmost-outermost reduction</fr:strong>. It scans through the expression from left to right
        and when it find a redex, it reduces it by applying beta reduction and returns to the beginning.</fr:p>
    <fr:p>The notation of leftmost-outermost reduction is closely related to the 
        notion of <fr:strong>call-by-name evaluation</fr:strong> in programming languages.
        (A little more distance to <fr:strong>call-by-need</fr:strong> evaluation in Haskell)</fr:p>
    <fr:p>In contrast, <fr:strong>call-by-value</fr:strong> evaluation is not complete, which would 
        reduce the argument of a function before applying beta reduction.</fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>524</fr:anchor><fr:addr type="machine">#362</fr:addr><fr:route>unstable-362.xml</fr:route><fr:title text="Church-Rosser Property"><fr:strong>Church-Rosser Property</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
    The outcome of a computation <fr:tex display="inline">e</fr:tex> is its normal form.
    It is naturally to ask the question whether the normal form is unique.
    The key to this question is the <fr:strong>Church-Rosser property</fr:strong> or <fr:strong>confluence</fr:strong>:
    If <fr:tex display="inline">e\to ^* e_1</fr:tex> and <fr:tex display="inline">e\to ^* e_2</fr:tex>, then there exists a term <fr:tex display="inline">e_3</fr:tex> such that
    <fr:tex display="block">         e_1\to ^* e_3\space \text {and}\space  e_2\to ^* e_3     </fr:tex>
    This implies the uniqueness of the normal form.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>525</fr:anchor><fr:addr type="machine">#364</fr:addr><fr:route>unstable-364.xml</fr:route><fr:title text="Representing Natural Numbers"><fr:strong>Representing Natural Numbers</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>We can represent natural numbers in lambda calculus by using the 
        <fr:strong>Church numerals</fr:strong> or <fr:strong>Church encoding</fr:strong>.
        The two abstractions should be related in some ways: 
        one <fr:tex display="inline">x</fr:tex> stands for zero and the other <fr:tex display="inline">f</fr:tex> stands for the successor function.</fr:p>
    <fr:p>The Church numeral <fr:tex display="inline">n</fr:tex> is a function that takes two arguments <fr:tex display="inline">f</fr:tex> and <fr:tex display="inline">x</fr:tex> and applies <fr:tex display="inline">f</fr:tex> to <fr:tex display="inline">x</fr:tex> <fr:tex display="inline">n</fr:tex> times.
        The Church numeral <fr:tex display="inline">0</fr:tex> is defined as the identity function <fr:tex display="inline">\lambda  f.\lambda  x.x</fr:tex>.
        The Church numeral <fr:tex display="inline">1</fr:tex> is defined as the successor of <fr:tex display="inline">0</fr:tex>:
        <fr:tex display="block">             1 = \lambda  f.\lambda  x.f(x)         </fr:tex>
        The Church numeral <fr:tex display="inline">2</fr:tex> is defined as the successor of <fr:tex display="inline">1</fr:tex>:
        <fr:tex display="block">             2 = \lambda  f.\lambda  x.f(f(x))         </fr:tex>
        And so on.</fr:p>
    <fr:p>The Church numeral <fr:tex display="inline">n</fr:tex> is defined as the successor of <fr:tex display="inline">n-1</fr:tex>:
        <fr:tex display="block">             n = \lambda  f.\lambda  x.f^n(x)         </fr:tex>
        where <fr:tex display="inline">f^n(x)</fr:tex> means applying <fr:tex display="inline">f</fr:tex> to <fr:tex display="inline">x</fr:tex> <fr:tex display="inline">n</fr:tex> times.</fr:p>
    <fr:p>The successor function is defined as follows:
        <fr:tex display="block">             S = \lambda  n.\lambda  f.\lambda  x.f(n\space  f\space  x)         </fr:tex></fr:p>
    
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>526</fr:anchor><fr:addr type="machine">#363</fr:addr><fr:route>unstable-363.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:authors></fr:authors><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                 \begin {align*}                     S\space  n &amp;= (\lambda  n.\lambda  f.\lambda  x.f(n\space  f\space  x))\space  n \\                     &amp;\to _\beta  \lambda  f.\lambda  x.f(n\space  f\space  x) \\                     &amp;\to _\beta  \lambda  f.\lambda  x.f^n(x) \\                     &amp;\to _\beta  n+1                 \end {align*}             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 

    <fr:p>Using the iteration property we can define mathematical functions 
        over the natural numbers in lambda calculus.
        The addition of two Church numerals <fr:tex display="inline">m</fr:tex> and <fr:tex display="inline">n</fr:tex> is defined as follows:
        <fr:tex display="block">             m+n = \lambda  n.\lambda  k. n\space  S\space  k         </fr:tex></fr:p>
    <fr:p>The multiplication of two Church numerals <fr:tex display="inline">m</fr:tex> and <fr:tex display="inline">n</fr:tex> is defined by
        iterating the addition function <fr:tex display="inline">m</fr:tex> times:
        <fr:tex display="block">             m*n = \lambda  n.\lambda  k. n\space  (k + ) \space  0         </fr:tex></fr:p>
    <fr:p>The exponentiation of two Church numerals <fr:tex display="inline">m</fr:tex> and <fr:tex display="inline">n</fr:tex> is defined as follows:
        <fr:tex display="block">             m^n = \lambda  m.\lambda  n. n\space  (m *) \space  1         </fr:tex></fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>527</fr:anchor><fr:addr type="machine">#365</fr:addr><fr:route>unstable-365.xml</fr:route><fr:title text="The Schema of Iteration"><fr:strong>The Schema of Iteration</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>As we saw before, a natural number <fr:tex display="inline">n</fr:tex> is represented by a function 
        that iterates its first argument <fr:tex display="inline">n</fr:tex> times on its second argument.
        <fr:tex display="block">             n = \lambda  g.\lambda  c.g^n(c)         </fr:tex>
        Another way to specify such a function schematically is 
        <fr:tex display="block">             \begin {align*}                 f \space 0 &amp;= c \\                 f (n+1) &amp;= g\space  (f\space  n)             \end {align*}         </fr:tex>
        If such a function satisfies such a <fr:strong>schema of iteration</fr:strong>, then it can 
        be defined in the lambda calculus on Church numerals as
        <fr:tex display="block">             f = \lambda  n.n \space  g \space  c         </fr:tex>
        This definition is <fr:strong>total</fr:strong> which means it is defined for all natural numbers.
        Let&apos;s define the multiplication again
        <fr:tex display="block">             \begin {align*}                 m*0 &amp;= 0 \\                 m*(n+1) &amp;= m + (m*n)             \end {align*}         </fr:tex>
        To fit our schema of iteration, we can define the multiplication by abstracting over <fr:tex display="inline">k</fr:tex>:
        <fr:tex display="block">             \begin {align*}                 \text {times}\space  0 &amp;= \lambda  k.0 \\                 \text {times}\space  (n+1) &amp;= \lambda  k.k + (\text {times}\space  n\space  k)             \end {align*}         </fr:tex>
        where the <fr:tex display="inline">c</fr:tex> and <fr:tex display="inline">g</fr:tex> are
        <fr:tex display="block">             \begin {align*}                 c &amp;= \lambda  k.0 \\                 g &amp;= \lambda  r.\lambda  k.k+(r\space  k)             \end {align*}         </fr:tex>
        and we obtain
        <fr:tex display="block">             \text {times} = \lambda  n.n(\lambda  rk. k + (r\space  k))(\lambda  k.0)         </fr:tex></fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>528</fr:anchor><fr:addr type="machine">#370</fr:addr><fr:route>unstable-370.xml</fr:route><fr:title text="The Schema of Primitive Recursion"><fr:strong>The Schema of Primitive Recursion</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
    <fr:p>Everything appears simply until we think of a very simple function,
        the <fr:strong>predecessor function</fr:strong> <fr:tex display="inline">\text {pred}</fr:tex> defined by
        <fr:tex display="block">             \begin {align*}                 \text {pred}\space  0 = 0 \\                 \text {pred}\space  (n+1) = n             \end {align*}         </fr:tex>
        What we would need is the <fr:strong>schema of primitive recursion</fr:strong>
        <fr:tex display="block">             \begin {align*}                 f\space  0 &amp;= c \\                 f\space  (n+1) &amp;= g\space  n\space  (f\space  n)             \end {align*}         </fr:tex>
        With which we can define the predecessor function by 
        <fr:tex display="block">             g = \lambda  x.\lambda  y.x         </fr:tex></fr:p>
    
    
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>529</fr:anchor><fr:addr type="machine">#366</fr:addr><fr:route>unstable-366.xml</fr:route><fr:title text="Define predecessor function"><fr:strong>Define predecessor function</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
        The key idea is to gain access to <fr:tex display="inline">n</fr:tex> in the schema of 
        primitive recursion by rebuilding it during the iteration.
        <fr:tex display="block">             \text {pred}_2\space  n = \langle  n, \text {pred}\space  n \rangle          </fr:tex>
        The key step is to express the definition by a schema of iteration
        rather than primitive recursion.
        <fr:tex display="block">             \text {pred}_2\space  0 = \langle  0, 0 \rangle          </fr:tex>
        We need a helper function for the successor case
        <fr:tex display="block">             \text {letPair}\space \langle  e_1,e_2\rangle \space  k = k\space  e_1\space  e_2         </fr:tex>
        This function passes the elements of the pair to a <fr:strong>continuation</fr:strong> <fr:tex display="inline">k</fr:tex>.
        <fr:tex display="block">             \text {pred}_2 (n+1) = \text {letPair}\space  (\text {pred}_2\space  n)\space  (\lambda  xy. \langle  x+1, x \rangle )          </fr:tex>
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>530</fr:anchor><fr:addr type="machine">#367</fr:addr><fr:route>unstable-367.xml</fr:route><fr:title text="Define Pairs"><fr:strong>Define Pairs</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
        Now we need to define pairs and <fr:tex display="inline">\text {letPair}</fr:tex>.
        The idea is to simply abstract over the continuation itself.
        <fr:tex display="block">             \begin {align*}                 \langle  x,y\rangle  &amp;= \lambda  k.k\space  x\space  y \\                 \text {pair} &amp;= \lambda  x.\lambda  y.\lambda  k.k\space  x\space  y \\                  \text {letPair} &amp;= \lambda  p.p             \end {align*}         </fr:tex>
        The letPair is not really needed here.
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>531</fr:anchor><fr:addr type="machine">#368</fr:addr><fr:route>unstable-368.xml</fr:route><fr:title text="Summary"><fr:strong>Summary</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
        Summarizing the above and we obtain the full definition of the predecessor function.
        <fr:tex display="block">             \begin {align*}                 \text {pred}_2 &amp;= \lambda  n.n\space  (\lambda  p.p (\lambda  xy.\text {pair} \space  (x+1) \space  x))\space  \text {pair} (\space  0 \space  0)\\                  \text {pred} &amp;= \lambda  n. (\text {pred}_2\space  n) \space  (\lambda  xy.y)             \end {align*}            </fr:tex>
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>532</fr:anchor><fr:addr type="machine">#369</fr:addr><fr:route>unstable-369.xml</fr:route><fr:title text="General Primitive Recursion"><fr:strong>General Primitive Recursion</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>cs-0002</fr:parent></fr:frontmatter><fr:mainmatter>
        The general case of primitive recursion follows by a similar pattern.
        We begin by defining a function <fr:tex display="inline">f_2</fr:tex>:
        <fr:tex display="block">             f_2\space  n = \langle  n, f\space  n \rangle          </fr:tex>
        We can define <fr:tex display="inline">f_2</fr:tex> using the schema of iteration
        <fr:tex display="block">             \begin {align*}                 f_2\space  0 &amp;= \langle  0, c \rangle  \\                 f_2\space  (n+1) &amp;= \text {letPair}\space  (f_2\space  n)\space  (\lambda  xy.\langle  x+1, g\space  x\space  y \rangle ) \\                 f\space  n &amp;= \text {letPair}\space  (f_2\space  n)\space  (\lambda  xy.y)             \end {align*}         </fr:tex>
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:p>When computing over natural numbers we can restrict the functions that can be 
    formed in schematic ways to obtain a language in which all functions <fr:strong>terminate</fr:strong>.
    Because if <fr:tex display="inline">c</fr:tex> and <fr:tex display="inline">g</fr:tex> are terminating then so is <fr:tex display="inline">f</fr:tex> formed from them by primitive recursion.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>533</fr:anchor><fr:addr type="user">cs-0003</fr:addr><fr:route>cs-0003.xml</fr:route><fr:title text="Recursion">Recursion</fr:title><fr:taxon>Computer Science</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In this note we complete the development of <fr:strong>recursion</fr:strong>.
    Refer to <fr:link type="local" href="tapl.xml" addr="tapl" title="Types and Programming Languages">TAPL</fr:link></fr:p>
  
    
    <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>534</fr:anchor><fr:addr type="machine">#358</fr:addr><fr:route>unstable-358.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0003</fr:parent></fr:frontmatter><fr:mainmatter><fr:strong>General Recursion</fr:strong>
    <fr:p>Let&apos;s first consider the <fr:strong>greatest common divisor</fr:strong> function <fr:tex display="inline">\gcd (a,b)</fr:tex></fr:p>
    <fr:tex display="block">         \begin {align*}             \gcd \space  a\space  a &amp;= a \\             \gcd \space  a\space  b &amp;= \gcd \space  (a-b)\space  b  \text { if } b &gt; a \\             \gcd \space  a\space  b &amp;= \gcd \space  a\space  (b-a)  \text { if } a &gt; b         \end {align*}     </fr:tex>
    This recursion is terminating because the arguments are decreasing.
    We can deal with this case currently and let&apos;s be hold.
    We consider the most general schema of recursion.
    <fr:tex display="block">         f = h\space  f     </fr:tex>
    which means that in the right-hand side we can make arbitrary recursive
    calls to the function <fr:tex display="inline">f</fr:tex>. For <fr:tex display="inline">\gcd </fr:tex> we have
    <fr:tex display="block">         h = \lambda  gab. \text {if } (a=b)\space  a\space ((             \text {if }\space (a&gt;b)\space (g\space  (a-b)\space  b)\space (g\space  a\space  (b-a))         ))     </fr:tex>
    How can we define <fr:tex display="inline">f</fr:tex> explicitly when given <fr:tex display="inline">h</fr:tex> so that <fr:tex display="inline">f = h\space  f</fr:tex>,
    which called a <fr:strong>fixed point</fr:strong> pf <fr:tex display="inline">h</fr:tex>. If we believe <fr:strong>Church-Turing thesis</fr:strong>,
    then any partial recursive function should be representable on Church numerals in lambda calculus.
    Hence we can find such <fr:tex display="inline">f</fr:tex> and the answer is called <fr:strong>Y-combinator</fr:strong>.
    We want that if <fr:tex display="inline">f = Y\space  h</fr:tex> and <fr:tex display="inline">f=h\space  f</fr:tex>, so we get <fr:tex display="inline">Y\space  h = h \space  (Y\space  h)</fr:tex>.
    <fr:tex display="block">         Y\space  h = h\space  (Y\space  h) = h\space  (h\space  (Y\space  h)) = h\space  (h\space  (h\space  (Y\space  h))) = \cdots      </fr:tex>
    This iterates infinitely. The definition of <fr:tex display="inline">Y</fr:tex> is:
    <fr:tex display="block">         Y = \lambda  h.(\lambda  x. h\space  (x\space  x))\space  (\lambda  x. h\space  (x\space  x))     </fr:tex>
    The application <fr:tex display="inline">x\space  x</fr:tex> will replicate <fr:tex display="inline">Y\space  h</fr:tex>:
    <fr:tex display="block">         \begin {align*}             Y\space  h &amp;= (\lambda  x. h\space  (x\space  x))\space  (\lambda  x. h\space  (x\space  x)) \\             &amp;= h\space  ((\lambda  x. h\space  (x\space  x))\space  (\lambda  x. h\space  (x\space  x))) \\             &amp;= h\space  (Y\space  h)         \end {align*}     </fr:tex>
    The partial recursive functions include functions that are <fr:strong>undefined</fr:strong> (have no normal form) 
    on some arguments, hence we can&apos;t always find an answer.
    Consider <fr:tex display="inline">f=f</fr:tex> as a recursion schema and <fr:tex display="inline">h=\text {id}</fr:tex>.
    <fr:tex display="block">         Y\space  h = Y\space  \text {id} = (\lambda  x. \text {id}\space  (x\space  x))\space  (\lambda  x. \text {id}\space  (x\space  x))         = (\lambda  x. x\space  x)\space  (\lambda  x. x\space  x) = \Omega      </fr:tex>
    The function <fr:tex display="inline">f=\Omega </fr:tex> solves the equation <fr:tex display="inline">f=f</fr:tex> by giving a divergent result.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
  

  
    
    <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>535</fr:anchor><fr:addr type="machine">#359</fr:addr><fr:route>unstable-359.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0003</fr:parent></fr:frontmatter><fr:mainmatter><fr:strong>Define Functions By Recursion</fr:strong>
    <fr:p>Consider the factorial function:</fr:p>
    <fr:tex display="block">         \text {fact}\space  n = \text {if } (n=0)\space  1\space  (n\space  \text {fact}\space  (n-1))     </fr:tex>
    This requires a test <fr:tex display="inline">\text {if0}</fr:tex> satisfies:
    <fr:tex display="block">         \begin {align*}             \text {if0}(0,c,d) &amp;=c\\             \text {if0}(n+1,c,d) &amp;=d         \end {align*}     </fr:tex>
    We can define <fr:tex display="inline">\text {if0}</fr:tex> by (Recall that <fr:tex display="inline">K=\lambda  xy.x</fr:tex>):
    <fr:tex display="block">         \text {if0} = \lambda  ncd. n\space (K\space  d)\space  c     </fr:tex>
    The argument of Y combinator is defined:
    <fr:tex display="block">         h_\text {fact} = \lambda  g. \lambda  n. \text {if0}\space  n\space  1\space  (n\space  g\space  (n-1))     </fr:tex>
    and
    <fr:tex display="block">         \text {fact} = Y\space  h_\text {fact}     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
  
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>536</fr:anchor><fr:addr type="user">cs-0004</fr:addr><fr:route>cs-0004.xml</fr:route><fr:title text="Scanners">Scanners</fr:title><fr:taxon>Computer Science</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The scanner&apos;s task is to transform a stream of characters into a stream 
    of words in the input language. Each word must be classified into a 
    <fr:strong>syntactic category</fr:strong>.
    This note refers to <fr:link type="local" href="eng-compiler-2022.xml" addr="eng-compiler-2022" title="Engineering a Compiler">Engineering a compiler</fr:link></fr:p><fr:p>The first stage of a compiler is to perform <fr:strong>lexical analysis</fr:strong> by a scanner.
    The parser or <fr:strong>syntax analyzer</fr:strong> will fit the stream of words to a grammatical 
    model of the input language.</fr:p><fr:p>Scanner construction has a strong foundation in formal language theory.
    Scanners are based on <fr:strong>recognizers</fr:strong> that simulate <fr:strong>deterministic finite automata</fr:strong>.
    We can specify the lexical structure using a set of <fr:strong>regular expression</fr:strong>.</fr:p><fr:p>Each time a scanner recognizes a word, it will return a <fr:strong>token</fr:strong> that
    contains the word (<fr:strong>lexeme</fr:strong>) and its syntactic category.
    The scanner uses <fr:strong>microsyntax</fr:strong> (the lexical structure of a language) to 
    find and classify words. <fr:strong>Keywords</fr:strong> are <fr:strong>identifiers</fr:strong> but have special meanings.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>537</fr:anchor><fr:addr type="machine">#354</fr:addr><fr:route>unstable-354.xml</fr:route><fr:title text="A first look at recognizers">A first look at recognizers</fr:title><fr:authors></fr:authors><fr:parent>cs-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>A char-by-char algorithm to recognize words is trivial.
        Consider we want to recognize the word <fr:code>new</fr:code>.
        We can write down the following code.</fr:p><fr:pre>    c &lt;- nextChar();
    if (c == &apos;n&apos;) {
        c &lt;- nextChar();
        if (c == &apos;e&apos;) {
            c &lt;- nextChar();
            if (c == &apos;w&apos;) {
                return newToken();
            }
        }
    }
    reportError();</fr:pre><fr:p>We can also represent the code fragment using the simple <fr:strong>transition diagram</fr:strong>.</fr:p>
    <fr:embedded-tex hash="d05f347414c07afcf952ed181dbb69cd"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            {S_0} &amp; {S_1} &amp; {S_2} &amp; {S_3}
            \arrow [&quot;n&quot;, from=1-1, to=1-2]
            \arrow [&quot;e&quot;, from=1-2, to=1-3]
            \arrow [&quot;w&quot;, from=1-3, to=1-4]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>538</fr:anchor><fr:addr type="machine">#355</fr:addr><fr:route>unstable-355.xml</fr:route><fr:title text="A formalism for recognizers">A formalism for recognizers</fr:title><fr:authors></fr:authors><fr:parent>cs-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Transition diagrams can be viewed as formal mathematics objects called <fr:strong>finite automata</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>539</fr:anchor><fr:addr type="user">def-003M</fr:addr><fr:route>def-003M.xml</fr:route><fr:title text="Finite Automata">Finite Automata</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>finite automata (FA)</fr:strong> is a five-tuple <fr:tex display="inline">(S,\Sigma ,\delta ,s_0,S_A)</fr:tex> where
    <fr:ul><fr:li><fr:tex display="inline">S</fr:tex> is the finite set of states in the recognizer including <fr:tex display="inline">s_e</fr:tex>,
            the error state.</fr:li>
        <fr:li><fr:tex display="inline">\Sigma </fr:tex> is the finite alphabet used by the recognizer. 
            <fr:tex display="inline">\Sigma </fr:tex> is the union of the edge labels in the transition diagram.</fr:li>
        <fr:li><fr:tex display="inline">\delta (s, c)</fr:tex> is the recognizer&apos;s transition function, which 
            maps each state <fr:tex display="inline">s\in  S</fr:tex> and character <fr:tex display="inline">c\in \Sigma </fr:tex> into some next state.
            In state <fr:tex display="inline">s_i</fr:tex> with input character <fr:tex display="inline">c</fr:tex> the FA takes the transition
            <fr:tex display="inline">s_i \xrightarrow {c} \delta (s_i, c)</fr:tex>.</fr:li>
        <fr:li><fr:tex display="inline">s_0\in  S</fr:tex> is the initial state of the recognizer.</fr:li>
        <fr:li><fr:tex display="inline">S_A</fr:tex> is the set of accepting states, <fr:tex display="inline">S_A\subseteq  S</fr:tex>.</fr:li></fr:ul>
    <fr:tex display="inline">\delta </fr:tex> is only partially defined. For all other combinations of the 
    state <fr:tex display="inline">s_i</fr:tex> and input char <fr:tex display="inline">c</fr:tex> we can define <fr:tex display="inline">\delta (s_i,c)=s_e</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>An FA <fr:strong>accpets</fr:strong> a string <fr:tex display="inline">x</fr:tex> and iff starting in <fr:tex display="inline">s_0</fr:tex>,
        the sequence of chars in  <fr:tex display="inline">x</fr:tex> takes the FA to an accepting state
        when the entire string has been consumed.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>540</fr:anchor><fr:addr type="user">def-003N</fr:addr><fr:route>def-003N.xml</fr:route><fr:title text="Accepts">Accepts</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If the string <fr:tex display="inline">x</fr:tex> consists characters <fr:tex display="inline">x_1, x_2, \ldots , x_n</fr:tex> then the
    FA <fr:tex display="inline">(S,\Sigma ,\delta ,s_0,S_A)</fr:tex> <fr:strong>accpets</fr:strong> <fr:tex display="inline">x</fr:tex> iff there is a sequence
    <fr:tex display="block">         \delta (             \delta (                 \dots \delta (\delta (                     \delta (s_0,x_1),x_2),x_3)\dots ,                 x_{n-1}             )             ,x_n         )\in  S_A     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>541</fr:anchor><fr:addr type="machine">#356</fr:addr><fr:route>unstable-356.xml</fr:route><fr:title text="Recognize more complex words">Recognize more complex words</fr:title><fr:authors></fr:authors><fr:parent>cs-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The char-by-char model is very simple and now we consider about numbers.
        For simplicity, we consider only unsigned integers: An unsigned integer is either
        zero or series of one or more digits where the first one is non-zero.</fr:p>
    <fr:embedded-tex hash="b460f960b96d5c831acb91408c74102e"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            &amp; {S_2}
            \arrow [out=65, in=25 ,loop,&quot;0..9&quot;]
            \\
            {S_0} \\
            &amp; {S_1}
            \arrow [&quot;0&quot;, from=2-1, to=3-2]
            \arrow [&quot;{1..9}&quot;, from=2-1, to=1-2]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex>
<fr:p>And the code implementation can be:</fr:p><fr:pre>    state &lt;- s0;
    char &lt;-nextChar();
    while (state != se and char != eof) {
        state &lt;- delta(state, char);
        char &lt;- nextChar();
    }
    if (state in SA) {
        return Acceptance();
    } else {
        reportError();
    }</fr:pre><fr:p>Another example is to recognize <fr:strong>identifiers</fr:strong> which are sequences of letters and digits,
        starting with a letter. Many languages include other special characters for identifiers.
        The FA for unsigned integers and identifiers are different in syntactic categories.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>542</fr:anchor><fr:addr type="machine">#357</fr:addr><fr:route>unstable-357.xml</fr:route><fr:title text="Regular Expressions">Regular Expressions</fr:title><fr:authors></fr:authors><fr:parent>cs-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The set of words accpeted by a finite automata <fr:tex display="inline">F</fr:tex> forms a language <fr:tex display="inline">L(F)</fr:tex>.
        The transition diagram of <fr:tex display="inline">F</fr:tex> specifies the syntactic structure of <fr:tex display="inline">L(F)</fr:tex>.
        But such representation is complex and non-intuitive.
        Most systems use a notation called <fr:strong>regular expressions</fr:strong> to specify the language.
        Any language described by an RE is considered a <fr:strong>regular language</fr:strong>.
        RE is equivalent to FA.</fr:p><fr:p>To work with REs in a rigorous way, we need a foraml definition.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>543</fr:anchor><fr:addr type="user">cs-0005</fr:addr><fr:route>cs-0005.xml</fr:route><fr:title text="Simply Typed Lambda Calculus and Representation Theorems">Simply Typed Lambda Calculus and Representation Theorems</fr:title><fr:taxon>Computer Science</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We have explored the power of lambda calculus.
    Church&apos;s original purpose of the pure calculus of functions 
    was a new foundations of mathematics distinct from set theory.
    Unfortunately the original lambda calculus is <fr:strong>inconsistent</fr:strong> (Every proposition has a proof).
    Church returned to the ideas by Russell and Whitehead and developed the <fr:strong>Church&apos;s Simple Theory of Types</fr:strong>.
    <fr:strong>SLTC</fr:strong> is a typed interpretation of the lambda calculus with only one type constructor <fr:tex display="inline">\to </fr:tex>
    that builds function types.</fr:p><fr:p>We follow the converntion that function type constructor <fr:tex display="inline">\to </fr:tex> is right-associative.
    We write <fr:tex display="inline">e:\tau </fr:tex> if expression <fr:tex display="inline">e</fr:tex> has type <fr:tex display="inline">\tau </fr:tex>.
    <fr:tex display="block">         \lambda  x.x:\tau \to \tau      </fr:tex>
    But the type is not unique. The booleans can be typed:
    <fr:tex display="block">         \begin {align*}             \text {true} &amp;= \lambda  x.\lambda  y.x : \alpha \to (\beta \to \alpha )\\             \text {false} &amp;= \lambda  x.\lambda  y.y : \alpha \to (\beta \to \beta )         \end {align*}     </fr:tex></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>544</fr:anchor><fr:addr type="machine">#242</fr:addr><fr:route>unstable-242.xml</fr:route><fr:title text="Typing Judgment">Typing Judgment</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Wem can formalize judgments about expressions and types using <fr:strong>inference rules</fr:strong>.
        For instance:
        <fr:tex display="block">             \frac {                 e_1:\tau _1\quad  e_2:\tau _2             }{                 e_1\space  e_2:\tau _2             }         </fr:tex>
        The application <fr:tex display="inline">e_1\space  e_2</fr:tex> has type <fr:tex display="inline">\tau _2</fr:tex> if <fr:tex display="inline">e_1</fr:tex> has type 
        <fr:tex display="inline">\tau _1\to \tau _2</fr:tex> and <fr:tex display="inline">e_2</fr:tex> has type <fr:tex display="inline">\tau _1</fr:tex>.</fr:p><fr:p>We can record the types of variable in a <fr:strong>typing context</fr:strong>.
        <fr:tex display="block">             \Gamma  :\equiv  x_1:\tau _1,\ldots ,x_n:\tau _n         </fr:tex>
        And we always assume that all variables declared in a context are distinct.
        This avoids any ambiguity when we try to determine the type of a variable.
        The typing judgment now becomes
        <fr:tex display="block">             \Gamma \vdash  e:\tau          </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>545</fr:anchor><fr:addr type="machine">#243</fr:addr><fr:route>unstable-243.xml</fr:route><fr:title text="The Limits of Simple Types">The Limits of Simple Types</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Are there expressions that cannot be typed in the simple type system?
        Yes, for example, <fr:tex display="inline">\Omega =\lambda  x.x\space  x</fr:tex> cannot be typed.
        But how do we prove that  <fr:tex display="inline">\Omega </fr:tex> cannot be typed?</fr:p><fr:p>We can apply the typing rules and get a contradiction.
        <fr:tex display="inline">\Omega </fr:tex> is a lambda abstraction hence we can assume that it has type <fr:tex display="inline">\tau \to \sigma </fr:tex>.
        Then <fr:tex display="inline">x</fr:tex> has type <fr:tex display="inline">\tau </fr:tex> and <fr:tex display="inline">x\space  x</fr:tex> has type <fr:tex display="inline">\sigma </fr:tex>.
        By the application of <fr:tex display="inline">x\space  x</fr:tex> we get that <fr:tex display="inline">\tau =\tau \to \sigma </fr:tex>, 
        which does not exist.</fr:p><fr:p>To recover from this in full generality we need <fr:strong>recursive types</fr:strong>.
        <fr:tex display="block">             \tau  =F\tau          </fr:tex>
        where <fr:tex display="inline">F=\lambda \alpha .\alpha \to \sigma </fr:tex> and we might have a solution with 
        <fr:tex display="inline">\tau =Y\space  F</fr:tex>. But such solution is not available to us. We do not have 
        function from types to types <fr:tex display="inline">F</fr:tex> and a type level Y combinator.
        However it is ok to construct recursive types (we would do later).</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>546</fr:anchor><fr:addr type="machine">#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:title text="Characterizing the Booleans">Characterizing the Booleans</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>We now show that the representation of the booleans is correct.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>547</fr:anchor><fr:addr type="machine">#245</fr:addr><fr:route>unstable-245.xml</fr:route><fr:title text="Representation of Booleans">Representation of Booleans</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#244</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex display="inline">\emptyset \vdash  e:\alpha \to (\alpha \to \alpha )</fr:tex> and <fr:tex display="inline">e</fr:tex> is a normal form, 
            then <fr:tex display="inline">e = \text {true}</fr:tex> or <fr:tex display="inline">e = \text {false}</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We will later combine this with the following theorems which yields 
    correctness of the representation of the booleans.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>548</fr:anchor><fr:addr type="user">def-003O</fr:addr><fr:route>def-003O.xml</fr:route><fr:title text="Weak Normalization">Weak Normalization</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex display="inline">\Gamma \vdash  e:\tau </fr:tex> then <fr:tex display="inline">e\to _{\beta }^*e&apos;</fr:tex> for a <fr:strong>normal form</fr:strong> <fr:tex display="inline">e&apos;</fr:tex>.
    And we can define <fr:strong>subject reduction</fr:strong>, if <fr:tex display="inline">\Gamma \vdash  e:\tau </fr:tex> and <fr:tex display="inline">e\to _{\beta }e&apos;</fr:tex> then <fr:tex display="inline">\Gamma \vdash  e&apos;:\tau </fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>549</fr:anchor><fr:addr type="machine">#246</fr:addr><fr:route>unstable-246.xml</fr:route><fr:title text="Reduction revised">Reduction revised</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Our characterization of normal forms is quite simple: terms that do not reduce.
        However, this is a <fr:strong>negative</fr:strong> condition, which is difficult to work with in proofs.
        We would like to have a <fr:strong>positive</fr:strong> condition, which is easier to work with.</fr:p><fr:p>We tend to give definitions in the form of inference rules.
        The property then holds if the judgment can be derived using the rules.
        (This closely related to the <fr:strong>inductive deefintion</fr:strong>).
        Before defining the normal forms we formally define <fr:strong>beta reduction</fr:strong>.
        The judgment here <fr:tex display="inline">e\to  e&apos;</fr:tex> expressing that <fr:tex display="inline">e</fr:tex> reduces to <fr:tex display="inline">e&apos;</fr:tex>.
        <fr:tex display="block">             \begin {align*}                 \frac {}{(\lambda  x.e_1)e_2\to  e_1[x:=e_2]} (\text {red/beta}) \\                 \frac {e\to  e&apos;}{\lambda  x.e \to  \lambda  x.e&apos;} (\text {red/lam}) \\                 \frac {e_1\to  e_1&apos;}{e_1\space  e_2\to  e_1&apos;\space  e_2} (\text {red/app}_1) \\                 \frac {e_2\to  e_2&apos;}{e_1\space  e_2\to  e_1\space  e_2&apos;} (\text {red/app}_2)                             \end {align*}         </fr:tex></fr:p><fr:p>A <fr:strong>normal form</fr:strong> is an expression that does not reduce.
        To give a proper formalization,, we need a separate judgment for <fr:strong>neutral terms</fr:strong>
        which do not create a redex when applied to an argument.
        <fr:tex display="block">                                       \begin {align*}                 \frac {e\text { normal}}{\lambda  x.e\text { normal}} (\text {normal/lam}) \\                 \frac {e\text { neutral}}{e\text { normal}} (\text {normal/var}) \\                 \frac {}{x\text { neutral}} (\text {neutral/var}) \\                 \frac {e_1\text { neutral}\quad  e_2\text { normal}}{e_1\space  e_2\text { neutral}} (\text {neutral/app}) \\             \end {align*}         </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>550</fr:anchor><fr:addr type="machine">#247</fr:addr><fr:route>unstable-247.xml</fr:route><fr:title text="Normal Forms and Reduction">Normal Forms and Reduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The characterization of normal forms via inference rules is compact,
        but is it really the same as saying that an expression does not reduce?
        We break this down into the following two properties.
        <fr:ul><fr:li>For all expressions <fr:tex display="inline">e</fr:tex>, either <fr:tex display="inline">e</fr:tex> reduces or <fr:tex display="inline">e</fr:tex> is normal</fr:li>
            <fr:li>For all expressions <fr:tex display="inline">e</fr:tex>, it is not that case <fr:tex display="inline">e</fr:tex> reduces and <fr:tex display="inline">e</fr:tex> is normal</fr:li></fr:ul></fr:p><fr:p>We have theorem that ensures that the first property holds. (Proof is omitted).</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>551</fr:anchor><fr:addr type="user">thm-0010</fr:addr><fr:route>thm-0010.xml</fr:route><fr:title text="Reduction and normal forms">Reduction and normal forms</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For every expression <fr:tex display="inline">e</fr:tex>, either <fr:tex display="inline">e\to  e&apos;</fr:tex> for some expression <fr:tex display="inline">e&apos;</fr:tex> or <fr:tex display="inline">e</fr:tex> is a normal form.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>552</fr:anchor><fr:addr type="user">cs-0006</fr:addr><fr:route>cs-0006.xml</fr:route><fr:title text="Introduction to Programming Language Semantic">Introduction to Programming Language Semantic</fr:title><fr:taxon>Computer Science</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>11</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>I decided to read one paper or article every week.
    This week&apos;s topic is programming language semantics, refer to <fr:strong>Graham Huttons</fr:strong>&apos;s 
    paper <fr:link type="local" href="pl-123.xml" addr="pl-123" title="Programming language semantics: It&apos;s easy as 1,2,3">Programming language semantics: It&apos;s easy as 1,2,3</fr:link>.</fr:p><fr:p><fr:strong>Semantics</fr:strong> is the general term for the study of meaning.
    <fr:strong>Programming language semantics</fr:strong> gives precise mathematical meaning to programs.
    We use a simple <fr:strong>arithmetic expression language</fr:strong> 
    (including integers and addition only) to illustrate the basic concepts.
    This is an example of <fr:strong>Occam&apos;s razor</fr:strong>, a philosophical principle that favours the 
    simplest explanation for a phenomenon.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>553</fr:anchor><fr:addr type="machine">#343</fr:addr><fr:route>unstable-343.xml</fr:route><fr:title text="Arithmetic Expressions">Arithmetic Expressions</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>11</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0006</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Now let&apos;s define our language of arithmetic expressions
        built up from the set of integers and the operation of addition.
        Use a <fr:strong>context-free</fr:strong> grammar.
        <fr:tex display="block">             E:\equiv \mathbb {Z} | E+E         </fr:tex></fr:p><fr:p>An expression is either an integer value or the addition of two sub-expressions.
        We assume that parentheses can be <fr:strong>freely</fr:strong> used as required to disambiguate expressions 
        written in normal textual form. This grammar can be easily translated into 
        a <fr:strong>Haskell</fr:strong> data type.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Expr = Val Integer | Add Expr Expr</html:code></fr:pre>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>555</fr:anchor><fr:addr type="machine">#344</fr:addr><fr:route>unstable-344.xml</fr:route><fr:title text="Denotational Semantics">Denotational Semantics</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>11</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0006</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Now we consider <fr:strong>denotational semantics</fr:strong>, 
        where the terms in a language is defined using a 
        <fr:strong>valuation function</fr:strong> that maps terms into values in an appropriate <fr:strong>semantic domain</fr:strong>.</fr:p><fr:p>Formally, for a language <fr:tex display="inline">T</fr:tex> of syntactic terms comprises
        two components: a set <fr:tex display="inline">V</fr:tex> of <fr:strong>semantic values</fr:strong> and a 
        <fr:strong>valuation function</fr:strong> of type <fr:tex display="inline">T\to  V</fr:tex> that maps terms to 
        their meanings as values.
        This function is written by enclosing a term in a <fr:strong>semantic brackets</fr:strong> 
        (Also known as Oxford or Strachey brackets),
        writing <fr:tex display="inline">\llbracket  t\rrbracket </fr:tex> for the value of term <fr:tex display="inline">t</fr:tex>.
        In addition, the valuation function is required to be <fr:strong>compositional</fr:strong>,
        the meaning  of a <fr:strong>compound term</fr:strong> is defined purely in terms of the meaning
        of its sub-terms.</fr:p><fr:p>Compositionality aids understanding by ensuring that the semantics is modular
        and supports the use of simple <fr:strong>equational reasoning</fr:strong> techniques for proving properties of
        the semantics. When the set of semantic values is clear, a denotational semantics is often
        identified with the underlying valuation function.</fr:p><fr:p>Taking <fr:tex display="inline">V</fr:tex> the Haskell type <fr:code>Integer</fr:code> of integers and define a valuation function
        of type <fr:code>Expr -&gt; Integer</fr:code> (by following equations) we can define the denotational semantics of our expression language.
        <fr:tex display="block">             \begin {align*}                 \llbracket \text {Val} \space  n\rrbracket  &amp;= n \\                 \llbracket \text {Add} \space  e_1\space  e_2\rrbracket  &amp;= \llbracket  e_1\rrbracket  + \llbracket  e_2\rrbracket              \end {align*}         </fr:tex>
        This definition satisfies the compositionality requirement obviously.
        Note that the symbol <fr:tex display="inline">+</fr:tex> has two different purposes.
        On the left side, it is a <fr:strong>syntactic</fr:strong> constructor for building terms,
        while on the right side, it is a <fr:strong>semantic</fr:strong> operator for adding integers.</fr:p><fr:p>Compositionality simplifies reasoning because it allows us to 
        replace <fr:strong>equals by equals</fr:strong>. For example,
        <fr:tex display="block">             \frac {                 \llbracket  e_1\rrbracket  = n_1 \quad  \llbracket  e_2\rrbracket  = n_2             }{                 \llbracket \text {Add} \space  e_1\space  e_2\rrbracket  =                 \llbracket \text {Add} \space  n_1\space  n_2\rrbracket              }         </fr:tex>
        we can freely replace the two argument expressions of an addition by other expressions with the same meanings, 
        and the meaning of the whole addition will remain unchanged.
        Using the definition of the valuation function, we can prove this property.
        <fr:tex display="block">             \begin {align*}                 \llbracket \text {Add} \space  e_1\space  e_2\rrbracket  &amp;=                  \llbracket  e_1\rrbracket  + \llbracket  e_2\rrbracket  (\text {By definition of } \llbracket -\rrbracket ) \\                 &amp;= \llbracket  n_1\rrbracket  + \llbracket  n_2\rrbracket  (\text {Assumptions}) \\                  &amp;= \llbracket \text {Add} \space  n_1\space  n_2\rrbracket  (\text {By definition of } \llbracket -\rrbracket )             \end {align*}         </fr:tex></fr:p><fr:p>Given that terms and their semantics are built up <fr:strong>inductively</fr:strong>,
        proofs about denotational semantics typically  proceed using <fr:strong>structural induction</fr:strong>.
        Let us show that our expression semantics is <fr:strong>total</fr:strong>,
        that is, for every expression <fr:tex display="inline">e</fr:tex> there is an integer <fr:tex display="inline">n</fr:tex> such that <fr:tex display="inline">\llbracket  e\rrbracket  = n</fr:tex>.</fr:p>
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>556</fr:anchor><fr:addr type="machine">#345</fr:addr><fr:route>unstable-345.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>11</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#344</fr:parent></fr:frontmatter><fr:mainmatter>
        For the base case <fr:tex display="inline">e = \text {Val} \space  n</fr:tex>, we have <fr:tex display="inline">\llbracket  e\rrbracket  = n</fr:tex> trivially.
        For the inductive case <fr:tex display="inline">e = \text {Add} \space  e_1\space  e_2</fr:tex>,
        we can assume by induction that <fr:tex display="inline">\llbracket  e_1\rrbracket  = n_1</fr:tex> and <fr:tex display="inline">\llbracket  e_2\rrbracket  = n_2</fr:tex>
        for some integers <fr:tex display="inline">n_1</fr:tex> and <fr:tex display="inline">n_2</fr:tex>. Then <fr:tex display="inline">\llbracket  e\rrbracket  = n_1 + n_2</fr:tex> by definition of the valuation function,
        indicates this case is also true. Therefore, the semantics is total.
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 
<fr:p>The valuation function can be translated into a Haskell function</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval :: Expr -&gt; Integer
eval (Val n) = n
eval (Add x y) = eval x + eval y</html:code></fr:pre>
<fr:p>More generally, a denotational semantics can be viewed as an evaluator (or <fr:strong>interpreter</fr:strong>).
        Even <fr:strong>eval</fr:strong> is defined recursively, the semantics is compositional its behavior
        can be understood  as simply replacing the <fr:strong>constructors</fr:strong> for expressions by other functions.
        In this manner, a denotational semantics can also be viewed as an evaluation function that
        is defined by <fr:strong>folding</fr:strong> over the syntax of the source language.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval :: Expr -&gt; Integer
eval = fold id (+)</html:code></fr:pre>
<fr:p>The fold operator captures the ideas of replacing constructors
        of the language by other functions</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">fold :: (Integer -&gt; a) -&gt; (a -&gt; a -&gt; a) -&gt; Expr -&gt; a 
fold f g (Val n) = f n
fold f g (Add x y) = g (fold f g x) (fold f g y)</html:code></fr:pre>
<fr:p>Note that the above semantics for expressions does not specify the order
        of evaluation. If we do wish to make evaluation order explicit 
        this requires the introduction of additional structure into the semantics,
        named <fr:strong>abstract machines</fr:strong> (Discuss later).</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>560</fr:anchor><fr:addr type="machine">#346</fr:addr><fr:route>unstable-346.xml</fr:route><fr:title text="Small-Step Operational Semantics">Small-Step Operational Semantics</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>11</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0006</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Another popular approach to semantics is the <fr:strong>operational approach</fr:strong>,
        where the meaning of terms is defined using an <fr:strong>execution relation</fr:strong>
        that specifies how terms can be executed in an appropriate machine model.
        There are two basic forms of operational semantics:
        <fr:ul><fr:li><fr:strong>small-step</fr:strong>: describes the individual steps of execution</fr:li>
            <fr:li><fr:strong>big-step</fr:strong>: describes the overall results of execution</fr:li></fr:ul>
        In this section we consider the small-step approach, 
        which is also known as <fr:strong>structural operational semantics</fr:strong>.</fr:p><fr:p>Formally, a small-step operational semantics for a language <fr:tex display="inline">T</fr:tex> of syntactic terms
        comprises two components:
        a set <fr:tex display="inline">S</fr:tex> of <fr:strong>execution states</fr:strong> and 
        a <fr:strong>transition relation</fr:strong> of type <fr:tex display="inline">S\to  S</fr:tex> that specifies how terms can be executed.
        If there is a transition from state <fr:tex display="inline">s</fr:tex> to state <fr:tex display="inline">s&apos;</fr:tex> in a single execution step, we write <fr:tex display="inline">s\to  s&apos;</fr:tex>.</fr:p><fr:p>Arithmetic expressions have a simple small-step operational semantics,
        given by taking <fr:tex display="inline">S</fr:tex> as the Haskell type. And we define transition relation 
        on <fr:code>Expr</fr:code> by the following inference rules.
        <fr:tex display="block">             \begin {align*}                 \frac {}{                     \text {Add}\space (\text {Val}\space  n_1)\space (\text {Val}\space  n_2)\to \text {Val}\space (n_1+n_2)                 } \\                 \frac {x\to  x&apos;}{\text {Add} \space  x\space  y\to \text {Add} \space  x&apos;\space  y}                  \quad                   \frac {y\to  y&apos;}{\text {Add} \space  x\space  y\to \text {Add} \space  x\space  y&apos;}             \end {align*}         </fr:tex></fr:p><fr:p>The first rule states that two values can be added to give a single value and is called a
        <fr:strong>reduction</fr:strong> (or <fr:strong>contraction</fr:strong>) rule.
        An expression that matches such a rule is termed a reducible expression or <fr:strong>redex</fr:strong>.
        The last two rules are called <fr:strong>structural</fr:strong> (or <fr:strong>congruence</fr:strong>) rules as 
        they specify how larger terms can be reduced.</fr:p><fr:p>The semantics is <fr:strong>non-deterministic</fr:strong> because an expression
        may have more than one possible transition.
        This is obviously from the structural rules, which allow either sub-expression to be reduced first.</fr:p><fr:p>We can now capture a the relation between the denotational and operational semantics,
        namely that making a transition does not change the denotation of an expression.
        <fr:tex display="block">             \frac {                 e\to  e&apos;             }{                 \llbracket e\rrbracket  = \llbracket e&apos;\rrbracket              }         </fr:tex>
        This property can be proved by induction on the structure of the expression <fr:tex display="inline">e</fr:tex>.
        Note that by using the &quot;equals by equals&quot; and the assumption <fr:tex display="inline">x\to  x&apos;</fr:tex> we can easily 
        prove the inductive case. The details are omitted here as it involves quite a bit of 
        case analysis. We will later see the <fr:strong>principle of rule induction</fr:strong>, which gives 
        a simpler and more direct way to prove such properties.</fr:p><fr:p>Evaluation of an expression using the small-step semantics proceeds by a series of zero
        or more transition steps. Formally we can write <fr:tex display="inline">e\to ^* e&apos;</fr:tex> to indicate that <fr:tex display="inline">e</fr:tex> can be
        reduced to <fr:tex display="inline">e&apos;</fr:tex> in zero or more steps.
        We can generate a transition tree that captures all possible execution
        paths for an expression. Using the list comprehension we can define a 
        function that returns the list of all expressions that can be reduced 
        from a given expression <fr:tex display="inline">e</fr:tex> in a single transition.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">trans :: Expr -&gt; [Expr]
trans (Val n) = []
trans (Add (Val n) (Val m)) = [Val (n + m)]
trans (Add x y) = [Add x&apos; y | x&apos; &lt;- trans x] ++ [Add x y&apos; | y&apos; &lt;- trans y]</html:code></fr:pre>
<fr:p>We can define a Haskell datatype for transition trees 
        and an execution function that converts expressions into 
        transition trees.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Tree a = Node a [Tree a]
exec :: Expr -&gt; Tree Expr
exec e = Node e [exec e&apos; | e&apos; &lt;- trans e]</html:code></fr:pre>
<fr:p>Though <fr:code>exec</fr:code> is defined recursively, its behavior can be understood as simply applying
        the identity function to give the root of the tree and the transition function to generate a 
        list of residual expressions to be processed to give the subtrees.
        A small-step semantics can be viewed as giving rise to an execution
        function that is defined by <fr:strong>unfolding</fr:strong> to transition trees.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">exec :: Expr -&gt; Tree Expr
exec = unfold id trans</html:code></fr:pre>
<fr:p>The <fr:code>unfold</fr:code> function captures the idea of generating a tree 
        from a seed value <fr:tex display="inline">x</fr:tex> by applying a function <fr:tex display="inline">f</fr:tex> to give the root 
        and a function <fr:tex display="inline">g</fr:tex> to give a list of residual values to be processed
        for the subtrees.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">unfold :: (t -&gt; a) -&gt; (t -&gt; [t]) -&gt; t -&gt; Tree a
unfold f g x = Node (f x) [unfold f g x&apos; | x&apos; &lt;- g x]</html:code></fr:pre>
<fr:p>The operational semantics corresponds to <fr:strong>unfolding to transition trees</fr:strong>,
        while denotational semantics corresponds to <fr:strong>folding over syntax trees</fr:strong>.
        Thinking about semantics in terms of recursion operators reveals a duality</fr:p><fr:p>The above semantics for expressions does not specify the order of evaluation.
        But we can modify the inference rules to achieve this. Replace the second <fr:tex display="inline">\text {Add}</fr:tex> 
        rule by the following rule ensures the first argument of addition is 
        always reduced first.
        <fr:tex display="block">             \frac {                 y\to  y&apos;             }{                 \text {Add} (\text {Val}\space  n)\space  y \to  \text {Add} (\text {Val}\space  n)\space  y&apos;             }         </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>565</fr:anchor><fr:addr type="machine">#347</fr:addr><fr:route>unstable-347.xml</fr:route><fr:title text="Rule induction">Rule induction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>11</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0006</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>For denotational semantics we have structural induction,
        dual to this, for operational semantics we have <fr:strong>rule induction</fr:strong>.
        This allows us to perform proofs by considering the structure of the rules 
        that are used to define the semantics.</fr:p><fr:p>We introduce the idea of rule induction using a simple numeric example.
        We begin by inductively defining a set of natural numbers.
        <fr:tex display="block">                 \frac {}{0\in \mathbb {N}} \quad                   \frac {n\in \mathbb {N}}{n+1\in \mathbb {N}}         </fr:tex>
        This is the standard definition of the natural numbers using peano axioms,
        where the first rule states that zero is a natural number and the second rule states that
        if <fr:tex display="inline">n</fr:tex> is a natural number then so is <fr:tex display="inline">n+1</fr:tex>.</fr:p><fr:p>For the inductively defined set <fr:tex display="inline">\mathbb {N}</fr:tex>. The principle of rule induction
        states that in order to prove a property <fr:tex display="inline">P(n)</fr:tex> for all natural numbers <fr:tex display="inline">n</fr:tex>,
        it suffices to prove that <fr:tex display="inline">P(0)</fr:tex> holds and that if <fr:tex display="inline">P(n)</fr:tex> holds then <fr:tex display="inline">P(n+1)</fr:tex> holds.
        <fr:tex display="block">             \frac {                 P(0)\quad \forall  n\in \mathbb {N}. P(n)\to  P(n+1)             }{                 \forall  n\in \mathbb {N}. P(n)             }         </fr:tex>
        Notice that this is the well-known <fr:strong>principle of mathematical induction</fr:strong>.</fr:p><fr:p>The concept of rule induction can easily be generalised to multiple base and 
        inductive cases, to rule with multiple preconditions and so on.
        For the small-step semantics of expressions, we have one base case and two inductive cases.
        Hence if we want to show that some property <fr:tex display="inline">P(e,e&apos;)</fr:tex> on pairs of expression holds for 
        all transition <fr:tex display="inline">e\to  e&apos;</fr:tex>, we can use rule induction:
        <fr:tex display="block">             \frac {                 \begin {align*}                     P(\text {Add}\space (\text {Val}\space  n_1)\space (\text {Val}\space  n_2),\text {Val}\space (n_1+n_2)) \\                     \forall  x\to  x&apos;. P(x,x&apos;)\to  P(\text {Add}\space  x\space  y,\text {Add}\space  x&apos;\space  y) \\                     \forall  y\to  y&apos;. P(y,y&apos;)\to  P(\text {Add}\space  x\space  y,\text {Add}\space  x\space  y&apos;)                 \end {align*}             }{                 \forall  e\to  e&apos;. P(e,e&apos;)             }         </fr:tex>
        We write <fr:tex display="inline">\forall  x\to  y.P(x,y)</fr:tex> as shorthand for 
        <fr:tex display="block">\forall  x,y.x\to  y\Rightarrow  P(x,y)</fr:tex>. Now we give the proof 
        of the property <fr:tex display="inline">\llbracket e\rrbracket  = \llbracket e&apos;\rrbracket </fr:tex> for all transitions <fr:tex display="inline">e\to  e&apos;</fr:tex>.
        <fr:tex display="block">             \forall  e\to  e&apos;. \llbracket e\rrbracket  = \llbracket e&apos;\rrbracket          </fr:tex></fr:p>
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>566</fr:anchor><fr:addr type="machine">#348</fr:addr><fr:route>unstable-348.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>11</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#347</fr:parent></fr:frontmatter><fr:mainmatter>
        The proof consists of three parts: the base case, the reduction rule and the structural rule.
        <fr:tex display="block">             \begin {align*}                 \llbracket \text {Add}\space (\text {Val}\space  n)\space (\text {Val}\space  m)\rrbracket                  &amp;= \llbracket \text {Val}\space  n\rrbracket  + \llbracket \text {Val}\space  m\rrbracket  \\                 &amp;= n + m \\                 &amp;= \llbracket \text {Val}\space (n+m)\rrbracket              \end {align*}         </fr:tex>
        and
        <fr:tex display="block">             \begin {align*}                 \llbracket \text {Add}\space  x\space  y\rrbracket                  &amp;= \llbracket x\rrbracket  + \llbracket y\rrbracket   \\                 &amp;= \llbracket x&apos;\rrbracket  + \llbracket y\rrbracket  (\text {By assumption }\llbracket x\rrbracket =\llbracket x&apos;\rrbracket ) \\                 &amp;= \llbracket \text {Add}\space  x&apos;\space  y\rrbracket              \end {align*}         </fr:tex>
        and 
        <fr:tex display="block">             \begin {align*}                 \llbracket \text {Add}\space  x\space  y\rrbracket                  &amp;= \llbracket x\rrbracket  + \llbracket y\rrbracket   \\                 &amp;= \llbracket x\rrbracket  + \llbracket y&apos;\rrbracket  (\text {By assumption }\llbracket y\rrbracket =\llbracket y&apos;\rrbracket ) \\                  &amp;= \llbracket \text {Add}\space  x\space  y&apos;\rrbracket              \end {align*}         </fr:tex>
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>567</fr:anchor><fr:addr type="machine">#349</fr:addr><fr:route>unstable-349.xml</fr:route><fr:title text="Contextual Semantics">Contextual Semantics</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>11</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0006</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The small-step semantics for expressions above has one basic reduction rule 
        for adding values and two structural rules that allow addition to be performed
        in larger expressions. Separating these two kinds of rules results 
        the notion of <fr:strong>contextual semantics</fr:strong> (or <fr:strong>reduction semantics</fr:strong>).</fr:p><fr:p>Informally, a context in this setting is a term with a &quot;<fr:strong>hole</fr:strong>&quot;, 
        usually written as <fr:tex display="inline">[-]</fr:tex>, which can be filled with another term later.
        In a contextual semantics, the hole represents the location where a <fr:strong>single</fr:strong>
        basic step of execution may take place within a term.</fr:p><fr:p>Consider the following transition in our small-step semantics.
        <fr:tex display="block">             (1+2)+(3+4)\to  3+(3+4)         </fr:tex>
        The addition is performed on the left side.
        We say that we can perform the basic step <fr:tex display="inline">1+2\to 3</fr:tex> in the 
        <fr:strong>context</fr:strong> <fr:tex display="inline">[-]+(3+4)</fr:tex> where <fr:tex display="inline">[-]</fr:tex> implies the location of the
        addition takes place.</fr:p><fr:p>The language <fr:tex display="inline">C</fr:tex> of contexts of arithmetic expressions can be formally defined by 
        <fr:tex display="block">             C:\equiv [-]|C+E|E+C         </fr:tex>
        As previously, we can define a Haskell datatype for contexts.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Cont = Hole | Add Cont Expr | Add Expr Cont</html:code></fr:pre>
<fr:p>The kind of context is known as &quot;outside-in&quot; as locating the hole involves
        navigating from the outside of the context inwards. To fill the hole in 
        a context <fr:tex display="inline">c</fr:tex> with an expression <fr:tex display="inline">e</fr:tex> we write <fr:tex display="inline">c\space [e]</fr:tex>:
        <fr:tex display="block">             \begin {align*}                 \text {Hole}\space [e] &amp;= e \\                 (\text {AddL}\space c\space r)\space [e] &amp;= \text {Add}\space  (c\space [e])\space  r \\                 (\text {AddR}\space l\space c)\space [e] &amp;= \text {Add}\space  l\space (c\space [e])             \end {align*}         </fr:tex></fr:p><fr:p>Use the idea of hole filling we can redefine the small-step semantics
        for expressions in contextual style.
        <fr:tex display="block">             \frac {}{                 \text {Add}\space (\text {Val}\space  n_1)\space (\text {Val}\space  n_2)\rightarrowtail  \text {Val}\space (n_1+n_2)             } \quad              \frac {                 e \rightarrowtail  e&apos;             }{                 c\space  [e] \to  c\space  [e&apos;]             }         </fr:tex>
        This first rule defines a reduction relation <fr:tex display="inline">\rightarrowtail </fr:tex> that captures the basic behavior of addition,
        while the second defines a transition relation <fr:tex display="inline">\to </fr:tex> that allows the first rule to be applied in 
        any context.</fr:p><fr:p>We have now refactored the small-step semantics into a single reduction rule and a single structural rule.
        If we subsequently want to extend the language with other features,
        it only requires adding new reduction rules and extending the notion of contexts
        but not need to adding new structural rules.</fr:p><fr:p>Now we define the hole filling function in Haskell.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">fill :: Cont -&gt; Expr -&gt; Expr
fill Hole e = e
fill (AddL c r) e = Add (fill c e) r
fill (AddR l c) e = Add l (fill c e)</html:code></fr:pre>
<fr:p>The dual operation which splits an expression into all possible pairs of 
    contexts and expressions can be defined:</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">split :: Expr -&gt; [(Cont,Expr)]
split e = (Hole, e) : case e of
Val n -&gt; []
Add l r -&gt; [(AddL c r, x) | (c, x) &lt;- split l] ++ 
            [(AddR l c, x) | (c, x) &lt;- split r]</html:code></fr:pre>
<fr:p>A pair <fr:tex display="inline">(c,x)</fr:tex> comprising a context #[c] and an expression <fr:tex display="inline">x</fr:tex> is
        an element of the list returned by <fr:code>split e</fr:code> precisely when <fr:code>fill c x = e</fr:code>.
        The contextual semantics can be translated into Haskell function that returns
        the lists of all expressions that can be reached by performing a single reduction step.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">reduce :: Expr -&gt; [Expr]
reduce (Add (Val n) (Val m)) = [Val (n + m)]
reduce _ = []</html:code></fr:pre>
<fr:p>or a single transition step.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">trans :: Expr -&gt; [Expr]
trans e = [fill c x&apos; | (c, x) &lt;- split e, x&apos; &lt;- reduce x]</html:code></fr:pre>
<fr:p>This function splits the given expression into all possible context 
        and expression pairs, then considering any reduction that can made by each component
        expression, and finally filling the hole in the context with the reduced expression.</fr:p><fr:p>Notice that the contextual semantics does not specify an evaluation
        order for addition and is non-deterministic. We can modify the language
        of contexts to achieve so.
        <fr:tex display="block">             C:\equiv [-]|C+E|\mathbb {Z}+C         </fr:tex>
        This version of the semantics also satisfies a <fr:strong>unique decomposition property</fr:strong>,
        that is, any expression <fr:tex display="inline">e</fr:tex> that is not a value can be uniquely decomposed into the 
        form <fr:tex display="inline">e=c\space [x]</fr:tex> for some context <fr:tex display="inline">c</fr:tex> and reducible expression <fr:tex display="inline">x</fr:tex>. This can be 
        proved by induction on the expression <fr:tex display="inline">e</fr:tex>.</fr:p><fr:p>Contexts are related to a number of other important concepts in
        programming and semantics, including the use of continuations to make control flow
        explicit (John C. Reynolds 1972).</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>573</fr:anchor><fr:addr type="machine">#350</fr:addr><fr:route>unstable-350.xml</fr:route><fr:title text="Big-step Semantics">Big-step Semantics</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>11</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0006</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Big-step semantics is also known as <fr:strong>natural semantics</fr:strong>,
        which focus on large execution step. For a language T of syntactic terms
        comprises two components: a set <fr:tex display="inline">V</fr:tex> of values and 
        an evaluation relation between <fr:tex display="inline">T</fr:tex> and <fr:tex display="inline">V</fr:tex> that relates each term 
        to all values that can be reached by fully executing the term.
        If a term <fr:tex display="inline">t</fr:tex> and a value <fr:tex display="inline">v</fr:tex> are related, we say that <fr:tex display="inline">t</fr:tex> can evaluate to <fr:tex display="inline">v</fr:tex> 
        and write this as <fr:tex display="inline">t\Downarrow  v</fr:tex></fr:p><fr:tex display="block">         \frac {}{             \text {Val}\space  n\Downarrow  n         }         \quad          \frac {             x\Downarrow  n\quad  y\Downarrow  m          }{             \text {Add}\space  x\space  y\Downarrow  n+m         }     </fr:tex><fr:p>The Haskell function definition is similar to the small-step semantics,
        by using the list comprehension.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval :: Expr -&gt; [Integer]
eval (Val n) = [n]
eval (Add x y) = [n + m | n &lt;- eval x, m &lt;- eval y]</html:code></fr:pre>
<fr:p>This is similar to denotational semantics but using inference rules
        rather than a functional manner.
        However, there is no need for a big-step semantics to be compositional.
        Formally, the denotational and big-step semantics for the expression language
        are equivalent, which can be captured by the following property:
        <fr:tex display="block">             \llbracket e\rrbracket  = n \iff  e\Downarrow  n         </fr:tex>
        This is easily verified by induction.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>575</fr:anchor><fr:addr type="machine">#351</fr:addr><fr:route>unstable-351.xml</fr:route><fr:title text="Abstract Machine">Abstract Machine</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>11</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0006</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>All the exmaples we have meet focused on explaining semantic ideas,
        now we show how language of integers and addition can also be used to help 
        discover semantic ideas.
        We show how it can be used as the basis for discovering how to implement 
        an <fr:strong>abstract machine</fr:strong>.</fr:p><fr:p>Remember the evaluation order problem we meet before,
        if we want to make evaluation order explicit, we can introduce additional
        structure into the semantics by constructing an abstract machine.</fr:p><fr:p>Formally, an abstract machine is usually deifned by a set of syntactic rewrite ruless 
        that make explicit how each step of evaluation proceeds.
        This section we show how an abstract machine for our example language can 
        be systematically derived from the evaluation function using steps
        based on two important semantic concepts, <fr:strong>continuations</fr:strong> and <fr:strong>defunctionalisation</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>576</fr:anchor><fr:addr type="machine">#352</fr:addr><fr:route>unstable-352.xml</fr:route><fr:title text="Add Continuations">Add Continuations</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>11</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#351</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>We want to make the order of evaluation explicit in the semantics itself.
            A standard technique for achieving this aim is to rewrite the semantics
            in <fr:strong>continuation-passing style</fr:strong>.</fr:p><fr:p>In our setting, a continuation is a function that will be applied to the result of an
            evaluation. Formally, for our semantics <fr:code>eval :: Expr -&gt; Integer</fr:code>, a continuation
            is a function of type <fr:code>Integer -&gt; Integer</fr:code> that will be applied to the resulting integer
            to give a new integer. (This type can be generalized to <fr:code>Integer -&gt; a</fr:code>, but we do not need now)
            We capture the notion of such a continuation using the following type declaration:</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">type Continuation = Integer -&gt; Integer</html:code></fr:pre>
<fr:p>We now define a new semantics <fr:tex display="inline">\text {eval}&apos;</fr:tex>, which takes an expression and returns
            an integer as previously but also takes a continuation as an additional argument,
            which is applied to the result of evaluating the expression.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval&apos; :: Expr -&gt; Continuation -&gt; Integer</html:code></fr:pre>
<fr:p>The behavior of <fr:tex display="inline">\text {eval}&apos;</fr:tex> should be:</fr:p><fr:tex display="block">             \text {eval}&apos;\space  e\space  c = \text {c (eval e)}         </fr:tex><fr:p>We want to calculate a definition that satisfies the specification.
            Using structural induction on the expression <fr:tex display="inline">e</fr:tex>, we construct 
            the term <fr:tex display="inline">\text {eval}&apos;\space  e\space  c</fr:tex> by gradually removing the reference to <fr:code>eval</fr:code>.
            For the base case, <fr:tex display="inline">e = \text {Val}\space  n</fr:tex> we have</fr:p><fr:tex display="block">             \begin {align*}                 \text {eval}&apos;\space (\text {Val}\space  n)\space  c                  &amp;= c\space  (\text {eval}\space  (\text {Val}\space  n)) \\                 &amp;= c\space  n             \end {align*}         </fr:tex><fr:p>For the inductive case, <fr:tex display="inline">e = \text {Add}\space  x\space  y</fr:tex> we begin in the same way:</fr:p><fr:tex display="block">             \begin {align*}                 \text {eval}&apos;\space (\text {Add}\space  x\space  y)\space  c                  &amp;= c\space  (\text {eval}\space  (\text {Add}\space  x\space  y)) \\                 &amp;= c\space  (\text {eval}\space  x + \text {eval}\space  y)             \end {align*}         </fr:tex><fr:p>However, no further definition can be applied now, so we consider the inductive hypothesis:
            Forall <fr:tex display="inline">c&apos;</fr:tex> and <fr:tex display="inline">c&apos;&apos;</fr:tex> we have <fr:tex display="inline">\text {eval}&apos;\space  x\space  c&apos; = c&apos;(\text {eval}\space  x)</fr:tex> and
            <fr:tex display="inline">\text {eval}&apos;\space  y\space  c&apos;&apos; = c&apos;&apos;(\text {eval}\space  y)</fr:tex>. This can readily be achieved by 
            abstracting over <fr:tex display="inline">\text {eval}\space  x</fr:tex> and <fr:tex display="inline">\text {eval}\space  y</fr:tex> using lambda abstraction.</fr:p><fr:tex display="block">             \begin {align*}                 &amp; c\space  (\text {eval}\space  x + \text {eval}\space  y) \\                 =&amp; (\lambda  n\to  c\space (n+\text {eval}\space  y)) \\                 =&amp; \text {eval}&apos;\space  x\space  (\lambda  n\to  c\space (n+\text {eval}\space  y)) \\                  =&amp; \text {eval}&apos;\space  x\space  (\lambda  n\to  (\lambda  m\to  c\space (n+m))(\text {eval}\space  y)) \\                  =&amp; \text {eval}&apos;\space  x\space  (\lambda  n\to  \text {eval}&apos;\space  y\space  (\lambda  m\to  c\space (n+m)))             \end {align*}         </fr:tex><fr:p>The final term does not refer to <fr:tex display="inline">\text {eval}</fr:tex> now.
            In summary we have calculated the following definition</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval&apos; :: Expr -&gt; Continuation -&gt; Integer
eval&apos; (Val n) c = c n 
eval&apos; (Add x y) c = eval&apos; x (\n -&gt; eval&apos; y (\m -&gt; c (n + m)))</html:code></fr:pre>
<fr:p>Our original semantics can be recovered from the new semantics by
            using the identity continuation <fr:tex display="inline">\lambda  n \to  n</fr:tex></fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval e = eval&apos; e (\n -&gt; n)</html:code></fr:pre>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>581</fr:anchor><fr:addr type="machine">#353</fr:addr><fr:route>unstable-353.xml</fr:route><fr:title text="Defunctionalise">Defunctionalise</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>11</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#351</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>We use continuation to make the order of evaluation explicit in the semantics,
            but this also makes the semantics into a higher-order function.
            Hence our second step is to regain the first-order nature of the original semantics by 
            eliminating the use of continuations but <fr:strong>retaining</fr:strong> the explicit order of evaluation they introduced.</fr:p><fr:p>A standard technique for eliminating the use of functions as arguments is <fr:strong>defunctionalisation</fr:strong>.
            We do not usually need the entire function-space of possible argument functions, 
            there only a few forms of such functions are actually used.
            Hence we represent the argument functions that we actually need using 
            a datatype rather than functions.</fr:p><fr:p>We begin by defining three combinators <fr:strong>halt</fr:strong>, <fr:strong>next</fr:strong> and <fr:strong>add</fr:strong> 
            for constructing the continuations we used.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">halt :: Continuation
halt n = n

next :: Expr -&gt; Continuation -&gt; Continuation
next y c = \n -&gt; eval&apos; y (add n c)

add :: Integer -&gt; Continuation -&gt; Continuation
add n c = \m -&gt; c (n + m)</html:code></fr:pre>
<fr:p>Use the combinators, our continuation semantics can now be written as:</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval :: Expr -&gt; Integer
eavl e = eval&apos; e halt

eval&apos; :: Expr -&gt; Continuation -&gt; Integer
eval&apos; (Val n) c = c n 
eval&apos; (Add x y) c = eval&apos; x (next y c)</html:code></fr:pre>
<fr:p>Now we declare a new datatype for continuations, consists of three constructors.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data CONT = HALT | NEXT Expr CONT | ADD Integer CONT</html:code></fr:pre>
<fr:p>The following translation function forms a denotational semantics for <fr:code>CONT</fr:code></fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">exec :: CONT -&gt; Continuation
exec HALT = halt
exec (NEXT y c) = next y (exec c)
exec (ADD n c) = add n (exec c)</html:code></fr:pre>
<fr:p>This function is usually called <fr:strong>apply</fr:strong>, which can be viewed as 
            applying a representation of a continuation to an integer to give another integer.
            We want to define a new semantics <fr:tex display="inline">\text {eval}&apos;</fr:tex> which behaves in the same way 
            as our previous <fr:tex display="inline">\text {eval}&apos;</fr:tex> except that it uses values of type <fr:code>CONT</fr:code> 
            rather than <fr:code>Continuation</fr:code>.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval&apos;&apos; :: Expr -&gt; CONT -&gt; Integer</html:code></fr:pre>

            The desired behavior of <fr:tex display="inline">\text {eval}&apos;&apos;</fr:tex> is:
            <fr:tex display="block">                 \text {eval}&apos;&apos;\space  e\space  c = \text {eval}&apos;\space  e\space  (\text {exec}\space  c)             </fr:tex></fr:p><fr:p>As before, we proceed by structural induction on expression <fr:tex display="inline">e</fr:tex>.
            The base case <fr:tex display="inline">e=\text {Val}\space  n</fr:tex> is trivial
            <fr:tex display="block">                 \begin {align*}                     \text {eval}&apos;&apos;\space (\text {Val}\space  n)\space  c                     &amp;= \text {eval}&apos;\space (\text {Val}\space  n)\space  (\text {exec}\space  c) \\                     &amp;= \text {exec}\space  c\space  n \\                 \end {align*}             </fr:tex></fr:p><fr:p>For the inductive case <fr:tex display="inline">e = \text {Add}\space  x\space  y</fr:tex>:
            <fr:tex display="block">                 \begin {align*}                     \text {eval}&apos;&apos;\space (\text {Add}\space  x\space  y)\space  c                      &amp;= \text {eval}&apos;\space (\text {Add}\space  x\space  y)\space  (\text {exec}\space  c) \\                     &amp;= \text {eval}&apos;\space  x\space (\text {next}\space  y\space (\text {exec}\space  c)) \\                      &amp;= \text {eval}&apos;\space  x\space (\text {exec}\space (\text {NEXT}\space  y\space  c)) \\                     &amp;= \text {eval}&apos;&apos;\space  x\space  (\text {NEXT}\space  y\space  c)                 \end {align*}             </fr:tex>
            The last step uses the inductive hypothesis for <fr:tex display="inline">x</fr:tex></fr:p><fr:p>In the basic case, <fr:tex display="inline">\text {exec}</fr:tex> still refers to the semantic <fr:tex display="inline">\text {eval}&apos;</fr:tex>,
            via the combinator <fr:tex display="inline">\text {next}</fr:tex>. Hence we need to compute a new definition 
            for <fr:tex display="inline">\text {exec}</fr:tex> that refers to our new <fr:tex display="inline">\text {eval}&apos;&apos;</fr:tex>.</fr:p><fr:tex display="block">             \begin {align*}                 \text {exec}\space \text {HALT}\space  n                  &amp;= \text {halt}\space  n                 \\                  &amp;= n                             \end {align*}         </fr:tex><fr:p>The other case is also easy to compute, no need to induction.</fr:p><fr:tex display="block">             \begin {align*}                 \text {exec}\space (\text {NEXT}\space  y\space  c)\space  n                  &amp;= \text {eval}&apos;&apos;\space  y\space (\text {ADD}\space  n\space  c)                 \\                  \text {exec}\space (\text {ADD}\space  n\space  c)\space  m                  &amp;= \text {exec}\space  c\space (n+m)             \end {align*}         </fr:tex><fr:p>Our original semantics <fr:tex display="inline">\text {eval}</fr:tex> can be recovered from the new 
            semantics <fr:tex display="inline">\text {eval}&apos;&apos;</fr:tex> too.</fr:p><fr:tex display="block">             \begin {align*}                 \text {eval}\space  e                  &amp;= \text {eval}&apos;\space  e\space (\lambda  n\to  n) \\                  &amp;= \text {eval}&apos;\space  e\space \text {halt} \\                  &amp;= \text {eval}&apos;\space  e\space (\text {exec}\space \text {HALT}) \\                  &amp;= \text {eval}&apos;&apos;\space  e\text {HALT}             \end {align*}         </fr:tex><fr:p>In summary, we have calculated the following definitions:</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval&apos;&apos; :: Expr -&gt; CONT -&gt; Integer
eval&apos;&apos; (Val n) c = exec c n 
eval&apos;&apos; (Add x y) c = eval&apos;&apos; x (NEXT y c)

exec :: CONT -&gt; Integer -&gt; Integer
exec HALT n = n 
exec (NEXT y c) n = eval&apos;&apos; y (ADD n c)
exec (ADD n c) m = exec c (n + m)

eval :: Expr -&gt; Integer
eval e = eval&apos;&apos; e HALT</html:code></fr:pre>
<fr:p>The four components (<fr:tex display="inline">\text {eval}&apos;&apos;</fr:tex>, <fr:tex display="inline">\text {eval}</fr:tex>, <fr:tex display="inline">\text {exec}</fr:tex> and <fr:code>CONT</fr:code>)
            forms an abstract machine.</fr:p><fr:p><fr:code>CONT</fr:code> is the type of <fr:strong>control stack</fr:strong> which comprises 
            instructions that determine how the machine should continue after evaluating
            the current expression. Sometimes it is called an &quot;eval/continue&quot; machine.
            The control stack can also be defined as a list of instructions.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">type CONT = [INST]
data INST = NEXT Expr | ADD Integer</html:code></fr:pre></fr:p><fr:p><fr:tex display="inline">\text {eval}</fr:tex> evaluates an expression and give an integer by simply 
            call the <fr:tex display="inline">\text {eval}&apos;&apos;</fr:tex> with empty control stack <fr:tex display="inline">\text {HALT}</fr:tex>.</fr:p><fr:p><fr:tex display="inline">\text {eval}&apos;&apos;</fr:tex> evaluates an expression in the context of a control stack.
            If the expression is an integer, we execute the control stack using this 
            integer as an argument. If the expression is an addition, 
            we evaluate the first argument <fr:tex display="inline">x</fr:tex> and place the instruction <fr:tex display="inline">\text {NEXT}\space  y</fr:tex>
            on the top of the control stack.</fr:p><fr:p><fr:tex display="inline">\text {exec}</fr:tex> executes the control stack. If the control stack is empty,
            then just return the integer argument as the result. If the top instruction
            is <fr:tex display="inline">\text {NEXT}\space  y</fr:tex>, we evaluate <fr:tex display="inline">y</fr:tex> and place the instruction <fr:tex display="inline">\text {ADD}\space  n</fr:tex>
            to the stack top. If the top instruction is <fr:tex display="inline">\text {ADD}\space  n</fr:tex>,evaluation of the 
            two arguments of an addition is complete, and we execute the remaining control stack 
            in the context of the sum of the resulting integers.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>589</fr:anchor><fr:addr type="user">cs-0007</fr:addr><fr:route>cs-0007.xml</fr:route><fr:title text="Categorical Semantics for Type Theories">Categorical Semantics for Type Theories</fr:title><fr:taxon>Type Theory</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is a collection of notes on categorical semantics for type theories.
    The notes are based on the <fr:link type="local" href="cs-tt-2020.xml" addr="cs-tt-2020" title="Categorical Semantics for Type Theories">paper</fr:link> by Jason Z.S. Hu and <fr:link type="local" href="ncatlab.xml" addr="ncatlab" title="NLab">NLab</fr:link>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>590</fr:anchor><fr:addr type="machine">#336</fr:addr><fr:route>unstable-336.xml</fr:route><fr:title text="Introduction">Introduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0007</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Over the last few decades, many type systems are designed for different purposes:
        general program safety, security, and correctness. The <fr:strong>categorical semantics</fr:strong>
        is a collection of methods which define meanings of types and programs in category theory.</fr:p><fr:p>Category theory is a branch of mathematics studying an abstract kind of mappings, called morphisms,
        and their algebraic relations. Its generality serves as a common language for navigating connections
        between different concepts in different areas. We will first go over some basic concepts in category theory.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>591</fr:anchor><fr:addr type="machine">#337</fr:addr><fr:route>unstable-337.xml</fr:route><fr:title text="Basic Category Theory concepts">Basic Category Theory concepts</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0007</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Formally, a definition in category theory consists of two parts: data and axioms.
        The most basic definition is the <fr:strong>category</fr:strong></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>592</fr:anchor><fr:addr type="user">def-003E</fr:addr><fr:route>def-003E.xml</fr:route><fr:title text="Category">Category</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>513</fr:anchor><fr:addr type="machine">#315</fr:addr><fr:route>unstable-315.xml</fr:route><fr:title text="With one collection"><fr:strong>With one collection</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>def-003E</fr:parent></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex display="inline">C</fr:tex> consists
    <fr:ul><fr:li>A collection of <fr:strong>objects</fr:strong> <fr:tex display="inline">C_0</fr:tex> (<fr:tex display="inline">\text {Ob}(C)</fr:tex>).</fr:li>
        <fr:li>A collection <fr:tex display="inline">C_1</fr:tex> (<fr:tex display="inline">\text {Mor}(C)</fr:tex>) of <fr:strong>morphisms</fr:strong> (arrows).</fr:li>
        <fr:li>For every morphism <fr:tex display="inline">f</fr:tex> there are an object <fr:tex display="inline">s(f)</fr:tex> (<fr:strong>source</fr:strong>, domain) and an object <fr:tex display="inline">t(f)</fr:tex> (<fr:strong>target</fr:strong>, codomain).</fr:li>
        <fr:li>For every pair of morphisms <fr:tex display="inline">f, g</fr:tex> such that <fr:tex display="inline">t(f) = s(g)</fr:tex>, there is a morphism <fr:tex display="inline">g \circ  f</fr:tex> (<fr:strong>composition</fr:strong>) (Also written <fr:tex display="inline">gf</fr:tex> or <fr:tex display="inline">f;g</fr:tex>).</fr:li>
        <fr:li>For every object <fr:tex display="inline">x</fr:tex>, there is a morphism <fr:tex display="inline">\text {id}_x</fr:tex> (or <fr:tex display="inline">1_x</fr:tex>) called <fr:strong>identity</fr:strong>.</fr:li>
        <fr:li>The following properties hold:
            <fr:ul><fr:li><fr:tex display="inline">s(g \circ  f) = s(f)</fr:tex> and <fr:tex display="inline">t(g \circ  f) = t(g)</fr:tex>.</fr:li>
                <fr:li><fr:tex display="inline">s(1_x) = x</fr:tex> and <fr:tex display="inline">t(1_x) = x</fr:tex>.</fr:li>
                <fr:li>Composition is <fr:strong>associative</fr:strong>: <fr:tex display="inline">h \circ  (g \circ  f) = (h \circ  g) \circ  f</fr:tex> when <fr:tex display="inline">t(f) = s(g)</fr:tex>, and <fr:tex display="inline">t(g) = s(h)</fr:tex>.</fr:li>
                <fr:li>Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex display="inline">f \circ  \text {id}_x = f</fr:tex> and <fr:tex display="inline">\text {id}_y \circ  f = f</fr:tex></fr:li></fr:ul></fr:li></fr:ul>
    If the identity map and its axioms are omitted then one speaks of a <fr:strong>semicategory</fr:strong>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>514</fr:anchor><fr:addr type="machine">#316</fr:addr><fr:route>unstable-316.xml</fr:route><fr:title text="With a family of collections of morphisms"><fr:strong>With a family of collections of morphisms</fr:strong></fr:title><fr:authors></fr:authors><fr:parent>def-003E</fr:parent></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex display="inline">C</fr:tex> consists
    <fr:ul><fr:li>A collection of <fr:strong>objects</fr:strong> <fr:tex display="inline">C_0</fr:tex> (<fr:tex display="inline">\text {Ob}(C)</fr:tex>).</fr:li>
        <fr:li>For every pair of objects <fr:tex display="inline">x, y</fr:tex>, a collection <fr:tex display="inline">C_1(x, y)</fr:tex> (<fr:tex display="inline">\hom _C(x,y)</fr:tex>) of <fr:strong>morphisms</fr:strong> from <fr:tex display="inline">x</fr:tex> to <fr:tex display="inline">y</fr:tex>.</fr:li>
        <fr:li>For each pair of morphisms <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex> and <fr:tex display="inline">g</fr:tex> in <fr:tex display="inline">C_1(y,z)</fr:tex>, a morphism <fr:tex display="inline">g \circ  f</fr:tex> in <fr:tex display="inline">C_1(x,z)</fr:tex>.
            called their <fr:strong>composition</fr:strong>.</fr:li>
        <fr:li>For each object <fr:tex display="inline">x</fr:tex>, a morphism <fr:tex display="inline">\text {id}_x</fr:tex> in <fr:tex display="inline">C_1(x,x)</fr:tex> called the <fr:strong>identity</fr:strong> on <fr:tex display="inline">x</fr:tex>.</fr:li>
        <fr:li>The following properties hold:
            <fr:ul><fr:li>Composition is <fr:strong>associative</fr:strong>: <fr:tex display="inline">h \circ  (g \circ  f) = (h \circ  g) \circ  f</fr:tex> for all <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex>, <fr:tex display="inline">g</fr:tex> in <fr:tex display="inline">C_1(y,z)</fr:tex>, and <fr:tex display="inline">h</fr:tex> in <fr:tex display="inline">C_1(z,w)</fr:tex>.</fr:li>
                <fr:li>Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex display="inline">f \circ  \text {id}_x = f</fr:tex> and <fr:tex display="inline">\text {id}_y \circ  f = f</fr:tex> for all <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex>.</fr:li></fr:ul></fr:li></fr:ul>
    Usually we write <fr:tex display="inline">\text {Mor}(C)</fr:tex> for the disjoint union <fr:tex display="inline">\bigsqcup _{x,y \in  C_0} C_1(x,y)</fr:tex>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We only talk about <fr:strong>collections</fr:strong> here, which is vague, because we do not specify 
        they are sets or classes. If both objects and morphisms fit in sets, we say the category
        is <fr:strong>small</fr:strong>. For a counterexample, the category of all sets is not small. However,
        all functions between sets can be contained in a set. In this case, the category is <fr:strong>locally small</fr:strong>.
        When morphisms between two objects fit in a set, we call the set <fr:strong>hom-set</fr:strong>.</fr:p><fr:p>Since category theory is constructed to study structures and a category is actually a structure,
        we can talk about the category of all small categories <fr:tex display="inline">\mathbf {Cat}</fr:tex>. Similar to morphisms, we can 
        define <fr:strong>functor</fr:strong> between categories.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>593</fr:anchor><fr:addr type="user">def-003G</fr:addr><fr:route>def-003G.xml</fr:route><fr:title text="Functor">Functor</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>functor</fr:strong> <fr:tex display="inline">F</fr:tex> from a category <fr:tex display="inline">C</fr:tex> to a category <fr:tex display="inline">D</fr:tex> is a map
    sending each <fr:tex display="inline">x\in  C</fr:tex> to an object <fr:tex display="inline">F(x)\in  D</fr:tex> and each morphism
    <fr:tex display="inline">f:x\to  y</fr:tex> in <fr:tex display="inline">C</fr:tex> to morphism <fr:tex display="inline">F(f):F(x)\to  F(y)</fr:tex> in <fr:tex display="inline">D</fr:tex>, such that 
    <fr:ul><fr:li>Composition is preserved: <fr:tex display="inline">F(g\circ  f) = F(g)\circ  F(f)</fr:tex>.</fr:li>
        <fr:li>Identity is preserved: <fr:tex display="inline">F(\text {id}_x) = \text {id}_{F(x)}</fr:tex>.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We can push this idea further by considering functors as objects and <fr:strong>natural transformations</fr:strong> as morphisms.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>594</fr:anchor><fr:addr type="user">def-003I</fr:addr><fr:route>def-003I.xml</fr:route><fr:title text="Functor Category">Functor Category</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex> be categories, the functor category <fr:tex display="inline">D^C</fr:tex> 
    (or <fr:tex display="inline">[C,D]</fr:tex>) is the category whose
    <fr:ul><fr:li>objects are functors from <fr:tex display="inline">C</fr:tex> to <fr:tex display="inline">D</fr:tex>.</fr:li>
        <fr:li>morphisms are <fr:strong>natural transformations</fr:strong> between functors.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Here we use a <fr:strong>commutative diagram</fr:strong> to represent a natural transformation.
        When a diagram commutes, morphisms composed by different paths with the same end points
        are equal. The following diagram represents the equality that <fr:tex display="inline">G(f)\circ \alpha _x = \alpha _y\circ  F(f)</fr:tex>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>595</fr:anchor><fr:addr type="user">def-003J</fr:addr><fr:route>def-003J.xml</fr:route><fr:title text="Natural Transformation">Natural Transformation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex> be categories and <fr:tex display="inline">F,G:C\to  D</fr:tex> be functors.
    A <fr:strong>natural transformation</fr:strong> <fr:tex display="inline">\alpha :F\Rightarrow   G</fr:tex> is 
    an assignment to every object <fr:tex display="inline">x\in  C</fr:tex> of a morphism <fr:tex display="inline">\alpha _x:F(x)\to  G(x)</fr:tex> in <fr:tex display="inline">D</fr:tex>,
    (called the <fr:strong>component</fr:strong> of <fr:tex display="inline">\alpha </fr:tex> at <fr:tex display="inline">x</fr:tex>)
    the following diagram commutes in <fr:tex display="inline">D</fr:tex>:
    
    <fr:embedded-tex hash="9e8c6059143e8cbd6e00022532ed04e2"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            {F(x)} &amp;&amp; {F(y)} \\
            \\
            {G(x)} &amp;&amp; {G(y)}
            \arrow [&quot;{F(f)}&quot;, from=1-1, to=1-3]
            \arrow [&quot;{G(f)}&quot;, from=3-1, to=3-3]
            \arrow [&quot;{\alpha _x}&quot;, from=1-1, to=3-1]
            \arrow [&quot;{\alpha _y}&quot;, from=1-3, to=3-3]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>596</fr:anchor><fr:addr type="machine">#338</fr:addr><fr:route>unstable-338.xml</fr:route><fr:title text="Basic Category Theory Structures">Basic Category Theory Structures</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0007</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Though the theory is already rich by only considering sets and categories, 
        it would not be interesting enough. We want to know a little more about the 
        category that we are working with. To achieve so, we can require some additional
        structures on the category. A common structure is the cartesian product.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>597</fr:anchor><fr:addr type="user">def-003P</fr:addr><fr:route>def-003P.xml</fr:route><fr:title text="Cartesian Product">Cartesian Product</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given any category <fr:tex display="inline">\mathcal {C}</fr:tex>, and any set <fr:tex display="inline">\{X_i\}_{i\in  I}</fr:tex> of
    its objects, the product of all these objects is, if it exists, an object
    <fr:tex display="inline">         \prod _{i\in  I} X_i \in  \mathcal {C}     </fr:tex>
    equipped with morphisms (projections)
    <fr:tex display="block">         p_i : \left (\prod _{i\in  I} X_i\right ) \to  X_i     </fr:tex>
    for each <fr:tex display="inline">i\in  I</fr:tex>, such that it is <fr:strong>universal with this property</fr:strong>, i.e.
    such that given any other object <fr:tex display="inline">Q\in  C</fr:tex> with morphisms
    <fr:tex display="inline">         Q \xrightarrow {f_i} X_i      </fr:tex>
    there is a <fr:strong>unique</fr:strong> morphism
    <fr:tex display="block">         (f_i)_{i\in  I} : Q \to  \prod _{i\in  I} X_i     </fr:tex>
    where the following diagram commutes:
    
    <fr:embedded-tex hash="4025ac184b830256b9ce3b0638958390"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            Q \\
            \\
            {\prod _{i\in  I} X_i} &amp;&amp; {X_i}
            \arrow [&quot;{p_i}&quot;, from=3-1, to=3-3]
            \arrow [&quot;{f_i}&quot;, from=1-1, to=3-3]
            \arrow [&quot;{(f_i)_{i\in  I}}&quot;&apos;, from=1-1, to=3-1]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>With this definition, it is natural to ask what can serve as a <fr:strong>nullary product</fr:strong>.
        The concept is characterized by terminal objects.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>598</fr:anchor><fr:addr type="user">def-003Q</fr:addr><fr:route>def-003Q.xml</fr:route><fr:title text="Terminal Object">Terminal Object</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>terminal object</fr:strong> in a category <fr:tex display="inline">\mathcal {C}</fr:tex> is an object <fr:tex display="inline">\top </fr:tex> of <fr:tex display="inline">\mathcal {C}</fr:tex> 
    satisfying the following universal property: for any object <fr:tex display="inline">X</fr:tex> in <fr:tex display="inline">\mathcal {C}</fr:tex>,
    there exists a unique morphism <fr:tex display="inline">!:X\to  \top </fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>When making math statements, we often encounter concepts that are dual to each other.
        In category theory, this phenomenon is captured by the concept of <fr:strong>duality</fr:strong>.
        Intuitively, duality offers us free dual theorem from the original one.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>599</fr:anchor><fr:addr type="user">def-003R</fr:addr><fr:route>def-003R.xml</fr:route><fr:title text="Opposite Category">Opposite Category</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For a category <fr:tex display="inline">\mathcal {C}</fr:tex>, the <fr:strong>opposite category</fr:strong> <fr:tex display="inline">\mathcal {C}^{op}</fr:tex> 
    has the same objects as <fr:tex display="inline">\mathcal {C}</fr:tex>, but the morphisms are reversed.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>For example, the product in the opposite category, all <fr:strong>universal properties</fr:strong> corresponds
        to a dual concept.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>600</fr:anchor><fr:addr type="user">def-003S</fr:addr><fr:route>def-003S.xml</fr:route><fr:title text="Coproduct">Coproduct</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For <fr:tex display="inline">\mathcal {C}</fr:tex> a category and <fr:tex display="inline">X, Y \in \text {Ob}{\mathcal {C}}</fr:tex>,
    the <fr:strong>coproduct</fr:strong> is an object <fr:tex display="inline">X\sqcup   Y</fr:tex> equipped with 
    two morphisms <fr:tex display="inline">i_X:X\to  X\sqcup   Y</fr:tex> and <fr:tex display="inline">i_Y:Y\to  X\sqcup   Y</fr:tex> such that
    it is universal with this property. That is, for any object <fr:tex display="inline">Z</fr:tex> and morphisms
    <fr:tex display="inline">f:X\to  Z</fr:tex> and <fr:tex display="inline">g:Y\to  Z</fr:tex>, there exists a unique morphism <fr:tex display="inline">\langle  f, g\rangle :X\sqcup   Y\to  Z</fr:tex>
    such that the following diagram commutes:
    
    <fr:embedded-tex hash="e6897b75170fa778dd177cd469cbcef7"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            X &amp;&amp; {X\sqcup  Y} &amp;&amp; Y \\
            \\
            &amp;&amp; Z
            \arrow [&quot;{[f,g]}&quot;&apos;, dashed, from=1-3, to=3-3]
            \arrow [&quot;f&quot;&apos;, from=1-1, to=3-3]
            \arrow [&quot;{i_Y}&quot;&apos;, from=1-5, to=1-3]
            \arrow [&quot;{i_X}&quot;, from=1-1, to=1-3]
            \arrow [&quot;g&quot;, from=1-5, to=3-3]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>601</fr:anchor><fr:addr type="machine">#339</fr:addr><fr:route>unstable-339.xml</fr:route><fr:title text="Logic, Types and Categories">Logic, Types and Categories</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0007</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>One important principle in type theory is the <fr:strong>Curry-Howard Isomorphism</fr:strong> (Propositions as types).
        It depicts the connection between logic and types. A program can represent a logical argument, and 
        operations in logic find meaningful correspondences in program execution.
        The principle was later extended with category theory due to <fr:strong>Lambek</fr:strong>. In his work, he showed
        a correspondence between STLC and <fr:strong>Cartesian Closed Categories (CCC)</fr:strong> and revealed the connection
        between types and categories. The correspondence is called the <fr:strong>Curry-Howard-Lambek Isomorphism</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>602</fr:anchor><fr:addr type="machine">#340</fr:addr><fr:route>unstable-340.xml</fr:route><fr:title text="Syntax and Semantics">Syntax and Semantics</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#339</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>In general, there are two approaches to understand or design a type system: the <fr:strong>syntactic</fr:strong> view 
            and <fr:strong>semantic</fr:strong> view.

            The syntactic view focuses on the syntactic structure of types and programs. We study about <fr:strong>subject reduction</fr:strong>,
            <fr:strong>cut elimination</fr:strong> and etc, simply by manipulating the syntax. It is usually more direct and easier to understand
            as it is often conducted via induction on some syntactic structures. And it also suggest algorithms which can be implemented.
            The disadvantage is that it is limited and hard to proof some properties like normalization.

            The semantic appoaches are more powerful in general. It is based on mathematics models of type systems.
            In exchange of the strength and generality, it is usually harder to understand and heavyweight, requries
            more intuition of the concepts.</fr:p><fr:p>One clasical semantic approach to logic is algebraic logic. A logical system is modeled by some algebraic theory.
            (often related to <fr:strong>lattices</fr:strong> and <fr:strong>semi-lattices</fr:strong>). Famous examples include <fr:strong>Boolean algebras</fr:strong>
            for classic propositional logic and <fr:strong>Heyting algebras</fr:strong> for intuitionistic counterpart. 
            The algebraic logic is a powerful tool to study the properties of logical systems, but has a limitation that 
            all operations are limited in one structured set.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>603</fr:anchor><fr:addr type="machine">#341</fr:addr><fr:route>unstable-341.xml</fr:route><fr:title text="Computations as Monads">Computations as Monads</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#339</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>An important result from ategorical semantics could be <fr:strong>monads</fr:strong>.
            In <fr:strong>Moggi</fr:strong>&apos;s paper, he showed that monads can be used to model computational effects.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>604</fr:anchor><fr:addr type="user">def-003T</fr:addr><fr:route>def-003T.xml</fr:route><fr:title text="Monad">Monad</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>monad</fr:strong> of a category <fr:tex display="inline">\mathcal {C}</fr:tex> is an endofunctor <fr:tex display="inline">M:\mathcal {C}\to \mathcal {C}</fr:tex> with two natural
    transformations <fr:tex display="inline">\eta :\text {id}_{\mathcal {C}}\Rightarrow  M</fr:tex> and <fr:tex display="inline">\mu :M^2\Rightarrow  M</fr:tex> satisfying the following conditions:
    
    <fr:embedded-tex hash="d8d933290bf594a11e12a52477471318"><fr:embedded-tex-preamble>
      \usepackage {tikz-cd}
      \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
        
        \begin {tikzcd}
            {M^2(X)} &amp;&amp; {M(X)} &amp;&amp; {M^2(X)} \\
            &amp;&amp; {M(X)} \\
            \\
            &amp; {M^3(X)} &amp;&amp; {M^2(X)} \\
            &amp; {M^2(X)} &amp;&amp; {M(X)}
            \arrow [&quot;{\mu _{M(X)}}&quot;&apos;, from=4-2, to=5-2]
            \arrow [&quot;{\mu _X}&quot;, from=5-2, to=5-4]
            \arrow [&quot;{1_{M(X)}}&quot;, from=1-3, to=2-3]
            \arrow [&quot;{\mu _X}&quot;&apos;, from=1-1, to=2-3]
            \arrow [&quot;{M(\eta _X)}&quot;&apos;, from=1-3, to=1-1]
            \arrow [&quot;{\eta _{ M(X)}}&quot;, from=1-3, to=1-5]
            \arrow [&quot;{\mu _X}&quot;, from=1-5, to=2-3]
            \arrow [&quot;{\mu _X}&quot;, from=4-4, to=5-4]
            \arrow [&quot;{M(\mu _X)}&quot;, from=4-2, to=4-4]
        \end {tikzcd}
    
    </fr:embedded-tex-body></fr:embedded-tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>It requires an operation over functors named <fr:strong>whiskering</fr:strong></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>605</fr:anchor><fr:addr type="user">def-003U</fr:addr><fr:route>def-003U.xml</fr:route><fr:title text="Whiskering">Whiskering</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">F,G:C\to  D</fr:tex> and <fr:tex display="inline">H,D\to  E</fr:tex> be functors and <fr:tex display="inline">\eta :F\to  G</fr:tex> be a natural 
    transformation whose coordinate at any object <fr:tex display="inline">A</fr:tex> of <fr:tex display="inline">C</fr:tex> is <fr:tex display="inline">\eta _A</fr:tex>, then 
    <fr:strong>whiskering</fr:strong> <fr:tex display="inline">H</fr:tex> and <fr:tex display="inline">\eta </fr:tex> yields the natural transformation 
    <fr:tex display="inline">H\circ \eta :H\circ  F\to  H\circ  G</fr:tex> whose coordinate at <fr:tex display="inline">A</fr:tex> is <fr:tex display="inline">H(\eta _A)</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>606</fr:anchor><fr:addr type="machine">#342</fr:addr><fr:route>unstable-342.xml</fr:route><fr:title text="Logic as Adjoint Functors">Logic as Adjoint Functors</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>21</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#339</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Categorical logic is a new approach to logic, due to <fr:strong>Lawvere</fr:strong>. 
            He showed that logical constructs are fundamentally just <fr:strong>adjoint functors</fr:strong>.
            This allows us to capture many logical constructs by using only one categorical concept.
            Adjoint also provides a strong guarantee about the derived syntactic formulation.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>607</fr:anchor><fr:addr type="user">def-003V</fr:addr><fr:route>def-003V.xml</fr:route><fr:title text="Adjoint Functor">Adjoint Functor</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">\mathcal {C}</fr:tex> and <fr:tex display="inline">\mathcal {D}</fr:tex> be categories and a pair of functors 
    <fr:tex display="inline">F:\mathcal {C}\to \mathcal {D}</fr:tex> and <fr:tex display="inline">G:\mathcal {D}\to \mathcal {C}</fr:tex>. This is called 
    pair of <fr:strong>adjoint functors</fr:strong> (or <fr:strong>adjunction</fr:strong>) with <fr:tex display="inline">F</fr:tex> the left adjoint
    and <fr:tex display="inline">G</fr:tex> the right adjoint denoted 
    <fr:tex display="block">         F\dashv  G     </fr:tex>
    if there is a natural isomorphism between the hom-functors:
    <fr:tex display="block">         \hom _{\mathcal {D}}(F(-),-)\cong \hom _{\mathcal {C}}(-,G(-))     </fr:tex>
    which means forall objects <fr:tex display="inline">C\in \mathcal {C}</fr:tex> and <fr:tex display="inline">D\in \mathcal {D}</fr:tex>, there is a bijection
    <fr:tex display="block">         \hom _{\mathcal {D}}(F(C),D)\cong \hom _{\mathcal {C}}(C,G(D)) \\          (F(C)\xrightarrow {f}D) \mapsto  (C\xrightarrow {G(f)}G(D))     </fr:tex>
    which is natural in both <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>608</fr:anchor><fr:addr type="user">math-0007</fr:addr><fr:route>math-0007.xml</fr:route><fr:title text="Vector Calculus and Geometry of Space">Vector Calculus and Geometry of Space</fr:title><fr:taxon>Differential Geometry</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Notes about multi-variable calculus, geometry of space and linear algebra.
    Refer to <fr:link type="external" href="A%20Visual%20Introduction%20to%20Differential%20Forms%20and%20Calculus%20on%20Manifolds">df-cm-2018</fr:link>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>609</fr:anchor><fr:addr type="machine">#306</fr:addr><fr:route>unstable-306.xml</fr:route><fr:title text="Review of Vector Spaces">Review of Vector Spaces</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>math-0007</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>We now start with introducing the vector space over the field of real numbers <fr:tex display="inline">\mathbb {R}</fr:tex>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>610</fr:anchor><fr:addr type="user">def-000H</fr:addr><fr:route>def-000H.xml</fr:route><fr:title text="Vector Space">Vector Space</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A vector space over a <fr:link type="local" href="def-0006.xml" addr="def-0006" title="Field">field</fr:link> <fr:tex display="inline">F</fr:tex> is a non-empty set <fr:tex display="inline">V</fr:tex> together with a binary operation and a binary function that satisfy the axioms listed below. 
    In this context, the elements of <fr:tex display="inline">V</fr:tex> are commonly called <fr:strong>vectors</fr:strong>, and the elements of <fr:tex display="inline">F</fr:tex> are called <fr:strong>scalars</fr:strong>.
    <fr:ul><fr:li>Commutativity: <fr:tex display="inline">             \forall  x, y \in  V, x + y = y + x         </fr:tex></fr:li>
        <fr:li>Associativity: <fr:tex display="inline">             \forall  x, y, z \in  V, (x + y) + z = x + (y + z)         </fr:tex></fr:li>
        <fr:li>Additive Identity: <fr:tex display="inline">             \exists  0 \in  V \text { such that } \forall  x \in  V, x + 0 = x         </fr:tex></fr:li>
        <fr:li>Multiplicative Identity: <fr:tex display="inline">             \forall  x \in  V, 1x = x         </fr:tex></fr:li>
        <fr:li>Additive Inverse: <fr:tex display="inline">             \forall  x \in  V, \exists  y \in  V \text { such that } x + y = 0         </fr:tex></fr:li>
        <fr:li>Distributivity: <fr:tex display="inline">             \forall  x, y \in  V, \forall  c, d \in  F, c(x + y) = cx + cy, (c + d)x = cx + dx         </fr:tex></fr:li></fr:ul></fr:p><fr:p>Elements of a vector space are called <fr:strong>vectors</fr:strong> or <fr:strong>points</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Use <fr:tex display="inline">\mathbb {R}^2</fr:tex> as an example we can see (Note that we always treat elements of vector spaces as 
        column vectors and never as row vectors):
        <fr:tex display="block">             c \cdot  \begin {bmatrix}                 a \\ b             \end {bmatrix} = \begin {bmatrix}                 c \cdot  a \\ c \cdot  b             \end {bmatrix}         </fr:tex></fr:p><fr:p>Now we will consider a certain type of transformation between vector spaces called a <fr:link type="local" href="def-0025.xml" addr="def-0025" title="Linear Map"><fr:strong>linear transformation</fr:strong></fr:link>.
        Suppose <fr:tex display="inline">T</fr:tex> is a mapping between <fr:tex display="inline">\mathbb {R}^n</fr:tex> and <fr:tex display="inline">\mathbb {R}^m</fr:tex>, that is <fr:tex display="inline">T:\mathbb {R}^n\to \mathbb {R}^m</fr:tex>, then <fr:tex display="inline">T</fr:tex> is a linear transformation if:
        <fr:tex display="block">             T(c \cdot  \vec {v}) = c \cdot  T(\vec {v})             \\              T(\vec {v} + \vec {w}) = T(\vec {v}) + T(\vec {w})         </fr:tex>
        If <fr:tex display="inline">T</fr:tex> is a linear transformation from <fr:tex display="inline">\mathbb {R}^m</fr:tex> to <fr:tex display="inline">\mathbb {R}</fr:tex> we simply call it a <fr:strong>linear function</fr:strong> or a <fr:strong>linear functional</fr:strong>.</fr:p><fr:p>We now turn our attention to the relationship between linear transformation and matrices. 
        We just stick to vector spaces <fr:tex display="inline">\mathbb {R}^n</fr:tex> and the standard basis made up of the <fr:strong>Euclidian unit vectors</fr:strong>.
        In order to write linear transformation <fr:tex display="inline">T:\mathbb {R}^n\to \mathbb {R}^m</fr:tex> as a matrix we need ordered bases for both <fr:tex display="inline">\mathbb {R}^n</fr:tex> and <fr:tex display="inline">\mathbb {R}^m</fr:tex>.
        We can use the intuitively obvious order <fr:tex display="inline">e_1 &lt; e_2 &lt; \cdots  &lt; e_n</fr:tex>.
        Now we can give formal definition of the matrix representation of a linear transformation.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>611</fr:anchor><fr:addr type="user">def-003W</fr:addr><fr:route>def-003W.xml</fr:route><fr:title text="Matrix Representation of Linear Transformation over {R}^n">Matrix Representation of Linear Transformation over <fr:tex display="inline">\mathbb {R}^n</fr:tex></fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex display="inline">T:\mathbb {R}^n\to \mathbb {R}^m</fr:tex> is a linear transformation between vector spaces <fr:tex display="inline">\mathbb {R}^n</fr:tex> and <fr:tex display="inline">\mathbb {R}^m</fr:tex>.
    Let <fr:tex display="inline">e_1, e_2, \ldots , e_n</fr:tex> be the standard basis of <fr:tex display="inline">\mathbb {R}^n</fr:tex> and <fr:tex display="inline">f_1, f_2, \ldots , f_m</fr:tex> be the standard basis of <fr:tex display="inline">\mathbb {R}^m</fr:tex>.
    Then the matrix representation of <fr:tex display="inline">T</fr:tex> is the <fr:tex display="inline">m \times  n</fr:tex> matrix <fr:tex display="inline">A</fr:tex> such that for <fr:tex display="inline">1\leq  j\leq  n</fr:tex>:
    <fr:tex display="block">         T(e_j) = \sum _{i=1}^m A_{ij} f_i     </fr:tex>
    where the matrix representation of <fr:tex display="inline">T</fr:tex> is given by the <fr:tex display="inline">m\times  n</fr:tex> matrix with entries <fr:tex display="inline">A_{ij}</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The last major topic in this section is the definition of the <fr:link type="local" href="def-003X.xml" addr="def-003X" title="Dual Space">dual space</fr:link>.
        In our discussion, we only concern the dual space of <fr:tex display="inline">\mathbb {R}^n</fr:tex> which is denoted as <fr:tex display="inline">(\mathbb {R}^n)^*</fr:tex>.
        Now let&apos;s consider the <fr:strong>dual basis</fr:strong> of <fr:tex display="inline">(\mathbb {R}^n)^*</fr:tex> which is denoted as <fr:tex display="inline">\{T_1, \cdots , T_n\}</fr:tex>, 
        which is defined by:
        <fr:tex display="block">             T_i(e_j) = e^i(e_j) = \langle  e^i, e_j \rangle  = \delta _{j}^i         </fr:tex>
        where <fr:tex display="inline">\delta _{ij}</fr:tex> is the <fr:link type="local" href="def-001P.xml" addr="def-001P" title="Kronecker Delta">Kronecker delta</fr:link>. We say that <fr:tex display="inline">T_i</fr:tex> is dual to the vector <fr:tex display="inline">e_i</fr:tex>.
        Note that we also denote <fr:tex display="inline">T_i</fr:tex> as <fr:tex display="inline">e^i</fr:tex> using superscript notation. And the notation <fr:tex display="inline">\langle  e^i, e_j \rangle </fr:tex> d
        indicates the products of row vector <fr:tex display="inline">e^i</fr:tex> and column vector <fr:tex display="inline">e_j</fr:tex> (Usually used in quantum computing).
        <fr:tex display="block">             \alpha (v) = \langle  \alpha , v \rangle  = [a,b] \times  \begin {bmatrix}                 x \\ y             \end {bmatrix} = ax + by         </fr:tex>
        This explains wht we always denote elements of the vector space as column vectors, because elements of the dual space 
        are written as row vectors and its very important to distinguish between them.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>612</fr:anchor><fr:addr type="machine">#307</fr:addr><fr:route>unstable-307.xml</fr:route><fr:title text="Dot Products">Dot Products</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>math-0007</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>In linear algebra, <fr:strong>dot product</fr:strong> or <fr:strong>scalar product</fr:strong> is an operation that takes two vectors and returns a scalar.
        Geometrically, it is the product of the Euclidean magnitudes of the two vectors and the cosine of the angle between them.
        Dot product is also used to define lengths and angles.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>613</fr:anchor><fr:addr type="user">def-0041</fr:addr><fr:route>def-0041.xml</fr:route><fr:title text="Dot Product (Coordinate Form)">Dot Product (Coordinate Form)</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>dot product</fr:strong> of two vectors <fr:tex display="inline">\vec {a} = (a_1, a_2, \cdots , a_n)</fr:tex> and <fr:tex display="inline">\vec {b} = (b_1, b_2, \cdots , b_n)</fr:tex> is defined as
    <fr:tex display="block">         \vec {a}\cdot \vec {b} = a_1b_1 + a_2b_2 + \cdots  + a_nb_n = \sum _{i=1}^n a_ib_i.     </fr:tex>
    The dot product is also called the <fr:strong>inner product</fr:strong> or <fr:strong>scalar product</fr:strong>.
    The dot product satisfies the following properties:
    <fr:ul><fr:li><fr:strong>Commutative</fr:strong>: <fr:tex display="inline">\vec {a}\cdot \vec {b} = \vec {b}\cdot \vec {a}</fr:tex></fr:li>
        <fr:li><fr:strong>Distributive</fr:strong>: <fr:tex display="inline">\vec {a}\cdot (\vec {b} + \vec {c}) = \vec {a}\cdot \vec {b} + \vec {a}\cdot \vec {c}</fr:tex></fr:li>
        <fr:li><fr:strong>Bilinear</fr:strong>: <fr:tex display="inline">\vec {a}\cdot (k\vec {b}) = k(\vec {a}\cdot \vec {b}) = (\vec {a}\cdot  k\vec {b})</fr:tex></fr:li>
        <fr:li><fr:strong>Scalar Multiplication</fr:strong>: <fr:tex display="inline">(c_1\vec {a}) \cdot  (c_2\vec {b}) = c_1c_2(\vec {a}\cdot \vec {b})</fr:tex></fr:li>
        <fr:li><fr:strong>Orthogonality</fr:strong>: If <fr:tex display="inline">\vec {a}\cdot \vec {b} = 0</fr:tex>, then <fr:tex display="inline">\vec {a}</fr:tex> and <fr:tex display="inline">\vec {b}</fr:tex> are <fr:strong>orthogonal</fr:strong></fr:li>
        <fr:li><fr:strong>Product Rule</fr:strong>: If <fr:tex display="inline">\vec {a}</fr:tex> and <fr:tex display="inline">\vec {b}</fr:tex> are vector valued differentiable functions then the derivative 
            of <fr:tex display="inline">\vec {a}\cdot \vec {b}</fr:tex> is given by the rule <fr:tex display="inline">(\vec {a}\cdot \vec {b})&apos; = \vec {a}&apos;\cdot \vec {b} + \vec {a}\cdot \vec {b}&apos;</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>614</fr:anchor><fr:addr type="user">def-0042</fr:addr><fr:route>def-0042.xml</fr:route><fr:title text="Dot Product (Geometric Form)">Dot Product (Geometric Form)</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In <fr:strong>Euclidean space</fr:strong>, a <fr:strong>Euclidean vector</fr:strong> is a geometric object that possesses both 
    a norm and a direction. The <fr:strong>dot product</fr:strong> of two vectors <fr:tex display="inline">\vec {a}</fr:tex> and <fr:tex display="inline">\vec {b}</fr:tex> is defined as
    <fr:tex display="block">         \vec {a}\cdot \vec {b} = \lVert \vec {a}\rVert \lVert \vec {b}\rVert \cos \theta      </fr:tex>
    where <fr:tex display="inline">\theta </fr:tex> is the angle between the two vectors.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The geometric definition of dot product helps us express the projection of one vector onto another as well as the component of 
        one vector in the direction of another. By simple geometry we can derive the formula for the <fr:strong>projection</fr:strong>
        <fr:tex display="block">             \text {proj}_{\vec {a}}\vec {b} = \frac {\vec {a}\cdot \vec {b}}{\lVert \vec {a}\rVert }\frac {\vec {a}}{\lVert \vec {a}\rVert }         </fr:tex>
        and the <fr:strong>component</fr:strong> of <fr:tex display="inline">\vec {b}</fr:tex> in the direction <fr:tex display="inline">\vec {a}</fr:tex> is given by
        <fr:tex display="block">             \text {comp}_{\vec {a}}\vec {b} = \lVert \text {proj}_{\vec {a}}\vec {b}\rVert  = \frac {\vec {a}\cdot \vec {b}}{\lVert \vec {a}\rVert }         </fr:tex></fr:p><fr:p>Two points determine a line, and so does a point and a vector. Define the base point vector <fr:tex display="inline">\vec {b}=(x,y,z)</fr:tex> and
        the direction vector <fr:tex display="inline">\vec {v}=(a,b,c)</fr:tex> then the line is given by <fr:tex display="inline">\vec {r}(t)</fr:tex>
        <fr:tex display="block">             \vec {r}(t) = t\vec {v} + \vec {b} = (at+x, bt+y, ct+z)         </fr:tex>
        Solving for <fr:tex display="inline">t</fr:tex> in the equation we get
        <fr:tex display="block">             t = \frac {x-at}{a} = \frac {y-bt}{b} = \frac {z-ct}{c}         </fr:tex>
        which is the <fr:strong>equation of line</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>615</fr:anchor><fr:addr type="machine">#308</fr:addr><fr:route>unstable-308.xml</fr:route><fr:title text="Volume and Determinants">Volume and Determinants</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>math-0007</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>determinant</fr:strong> has various properties and applications in linear algebra and geometry.
        For us the most useful thing about it will be how it relates to volume:
        the determinant of a matrix gives the <fr:strong>signed volume</fr:strong> of the parallelepiped that 
        is generated by the vectors given by the matrix columns.</fr:p><fr:p>Determinants can be introduced in a variety of different ways but many of them are not at all clear.
        It usually relates to volume hence we will actually use our intuitive understanding of volumes and 
        three properties that we expected volume to have to derive the determinant (It is <fr:strong>uniquely</fr:strong> determined!).</fr:p><fr:p>So how do we expect volume to behave?
        First we expect a unit cube to have a volume of one.
        Second we expect the <fr:strong>degenerate</fr:strong> parallelepiped to have a volume of zero. Basically in <fr:tex display="inline">n</fr:tex> dimensions any 
        <fr:tex display="inline">n-1</fr:tex> dimensions object has zero <fr:tex display="inline">n</fr:tex>-D volume.
        Third we expect that volumes to be <fr:strong>linear</fr:strong>.
        Now with these three properties we move to the actual mathematics.</fr:p><fr:p>Suppose we have a parallelepiped <fr:tex display="inline">\mathscr {P}\in \mathbb {R}^n</fr:tex> whose edges are given by <fr:tex display="inline">v_1, v_2, \cdots , v_n\in \mathbb {R}^n</fr:tex>.
        We sat that the parallelepiped <fr:tex display="inline">\mathscr {P}</fr:tex> is the <fr:strong>span</fr:strong> of the vectors <fr:tex display="inline">v_1, v_2, \cdots , v_n</fr:tex> and 
        write <fr:tex display="inline">\mathscr {P}=\text {span}\{v_1, v_2, \cdots , v_n\}</fr:tex> (Note that this span is different from linear span).
        We want to find function <fr:tex display="inline">D:\mathbb {R}^{n\times  n}\to \mathbb {R}</fr:tex> which takes <fr:tex display="inline">v_1, v_2, \cdots , v_n</fr:tex> or a matrix with <fr:tex display="inline">v_1, v_2, \cdots , v_n</fr:tex> as columns
        to a real number which is the volume of <fr:tex display="inline">\mathscr {P}</fr:tex>. Now we present the three properties in mathematical form.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>616</fr:anchor><fr:addr type="machine">#309</fr:addr><fr:route>unstable-309.xml</fr:route><fr:title text="Properties of Volume">Properties of Volume</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#308</fr:parent></fr:frontmatter><fr:mainmatter><fr:ul><fr:li><fr:tex display="inline"> D(I) = I </fr:tex> where <fr:tex display="inline">I = [e_1, e_2, \cdots , e_n]</fr:tex> is the identity matrix.</fr:li>
            <fr:li><fr:tex display="inline"> D(v_1, v_2, \cdots , v_n) = 0 </fr:tex> if <fr:tex display="inline">v_i = v_j</fr:tex> for any <fr:tex display="inline">i\neq  j</fr:tex>.</fr:li>
            <fr:li><fr:tex display="inline"> D(v_1, \cdots , v_{j-1}, v+cw, v_{j+1}, \cdots , v_n) \\                  = D(v_1, \cdots , v_{j-1}, v, v_{j+1}, \cdots , v_n) + cD(v_1, \cdots , v_{j-1}, w, v_{j+1}, \cdots , v_n) </fr:tex>
                for any <fr:tex display="inline">1 \leq  j \leq  n</fr:tex>, that is, <fr:tex display="inline">D</fr:tex> is linear.</fr:li></fr:ul></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now we use these properties of volume to derive several other useful properties.
        The first property is that the volumes are signed.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>617</fr:anchor><fr:addr type="machine">#310</fr:addr><fr:route>unstable-310.xml</fr:route><fr:title text="Derived Properties of Volume Function">Derived Properties of Volume Function</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#308</fr:parent></fr:frontmatter><fr:mainmatter><fr:ul><fr:li><fr:tex display="inline">D</fr:tex> is alternating, if we switch any two vectors the sign changes.
                <fr:tex display="block">                     D(v_1, \cdots , v_i, \cdots , v_j, \cdots , v_n) = -D(v_1, \cdots , v_j, \cdots , v_i, \cdots , v_n)                 </fr:tex></fr:li> 
            <fr:li>If <fr:tex display="inline">v_1, v_2, \cdots , v_n</fr:tex> are <fr:link type="local" href="def-000Q.xml" addr="def-000Q" title="Linearly dependent">linear dependent</fr:link> then
                <fr:tex display="block">                     D(v_1, v_2, \cdots , v_n) = 0                 </fr:tex></fr:li>
            <fr:li>Adding a multiple of one vector to another does not change the determinant.</fr:li></fr:ul></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We almost ready to derive the formula for determinant. The final ingredient we need to do is <fr:strong>permutations</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>618</fr:anchor><fr:addr type="user">def-003Y</fr:addr><fr:route>def-003Y.xml</fr:route><fr:title text="Permutation">Permutation</fr:title><fr:taxon>Defintion</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>permutation</fr:strong> of a set <fr:tex display="inline">S</fr:tex> is a bijection from <fr:tex display="inline">S</fr:tex> to itself.
    The set of permutation of <fr:tex display="inline">\{1,\cdots , n\}</fr:tex> is usually denoted by <fr:tex display="inline">S_n</fr:tex>.
    We often denote a particular permutation <fr:tex display="inline">\sigma </fr:tex> by <fr:strong>Cauchy&apos;s two-line notation</fr:strong>:
    <fr:tex display="block">         \begin {bmatrix}             1 &amp; 2 &amp; \cdots  &amp; n \\             \sigma (1) &amp; \sigma (2) &amp; \cdots  &amp; \sigma (n)         \end {bmatrix}     </fr:tex>
    or <fr:strong>Cauchy&apos;s one-line notation</fr:strong>: <fr:tex display="inline">(\sigma (1),\sigma (2),\cdots ,\sigma (n))</fr:tex>.
    Another common notation is the <fr:strong>cycle notation</fr:strong>:
    <fr:tex display="block">         (i_1\ i_2\ \cdots \ i_k)     </fr:tex> which means <fr:tex display="inline">i_1 \to  i_2 \to  \cdots  \to  i_k \to  i_1</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>619</fr:anchor><fr:addr type="user">def-003Z</fr:addr><fr:route>def-003Z.xml</fr:route><fr:title text="Transposition">Transposition</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link type="local" href="def-003Y.xml" addr="def-003Y" title="Permutation">permutation</fr:link> in which only two elements are exchanged is called a <fr:strong>transposition</fr:strong>.
    The notation is <fr:tex display="inline">\tau _{i,j}</fr:tex> where <fr:tex display="inline">i</fr:tex> and <fr:tex display="inline">j</fr:tex> are the two elements exchanged while the others remain fixed.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Notice that the composition of two permutations is also a permutation. 
        And for any permutation <fr:tex display="inline">\sigma </fr:tex> we can perform a series of transpositions to get the identity permutation.
        It turns out that the count of the number of transpositions needed to get the identity permutation is always the same,
        which is called the <fr:strong>parity</fr:strong> of the permutation.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>620</fr:anchor><fr:addr type="user">def-0040</fr:addr><fr:route>def-0040.xml</fr:route><fr:title text="Sign of Permutation">Sign of Permutation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>sign</fr:strong> of a <fr:link type="local" href="def-003Y.xml" addr="def-003Y" title="Permutation">permutation</fr:link> <fr:tex display="inline">\sigma \in  S_n</fr:tex> is a function <fr:tex display="inline">\text {sgn}:S_n\to \{-1,1\}</fr:tex> defined as
    <fr:tex display="inline">\text {sgn}(\sigma ) = 1</fr:tex> if <fr:tex display="inline">\sigma </fr:tex> requires an even number of permutations and 
    <fr:tex display="inline">\text {sgn}(\sigma ) = -1</fr:tex> if <fr:tex display="inline">\sigma </fr:tex> requires an odd number of permutations to get the identity permutation.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now we define the permutation of unit vectors <fr:tex display="inline">E_\sigma  = [e_{\sigma (1)}, e_{\sigma (2)}, \cdots , e_{\sigma (n)}]</fr:tex>.
        We got the property that
        <fr:tex display="block">             D(E_\sigma ) = \text {sgn}(\sigma )D(I) = \text {sgn}(\sigma )         </fr:tex>
        Now we have all the pieces necessary to find a formula that will give the volume of the parallelepiped spanned
        by <fr:tex display="inline">n</fr:tex> vectors.
        <fr:tex display="block">             \begin {align*}                 D\left (\begin {bmatrix}                     a_{11} &amp; a_{12} &amp; \cdots  &amp; a_{1n} \\                     a_{21} &amp; a_{22} &amp; \cdots  &amp; a_{2n} \\                     \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                     a_{n1} &amp; a_{n2} &amp; \cdots  &amp; a_{nn}                 \end {bmatrix}\right ) &amp;= \sum _{i_1=1}^n a_{i_11}D\left (\begin {bmatrix}                     | &amp; a_{12} &amp; \cdots  &amp; a_{1n} \\                     e_{i_1} &amp; a_{22} &amp; \cdots  &amp; a_{2n} \\                     | &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                     | &amp; a_{n2} &amp; \cdots  &amp; a_{nn}                 \end {bmatrix}\right ) \\                  &amp;= \sum _{i_1=1}^n a_{i_11} \sum _{i_2=1}^n a_{i_22}D\left (\begin {bmatrix}                     | &amp; | &amp; \cdots  &amp; a_{1n} \\                     e_{i_1} &amp; e_{i_2} &amp; \cdots  &amp; a_{2n} \\                     | &amp; | &amp; \vdots  &amp; \vdots  \\                     | &amp; | &amp; \cdots  &amp; a_{nn}                 \end {bmatrix}\right ) \\                 &amp;= \vdots  \\                  &amp;= \sum _{i_1, i_2, \cdots , i_n = 1}^{n} a_{i_11}a_{i_22}\cdots  a_{i_nn}D\left (                     \begin {bmatrix}                         | &amp; | &amp;  &amp; | \\                         e_{i_1} &amp; e_{i_2} &amp; \cdots  &amp; e_{i_n} \\                         | &amp; | &amp;  &amp; | \\                     \end {bmatrix}                 \right ) \\                  &amp;= \sum _{\sigma \in  S_n} a_{\sigma (1)1}\cdots  a_{\sigma (n)n}                 D\left (                     \begin {bmatrix}                         | &amp; | &amp;  &amp; | \\                         e_{\sigma (1)} &amp; e_{\sigma (2)} &amp; \cdots  &amp; e_{\sigma (n)} \\                         | &amp; | &amp;  &amp; | \\                     \end {bmatrix}                 \right ) \\                  &amp;= \sum _{\sigma \in  S_n} a_{\sigma (1)1}a_{\sigma (2)2}\cdots  a_{\sigma (n)n} \text {sgn}(\sigma ) \\                  &amp;= \sum _{\sigma \in  S_n} \text {sgn}(\sigma ) \prod _{i=1}^n a_{\sigma (i)i}             \end {align*}         </fr:tex>
        In the forth step we transform the terms because the value of <fr:tex display="inline">D</fr:tex> is zero for any <fr:tex display="inline">{i_j} = {i_k}</fr:tex>,
        non-zero terms should be permutation of <fr:tex display="inline">S_n</fr:tex>.</fr:p><fr:p>It&apos;s easy to validate that the following properties of the determinant holds:
        <fr:ul><fr:li><fr:tex display="inline">D(AB) = D(A)D(B)</fr:tex></fr:li>
            <fr:li><fr:tex display="inline">D(A) = D(A^T)</fr:tex></fr:li></fr:ul>
        The second statement for transpose of <fr:tex display="inline">A</fr:tex> indicates that all the properties above also holds for row as well.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>621</fr:anchor><fr:addr type="machine">#311</fr:addr><fr:route>unstable-311.xml</fr:route><fr:title text="Derivatives of Multivariable Functions">Derivatives of Multivariable Functions</fr:title><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>math-0007</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>In this section we will introduce the idea of the derivative of a multivariable function. 
        Recall that a function <fr:tex display="inline">f:\mathbb {R}\to \mathbb {R}</fr:tex> the derivative of <fr:tex display="inline">f</fr:tex> at <fr:tex display="inline">x_0\in \mathbb {R}</fr:tex> is given by
        <fr:tex display="block">             f&apos;(x_0) = \lim _{h\to  0} \frac {f(x_0+h) - f(x_0)}{h}         </fr:tex>
        if the limit exists. Now let&apos;s do some transformations:
        <fr:tex display="block">             \begin {align*}                 &amp; f&apos;(x_0) = \lim _{h\to  0} \frac {f(x_0+h) - f(x_0)}{h} \\                 \implies  &amp; \lim _{h\to  0} \frac {f(x_0+h) - f(x_0) -f&apos;(x_0)h }{h} = 0 \\                 \implies  &amp; \lim _{x\to  x_0} \frac {f(x) - f(x_0) - f&apos;(x_0)(x-x_0)}{x-x_0} = 0 \\                  \implies  &amp; \lim _{x\to  x_0} \frac {|f(x) - f(x_0) - f&apos;(x_0)(x-x_0)|}{|x-x_0|} = 0             \end {align*}         </fr:tex></fr:p><fr:p>Since <fr:tex display="inline">f&apos;(x_0)</fr:tex> represents the slope of the line tangent to the graph of <fr:tex display="inline">f</fr:tex> at <fr:tex display="inline">(x_0, f(x_0))</fr:tex>,
        differentiability of <fr:tex display="inline">f</fr:tex> at <fr:tex display="inline">x_0</fr:tex> means that there exists a number <fr:tex display="inline">m</fr:tex> st
        <fr:tex display="block">             \lim _{x\to  x_0} \frac {|f(x) - f(x_0) - m(x-x_0)|}{|x-x_0|} = 0         </fr:tex>
        Now consider the function <fr:tex display="inline">T:\mathbb {R}\to \mathbb {R}</fr:tex> where <fr:tex display="inline">T(s) = ms</fr:tex>
        <fr:tex display="block">             T(s+t) = m(s+t) = ms + mt = T(s) + T(t)             \\              T(cs) = mcs = c(ms) = cT(s)         </fr:tex>
        then <fr:tex display="inline">T</fr:tex> is a linear transformation. In fact <fr:tex display="inline">T</fr:tex> is the linear function that most closely approximates the 
        function <fr:tex display="inline">f</fr:tex> at the point <fr:tex display="inline">(x_0, f(x_0))</fr:tex>. So for <fr:tex display="inline">x</fr:tex> values that are very close to <fr:tex display="inline">x_0</fr:tex> we have
        <fr:tex display="block">             f(x) \approx  m(x-x_0) + f(x_0)         </fr:tex></fr:p><fr:p>Now let&apos;s generalize the concept of derivatives to functions of the form <fr:tex display="inline">f:\mathbb {R}^n\to \mathbb {R}^m</fr:tex>.
        We assume the function <fr:tex display="inline">f</fr:tex> has the form
        <fr:tex display="block">             \begin {align*}                 &amp;f(x_1, x_2, \cdots , x_n) =                  \\                  &amp;(f_1(x_1, x_2, \cdots , x_n), f_2(x_1, x_2, \cdots , x_n), \cdots , f_m(x_1, x_2, \cdots , x_n))             \end {align*}         </fr:tex>
        We want to search for this linear transformation which we will denoted by <fr:tex display="inline">Df</fr:tex>,
        that most closely approximates this function <fr:tex display="inline">f:\mathbb {R}^n\to \mathbb {R}^m</fr:tex> at some specific point <fr:tex display="inline">x_0=(x_{1_0}, x_{2_0}, \cdots , x_{n_0}) \in  \mathbb {R}^n</fr:tex>.
        If <fr:tex display="inline">f</fr:tex> is differentiable at <fr:tex display="inline">x_0</fr:tex> then there exists a linear transformation <fr:tex display="inline">Df(x_0):\mathbb {R}^n\to \mathbb {R}^m</fr:tex> such that
        <fr:tex display="block">             \lim _{x\to  x_0} \frac {                 \lVert                      f(x) - f(x_0) - Df(x_0)(x-x_0)                 \rVert              }{\lVert x-x_0\rVert } = 0         </fr:tex>
        The <fr:tex display="inline">\lVert \cdot \rVert </fr:tex> represents the <fr:strong>Euclidean norm</fr:strong> of the vector (Multi-dimensional version of the absolute value)
        <fr:tex display="block">             \lVert \vec {x}\rVert  = \sqrt {x_1^2 + x_2^2 + \cdots  + x_n^2} = \sqrt {\sum _{i=1}^n x_i^2}         </fr:tex>
        which is just the length of the vector. This allows us to perform dividing.</fr:p><fr:p>As before we have
        <fr:tex display="block">             f(x) \approx  Df(x_0)(x-x_0) + f(x_0)         </fr:tex>
        Now we want to write <fr:tex display="inline">Df(x)</fr:tex> as a matrix. Denote the basis of <fr:tex display="inline">\mathbb {R}^n</fr:tex> as <fr:tex display="inline">e_j</fr:tex> and the basis of <fr:tex display="inline">\mathbb {R}^m</fr:tex> as <fr:tex display="inline">f_i</fr:tex>.
        Then we want to find <fr:tex display="inline">a_{ij}</fr:tex> st
        <fr:tex display="block">             Df(x)(e_j) = \sum _{i=1}^{m} a_{ij} f_j = \begin {bmatrix}                 a_{1j} \\ a_{2j} \\ \vdots  \\ a_{mj}             \end {bmatrix}         </fr:tex>
        In other words, the <fr:tex display="inline">i</fr:tex>-th component of the <fr:tex display="inline">j</fr:tex>-th column of <fr:tex display="inline">Df(x)</fr:tex> is just the <fr:tex display="inline">i</fr:tex>-th component of the <fr:tex display="inline">Df(x)(e_j)</fr:tex></fr:p><fr:p>Recall from vector calculus that given a function <fr:tex display="inline">f:\mathbb {R}^n\to \mathbb {R}</fr:tex> we defined the <fr:strong>partial derivative</fr:strong> of <fr:tex display="inline">f</fr:tex> with respect to the <fr:tex display="inline">x_j</fr:tex> as 
        <fr:tex display="block">             \frac {\partial  f}{\partial  x_j} = \lim _{h\to 0}             \frac {f(x_1,\cdots ,x_j+h,\cdots ,x_n) - f(x_1,\cdots ,x_n)}{h}         </fr:tex>
        Hence we can define the partial derivatives for each <fr:tex display="inline">f_i (1\leq  i\leq  m)</fr:tex> with respect to each <fr:tex display="inline">x_j (1\leq  j\leq  n)</fr:tex>.
        <fr:tex display="block">             \frac {\partial  f_i}{\partial  x_j} = \lim _{h\to 0}             \frac {f_i(x_1,\cdots ,x_j+h,\cdots ,x_n) - f_i(x_1,\cdots ,x_n)}{h}         </fr:tex>
        Thus we have
        <fr:tex display="block">             \frac {\partial  f_i}{\partial  x_j} = a_{ij}         </fr:tex>
        To find <fr:tex display="inline">a_{ij}</fr:tex> of <fr:tex display="inline">Df(x_0)</fr:tex> we need to find the <fr:tex display="inline">i</fr:tex>-th element of <fr:tex display="inline">Df(x_0)(e_j)</fr:tex>. Let
        <fr:tex display="block">             x = \begin {bmatrix}                 x_{1_0} \\ x_{2_0} \\ \vdots  \\ x_{n_0}             \end {bmatrix} + \begin {bmatrix}                 0 \\ \vdots  \\ 1 \\ \vdots  \\ 0             \end {bmatrix} = x_0 + he_j         </fr:tex>
        We have 
        <fr:tex display="block">             \lim _{x\to  x_0}\frac {\lVert f(x)-f(x_0)-Df(x_0)(he_j)\rVert }{\lVert he_j\rVert }             \\ \implies               \lim _{h\to 0}\frac {\lVert                  f(x_0+he_j) - f(x_0) -hDf(x_0)(e_j)             \rVert }{\lVert h\rVert } = 0         </fr:tex>
        The component is given by 
        <fr:tex display="block">             \lim _{h\to 0}\frac {\lVert f_i(x_0+he_j)-f_i(x_0)-ha_{ij}\rVert }{\lVert h\rVert } = 0             \\ \implies               a_{ij} = \lim _{h\to 0}\frac {f_i(x_0+he_j) - f_i(x_0)}{h}         </fr:tex>
        which is exactly <fr:tex display="inline">\frac {\partial  f_i}{\partial  x_j}</fr:tex>. Thus the matrix representation of <fr:tex display="inline">Df(x)</fr:tex> is given by 
        a matrix called the <fr:strong>Jacobin matrix</fr:strong> of <fr:tex display="inline">f</fr:tex>.
        <fr:tex display="block">             Df(x) = \begin {bmatrix}                 \frac {\partial  f_1}{\partial  x_1} &amp; \frac {\partial  f_1}{\partial  x_2} &amp; \cdots  &amp; \frac {\partial  f_1}{\partial  x_n} \\                 \frac {\partial  f_2}{\partial  x_1} &amp; \frac {\partial  f_2}{\partial  x_2} &amp; \cdots  &amp; \frac {\partial  f_2}{\partial  x_n} \\                 \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                 \frac {\partial  f_m}{\partial  x_1} &amp; \frac {\partial  f_m}{\partial  x_2} &amp; \cdots  &amp; \frac {\partial  f_m}{\partial  x_n}             \end {bmatrix} = \left [                 \frac {\partial  f_i}{\partial  x_j}             \right ]         </fr:tex>
        where <fr:tex display="inline">i</fr:tex> ranges row and <fr:tex display="inline">j</fr:tex> ranges column.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>622</fr:anchor><fr:addr type="user">math-0008</fr:addr><fr:route>math-0008.xml</fr:route><fr:title text="Matrix Computation">Matrix Computation</fr:title><fr:taxon>Linear Algebra</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This post shows operations and applications over matrix, refers to Wikipedia.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>623</fr:anchor><fr:addr type="user">def-0043</fr:addr><fr:route>def-0043.xml</fr:route><fr:title text="Transpose">Transpose</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>transpose</fr:strong> of a matrix <fr:tex display="inline">A</fr:tex>, denoted by <fr:tex display="inline">A^T</fr:tex> is
    the matrix obtained by swapping the rows and columns of <fr:tex display="inline">A</fr:tex>.
    It satisfies the following properties:
    <fr:ul><fr:li><fr:tex display="inline">(A^T)^T = A</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">(A + B)^T = A^T + B^T</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">(cA)^T = cA^T</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">(AB)^T = B^TA^T</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>If the following condition satisfies:
    <fr:tex display="block">         a_{ij} = a_{ji} \quad  \forall  i,j     </fr:tex>
    Then the matrix is called symmetric.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>624</fr:anchor><fr:addr type="user">def-001N</fr:addr><fr:route>def-001N.xml</fr:route><fr:title text="Symmetric Matrix">Symmetric Matrix</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A square matrix <fr:tex display="inline">A</fr:tex> is symmetric if it is equal to its transpose:
    <fr:tex display="block">         A = A^T     </fr:tex>
    This also implies <fr:tex display="inline">A^{-1} A^T = I</fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>625</fr:anchor><fr:addr type="user">def-0044</fr:addr><fr:route>def-0044.xml</fr:route><fr:title text="Determinant">Determinant</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The determinant of a <fr:tex display="inline">n\times  n</fr:tex> square matrix <fr:tex display="inline">A</fr:tex> is commonly denoted <fr:tex display="inline">\det  A</fr:tex> or <fr:tex display="inline">|A|</fr:tex>.
    It satisfies the following properties:
    <fr:ul><fr:li><fr:tex display="inline">\det  A^T = \det  A</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">\det  AB = \det  A \det  B</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">\det  \lambda  A = \lambda ^n \det  A</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>To compute the inverse of a matrix, we need <fr:strong>Adjugate matrix</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>626</fr:anchor><fr:addr type="user">def-0045</fr:addr><fr:route>def-0045.xml</fr:route><fr:title text="First Minor and Cofactor">First Minor and Cofactor</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex display="inline">A</fr:tex> is a square matrix, then the <fr:strong>minor</fr:strong> of the entry in the i-th row and j-th 
    column (also called the <fr:tex display="inline">(i, j)</fr:tex> minor, or a first minor) is the <fr:strong>determinant</fr:strong> of 
    the sub-matrix formed by deleting the i-th row and j-th column.
    The <fr:tex display="inline">(i, j)</fr:tex> minor is denoted as <fr:tex display="inline">M_{ij}</fr:tex>.
    The <fr:strong>Cofactor</fr:strong> is obtained by multiplying the minor by <fr:tex display="inline">(-1)^{i+j}</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>627</fr:anchor><fr:addr type="user">def-0046</fr:addr><fr:route>def-0046.xml</fr:route><fr:title text="Cofactor Matrix">Cofactor Matrix</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The matrix formed by all of the <fr:link type="local" href="def-0045.xml" addr="def-0045" title="First Minor and Cofactor">cofactors</fr:link> of a square matrix <fr:tex display="inline">A</fr:tex> is called the cofactor matrix,
    or <fr:strong>comatrix</fr:strong>:
    <fr:tex display="block">         C = \left [              \begin {array}{cccc}                 C_{11} &amp; C_{12} &amp; \cdots  &amp; C_{1n} \\                 C_{21} &amp; C_{22} &amp; \cdots  &amp; C_{2n} \\                 \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                 C_{n1} &amp; C_{n2} &amp; \cdots  &amp; C_{nn}             \end {array}         \right ]     </fr:tex>
    The <fr:strong>Adjugate matrix</fr:strong> of <fr:tex display="inline">A</fr:tex> is the transpose of the cofactor matrix.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Then the inverse of <fr:tex display="inline">A</fr:tex> is the transpose of the cofactor matrix times the reciprocal of the determinant of <fr:tex display="inline">A</fr:tex>:
    <fr:tex display="block">         A^{-1} = \frac {1}{\det  A} \cdot  \text {adj} A = \frac {1}{\det  A} \cdot  C^T     </fr:tex></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>628</fr:anchor><fr:addr type="user">def-0047</fr:addr><fr:route>def-0047.xml</fr:route><fr:title text="Singular Matrix">Singular Matrix</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A square matrix that is not <fr:strong>invertible</fr:strong> is called <fr:strong>singular</fr:strong> or degenerate</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>629</fr:anchor><fr:addr type="machine">#299</fr:addr><fr:route>unstable-299.xml</fr:route><fr:title text="An important property of the inverse of a matrix">An important property of the inverse of a matrix</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors></fr:authors><fr:parent>math-0008</fr:parent></fr:frontmatter><fr:mainmatter><fr:p><fr:tex display="block">             A \cdot  \text {adj} A = \text {adj} A \cdot  A = \det  A \cdot  I         </fr:tex></fr:p>
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>630</fr:anchor><fr:addr type="machine">#300</fr:addr><fr:route>unstable-300.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#299</fr:parent></fr:frontmatter><fr:mainmatter>
        Let <fr:tex display="inline">A \cdot  \text {adj} A = (b_{ij})</fr:tex> and we have
        <fr:tex display="block">             b_{ij} = a_{i1}A_{j1} + a_{i2}A_{j2} + \cdots  + a_{in}A_{jn} = \delta _{ij} \cdot  \det  A         </fr:tex>
        Hence we have <fr:tex display="inline">A \cdot  \text {adj} A = \det  A \cdot  I</fr:tex> 
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>631</fr:anchor><fr:addr type="machine">#301</fr:addr><fr:route>unstable-301.xml</fr:route><fr:title text="Matrix Polynomial and Computation">Matrix Polynomial and Computation</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors></fr:authors><fr:parent>math-0008</fr:parent></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>632</fr:anchor><fr:addr type="user">def-0048</fr:addr><fr:route>def-0048.xml</fr:route><fr:title text="Matrix Polynomial">Matrix Polynomial</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>matrix polynomial</fr:strong> is a polynomial with square matrices as variables.
    The general form of a matrix polynomial is:
    <fr:tex display="block">         P(A) = \sum _{i=0}^{n} a_i A^i     </fr:tex>
    where <fr:tex display="inline">A^0 = I</fr:tex> is the identity matrix.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>If <fr:tex display="inline">A</fr:tex> is a diagonal matrix, then the polynomial of <fr:tex display="inline">A</fr:tex> is the diagonal matrix of the polynomial of the diagonal elements of <fr:tex display="inline">A</fr:tex>.
        <fr:tex display="block">             p(A) = \begin {bmatrix}                 p(a_{11}) &amp; 0 &amp; \cdots  &amp; 0 \\                 0 &amp; p(a_{22}) &amp; \cdots  &amp; 0 \\                 \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                 0 &amp; 0 &amp; \cdots  &amp; p(a_{nn})             \end {bmatrix}         </fr:tex></fr:p><fr:p>If <fr:tex display="inline">A = P\Lambda  P^{-1}</fr:tex>, then <fr:tex display="inline">A^k = P \Lambda  ^k P^{-1}</fr:tex> and hence
        <fr:tex display="block">             p(A) = a_0 I + a_1 A + a_2 A^2 + \cdots  + a_n A^n = P \Lambda  P^{-1}         </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>633</fr:anchor><fr:addr type="machine">#302</fr:addr><fr:route>unstable-302.xml</fr:route><fr:title text="Solving a Linear System">Solving a Linear System</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors></fr:authors><fr:parent>math-0008</fr:parent></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>634</fr:anchor><fr:addr type="user">thm-0011</fr:addr><fr:route>thm-0011.xml</fr:route><fr:title text="Cramer&apos;s rule">Cramer&apos;s rule</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Consider a system of <fr:tex display="inline">n</fr:tex> linear equations for <fr:tex display="inline">n</fr:tex> unknowns, represented in matrix multiplication form as follows:
    <fr:tex display="block">         A \cdot  X = B     </fr:tex>
    where <fr:tex display="inline">A</fr:tex> is a square matrix of order <fr:tex display="inline">n</fr:tex>, <fr:tex display="inline">X</fr:tex> is a column matrix of order <fr:tex display="inline">n</fr:tex> and <fr:tex display="inline">B</fr:tex> is a column matrix of order <fr:tex display="inline">n</fr:tex>.
    <fr:tex display="block">         X = \begin {bmatrix} x_1 \\ x_2 \\ \vdots  \\ x_n \end {bmatrix}     </fr:tex>
    The Cramer&apos;s rule states that the solution to the system of equations is given by:
    <fr:tex display="block">         x_i = \frac {\text {det}(A_i)}{\text {det}(A)}     </fr:tex>
    where <fr:tex display="inline">A_i</fr:tex> is the matrix obtained by replacing the <fr:tex display="inline">i</fr:tex>th column of <fr:tex display="inline">A</fr:tex> by <fr:tex display="inline">B</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Matrix partitioning is the process of dividing a matrix into smaller submatrices. 
        This is often done to simplify the computation of matrix operations, such as matrix multiplication.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>635</fr:anchor><fr:addr type="user">def-0049</fr:addr><fr:route>def-0049.xml</fr:route><fr:title text="Matrix Partitioning">Matrix Partitioning</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">A \in  \mathbb {C}^{m\times  n} </fr:tex>. A <fr:strong>partitioning</fr:strong> of <fr:tex display="inline">A</fr:tex> is a representation of <fr:tex display="inline">A</fr:tex> in the form
    <fr:tex display="block">         A = \begin {bmatrix}             A_{11} &amp; A_{12} &amp; \cdots  &amp; A_{1q} \\             A_{21} &amp; A_{22} &amp; \cdots  &amp; A_{2q} \\             \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\             A_{p1} &amp; A_{p2} &amp; \cdots  &amp; A_{pq}         \end {bmatrix}     </fr:tex>
    where <fr:tex display="inline">A_{ij} \in  \mathbb {C}^{m_i \times  n_j} </fr:tex> for <fr:tex display="inline">1 \leq  i \leq  p</fr:tex> and <fr:tex display="inline">1 \leq  j \leq  q</fr:tex> such that
    <fr:tex display="block">         \sum _{i=1}^p m_i = m \quad  \text {and} \quad  \sum _{j=1}^q n_j = n.     </fr:tex>
    The partitioned matrix operations are similar to the operations on the normal matrix.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>If the partitioned matrix is formed as diagonal blocks, then we can compute the determinant of the matrix by the following formula:
        <fr:tex display="block">             \det  A = \det  A_1 \cdot  \det  A_2 \cdots  \det  A_n         </fr:tex>
        And the inverse of the matrix is
        <fr:tex display="block">             A^{-1} = \begin {bmatrix}                 A_1^{-1} &amp; O &amp; \cdots  &amp; O \\                 O &amp; A_2^{-1} &amp; \cdots  &amp; O \\                 \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                 O &amp; O &amp; \cdots  &amp; A_n^{-1}             \end {bmatrix}         </fr:tex></fr:p><fr:p>The column partitioning of matrix is useful. 
        If we have <fr:tex display="inline">m\times  s</fr:tex> matrix <fr:tex display="inline">A = (a_{ij})</fr:tex> and <fr:tex display="inline">s\times  n</fr:tex> matrix <fr:tex display="inline">B=(b_{ij})</fr:tex>,
        their product can be written:
        <fr:tex display="block">             AB = \begin {bmatrix} A_1 \\ A_2 \\ \vdots  A_m \end {bmatrix}             \begin {bmatrix}                 B_1 &amp; B_2 &amp; \cdots  &amp; B_n             \end {bmatrix} =              \begin {bmatrix}                 A_1B_1 &amp; A_1B_2 &amp; \cdots  &amp; A_1B_n \\                 A_2B_1 &amp; A_2B_2 &amp; \cdots  &amp; A_2B_n \\                 \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                 A_mB_1 &amp; A_mB_2 &amp; \cdots  &amp; A_mB_n             \end {bmatrix}         </fr:tex>
        We can show that <fr:tex display="inline">A=O\iff  A^TA=O</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>636</fr:anchor><fr:addr type="machine">#303</fr:addr><fr:route>unstable-303.xml</fr:route><fr:title text="Matrix Transformation">Matrix Transformation</fr:title><fr:taxon>Section</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors></fr:authors><fr:parent>math-0008</fr:parent></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>637</fr:anchor><fr:addr type="user">def-004A</fr:addr><fr:route>def-004A.xml</fr:route><fr:title text="Elementary Operations">Elementary Operations</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>There are three types of elementary matrices, which correspond to three types of row operations
    (respectively, column operations, row operations are equivalent to multiplying on the left by the
    corresponding elementary matrix, and column operations are equivalent to multiplying on the right
    by the corresponding elementary matrix):
    <fr:ul><fr:li><fr:strong>Row switching</fr:strong>: A row within the matrix can be switched with another row.
            <fr:tex display="block">                 P_{i,j} = \begin {bmatrix}                     1 \\                     &amp; \ddots  \\                     &amp; &amp; 0 &amp; &amp;  1 \\                      &amp; &amp; &amp; \ddots  \\                      &amp; &amp; 1 &amp; &amp; 0 \\                      &amp; &amp; &amp; &amp; &amp; \ddots  \\                     &amp; &amp; &amp; &amp; &amp; &amp; 1                 \end {bmatrix}             </fr:tex></fr:li>
        <fr:li><fr:strong>Row multiplication</fr:strong>: Each element in a row can be multiplied by a non-zero constant.
            <fr:tex display="block">                 D_i(k) = \text {diag} (1, \cdots , k, \cdots , 1)             </fr:tex></fr:li>
        <fr:li><fr:strong>Row additio</fr:strong>: A row can be replaced by the sum of that row and a multiple of another row.
            <fr:tex display="block">                 T_{i,j} = \begin {bmatrix}                     1 \\                     &amp; \ddots  \\                     &amp; &amp; 1 &amp; &amp; k \\                      &amp; &amp; &amp; \ddots  \\                      &amp; &amp; &amp; &amp; 1 \\                      &amp; &amp; &amp; &amp; &amp; \ddots  \\                     &amp; &amp; &amp; &amp; &amp; &amp; 1                 \end {bmatrix}             </fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>638</fr:anchor><fr:addr type="user">def-004B</fr:addr><fr:route>def-004B.xml</fr:route><fr:title text="Column / Row Equivalence">Column / Row Equivalence</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Two matrices <fr:tex display="inline">A,B</fr:tex> are column / row equivalent if one can 
    be obtained from the other by a finite sequence of <fr:link type="local" href="def-004A.xml" addr="def-004A" title="Elementary Operations">elementary operations</fr:link>,
    denoted <fr:tex display="inline">A \sim  B</fr:tex>.
    The column / row equivalence is an <fr:link type="local" href="def-000X.xml" addr="def-000X" title="Equivalence Relation">equivalence relation</fr:link>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We can show that a matrix <fr:tex display="inline">A</fr:tex> is invertible iff there are finite elementary matrices
        <fr:tex display="inline">E_1, E_2, \cdots , E_n</fr:tex> such that
        <fr:tex display="block">             A = E_1E_2\cdots  E_n         </fr:tex></fr:p><fr:p>From above we can deduce that a square matrix <fr:tex display="inline">A</fr:tex> is invertible iff <fr:tex display="inline">A\sim  E</fr:tex>.
        This trick can be used for solving a linear system and computing the inverse of a matrix.
        For instance, given <fr:tex display="inline">AX=B</fr:tex> we can solve <fr:tex display="inline">X</fr:tex> by the following steps:
        Let <fr:tex display="inline">P</fr:tex> be a matrix such that <fr:tex display="inline">PA=I</fr:tex> where <fr:tex display="inline">I</fr:tex> is the identity matrix.
        Hence <fr:tex display="inline">P = A^{-1}</fr:tex> and we have <fr:tex display="inline">X = PB</fr:tex>, we can do elementary operations over matrix <fr:tex display="inline">(A, B)</fr:tex>
        to get the solution of <fr:tex display="inline">X</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>639</fr:anchor><fr:addr type="machine">#304</fr:addr><fr:route>unstable-304.xml</fr:route><fr:title text="Rank">Rank</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors></fr:authors><fr:parent>math-0008</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Now let&apos;s talk about the concept of <fr:strong>rank</fr:strong>.
        In linear algebra, the (column)<fr:strong>rank</fr:strong> of a matrix <fr:tex display="inline">A</fr:tex> is the dimension of the vector space 
        generated (or spanned) by its columns.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>640</fr:anchor><fr:addr type="user">def-004J</fr:addr><fr:route>def-004J.xml</fr:route><fr:title text="Rank">Rank</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The rank of a linear map or operator <fr:tex display="inline">\Phi </fr:tex> is defined as the dimension of its range:
    <fr:tex display="block">         \text {rank}(M)\equiv \dim (\text {range }(M))     </fr:tex>
    Note that the range (<fr:strong>column space</fr:strong>) of a matrix <fr:tex display="inline">M</fr:tex> is the <fr:link type="local" href="def-000M.xml" addr="def-000M" title="Linear Span">span</fr:link> of its column vectors.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Similarly we can define the row rank of a matrix. A fundamental result in linear algebra is 
        that the column rank and the row rank are always equal. Hence we can simply call it the rank of a matrix.
        If the column rank equals to the column size, we say that the matrix is full column rank.</fr:p><fr:p>A common approach to finding the rank of a matrix is to reduce it to a simpler form, 
        generally <fr:strong>row echelon form</fr:strong>, by elementary row operations.
        Row operations do not change the row space (hence do not change the row rank), and, being 
        invertible, map the column space to an isomorphic space (hence do not change the column rank).
        <fr:tex display="block">             A \sim  B \implies  \text {rank}(A) = \text {rank}(B)             \\              \text {rank}(A) = \text {rank}(A^T)         </fr:tex>
        Once in row echelon form, the rank is clearly the same for both row rank and column rank, 
        and equals to the number of <fr:strong>pivots</fr:strong> (or basic columns) and also the number of non-zero rows.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>641</fr:anchor><fr:addr type="user">def-004I</fr:addr><fr:route>def-004I.xml</fr:route><fr:title text="Row Echelon Form">Row Echelon Form</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A matrix is in <fr:strong>row echelon form</fr:strong> if
    <fr:ul><fr:li>All rows having only zero entries are at the bottom</fr:li>
        <fr:li>The leading entry (that is, the <fr:strong>left-most</fr:strong> nonzero entry) of every nonzero row, called
            the <fr:strong>pivot</fr:strong>, is on the right of the leading entry of every row above.</fr:li></fr:ul>
    Some texts add the condition that the leading coefficient must be <fr:tex display="inline">1</fr:tex>
    while others require this only in <fr:strong>reduced row echelon form</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>For instance, matrix <fr:tex display="inline">A = \begin {bmatrix}1&amp;2&amp;1\\-2&amp;-3&amp;1\\3&amp;5&amp;0\end {bmatrix}</fr:tex> can be transformed into reduced row-echelon form:
        <fr:tex display="block">\begin {aligned}{\begin {bmatrix}1&amp;2&amp;1\\-2&amp;-3&amp;1\\3&amp;5&amp;0\end {bmatrix}}&amp;\xrightarrow  {2R_{1}+R_{2}\to  R_{2}} {\begin {bmatrix}1&amp;2&amp;1\\0&amp;1&amp;3\\3&amp;5&amp;0\end {bmatrix}}\xrightarrow  {-3R_{1}+R_{3}\to  R_{3}} {\begin {bmatrix}1&amp;2&amp;1\\0&amp;1&amp;3\\0&amp;-1&amp;-3\end {bmatrix}}\\&amp;\xrightarrow  {R_{2}+R_{3}\to  R_{3}} \,\,{\begin {bmatrix}1&amp;2&amp;1\\0&amp;1&amp;3\\0&amp;0&amp;0\end {bmatrix}}\xrightarrow  {-2R_{2}+R_{1}\to  R_{1}} {\begin {bmatrix}1&amp;0&amp;-5\\0&amp;1&amp;3\\0&amp;0&amp;0\end {bmatrix}}~.\end {aligned}</fr:tex>
        The final matrix has two non-zero rows and thus the rank of matrix <fr:tex display="inline">A</fr:tex> is <fr:tex display="inline">2</fr:tex>.</fr:p><fr:p>The determinantal rank of a matrix is the order of the largest non-zero minor of the matrix.
        It is also the number of non-zero eigenvalues of the matrix. 
        This does not give an efficient way of computing the rank, but it is useful theoretically: 
        a single non-zero minor witnesses a lower bound for the rank of the matrix,
        which can be useful to prove that certain operations do not lower the rank of a matrix.</fr:p><fr:p>We can conclude the properties of rank:
        <fr:tex display="block">             \begin {align*}                 &amp;0 \leq  \text {rank}(A_{m\times  n}) \leq  \min (m,n) \\                 &amp;\text {rank}(A^T) = \text {rank}(A) \\                  &amp; A \sim  B \implies  \text {rank}(A)=\text {rank}(B) \\                  &amp; P, Q \text { is invertible} \implies  \text {rank}(PAQ) = \text {rank}(A) \\                  &amp; \max (\text {rank}(A), \text {rank}(B)) \leq  \text {rank}(A, B) \leq  \text {rank}(A) + \text {rank}(B) \\                  &amp; \text {rank}(A+B) \leq  \text {rank}(A) + \text {rank}(B) \\                 &amp; \text {rank}(AB) \leq  \min (\text {rank}(A), \text {rank}(B)) \\                  &amp; A_{m\times  n}B_{n\times  l} = O\implies  \text {rank}(A) + \text {rank}(B) \leq  n             \end {align*}         </fr:tex></fr:p><fr:p>With such properties we can prove an important theorem:
        <fr:tex display="block">             AB = O \land  A \text { is full rank} \implies  B = O         </fr:tex>
        which is known as the cancellation law of matrix multiplication.</fr:p><fr:p>The rank of a matrix is also related to the solution of a linear system.
        If the rank of the coefficient matrix is less than the rank of the augmented matrix, 
        then the system is inconsistent. Hence there does not exist a solution.
        Similarly we have the following discussion: For a <fr:tex display="inline">n</fr:tex>-variable linear system <fr:tex display="inline">Ax = b</fr:tex>
        <fr:ul><fr:li>If <fr:tex display="inline">\text {rank}(A) &lt; \text {rank}(A,b)</fr:tex>, the solution does not exist.</fr:li>
            <fr:li>If <fr:tex display="inline">\text {rank}(A)=\text {rank}(A,b)=n</fr:tex>, there is a unique solution.</fr:li>
            <fr:li>Ig <fr:tex display="inline">\text {rank}(A)=\text {rank}(A,b)&lt;n</fr:tex>, there are infinite solutions.</fr:li></fr:ul>
        This leads two fundamental theorems of linear systems:
        <fr:ul><fr:li><fr:tex display="inline">n</fr:tex>-variable regular linear system <fr:tex display="inline">Ax = 0</fr:tex> has a non-trivial solution iff <fr:tex display="inline">\text {rank}(A) &lt; n</fr:tex>.</fr:li>
            <fr:li>Matrix equation <fr:tex display="inline">AX = B</fr:tex> has solutions iff <fr:tex display="inline">\text {rank}(A) = \text {rank}(A,B)</fr:tex>.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>642</fr:anchor><fr:addr type="machine">#305</fr:addr><fr:route>unstable-305.xml</fr:route><fr:title text="Linear Combinations">Linear Combinations</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors></fr:authors><fr:parent>math-0008</fr:parent></fr:frontmatter><fr:mainmatter><fr:p></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>643</fr:anchor><fr:addr type="user">def-000L</fr:addr><fr:route>def-000L.xml</fr:route><fr:title text="Linear Combination">Linear Combination</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">V</fr:tex> be a <fr:link type="local" href="def-000H.xml" addr="def-000H" title="Vector Space">vector space</fr:link> over a field <fr:tex display="inline">F</fr:tex>.
    Let <fr:tex display="inline">v_1, \dots , v_n</fr:tex> be vectors in <fr:tex display="inline">V</fr:tex>.
    A <fr:strong>linear combination</fr:strong> of <fr:tex display="inline">v_1, \dots , v_n</fr:tex> is an expression of the form
    <fr:tex display="block">         a_1 v_1 + \dots  + a_n v_n     </fr:tex>
    where <fr:tex display="inline">a_1, \dots , a_n \in  F</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Given two sets of vectors, we say that they are eqaul iff their elements can write as linear combinations of each other.
        This condition can be written using rank:
        <fr:tex display="block">             \text {rank}(A) = \text {rank}(B) = \text {rank}(A, B)         </fr:tex></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>644</fr:anchor><fr:addr type="user">def-000P</fr:addr><fr:route>def-000P.xml</fr:route><fr:title text="Linearly independent">Linearly independent</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A set of vectors <fr:tex display="inline">\{v_1, \dots , v_n\}</fr:tex> is called <fr:strong>linearly independent</fr:strong> if
    <fr:tex display="block">a_1 v_1 + \dots  + a_n v_n = 0</fr:tex>
    implies that <fr:tex display="inline">a_1 = \dots  = a_n = 0</fr:tex>.
    The trivial case of <fr:tex display="inline">\{0\}</fr:tex> is also considered linearly independent.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>645</fr:anchor><fr:addr type="user">phy-0004</fr:addr><fr:route>phy-0004.xml</fr:route><fr:title text="Classical Mechanics">Classical Mechanics</fr:title><fr:taxon>Mechanics</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Notes about the classic mechanics. 
    Most of the content is based on the Wikipedia page about the subject.</fr:p><fr:p>The motion of a body can only be described relative to something else—other bodies, 
    observers, or a set of spacetime coordinates. These are called <fr:strong>frames of reference</fr:strong>. 
    All physical laws take their simplest form in an <fr:strong>inertial</fr:strong> frame.
    <fr:strong>Galilean invariance</fr:strong> or <fr:strong>Galilean relativity</fr:strong> states that the 
    laws of motion are the same in all <fr:strong>inertial frames of reference</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>646</fr:anchor><fr:addr type="machine">#283</fr:addr><fr:route>unstable-283.xml</fr:route><fr:title text="Center of mass">Center of mass</fr:title><fr:authors></fr:authors><fr:parent>phy-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The center of mass of a distribution of mass in space is the unique point 
        at any given time where the weighted relative position of the distributed mass sums to zero.
        <fr:ul><fr:li><fr:strong>System of particles</fr:strong>
                <fr:tex display="block">                     \vec {R} = \frac {\sum  m_i \vec {r}_i}{\sum  m_i}                 </fr:tex></fr:li>
            <fr:li><fr:strong>Continuous volume</fr:strong>
                <fr:p>If the mass is distributed continuously, the center of mass is given by the
                    following formula:
                    <fr:tex display="block">                         \vec {R} = \frac {\int  \vec {r} dm}{\int  dm}                     </fr:tex></fr:p></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>647</fr:anchor><fr:addr type="machine">#284</fr:addr><fr:route>unstable-284.xml</fr:route><fr:title text="Work and Energy">Work and Energy</fr:title><fr:authors></fr:authors><fr:parent>phy-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Work</fr:strong> is the energy transferred to or from an object via the application of force along a displacement.
        <fr:ul><fr:li>Positive Work: The force has a component in the direction of the displacement.</fr:li>
            <fr:li>Negative Work: The force has a component opposite to the direction of the displacement.</fr:li></fr:ul>
        Both force and displacement are vectors. The work done is given by the dot product of the two vectors,
        where the result is a scalar. The work can be given by line integrals:
        <fr:tex display="block">             W = \int _C \vec {F} \cdot  d\vec {r}         </fr:tex>
        where <fr:tex display="inline">d\vec {r}</fr:tex> is the tiny displacement vector along the path <fr:tex display="inline">C</fr:tex>.
        For motion along a straight line, we have a degenerated case of the line integral:
        <fr:tex display="block">             W = \vec {F} \cdot  \vec {r}         </fr:tex></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>648</fr:anchor><fr:addr type="user">thm-0012</fr:addr><fr:route>thm-0012.xml</fr:route><fr:title text="Work-Energy Principle">Work-Energy Principle</fr:title><fr:taxon>Principle</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An increase in the kinetic energy of a <fr:strong>rigid body</fr:strong> is caused by an equal amount 
    of positive work done on the body by the resultant force acting on that body. 
    Conversely, a decrease in kinetic energy is caused by an equal amount of negative work done by the resultant force.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Work on a free (no fields), rigid (no internal degrees of freedom) body, is equal to the change
        in kinetic energy <fr:tex display="inline">E_k</fr:tex> corresponding to the linear velocity and angular velocity of that body.
        <fr:tex display="block">             W = \Delta  E_k         </fr:tex></fr:p><fr:p>The work of forces generated by a potential function is known as potential energy 
        and the forces are said to be <fr:strong>conservative</fr:strong>. 
        Work on an object that is merely displaced in a conservative force field, without 
        change in velocity or rotation, is equal to minus the change of potential energy <fr:tex display="inline">E_p</fr:tex> of the object
        <fr:tex display="block">             W = -\Delta  E_p         </fr:tex></fr:p><fr:p>The time derivative of the work is called <fr:strong>power</fr:strong>:
        <fr:tex display="block">             P = \frac {dW}{dt}         </fr:tex>
        <fr:tex display="inline">dW</fr:tex> can be written as the dot product of the force and the velocity of the object <fr:tex display="inline">dW = \vec {F} \cdot  d\vec {r}</fr:tex>,
        hence the power can be written as:
        <fr:tex display="block">             P = \vec {F} \cdot  \frac {d\vec {r}}{dt} = \vec {F} \cdot  \vec {v}         </fr:tex>
        The work then can be expressed as the integral of the power over time:
        <fr:tex display="block">             W = \int _{\Delta  t} P dt = \int _{\Delta  t} \vec {F} \cdot  \vec {v} dt          </fr:tex></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>649</fr:anchor><fr:addr type="machine">#285</fr:addr><fr:route>unstable-285.xml</fr:route><fr:title text="Kinetic Energy">Kinetic Energy</fr:title><fr:authors></fr:authors><fr:parent>#284</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The kinetic energy of a point object, or a non-rotating rigid body depends on the 
            mass of the body as well as its speed.
            <fr:tex display="block">                 E_k = \frac {1}{2} m v^2 = \frac {p^2}{2m}             </fr:tex></fr:p>
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>650</fr:anchor><fr:addr type="machine">#286</fr:addr><fr:route>unstable-286.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:authors></fr:authors><fr:parent>#285</fr:parent></fr:frontmatter><fr:mainmatter>
            The work done in accelerating a particle with mass m during the infinitesimal time 
            interval <fr:tex display="inline">dt</fr:tex> is given by the dot product of force <fr:tex display="inline">\vec {F}</fr:tex> and the infinitesimal displacement <fr:tex display="inline">d\vec {x}</fr:tex>
            <fr:tex display="block">                 dW = \vec {F} \cdot  d\vec {x}                  = \frac {d\vec {p}}{dt} \cdot  \vec {v}dt                 = \vec {v}\cdot  d\vec {p} = \vec {v} \cdot  d(m\vec {v})             </fr:tex>
            Applying the product rule of differentiation, we get:
            <fr:tex display="block">                 d(\vec {v}\cdot \vec {v}) = 2\vec {v} \cdot  d\vec {v}             </fr:tex>
            Therefore we have:
            <fr:tex display="block">                 \vec {v} \cdot  d(m\vec {v}) = \frac {m}{2} d(\vec {v} \cdot  \vec {v})              </fr:tex>
            Since this is a total differential (that is, it only depends on the final state, 
            not how the particle got there), we can integrate it and call the result kinetic energy:
            <fr:tex display="block">                 E_k = \int _{v_1}^{v_2} \vec {p} \cdot  d\vec {v} = \frac {1}{2} m (v_2^2-v_1^2)             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 
<fr:p>If a rigid body <fr:tex display="inline">Q</fr:tex> is rotating about any line through the center of mass then it has <fr:strong>rotational kinetic energy</fr:strong>
            (<fr:tex display="inline">E_r</fr:tex>) which is simply the sum of the kinetic energies of its moving parts, and is thus given by:
            <fr:tex display="block">                 E_r = \int _Q \frac {v^2dm}{2} = \int _Q \frac {(r\omega )^2dm}{2} = \frac {\omega ^2}{2}\int _Qr^2dm = \frac {1}{2}I\omega ^2             </fr:tex>
            <fr:ul><fr:li><fr:tex display="inline">I = \int _Qr^2dm</fr:tex> is the moment of inertia of the body.</fr:li>
                <fr:li><fr:tex display="inline">\omega </fr:tex> is the angular velocity of the body.</fr:li>
                <fr:li><fr:tex display="inline">r</fr:tex> is the distance from the axis of rotation.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>651</fr:anchor><fr:addr type="machine">#287</fr:addr><fr:route>unstable-287.xml</fr:route><fr:title text="Momentum">Momentum</fr:title><fr:authors></fr:authors><fr:parent>phy-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Momentum</fr:strong> depends on the frame of reference, but in any inertial frame it is a conserved quantity,
        meaning that if a closed system is not affected by external forces, its total linear momentum does not change.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>652</fr:anchor><fr:addr type="machine">#288</fr:addr><fr:route>unstable-288.xml</fr:route><fr:title text="Definition in Classic Mechanics">Definition in Classic Mechanics</fr:title><fr:authors></fr:authors><fr:parent>#287</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>For a system with one or more particles, the total momentum is the sum of the momenta of the individual particles.
            <fr:tex display="block">                 \vec {p} = \sum  m_i \vec {v}_i             </fr:tex>
            Or use the center of mass:
            <fr:tex display="block">                 \vec {p} = M \vec {V}             </fr:tex>
            where <fr:tex display="inline">M</fr:tex> is the total mass of the system and <fr:tex display="inline">\vec {V}</fr:tex> is the velocity of the center of mass.
            This formula is known as the <fr:strong>Euler&apos;s first law of motion</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>653</fr:anchor><fr:addr type="machine">#289</fr:addr><fr:route>unstable-289.xml</fr:route><fr:title text="Relation to force">Relation to force</fr:title><fr:authors></fr:authors><fr:parent>#287</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>From Newton&apos;s second law, the rate of change of the momentum of a particle is equal to the 
            instantaneous force <fr:tex display="inline">F</fr:tex> acting on it
            <fr:tex display="block">                 \vec {F} = \frac {d\vec {p}}{dt}             </fr:tex>
            Hence the change in momentum in time interval <fr:tex display="inline">(t_1, t_2)</fr:tex> can be written as:
            <fr:tex display="block">                 I = \Delta \vec {p} = \int _{t_1}^{t_2} \vec {F} dt = \int _{\vec {p_1}}^{\vec {p_2}} d\vec {p}             </fr:tex>
            We read this as the <fr:strong>impulse</fr:strong> <fr:tex display="inline">I</fr:tex> is equal to the change in momentum.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>654</fr:anchor><fr:addr type="machine">#290</fr:addr><fr:route>unstable-290.xml</fr:route><fr:title text="Law of Conservation of Momentum">Law of Conservation of Momentum</fr:title><fr:authors></fr:authors><fr:parent>#287</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>In a closed system the total momentum remains constant.
            A closed system means that the system is not affected by external forces.
            Or approximately the external forces are extremely small.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>655</fr:anchor><fr:addr type="machine">#291</fr:addr><fr:route>unstable-291.xml</fr:route><fr:title text="Angular Momentum">Angular Momentum</fr:title><fr:authors></fr:authors><fr:parent>#287</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>A force applied perpendicularly to a lever multiplied by its distance from the 
            lever&apos;s fulcrum (the length of the lever arm) is its <fr:strong>torque</fr:strong>.
            <fr:tex display="block">                 \vec {\tau } = \vec {r} \times  \vec {F}             </fr:tex>
            The magnitude of torque is <fr:tex display="inline">\tau  = rF\sin \theta  </fr:tex> (<fr:tex display="inline">r</fr:tex> is the magnitude of the
            <fr:strong>position vector</fr:strong> <fr:tex display="inline">\vec {r}</fr:tex> and <fr:tex display="inline">\theta </fr:tex> is the angle between the force
            vector and the lever arm vector).</fr:p><fr:p>In three-dimensional Euclidean Space, the torque can be written as the components:
            <fr:tex display="block">                 \vec {\tau } = \begin {pmatrix}                     \tau _x \\                     \tau _y \\                     \tau _z                 \end {pmatrix} = \begin {pmatrix}                     yF_z - zF_y \\                     zF_x - xF_z \\                     xF_y - yF_x                 \end {pmatrix}             </fr:tex>
            The component of torque in the direction of an axis is called the torque to that axis.</fr:p><fr:p>The net torque determines the rate of change of the body&apos;s angular momentum.
            <fr:tex display="block">                 \vec {\tau } = \frac {d\vec {L}}{dt}             </fr:tex>
            The angular momentum of a particle is defined as:
            <fr:tex display="block">                 \vec {L} = \vec {r} \times  \vec {p}             </fr:tex></fr:p>
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>656</fr:anchor><fr:addr type="machine">#292</fr:addr><fr:route>unstable-292.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:authors></fr:authors><fr:parent>#291</fr:parent></fr:frontmatter><fr:mainmatter>
            Now we prove the equivalence of definitions.
            <fr:tex display="block">                 \frac {d\vec {L}}{dt} = \vec {r}\times \frac {d\vec {p}}{dt} + \frac {d\vec {r}}{dt}\times \vec {p}             </fr:tex>
            The rate of change of linear momentum is the force and the rate of change of position is velocity.
            <fr:tex display="block">                 \frac {d\vec {L}}{dt} = \vec {r}\times \vec {F} + \vec {v}\times \vec {p}             </fr:tex>
            The cross product of <fr:tex display="inline">\vec {p}</fr:tex> with <fr:tex display="inline">\vec {v}</fr:tex> is <fr:tex display="inline">0</fr:tex> because velocity and momentum are parallel.
            Hence we have:
            <fr:tex display="block">                 \frac {d\vec {L}}{dt} = \vec {r}\times \vec {F} = \tau              </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 
<fr:p>The above statement leads to the Conservation of Angular Momentum.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>657</fr:anchor><fr:addr type="machine">#293</fr:addr><fr:route>unstable-293.xml</fr:route><fr:title text="Rigid Body Dynamics">Rigid Body Dynamics</fr:title><fr:authors></fr:authors><fr:parent>phy-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>658</fr:anchor><fr:addr type="machine">#294</fr:addr><fr:route>unstable-294.xml</fr:route><fr:title text="Moment of Inertia">Moment of Inertia</fr:title><fr:authors></fr:authors><fr:parent>#293</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>When a body is free to rotate around an axis, torque must be applied to change its angular momentum.
            The amount of torque needed to cause any given angular acceleration
            is proportional to the moment of inertia of the body.
            The moment of inertia plays the role in rotational kinetics that mass (inertia) plays in linear kinetics,
            both characterize the resistance of a body to changes in its motion.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>659</fr:anchor><fr:addr type="user">phy-0005</fr:addr><fr:route>phy-0005.xml</fr:route><fr:title text="Simple Harmonic Motion">Simple Harmonic Motion</fr:title><fr:taxon>Physics</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The SHM note is based on Wikipedia.</fr:p><fr:p>In mechanics and physics, <fr:strong>simple harmonic motion</fr:strong> is a special type of periodic motion an object
    experiences by means of a <fr:strong>restoring force</fr:strong> whose magnitude is directly proportional to the 
    distance of the object from an <fr:strong>equilibrium position</fr:strong> and acts towards the equilibrium position.</fr:p><fr:p>In Newtonian mechanics, for one-dimensional simple harmonic motion, the equation of motion, 
    which is a second-order linear ordinary differential equation with constant coefficients,
    can be obtaind by Hooke&apos;s law and Newton&apos;s second law.
    <fr:tex display="block">         F_{\mathrm  {net} }=m{\frac  {\mathrm  {d} ^{2}x}{\mathrm  {d} t^{2}}}=-kx,     </fr:tex>
    where <fr:tex display="inline">m</fr:tex> is the inertial mass og the oscillating body, <fr:tex display="inline">x</fr:tex> is its displacement from 
    the equilibrium position and <fr:tex display="inline">k</fr:tex> is a constant. Therefore we have
    <fr:tex display="block">         {\frac  {\mathrm  {d} ^{2}x}{\mathrm  {d} t^{2}}}=-{\frac  {k}{m}}x,     </fr:tex>
    solving the differential equation we get the sinusoidal function
    <fr:tex display="block">         x(t)=C_{1}\cos  \left (\omega  t\right )+C_{2}\sin  \left (\omega  t\right ),     </fr:tex>
    where <fr:tex display="inline">\omega =\sqrt {\frac {k}{m}}</fr:tex>.</fr:p><fr:p>Let <fr:tex display="inline">t=0</fr:tex> we see that <fr:tex display="inline">C_1 = x(0)</fr:tex> so that <fr:tex display="inline">C_1</fr:tex> is the initial position.
    Taking the derivative of the equation and evaluating at <fr:tex display="inline">0</fr:tex> we get 
    <fr:tex display="inline">x&apos;(0) = \omega  C_2</fr:tex>. So <fr:tex display="inline">C_2</fr:tex> is the initial speed of the object 
    diverged by the angular frequency, <fr:tex display="inline">C_2 = \frac {v_0}{\omega }</fr:tex>. Thus
    <fr:tex display="block">         x(t)=x_{0}\cos  \left ({\sqrt  {\frac  {k}{m}}}t\right )+{\frac  {v_{0}}{\sqrt  {\frac  {k}{m}}}}\sin  \left ({\sqrt  {\frac  {k}{m}}}t\right ).     </fr:tex></fr:p><fr:p>This equation can also be written in the form:
    <fr:tex display="block">         x(t) = Acos(\omega  t-\phi )     </fr:tex>
    where
    <fr:tex display="block">         \begin {align*}             A = \sqrt {C_{1}^{2}+C_{2}^{2}} \\             \phi  = \arctan \left (\frac {C_{2}}{C_{1}}\right ) \\             \sin \phi  = \frac {C_{2}}{A} \\             \cos \phi  = \frac {C_{1}}{A}         \end {align*}     </fr:tex>
    Each of these constants carries a physical meaning of the motion:
    <fr:tex display="inline">A</fr:tex> is the <fr:strong>amplitude</fr:strong> and <fr:tex display="inline">\omega  = 2\pi  f</fr:tex> is the <fr:strong>angular frequency</fr:strong>
    and <fr:tex display="inline">\phi </fr:tex> is the initial <fr:strong>phase</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>660</fr:anchor><fr:addr type="machine">#278</fr:addr><fr:route>unstable-278.xml</fr:route><fr:title text="Energy">Energy</fr:title><fr:authors></fr:authors><fr:parent>phy-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The kinetic energy of the object at time <fr:tex display="inline">t</fr:tex> is given by
        <fr:tex display="block">             K(t)={\tfrac  {1}{2}}mv^{2}(t)={\tfrac  {1}{2}}m\omega  ^{2}A^{2}\sin  ^{2}(\omega  t-\varphi  )={\tfrac  {1}{2}}kA^{2}\sin  ^{2}(\omega  t-\varphi  )         </fr:tex>
        Besides the kinetic energy, the potential energy of the object at time <fr:tex display="inline">t</fr:tex> is given by
        <fr:tex display="block">             U(t)={\tfrac  {1}{2}}kx^{2}(t)={\tfrac  {1}{2}}kA^{2}\cos  ^{2}(\omega  t-\varphi  )         </fr:tex>
        The total energy of the object is the sum of the kinetic and potential energies
        <fr:tex display="block">             E=K+U={\tfrac  {1}{2}}kA^{2}         </fr:tex>
        which is a constant value. 
        Notice that if we solve <fr:tex display="inline">v</fr:tex> from the energy equation we get
        <fr:tex display="block">             v = \pm \sqrt {\frac {k}{m}(A^{2}-x^{2})} = \pm \omega \sqrt {A^{2}-x^{2}}         </fr:tex>
        which implies that the velocity is maximum when the displacement is zero and vice versa.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>661</fr:anchor><fr:addr type="machine">#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:title text="Superposition">Superposition</fr:title><fr:authors></fr:authors><fr:parent>phy-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>According to the principle of superposition of SHM, the resultant displacement
        of a number of waves in a medium at a particular point is the vector sum of the individual 
        displacements produced by each of the waves at that point. 
        Consider two waves having the same angular frequency (Suppose <fr:tex display="inline">\phi _2 &gt; \phi _1</fr:tex>) in the same line:
        <fr:tex display="block">             x_{1}(t)=A_{1}\cos (\omega  t+\phi _{1}) \\             x_{2}(t)=A_{2}\cos (\omega  t+\phi _{2})         </fr:tex>
        Use vector addition we can easily compute the resultant displacement
        <fr:tex display="block">             A = \sqrt {A_{1}^{2}+A_{2}^{2}+2A_{1}A_{2}\cos (\phi _{2}-\phi _{1})} \\         </fr:tex>
        and the resultant initial phase
        <fr:tex display="block">             \phi  = \arctan \left (\frac {A_{1}\sin \phi _{1}+A_{2}\sin \phi _{2}}{A_{1}\cos \phi _{1}+A_{2}\cos \phi _{2}}\right )         </fr:tex></fr:p><fr:p>For some special case, the resultant displacement can be simplified:
        <fr:ul><fr:li>If <fr:tex display="inline">\phi _2 - \phi _1 = 2k\pi , k \in \mathbb {Z}</fr:tex> then the resultant displacement is
                <fr:tex display="block">                     A = A_{1}+A_{2}                 </fr:tex></fr:li>
            <fr:li>If <fr:tex display="inline">\phi _2 - \phi _1 = (2k+1)\pi , k \in \mathbb {Z}</fr:tex> then the resultant displacement is
                <fr:tex display="block">                     A = |A_{1}-A_{2}|                 </fr:tex></fr:li></fr:ul></fr:p><fr:p>If the angular frequencies are different, the resultant displacement changes with time.
        For instance, given <fr:tex display="block">             x_1 = A_1\cos (\omega _1t+\phi _1) \\             x_2 = A_2\cos (\omega _2t+\phi _2)         </fr:tex>
        the resultant displacement is
        <fr:tex display="block">             A = \sqrt {A_{1}^{2}+A_{2}^{2}+2A_{1}A_{2}\cos ((\omega _{2}-\omega _{1})t+\phi _{2}-\phi _{1})}         </fr:tex></fr:p><fr:p>If two waves are perpendicular to each other
        <fr:tex display="block">             x = A\cos (\omega  t + \alpha )              \\              y = B\cos (\omega  t + \beta )         </fr:tex>
        we can compute that
        <fr:tex display="block">             \frac {x^2}{A^2} + \frac {y^2}{B^2} -             \frac {xy}{AB}\cos (\beta -\alpha ) = \sin ^2(\beta -\alpha )         </fr:tex>
        which is the equation of an ellipse.</fr:p><fr:ul><fr:li><fr:tex display="inline">\beta  - \alpha  = 0 \text { or } \pi </fr:tex> the ellipse becomes two line:
            <fr:tex display="block">                 (\frac {x}{A}\pm \frac {y}{B})^2 = 0 \implies  y = \pm  \frac {B}{A}x             </fr:tex>
            The trajectory is two straight line cross the origin.
            The resultant amplitude is <fr:tex display="inline">C = A^2 + B^2</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">\beta  - \alpha  = \pm \frac {\pi }{2}</fr:tex> the ellipse becomes a regular ellipse,
            i.e., the ellipse that takes the coordinates axis as its major axis.
            <fr:tex display="block">                 \frac {x^2}{A^2} + \frac {y^2}{B^2} = 1             </fr:tex>
            If <fr:tex display="inline">\beta  - \alpha  &gt; 0</fr:tex> the ellipse is clockwise, otherwise it is counter-clockwise.</fr:li></fr:ul></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>662</fr:anchor><fr:addr type="machine">#280</fr:addr><fr:route>unstable-280.xml</fr:route><fr:title text="Wave">Wave</fr:title><fr:authors></fr:authors><fr:parent>phy-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>wave</fr:strong> is a propagating dynamic disturbance (change from equilibrium) of one or more quantities.
        Waves are often described by a wave equation (standing wave field of two opposite waves) or a one-way 
        <fr:strong>wave equation</fr:strong> for single wave propagation in a defined direction.</fr:p><fr:p>There are two types of waves that are commonly stdudied: mechanical waves and electromagnetic waves.
        <fr:ul><fr:li>A <fr:strong>mechanical wave</fr:strong> is a local deformation (strain) in some physical medium that propagates
                form particle to particle by creating local stresses that cause strain in neighboring particles.</fr:li>
            <fr:li>The electromagnetic wave us propagating by the coupling between the electric and magnetic 
                fields. Electromagnetic waves can travel through a vacuum and through some dielectric media.</fr:li></fr:ul></fr:p><fr:p>According to the direction of vibration and propagation, waves can be classified into two types.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>663</fr:anchor><fr:addr type="user">def-004K</fr:addr><fr:route>def-004K.xml</fr:route><fr:title text="Transverse wave and Longitudinal wave">Transverse wave and Longitudinal wave</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:ul><fr:li>A <fr:strong>transverse wave</fr:strong> is a wave that oscillates perpendicularly to the direction of the wave&apos;s advance.</fr:li>
    <fr:li>A <fr:strong>longitudinal wave</fr:strong> is a wave that oscillates parallel to the direction of the wave&apos;s advance.</fr:li></fr:ul></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>664</fr:anchor><fr:addr type="machine">#281</fr:addr><fr:route>unstable-281.xml</fr:route><fr:title text="Basic Quantities">Basic Quantities</fr:title><fr:authors></fr:authors><fr:parent>#280</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The wavelength, frequency, speed and period are four import quantities of a wave.
            Now we give their relations.</fr:p><fr:p>The <fr:strong>wavelength</fr:strong> <fr:tex display="inline">\lambda </fr:tex> of a sinusoidal waveform traveling at constant speed <fr:tex display="inline">v</fr:tex> is given by
            <fr:tex display="block">                 \lambda  = vT = \frac {v}{f}             </fr:tex>
            where <fr:tex display="inline">f</fr:tex> is the frequency of the wave and <fr:tex display="inline">T</fr:tex> is the period of the wave.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>665</fr:anchor><fr:addr type="machine">#282</fr:addr><fr:route>unstable-282.xml</fr:route><fr:title text="Basic Principle">Basic Principle</fr:title><fr:authors></fr:authors><fr:parent>#280</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>principle of superposition</fr:strong> states that when two or more waves overlap, the resultant displacement
            at any point is the vector sum of the displacements of the individual waves at that point.</fr:p><fr:p>The <fr:strong>Huygens principle</fr:strong> states that each point on a <fr:strong>wavefront</fr:strong> is a source of spherical wavelets and the
            wavefront at a later time is the <fr:strong>envelope</fr:strong> of these wavelets.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>If the displacement of origin <fr:tex display="inline">O</fr:tex> can be expressed as
        <fr:tex display="block">             y_O = A\cos (\omega  t)         </fr:tex> 
        Such a vibration propagates along x-axis, the displacement of a point <fr:tex display="inline">P</fr:tex> (at <fr:tex display="inline">x</fr:tex>) at time <fr:tex display="inline">t</fr:tex> is
        <fr:tex display="block">             y = A\cos (\omega  t - 2\pi  f \frac {x}{v}) = A\cos  \omega (t - \frac {x}{v})         </fr:tex>
        The distance between <fr:tex display="inline">P</fr:tex> and <fr:tex display="inline">O</fr:tex> is <fr:tex display="inline">x</fr:tex>, in this time period the origin vibrates <fr:tex display="inline">\frac {x}{v}f</fr:tex> times.
        Every vibration changes the phase with <fr:tex display="inline">2\pi </fr:tex>. Hence <fr:tex display="inline">P</fr:tex> is behind <fr:tex display="inline">O</fr:tex> in <fr:tex display="inline">2\pi  f \frac {x}{v}</fr:tex> in phase.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1152</fr:anchor><fr:addr type="user">projects</fr:addr><fr:route>projects.xml</fr:route><fr:title text="Projects">Projects</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The programming projects I&apos;ve worked on.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1153</fr:anchor><fr:addr type="user">proj-0001</fr:addr><fr:route>proj-0001.xml</fr:route><fr:title text="Command Lisp">Command Lisp</fr:title><fr:taxon>Project</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link type="external" href="https://github.com/CAIMEOX/CommandLisp">Command Lisp</fr:link> is a simplified language designed for Minecraft Bedrock Command System, characterized by a very high level of abstraction, which is also a dialect of Lisp.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1154</fr:anchor><fr:addr type="user">proj-0002</fr:addr><fr:route>proj-0002.xml</fr:route><fr:title text="Pure Eval">Pure Eval</fr:title><fr:taxon>Project</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link type="external" href="https://github.com/PureEval/PureEval">Pure Eval</fr:link> was created for the <fr:link type="local" href="proj-0003.xml" addr="proj-0003" title="Voxel Geometry">VoxelGeometry</fr:link> project, aiming to build a compact yet powerful JavaScript functional utility toolkit.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1155</fr:anchor><fr:addr type="user">proj-0003</fr:addr><fr:route>proj-0003.xml</fr:route><fr:title text="Voxel Geometry">Voxel Geometry</fr:title><fr:taxon>Project</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link type="external" href="https://github.com/CAIMEOX/VoxelGeometry">Voxel Geometry</fr:link> is voxel geometry library which is used to construct Space (A collection of 3-dimension Vectors) and perform transformation between Spaces.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1156</fr:anchor><fr:addr type="user">proj-0004</fr:addr><fr:route>proj-0004.xml</fr:route><fr:title text="Minecraft ScriptAPI wrapper">Minecraft ScriptAPI wrapper</fr:title><fr:taxon>Project</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>These projects create Minecraft Script API wrapper for foreign language that compiles to JavaScript.</fr:p><fr:ul><fr:li><fr:link type="external" href="https://github.com/CAIMEOX/rescript-bedrock">ReScript</fr:link></fr:li>
    <fr:li><fr:link type="external" href="https://github.com/CAIMEOX/pure_bedrock">PureScript</fr:link></fr:li>
    <fr:li><fr:link type="external" href="https://github.com/CAIMEOX/BedrockFP">Idris2</fr:link></fr:li></fr:ul></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1157</fr:anchor><fr:addr type="user">proj-0005</fr:addr><fr:route>proj-0005.xml</fr:route><fr:title text="MoonBit Core">MoonBit Core</fr:title><fr:taxon>Project</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link type="external" href="https://github.com/moonbitlang/core">MoonBit Core</fr:link> is the standard library of the MoonBit language.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:backmatter></fr:tree>