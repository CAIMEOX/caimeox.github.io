<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>3175</anchor>  <taxon>Definition</taxon> <addr>def-002O</addr>  <route>def-002O.xml</route>   <title>Concatenation Operation</title>  </frontmatter> <mainmatter><p>
    Let <tex>A</tex> be a type.
    The <strong>Concatenation</strong> operation is defined:
    <tex display="block">          \text {concat} : (x:A) \to  (y:A) \to  (z:A) \to  (x=_Ay) \to  (y=_Az) \to  (x=_Az)     </tex></p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>3176</anchor>          </frontmatter> <mainmatter><strong>Construction</strong><p/>
    We can first construct:
    <tex display="block">         f(x):(y:A) \to  (x=_Ay) \to (z:A) \to  (y=_Az) \to (x=_Az)     </tex>
    For any <tex>x:A</tex>, it suffices to construct
    <tex display="block">         f(x,x, \text {refl} _x) : (z:A)  \to  (x=_Az) \to (x=_Az)     </tex>
    That is the identity function <tex>\lambda  z.  \text {id} _{x=_Az}</tex>.
    Then we can define by induction:
    <tex display="block">         f(x) : \equiv   \text {ind-eq}_{ x } ( \lambda  z. \text {id} )     </tex>
    Finally:
    <tex display="block">          \text {concat} _{x,y,z}(p,q) : \equiv  f(x,y,p,z,q)     </tex>
    Or simply we denote <tex>\text {concat} (p,q)</tex> as <tex>p  \cdot  q</tex>
</mainmatter> </tree>
  
</mainmatter> <backmatter><contributions/> <context><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>3177</anchor>  <taxon>Type Theory</taxon> <addr>tt-0005</addr>  <route>tt-0005.xml</route> <date><year>2024</year> <month>1</month> <day>31</day></date>  <title>Identity Types</title>  </frontmatter> <mainmatter><p>
    This post discuss the identity types in type theory.
    Refer to <link href="hott-2022.xml" type="local" addr="hott-2022" title="Introduction to Homotopy Type Theory">Introduction to Homotopy Type Theory</link>.
</p><p>
    How can we think of <strong>equality</strong> in type theory?
    Mentioned before, given a type <tex>A</tex> and two its elements <tex>a,b:A</tex>
    we can define a new type <tex>a=_Ab</tex> which is called the <strong>identity type</strong>.
    In this case, a term of <tex>a=_Ab</tex> is said to be a <em>witness</em> of the equality of <tex>a</tex> and <tex>b</tex>.
    And this witness is itself a type.
    We can then define their equality.
    This gives every type a <strong>groupoid structure</strong>.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>3178</anchor>  <taxon>Definition</taxon> <addr>def-002N</addr>  <route>def-002N.xml</route>   <title>Identity Type</title>  </frontmatter> <mainmatter><p>
    The <strong>identity type</strong> is an inductive type,
    generated by just a <strong>reflexivity</strong> <em>identification</em>
    that providing an equality of a term with itself.
</p><p>
    Consider a type <tex>A</tex> and let <tex>a:A</tex> be an element.
    The identity type of <tex>A</tex> at <tex>a</tex> is an inductive family of types <tex>a=_Ax</tex> 
    indexed by <tex>x:A</tex>.
    <tex display="block">          \frac {              \Gamma \vdash  a:A         }{              \Gamma ,x:A \vdash  a=_Ax \space \text {type}          }     </tex>
    The only constructor is the refl:
    <tex display="block">          \frac {              \Gamma \vdash  a:A         }{              \Gamma \vdash   \text {refl} _a:a=_Ax         }     </tex></p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>3179</anchor>          </frontmatter> <mainmatter><strong>
    Path Induction / Identification Elimination
</strong><p/>
    The induction principle of the identity type states that
    for any type family <tex>P(x,p)</tex> indexed by <tex>x:A</tex> and <tex>p:a=_Ax</tex>,
    <tex display="block">          \text {ind-eq}_{ a } :P(a,  \text {refl} _a) \to  (x:A) \to  (p:a=_Ax) \to  P(x,p)     </tex>
    satisfies <tex>\text {ind-eq}_{ a } (u,a, \text {refl} _a) \equiv  u</tex> where <tex>u:P(a, \text {refl} _a)</tex>.
    Formally we can write:
    <tex display="block">          \frac {              \Gamma \vdash  a:A, \quad   \Gamma ,x:A,p:a=_Ax \vdash  P(x,p) \space \text {type}          }{              \Gamma \vdash   \text {ind-eq}_{ a } (a, \text {refl} _a): P(a, \text {refl} _a)  \to  (x:A) \to  (p:a=_Ax) \to  P(x,p)         } \text {eq-elim}     </tex>
    <tex display="block">          \frac {              \Gamma \vdash  a:A, \quad   \Gamma ,x:A,p:a=_Ax \vdash  P(x,p) \space \text {type}          }{              \Gamma ,u:P(a, \text {refl} _a) \vdash   \text {ind-eq}_{ a } (u,a, \text {refl} _a) \equiv  u:P(a, \text {refl} _a)         } \text {eq-comp}     </tex>

</mainmatter> </tree>
  
<p>
    A term of <tex>a=_Ax</tex> is called a <strong>identification</strong> of <tex>a</tex> and <tex>x</tex>,
    or the <strong>path</strong> from <tex>a</tex> to <tex>x</tex>.
</p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>3180</anchor>          </frontmatter> <mainmatter><strong>Variable Version</strong><p/>
    We can form an identity type with variables of <tex>A</tex>.
    <tex display="block">          \Gamma ,x:A,y:A \vdash  x=_Ay \space \text {type}      </tex>
    with the following introduction rule:
    <tex display="block">          \frac {              \Gamma ,x:A \vdash  x:A         }{              \Gamma ,x:A \vdash   \text {refl} _x:x=_Ax         }     </tex>
    and similarly the elimination rule and computation rule.
</mainmatter> </tree>
  
</mainmatter> </tree><p>
    The identifications can be <strong>concatenated</strong> and <strong>inverted</strong>,
    which implies the <em>transitivity</em> and <em>symmetry</em> of the identity type.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>3181</anchor>  <taxon>Definition</taxon> <addr>def-002O</addr>  <route>def-002O.xml</route>   <title>Concatenation Operation</title>  </frontmatter> <mainmatter><p>
    Let <tex>A</tex> be a type.
    The <strong>Concatenation</strong> operation is defined:
    <tex display="block">          \text {concat} : (x:A) \to  (y:A) \to  (z:A) \to  (x=_Ay) \to  (y=_Az) \to  (x=_Az)     </tex></p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>3182</anchor>          </frontmatter> <mainmatter><strong>Construction</strong><p/>
    We can first construct:
    <tex display="block">         f(x):(y:A) \to  (x=_Ay) \to (z:A) \to  (y=_Az) \to (x=_Az)     </tex>
    For any <tex>x:A</tex>, it suffices to construct
    <tex display="block">         f(x,x, \text {refl} _x) : (z:A)  \to  (x=_Az) \to (x=_Az)     </tex>
    That is the identity function <tex>\lambda  z.  \text {id} _{x=_Az}</tex>.
    Then we can define by induction:
    <tex display="block">         f(x) : \equiv   \text {ind-eq}_{ x } ( \lambda  z. \text {id} )     </tex>
    Finally:
    <tex display="block">          \text {concat} _{x,y,z}(p,q) : \equiv  f(x,y,p,z,q)     </tex>
    Or simply we denote <tex>\text {concat} (p,q)</tex> as <tex>p  \cdot  q</tex>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>3183</anchor>  <taxon>Definition</taxon> <addr>def-002P</addr>  <route>def-002P.xml</route>   <title>Inverse Operation</title>  </frontmatter> <mainmatter><p>
    Let <tex>A</tex> be a type. The <strong>inverse oepration</strong> is defined:
    <tex display="block">          \text {inv} : (x:A) \to  (y:A) \to  (x=_Ay) \to  (y=_Ax)     </tex></p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>3184</anchor>          </frontmatter> <mainmatter>
    <strong>Construction</strong>
<p/>
    By induction, it suffices to construct:
    <tex display="block">          \text {inv} (x,x, \text {refl} _x) : (x=_Ax)     </tex>
    for any <tex>x:A</tex>. And trivially we have <tex>\text {inv} (x,x, \text {refl} _x) \equiv \text {refl} _x</tex>.
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>3185</anchor>  <taxon>Definition</taxon> <addr>def-002W</addr>  <route>def-002W.xml</route>   <title>Associator</title>  </frontmatter> <mainmatter><p>
    Let <tex>A</tex> be a type.
    These are 3 consecutive identifications
    <tex display="block">         p:x=_Ay,q:y=_Az, r:z=_Aw     </tex>
    we define the <strong>associator</strong>:
    <tex display="block">          \text {assoc} : (p,q,r): (p \cdot  q) \cdot  r = p \cdot  (q \cdot  r)     </tex></p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>3186</anchor>          </frontmatter> <mainmatter>
    <strong>Construction</strong>
<p/>
    By definition it suffices to show that
    <tex display="block">          \Pi _{(z:A)} \Pi _{(q:x=_Az)}          \Pi _{(w:A)} \Pi _{(r:z=_Aw)}         ( \text {refl} _x \cdot  q) \cdot  r =  \text {refl} _x \cdot  (q \cdot  r)     </tex>
    Let <tex>q:x=_Az</tex> and <tex>r:z=_Aw</tex>. By computation rule of identity types
    <tex display="block">          \text {refl} _x \cdot  q  \equiv  q     </tex>
    Then we can conclude that
    <tex display="block">         ( \text {refl} _x \cdot  q) \cdot  r  \equiv  q \cdot  r     </tex>
    similarly <tex>\text {refl} _x \cdot  (q \cdot  r)  \equiv  q \cdot  r</tex>.
    Hence we have the left and right side
    <tex display="block">         ( \text {refl} _x \cdot  q) \cdot  r =  \text {refl} _x \cdot  (q \cdot  r)     </tex>
    are judgementally equal, 
    so we can simply define the associator as
    <tex display="block">          \text {assoc} ( \text {refl} _x,q,r) : \equiv   \text {refl} _{q \cdot  r}     </tex>
</mainmatter> </tree>
  
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>3187</anchor>  <taxon>Definition</taxon> <addr>def-002X</addr>  <route>def-002X.xml</route>   <title>Unit Law Operations</title>  </frontmatter> <mainmatter><p>
    Let <tex>A</tex> be a type.
    We defined the <strong>unit law</strong> operations for <tex>x=_Ay</tex>:
    <tex display="block">          \begin {align*}              \text {left-unit} &amp; : (x=_Ay) \to  ( \text {refl} _x \cdot  x = x)  \\               \text {right-unit} &amp; : (x=_Ay) \to  (x \cdot \text {refl} _y = x)          \end {align*}     </tex></p> 
  
    
    <tree expanded="true" show-heading="true" show-metadata="false" toc="false" numbered="true" root="false"><frontmatter><anchor>3188</anchor>          </frontmatter> <mainmatter>
    <strong>Construction</strong>
<p/>
    By elimination it suffices to construct:
    <tex display="block">          \begin {align*}              \text {left-unit}( \text {refl} _x) &amp;:  \text {refl} _x  \cdot   \text {refl} _x =  \text {refl} _x  \\               \text {right-unit}( \text {refl} _x) &amp;:  \text {refl} _x  \cdot   \text {refl} _x =  \text {refl} _x          \end {align*}     </tex>
    In both cases we need only to construct <tex>\text {refl} _{ \text {refl} _x}</tex>.
</mainmatter> </tree>
  
</mainmatter> </tree></mainmatter> </tree></context> <related/> <backlinks/> <references/></backmatter></tree>