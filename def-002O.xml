<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>805</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-002O</fr:addr><fr:route>def-002O.xml</fr:route><fr:title>Concatenation Operation</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>A</fr:tex> be a type.
    The <fr:strong>Concatenation</fr:strong> operation is defined:
    <fr:tex display="block">          \text {concat} : (x:A) \to  (y:A) \to  (z:A) \to  (x=_Ay) \to  (y=_Az) \to  (x=_Az)     </fr:tex></fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>544</fr:anchor><fr:title><fr:strong>Construction</fr:strong></fr:title><fr:parent>def-002O</fr:parent></fr:frontmatter><fr:mainmatter>
    We can first construct:
    <fr:tex display="block">         f(x):(y:A) \to  (x=_Ay) \to (z:A) \to  (y=_Az) \to (x=_Az)     </fr:tex>
    For any <fr:tex>x:A</fr:tex>, it suffices to construct
    <fr:tex display="block">         f(x,x, \text {refl} _x) : (z:A)  \to  (x=_Az) \to (x=_Az)     </fr:tex>
    That is the identity function <fr:tex>\lambda  z.  \text {id} _{x=_Az}</fr:tex>.
    Then we can define by induction:
    <fr:tex display="block">         f(x) : \equiv   \text {ind-eq}_{ x } ( \lambda  z. \text {id} )     </fr:tex>
    Finally:
    <fr:tex display="block">          \text {concat} _{x,y,z}(p,q) : \equiv  f(x,y,p,z,q)     </fr:tex>
    Or simply we denote <fr:tex>\text {concat} (p,q)</fr:tex> as <fr:tex>p  \cdot  q</fr:tex>
</fr:mainmatter></fr:tree>
</fr:mainmatter><fr:backmatter><fr:contributions></fr:contributions><fr:context><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>804</fr:anchor><fr:taxon>Type Theory</fr:taxon><fr:addr>tt-0005</fr:addr><fr:route>tt-0005.xml</fr:route><fr:title>Identity Types</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>31</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
    This post discuss the identity types in type theory.
    Refer to <fr:link href="hott-2022.xml" type="local" addr="hott-2022">Introduction to Homotopy Type Theory</fr:link>.
</fr:p><fr:p>
    How can we think of <fr:strong>equality</fr:strong> in type theory?
    Mentioned before, given a type <fr:tex>A</fr:tex> and two its elements <fr:tex>a,b:A</fr:tex>
    we can define a new type <fr:tex>a=_Ab</fr:tex> which is called the <fr:strong>identity type</fr:strong>.
    In this case, a term of <fr:tex>a=_Ab</fr:tex> is said to be a <fr:em>witness</fr:em> of the equality of <fr:tex>a</fr:tex> and <fr:tex>b</fr:tex>.
    And this witness is itself a type.
    We can then define their equality.
    This gives every type a <fr:strong>groupoid structure</fr:strong>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>543</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-002N</fr:addr><fr:route>def-002N.xml</fr:route><fr:title>Identity Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The <fr:strong>identity type</fr:strong> is an inductive type,
    generated by just a <fr:strong>reflexivity</fr:strong> <fr:em>identification</fr:em>
    that providing an equality of a term with itself.
</fr:p><fr:p>
    Consider a type <fr:tex>A</fr:tex> and let <fr:tex>a:A</fr:tex> be an element.
    The identity type of <fr:tex>A</fr:tex> at <fr:tex>a</fr:tex> is an inductive family of types <fr:tex>a=_Ax</fr:tex> 
    indexed by <fr:tex>x:A</fr:tex>.
    <fr:tex display="block">          \frac {              \Gamma \vdash  a:A         }{              \Gamma ,x:A \vdash  a=_Ax \space \text {type}          }     </fr:tex>
    The only constructor is the refl:
    <fr:tex display="block">          \frac {              \Gamma \vdash  a:A         }{              \Gamma \vdash   \text {refl} _a:a=_Ax         }     </fr:tex></fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>541</fr:anchor><fr:title><fr:strong>
    Path Induction / Identification Elimination
</fr:strong></fr:title><fr:parent>def-002N</fr:parent></fr:frontmatter><fr:mainmatter>
    The induction principle of the identity type states that
    for any type family <fr:tex>P(x,p)</fr:tex> indexed by <fr:tex>x:A</fr:tex> and <fr:tex>p:a=_Ax</fr:tex>,
    <fr:tex display="block">          \text {ind-eq}_{ a } :P(a,  \text {refl} _a) \to  (x:A) \to  (p:a=_Ax) \to  P(x,p)     </fr:tex>
    satisfies <fr:tex>\text {ind-eq}_{ a } (u,a, \text {refl} _a) \equiv  u</fr:tex> where <fr:tex>u:P(a, \text {refl} _a)</fr:tex>.
    Formally we can write:
    <fr:tex display="block">          \frac {              \Gamma \vdash  a:A, \quad   \Gamma ,x:A,p:a=_Ax \vdash  P(x,p) \space \text {type}          }{              \Gamma \vdash   \text {ind-eq}_{ a } (a, \text {refl} _a): P(a, \text {refl} _a)  \to  (x:A) \to  (p:a=_Ax) \to  P(x,p)         } \text {eq-elim}     </fr:tex>
    <fr:tex display="block">          \frac {              \Gamma \vdash  a:A, \quad   \Gamma ,x:A,p:a=_Ax \vdash  P(x,p) \space \text {type}          }{              \Gamma ,u:P(a, \text {refl} _a) \vdash   \text {ind-eq}_{ a } (u,a, \text {refl} _a) \equiv  u:P(a, \text {refl} _a)         } \text {eq-comp}     </fr:tex>

</fr:mainmatter></fr:tree>
<fr:p>
    A term of <fr:tex>a=_Ax</fr:tex> is called a <fr:strong>identification</fr:strong> of <fr:tex>a</fr:tex> and <fr:tex>x</fr:tex>,
    or the <fr:strong>path</fr:strong> from <fr:tex>a</fr:tex> to <fr:tex>x</fr:tex>.
</fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>542</fr:anchor><fr:title><fr:strong>Variable Version</fr:strong></fr:title><fr:parent>def-002N</fr:parent></fr:frontmatter><fr:mainmatter>
    We can form an identity type with variables of <fr:tex>A</fr:tex>.
    <fr:tex display="block">          \Gamma ,x:A,y:A \vdash  x=_Ay \space \text {type}      </fr:tex>
    with the following introduction rule:
    <fr:tex display="block">          \frac {              \Gamma ,x:A \vdash  x:A         }{              \Gamma ,x:A \vdash   \text {refl} _x:x=_Ax         }     </fr:tex>
    and similarly the elimination rule and computation rule.
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:p>
    The identifications can be <fr:strong>concatenated</fr:strong> and <fr:strong>inverted</fr:strong>,
    which implies the <fr:em>transitivity</fr:em> and <fr:em>symmetry</fr:em> of the identity type.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>545</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-002O</fr:addr><fr:route>def-002O.xml</fr:route><fr:title>Concatenation Operation</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>A</fr:tex> be a type.
    The <fr:strong>Concatenation</fr:strong> operation is defined:
    <fr:tex display="block">          \text {concat} : (x:A) \to  (y:A) \to  (z:A) \to  (x=_Ay) \to  (y=_Az) \to  (x=_Az)     </fr:tex></fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>544</fr:anchor><fr:title><fr:strong>Construction</fr:strong></fr:title><fr:parent>def-002O</fr:parent></fr:frontmatter><fr:mainmatter>
    We can first construct:
    <fr:tex display="block">         f(x):(y:A) \to  (x=_Ay) \to (z:A) \to  (y=_Az) \to (x=_Az)     </fr:tex>
    For any <fr:tex>x:A</fr:tex>, it suffices to construct
    <fr:tex display="block">         f(x,x, \text {refl} _x) : (z:A)  \to  (x=_Az) \to (x=_Az)     </fr:tex>
    That is the identity function <fr:tex>\lambda  z.  \text {id} _{x=_Az}</fr:tex>.
    Then we can define by induction:
    <fr:tex display="block">         f(x) : \equiv   \text {ind-eq}_{ x } ( \lambda  z. \text {id} )     </fr:tex>
    Finally:
    <fr:tex display="block">          \text {concat} _{x,y,z}(p,q) : \equiv  f(x,y,p,z,q)     </fr:tex>
    Or simply we denote <fr:tex>\text {concat} (p,q)</fr:tex> as <fr:tex>p  \cdot  q</fr:tex>
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>547</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-002P</fr:addr><fr:route>def-002P.xml</fr:route><fr:title>Inverse Operation</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>A</fr:tex> be a type. The <fr:strong>inverse oepration</fr:strong> is defined:
    <fr:tex display="block">          \text {inv} : (x:A) \to  (y:A) \to  (x=_Ay) \to  (y=_Ax)     </fr:tex></fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>546</fr:anchor><fr:title>
    <fr:strong>Construction</fr:strong>
</fr:title><fr:parent>def-002P</fr:parent></fr:frontmatter><fr:mainmatter>
    By induction, it suffices to construct:
    <fr:tex display="block">          \text {inv} (x,x, \text {refl} _x) : (x=_Ax)     </fr:tex>
    for any <fr:tex>x:A</fr:tex>. And trivially we have <fr:tex>\text {inv} (x,x, \text {refl} _x) \equiv \text {refl} _x</fr:tex>.
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>549</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-002W</fr:addr><fr:route>def-002W.xml</fr:route><fr:title>Associator</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>A</fr:tex> be a type.
    These are 3 consecutive identifications
    <fr:tex display="block">         p:x=_Ay,q:y=_Az, r:z=_Aw     </fr:tex>
    we define the <fr:strong>associator</fr:strong>:
    <fr:tex display="block">          \text {assoc} : (p,q,r): (p \cdot  q) \cdot  r = p \cdot  (q \cdot  r)     </fr:tex></fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>548</fr:anchor><fr:title>
    <fr:strong>Construction</fr:strong>
</fr:title><fr:parent>def-002W</fr:parent></fr:frontmatter><fr:mainmatter>
    By definition it suffices to show that
    <fr:tex display="block">          \Pi _{(z:A)} \Pi _{(q:x=_Az)}          \Pi _{(w:A)} \Pi _{(r:z=_Aw)}         ( \text {refl} _x \cdot  q) \cdot  r =  \text {refl} _x \cdot  (q \cdot  r)     </fr:tex>
    Let <fr:tex>q:x=_Az</fr:tex> and <fr:tex>r:z=_Aw</fr:tex>. By computation rule of identity types
    <fr:tex display="block">          \text {refl} _x \cdot  q  \equiv  q     </fr:tex>
    Then we can conclude that
    <fr:tex display="block">         ( \text {refl} _x \cdot  q) \cdot  r  \equiv  q \cdot  r     </fr:tex>
    similarly <fr:tex>\text {refl} _x \cdot  (q \cdot  r)  \equiv  q \cdot  r</fr:tex>.
    Hence we have the left and right side
    <fr:tex display="block">         ( \text {refl} _x \cdot  q) \cdot  r =  \text {refl} _x \cdot  (q \cdot  r)     </fr:tex>
    are judgementally equal, 
    so we can simply define the associator as
    <fr:tex display="block">          \text {assoc} ( \text {refl} _x,q,r) : \equiv   \text {refl} _{q \cdot  r}     </fr:tex>
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>551</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-002X</fr:addr><fr:route>def-002X.xml</fr:route><fr:title>Unit Law Operations</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>A</fr:tex> be a type.
    We defined the <fr:strong>unit law</fr:strong> operations for <fr:tex>x=_Ay</fr:tex>:
    <fr:tex display="block">          \begin {align*}              \text {left-unit} &amp; : (x=_Ay) \to  ( \text {refl} _x \cdot  x = x)  \\               \text {right-unit} &amp; : (x=_Ay) \to  (x \cdot \text {refl} _y = x)          \end {align*}     </fr:tex></fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>550</fr:anchor><fr:title>
    <fr:strong>Construction</fr:strong>
</fr:title><fr:parent>def-002X</fr:parent></fr:frontmatter><fr:mainmatter>
    By elimination it suffices to construct:
    <fr:tex display="block">          \begin {align*}              \text {left-unit}( \text {refl} _x) &amp;:  \text {refl} _x  \cdot   \text {refl} _x =  \text {refl} _x  \\               \text {right-unit}( \text {refl} _x) &amp;:  \text {refl} _x  \cdot   \text {refl} _x =  \text {refl} _x          \end {align*}     </fr:tex>
    In both cases we need only to construct <fr:tex>\text {refl} _{ \text {refl} _x}</fr:tex>.
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:context><fr:related></fr:related><fr:backlinks></fr:backlinks><fr:references></fr:references></fr:backmatter></fr:tree>