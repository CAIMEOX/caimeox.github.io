<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>2345</anchor>  <taxon>Definition</taxon> <addr>def-002N</addr>  <route>def-002N.xml</route>   <title>Identity Type</title> </frontmatter> <mainmatter><p>
    The <strong>identity type</strong> is an inductive type,
    generated by just a <strong>reflexivity</strong> <em>identification</em>
    that providing an equality of a term with itself.
</p><p>
    Consider a type <tex>A</tex> and let <tex>a:A</tex> be an element.
    The identity type of <tex>A</tex> at <tex>a</tex> is an inductive family of types <tex>a=_Ax</tex> 
    indexed by <tex>x:A</tex>.
    <tex display="block">
         \frac {
             \Gamma \vdash  a:A
        }{
             \Gamma ,x:A \vdash  a=_Ax \space \text {type} 
        }
    </tex>
    The only constructor is the refl:
    <tex display="block">
         \frac {
             \Gamma \vdash  a:A
        }{
             \Gamma \vdash   \text {refl} _a:a=_Ax
        }
    </tex></p><block open="open"><headline><strong>
    Path Induction / Identification Elimination
</strong></headline> 
    The induction principle of the identity type states that
    for any type family <tex>P(x,p)</tex> indexed by <tex>x:A</tex> and <tex>p:a=_Ax</tex>,
    <tex display="block">
         \text {ind-eq}_{ a } :P(a,  \text {refl} _a) \to  (x:A) \to  (p:a=_Ax) \to  P(x,p)
    </tex>
    satisfies <tex>\text {ind-eq}_{ a } (u,a, \text {refl} _a) \equiv  u</tex> where <tex>u:P(a, \text {refl} _a)</tex>.
    Formally we can write:
    <tex display="block">
         \frac {
             \Gamma \vdash  a:A, \quad   \Gamma ,x:A,p:a=_Ax \vdash  P(x,p) \space \text {type} 
        }{
             \Gamma \vdash   \text {ind-eq}_{ a } (a, \text {refl} _a): (x:A) \to  (p:a=_Ax) \to  P(x,p)
        } \text {eq-elim}
    </tex>
    <tex display="block">
         \frac {
             \Gamma \vdash  a:A, \quad   \Gamma ,x:A,p:a=_Ax \vdash  P(x,p) \space \text {type} 
        }{
             \Gamma ,u:P(a, \text {refl} _a) \vdash   \text {ind-eq}_{ a } (u,a, \text {refl} _a) \equiv  u:P(a, \text {refl} _a)
        } \text {eq-comp}
    </tex>

</block><p>
    A term of <tex>a=_Ax</tex> is called a <strong>identification</strong> of <tex>a</tex> and <tex>x</tex>,
    or the <strong>path</strong> from <tex>a</tex> to <tex>x</tex>.
</p><block open="open"><headline><strong>Variable Version</strong></headline> 
    We can form an identity type with variables of <tex>A</tex>.
    <tex display="block">
         \Gamma ,x:A,y:A \vdash  x=_Ay \space \text {type} 
    </tex>
    with the following introduction rule:
    <tex display="block">
         \frac {
             \Gamma ,x:A \vdash  x:A
        }{
             \Gamma ,x:A \vdash   \text {refl} _x:x=_Ax
        }
    </tex>
    and similarly the elimination rule and computation rule.
</block></mainmatter> <backmatter><contributions/> <context><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>2346</anchor>  <taxon>Type Theory</taxon> <addr>tt-0005</addr>  <route>tt-0005.xml</route> <date><year>2024</year> <month>1</month> <day>31</day></date>  <title>Identity Types</title> </frontmatter> <mainmatter><p>
    How can we think of <strong>equality</strong> in type theory?
    Mentioned before, given a type <tex>A</tex> and two its elements <tex>a,b:A</tex>
    we can define a new type <tex>a=_Ab</tex> which is called the <strong>identity type</strong>.
    In this case, a term of <tex>a=_Ab</tex> is said to be a <em>witness</em> of the equality of <tex>a</tex> and <tex>b</tex>.
    And this witness is itself a type.
    We can then define their equality.
    This gives every type a <strong>groupoid structure</strong>.
</p><p>
    The identifications can be <strong>concatenated</strong> and <strong>inverted</strong>,
    which implies the <em>transitivity</em> and <em>symmetry</em> of the identity type.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>2347</anchor>  <taxon>Definition</taxon> <addr>def-002O</addr>  <route>def-002O.xml</route>   <title>Concatenation Operation</title> </frontmatter> <mainmatter><p>
    Let <tex>A</tex> be a type.
    The <strong>Concatenation</strong> operation is defined:
    <tex display="block">
         \text {concat} : (x:A) \to  (y:A) \to  (z:A) \to  (x=_Ay) \to  (y=_Az) \to  (x=_Az)
    </tex></p><block open="open"><headline><strong>Construction</strong></headline> 
    We can first construct:
    <tex display="block">
        f(x):(y:A) \to  (x=_Ay) \to (z:A) \to  (y=_Az) \to (x=_Az)
    </tex>
    For any <tex>x:A</tex>, it suffices to construct
    <tex display="block">
        f(x,x, \text {refl} _x) : (z:A)  \to  (x=_Az) \to (x=_Az)
    </tex>
    That is the identity function <tex>\lambda  z.  \text {id} _{x=_Az}</tex>.
    Then we can define by induction:
    <tex display="block">
        f(x) : \equiv   \text {ind-eq}_{ x } ( \lambda  z. \text {id} )
    </tex>
    Finally:
    <tex display="block">
         \text {concat} _{x,y,z}(p,q) : \equiv  f(x,y,p,z,q)
    </tex>
</block></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>2348</anchor>  <taxon>Definition</taxon> <addr>def-002P</addr>  <route>def-002P.xml</route>   <title>Inverse Operation</title> </frontmatter> <mainmatter><p>
    Let <tex>A</tex> be a type. The <strong>inverse oepration</strong> is defined:
    <tex display="block">
         \text {inv} : (x:A) \to  (y:A) \to  (x=_Ay) \to  (y=_Ax)
    </tex></p><block open="open"><headline>
    <strong>Construction</strong>
</headline> 
    By induction, it suffices to construct:
    <tex display="block">
         \text {inv} (x,x, \text {refl} _x) : (x=_Ax)
    </tex>
    for any <tex>x:A</tex>. And trivially we have <tex>\text {inv} (x,x, \text {refl} _x) \equiv \text {refl} _x</tex>.
</block></mainmatter> </tree></mainmatter> </tree></context> <related/> <backlinks/> <references/></backmatter></tree>