<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>881</fr:anchor><fr:addr type="machine">#243</fr:addr><fr:route>unstable-243.xml</fr:route><fr:title text="Simply Typed Lambda Calculus and Representation Theorems › The Limits of Simple Types"><fr:link type="local" href="cs-0005.xml" addr="cs-0005" title="Simply Typed Lambda Calculus and Representation Theorems">Simply Typed Lambda Calculus and Representation Theorems</fr:link> › The Limits of Simple Types</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Are there expressions that cannot be typed in the simple type system?
        Yes, for example, <fr:tex display="inline">\Omega =\lambda  x.x\space  x</fr:tex> cannot be typed.
        But how do we prove that  <fr:tex display="inline">\Omega </fr:tex> cannot be typed?</fr:p><fr:p>We can apply the typing rules and get a contradiction.
        <fr:tex display="inline">\Omega </fr:tex> is a lambda abstraction hence we can assume that it has type <fr:tex display="inline">\tau \to \sigma </fr:tex>.
        Then <fr:tex display="inline">x</fr:tex> has type <fr:tex display="inline">\tau </fr:tex> and <fr:tex display="inline">x\space  x</fr:tex> has type <fr:tex display="inline">\sigma </fr:tex>.
        By the application of <fr:tex display="inline">x\space  x</fr:tex> we get that <fr:tex display="inline">\tau =\tau \to \sigma </fr:tex>, 
        which does not exist.</fr:p><fr:p>To recover from this in full generality we need <fr:strong>recursive types</fr:strong>.
        <fr:tex display="block">             \tau  =F\tau          </fr:tex>
        where <fr:tex display="inline">F=\lambda \alpha .\alpha \to \sigma </fr:tex> and we might have a solution with 
        <fr:tex display="inline">\tau =Y\space  F</fr:tex>. But such solution is not available to us. We do not have 
        function from types to types <fr:tex display="inline">F</fr:tex> and a type level Y combinator.
        However it is ok to construct recursive types (we would do later).</fr:p></fr:mainmatter><fr:backmatter><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title text="Context">Context</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>882</fr:anchor><fr:addr type="user">cs-0005</fr:addr><fr:route>cs-0005.xml</fr:route><fr:title text="Simply Typed Lambda Calculus and Representation Theorems">Simply Typed Lambda Calculus and Representation Theorems</fr:title><fr:taxon>Computer Science</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We have explored the power of lambda calculus.
    Church&apos;s original purpose of the pure calculus of functions 
    was a new foundations of mathematics distinct from set theory.
    Unfortunately the original lambda calculus is <fr:strong>inconsistent</fr:strong> (Every proposition has a proof).
    Church returned to the ideas by Russell and Whitehead and developed the <fr:strong>Church&apos;s Simple Theory of Types</fr:strong>.
    <fr:strong>SLTC</fr:strong> is a typed interpretation of the lambda calculus with only one type constructor <fr:tex display="inline">\to </fr:tex>
    that builds function types.</fr:p><fr:p>We follow the converntion that function type constructor <fr:tex display="inline">\to </fr:tex> is right-associative.
    We write <fr:tex display="inline">e:\tau </fr:tex> if expression <fr:tex display="inline">e</fr:tex> has type <fr:tex display="inline">\tau </fr:tex>.
    <fr:tex display="block">         \lambda  x.x:\tau \to \tau      </fr:tex>
    But the type is not unique. The booleans can be typed:
    <fr:tex display="block">         \begin {align*}             \text {true} &amp;= \lambda  x.\lambda  y.x : \alpha \to (\beta \to \alpha )\\             \text {false} &amp;= \lambda  x.\lambda  y.y : \alpha \to (\beta \to \beta )         \end {align*}     </fr:tex></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>544</fr:anchor><fr:addr type="machine">#242</fr:addr><fr:route>unstable-242.xml</fr:route><fr:title text="Typing Judgment">Typing Judgment</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Wem can formalize judgments about expressions and types using <fr:strong>inference rules</fr:strong>.
        For instance:
        <fr:tex display="block">             \frac {                 e_1:\tau _1\quad  e_2:\tau _2             }{                 e_1\space  e_2:\tau _2             }         </fr:tex>
        The application <fr:tex display="inline">e_1\space  e_2</fr:tex> has type <fr:tex display="inline">\tau _2</fr:tex> if <fr:tex display="inline">e_1</fr:tex> has type 
        <fr:tex display="inline">\tau _1\to \tau _2</fr:tex> and <fr:tex display="inline">e_2</fr:tex> has type <fr:tex display="inline">\tau _1</fr:tex>.</fr:p><fr:p>We can record the types of variable in a <fr:strong>typing context</fr:strong>.
        <fr:tex display="block">             \Gamma  :\equiv  x_1:\tau _1,\ldots ,x_n:\tau _n         </fr:tex>
        And we always assume that all variables declared in a context are distinct.
        This avoids any ambiguity when we try to determine the type of a variable.
        The typing judgment now becomes
        <fr:tex display="block">             \Gamma \vdash  e:\tau          </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>545</fr:anchor><fr:addr type="machine">#243</fr:addr><fr:route>unstable-243.xml</fr:route><fr:title text="The Limits of Simple Types">The Limits of Simple Types</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Are there expressions that cannot be typed in the simple type system?
        Yes, for example, <fr:tex display="inline">\Omega =\lambda  x.x\space  x</fr:tex> cannot be typed.
        But how do we prove that  <fr:tex display="inline">\Omega </fr:tex> cannot be typed?</fr:p><fr:p>We can apply the typing rules and get a contradiction.
        <fr:tex display="inline">\Omega </fr:tex> is a lambda abstraction hence we can assume that it has type <fr:tex display="inline">\tau \to \sigma </fr:tex>.
        Then <fr:tex display="inline">x</fr:tex> has type <fr:tex display="inline">\tau </fr:tex> and <fr:tex display="inline">x\space  x</fr:tex> has type <fr:tex display="inline">\sigma </fr:tex>.
        By the application of <fr:tex display="inline">x\space  x</fr:tex> we get that <fr:tex display="inline">\tau =\tau \to \sigma </fr:tex>, 
        which does not exist.</fr:p><fr:p>To recover from this in full generality we need <fr:strong>recursive types</fr:strong>.
        <fr:tex display="block">             \tau  =F\tau          </fr:tex>
        where <fr:tex display="inline">F=\lambda \alpha .\alpha \to \sigma </fr:tex> and we might have a solution with 
        <fr:tex display="inline">\tau =Y\space  F</fr:tex>. But such solution is not available to us. We do not have 
        function from types to types <fr:tex display="inline">F</fr:tex> and a type level Y combinator.
        However it is ok to construct recursive types (we would do later).</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>546</fr:anchor><fr:addr type="machine">#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:title text="Characterizing the Booleans">Characterizing the Booleans</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>We now show that the representation of the booleans is correct.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>547</fr:anchor><fr:addr type="machine">#245</fr:addr><fr:route>unstable-245.xml</fr:route><fr:title text="Representation of Booleans">Representation of Booleans</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#244</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex display="inline">\emptyset \vdash  e:\alpha \to (\alpha \to \alpha )</fr:tex> and <fr:tex display="inline">e</fr:tex> is a normal form, 
            then <fr:tex display="inline">e = \text {true}</fr:tex> or <fr:tex display="inline">e = \text {false}</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We will later combine this with the following theorems which yields 
    correctness of the representation of the booleans.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>548</fr:anchor><fr:addr type="user">def-003O</fr:addr><fr:route>def-003O.xml</fr:route><fr:title text="Weak Normalization">Weak Normalization</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex display="inline">\Gamma \vdash  e:\tau </fr:tex> then <fr:tex display="inline">e\to _{\beta }^*e&apos;</fr:tex> for a <fr:strong>normal form</fr:strong> <fr:tex display="inline">e&apos;</fr:tex>.
    And we can define <fr:strong>subject reduction</fr:strong>, if <fr:tex display="inline">\Gamma \vdash  e:\tau </fr:tex> and <fr:tex display="inline">e\to _{\beta }e&apos;</fr:tex> then <fr:tex display="inline">\Gamma \vdash  e&apos;:\tau </fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>549</fr:anchor><fr:addr type="machine">#246</fr:addr><fr:route>unstable-246.xml</fr:route><fr:title text="Reduction revised">Reduction revised</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Our characterization of normal forms is quite simple: terms that do not reduce.
        However, this is a <fr:strong>negative</fr:strong> condition, which is difficult to work with in proofs.
        We would like to have a <fr:strong>positive</fr:strong> condition, which is easier to work with.</fr:p><fr:p>We tend to give definitions in the form of inference rules.
        The property then holds if the judgment can be derived using the rules.
        (This closely related to the <fr:strong>inductive deefintion</fr:strong>).
        Before defining the normal forms we formally define <fr:strong>beta reduction</fr:strong>.
        The judgment here <fr:tex display="inline">e\to  e&apos;</fr:tex> expressing that <fr:tex display="inline">e</fr:tex> reduces to <fr:tex display="inline">e&apos;</fr:tex>.
        <fr:tex display="block">             \begin {align*}                 \frac {}{(\lambda  x.e_1)e_2\to  e_1[x:=e_2]} (\text {red/beta}) \\                 \frac {e\to  e&apos;}{\lambda  x.e \to  \lambda  x.e&apos;} (\text {red/lam}) \\                 \frac {e_1\to  e_1&apos;}{e_1\space  e_2\to  e_1&apos;\space  e_2} (\text {red/app}_1) \\                 \frac {e_2\to  e_2&apos;}{e_1\space  e_2\to  e_1\space  e_2&apos;} (\text {red/app}_2)                             \end {align*}         </fr:tex></fr:p><fr:p>A <fr:strong>normal form</fr:strong> is an expression that does not reduce.
        To give a proper formalization,, we need a separate judgment for <fr:strong>neutral terms</fr:strong>
        which do not create a redex when applied to an argument.
        <fr:tex display="block">                                       \begin {align*}                 \frac {e\text { normal}}{\lambda  x.e\text { normal}} (\text {normal/lam}) \\                 \frac {e\text { neutral}}{e\text { normal}} (\text {normal/var}) \\                 \frac {}{x\text { neutral}} (\text {neutral/var}) \\                 \frac {e_1\text { neutral}\quad  e_2\text { normal}}{e_1\space  e_2\text { neutral}} (\text {neutral/app}) \\             \end {align*}         </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>550</fr:anchor><fr:addr type="machine">#247</fr:addr><fr:route>unstable-247.xml</fr:route><fr:title text="Normal Forms and Reduction">Normal Forms and Reduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>5</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0005</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The characterization of normal forms via inference rules is compact,
        but is it really the same as saying that an expression does not reduce?
        We break this down into the following two properties.
        <fr:ul><fr:li>For all expressions <fr:tex display="inline">e</fr:tex>, either <fr:tex display="inline">e</fr:tex> reduces or <fr:tex display="inline">e</fr:tex> is normal</fr:li>
            <fr:li>For all expressions <fr:tex display="inline">e</fr:tex>, it is not that case <fr:tex display="inline">e</fr:tex> reduces and <fr:tex display="inline">e</fr:tex> is normal</fr:li></fr:ul></fr:p><fr:p>We have theorem that ensures that the first property holds. (Proof is omitted).</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>551</fr:anchor><fr:addr type="user">thm-0010</fr:addr><fr:route>thm-0010.xml</fr:route><fr:title text="Reduction and normal forms">Reduction and normal forms</fr:title><fr:taxon>Theorem</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For every expression <fr:tex display="inline">e</fr:tex>, either <fr:tex display="inline">e\to  e&apos;</fr:tex> for some expression <fr:tex display="inline">e&apos;</fr:tex> or <fr:tex display="inline">e</fr:tex> is a normal form.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:backmatter></fr:tree>