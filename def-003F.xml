<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>1247</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003F</fr:addr><fr:route>def-003F.xml</fr:route><fr:title>Small Category</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    A <fr:link href="def-003E.xml" type="local" addr="def-003E">category</fr:link> is said to be <fr:strong>small</fr:strong> 
    if it has a <fr:strong>samll set</fr:strong> (i.e. a set but not a proper class) of objects and morphisms.
    In other words a small category is an <fr:strong>internal category</fr:strong> in category of sets.
</fr:p></fr:mainmatter><fr:backmatter><fr:contributions></fr:contributions><fr:context><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>1246</fr:anchor><fr:taxon>Category Theory</fr:taxon><fr:addr>math-0006</fr:addr><fr:route>math-0006.xml</fr:route><fr:title>Category Theory of Utilitarianism</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    This note is about the category theory and its applications.
    Instead of reading a well-organized book, I prefer to write down the things I learned
    from <fr:link href="ncatlab.xml" type="local" addr="ncatlab">ncatlab</fr:link> and papers.
</fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>358</fr:anchor><fr:title>
    <fr:strong>Ideas</fr:strong></fr:title><fr:parent>math-0006</fr:parent></fr:frontmatter><fr:mainmatter>
        Intuitively, a category is a collection of objects and arrows between them,
        such arrows can be composed and there is an identity arrow for each object.
    <fr:p>
        There are commonly two ways to define a category, which are equivalent in usual 
        foundations of mathematics. One of them generalizes the notion of <fr:strong>internal category</fr:strong>
        nicely while the other one is more convenient for <fr:strong>enriched category</fr:strong>.
    </fr:p>
    <fr:p>
        The major difference is whether they use a single collection of all morphisms or
        several collections of morphisms (<fr:strong>family of collections</fr:strong> indexed by pairs of objects)
    </fr:p>
</fr:mainmatter></fr:tree>
<fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>361</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003E</fr:addr><fr:route>def-003E.xml</fr:route><fr:title>Category</fr:title></fr:frontmatter><fr:mainmatter>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>359</fr:anchor><fr:title><fr:strong>With one collection</fr:strong></fr:title><fr:parent>def-003E</fr:parent></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex>C</fr:tex> consists
    <fr:ul><fr:li>
            A collection of <fr:strong>objects</fr:strong> <fr:tex>C_0</fr:tex> (<fr:tex>\text {Ob} (C)</fr:tex>).
        </fr:li>
        <fr:li>
            A collection <fr:tex>C_1</fr:tex> (<fr:tex>\text {Mor} (C)</fr:tex>) of <fr:strong>morphisms</fr:strong> (arrows).
        </fr:li>
        <fr:li>
            For every morphism <fr:tex>f</fr:tex> there are an object <fr:tex>s(f)</fr:tex> (<fr:strong>source</fr:strong>, domain) and an object <fr:tex>t(f)</fr:tex> (<fr:strong>target</fr:strong>, codomain).
        </fr:li>
        <fr:li>
            For every pair of morphisms <fr:tex>f, g</fr:tex> such that <fr:tex>t(f) = s(g)</fr:tex>, there is a morphism <fr:tex>g  \circ  f</fr:tex> (<fr:strong>composition</fr:strong>) (Also written <fr:tex>gf</fr:tex> or <fr:tex>f;g</fr:tex>).
        </fr:li>
        <fr:li>
            For every object <fr:tex>x</fr:tex>, there is a morphism <fr:tex>\text {id} _x</fr:tex> (or <fr:tex>1_x</fr:tex>) called <fr:strong>identity</fr:strong>.
        </fr:li>
        <fr:li>
            The following properties hold:
            <fr:ul><fr:li><fr:tex>s(g  \circ  f) = s(f)</fr:tex> and <fr:tex>t(g  \circ  f) = t(g)</fr:tex>.
                </fr:li>
                <fr:li><fr:tex>s(1_x) = x</fr:tex> and <fr:tex>t(1_x) = x</fr:tex>.
                </fr:li>
                <fr:li>
                    Composition is <fr:strong>associative</fr:strong>: <fr:tex>h  \circ  (g  \circ  f) = (h  \circ  g)  \circ  f</fr:tex> when <fr:tex>t(f) = s(g)</fr:tex>, and <fr:tex>t(g) = s(h)</fr:tex>.
                </fr:li>
                <fr:li>
                    Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex>f  \circ   \text {id} _x = f</fr:tex> and <fr:tex>\text {id} _y  \circ  f = f</fr:tex></fr:li></fr:ul></fr:li></fr:ul>
    If the identity map and its axioms are omitted then one speaks of a <fr:strong>semicategory</fr:strong>.
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>360</fr:anchor><fr:title><fr:strong>With a family of collections of morphisms</fr:strong></fr:title><fr:parent>def-003E</fr:parent></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex>C</fr:tex> consists
    <fr:ul><fr:li>
            A collection of <fr:strong>objects</fr:strong> <fr:tex>C_0</fr:tex> (<fr:tex>\text {Ob} (C)</fr:tex>).
        </fr:li>
        <fr:li>
            For every pair of objects <fr:tex>x, y</fr:tex>, a collection <fr:tex>C_1(x, y)</fr:tex> (<fr:tex>\hom _C(x,y)</fr:tex>) of <fr:strong>morphisms</fr:strong> from <fr:tex>x</fr:tex> to <fr:tex>y</fr:tex>.
        </fr:li>
        <fr:li>
            For each pair of morphisms <fr:tex>f</fr:tex> in <fr:tex>C_1(x,y)</fr:tex> and <fr:tex>g</fr:tex> in <fr:tex>C_1(y,z)</fr:tex>, a morphism <fr:tex>g  \circ  f</fr:tex> in <fr:tex>C_1(x,z)</fr:tex>.
            called their <fr:strong>composition</fr:strong>.
        </fr:li>
        <fr:li>
            For each object <fr:tex>x</fr:tex>, a morphism <fr:tex>\text {id} _x</fr:tex> in <fr:tex>C_1(x,x)</fr:tex> called the <fr:strong>identity</fr:strong> on <fr:tex>x</fr:tex>.
        </fr:li>
        <fr:li>
            The following properties hold:
            <fr:ul><fr:li>Composition is <fr:strong>associative</fr:strong>: <fr:tex>h  \circ  (g  \circ  f) = (h  \circ  g)  \circ  f</fr:tex> for all <fr:tex>f</fr:tex> in <fr:tex>C_1(x,y)</fr:tex>, <fr:tex>g</fr:tex> in <fr:tex>C_1(y,z)</fr:tex>, and <fr:tex>h</fr:tex> in <fr:tex>C_1(z,w)</fr:tex>.</fr:li>
                <fr:li>Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex>f  \circ   \text {id} _x = f</fr:tex> and <fr:tex>\text {id} _y  \circ  f = f</fr:tex> for all <fr:tex>f</fr:tex> in <fr:tex>C_1(x,y)</fr:tex>.</fr:li></fr:ul></fr:li></fr:ul>
    Usually we write <fr:tex>\text {Mor} (C)</fr:tex> for the disjoint union <fr:tex>\bigsqcup _{x,y  \in  C_0} C_1(x,y)</fr:tex>.
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:p>
    Its common to talk about some objects and their morphisms.
    Informally, a <fr:strong>diagram</fr:strong> in a category <fr:tex>C</fr:tex> consists of some 
    objects of <fr:tex>C</fr:tex> connected by some morphisms of <fr:tex>C</fr:tex>.
</fr:p><fr:p>
    This terminology is often used when speaking about <fr:strong>limits</fr:strong> or 
    <fr:strong>colimits</fr:strong> of a diagram.
</fr:p><fr:p>
    One formal way to define a diagram is to use a <fr:strong>functor</fr:strong> from a (very) small category to <fr:tex>C</fr:tex>.
    That is, a functor whose domain is a small category.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>362</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003F</fr:addr><fr:route>def-003F.xml</fr:route><fr:title>Small Category</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    A <fr:link href="def-003E.xml" type="local" addr="def-003E">category</fr:link> is said to be <fr:strong>small</fr:strong> 
    if it has a <fr:strong>samll set</fr:strong> (i.e. a set but not a proper class) of objects and morphisms.
    In other words a small category is an <fr:strong>internal category</fr:strong> in category of sets.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    We did not explain what a <fr:strong>functor</fr:strong> is, but it is very natural thought.
    Briefly, a functor is a <fr:strong>homomorphism</fr:strong> between two categories.
    It maps objects to objects and morphisms to morphisms, preserving the structure of the categories.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>363</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003G</fr:addr><fr:route>def-003G.xml</fr:route><fr:title>Functor</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    A <fr:strong>functor</fr:strong> <fr:tex>F</fr:tex> from a category <fr:tex>C</fr:tex> to a category <fr:tex>D</fr:tex> is a map
    sending each <fr:tex>x \in  C</fr:tex> to an object <fr:tex>F(x) \in  D</fr:tex> and each morphism
    <fr:tex>f:x \to  y</fr:tex> in <fr:tex>C</fr:tex> to morphism <fr:tex>F(f):F(x) \to  F(y)</fr:tex> in <fr:tex>D</fr:tex>, such that 
    <fr:ul><fr:li>
            Composition is preserved: <fr:tex>F(g \circ  f) = F(g) \circ  F(f)</fr:tex>.
        </fr:li>
        <fr:li>
            Identity is preserved: <fr:tex>F( \text {id} _x) =  \text {id} _{F(x)}</fr:tex>.
        </fr:li></fr:ul></fr:p></fr:mainmatter></fr:tree><fr:p>
    For the sake of completeness, we state the definition of the <fr:strong>functor category</fr:strong>
    and the <fr:strong>natural transformations</fr:strong> between functors.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>364</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003I</fr:addr><fr:route>def-003I.xml</fr:route><fr:title>Functor Category</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>C</fr:tex> and <fr:tex>D</fr:tex> be categories, the functor category <fr:tex>D^C</fr:tex> 
    (or <fr:tex>[C,D]</fr:tex>) is the category whose
    <fr:ul><fr:li>
            objects are functors from <fr:tex>C</fr:tex> to <fr:tex>D</fr:tex>.
        </fr:li>
        <fr:li>
            morphisms are <fr:strong>natural transformations</fr:strong> between functors.
        </fr:li></fr:ul></fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>365</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003J</fr:addr><fr:route>def-003J.xml</fr:route><fr:title>Natural Transformation</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>C</fr:tex> and <fr:tex>D</fr:tex> be categories and <fr:tex>F,G:C \to  D</fr:tex> be functors.
    A <fr:strong>natural transformation</fr:strong> <fr:tex>\alpha :F \Rightarrow   G</fr:tex> is 
    an assignment to every object <fr:tex>x \in  C</fr:tex> of a morphism <fr:tex>\alpha _x:F(x) \to  G(x)</fr:tex> in <fr:tex>D</fr:tex>,
    (called the <fr:strong>component</fr:strong> of <fr:tex>\alpha</fr:tex> at <fr:tex>x</fr:tex>)
    the following diagram commutes in <fr:tex>D</fr:tex>:
    
    <fr:embedded-tex hash="bce411235fd5c6731abb602d7c12b697"><fr:embedded-tex-preamble>
       \usepackage {tikz-cd}
       \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
         
         \begin {tikzcd}
            {F(x)} &amp;&amp; {F(y)}  \\ 
             \\ 
            {G(x)} &amp;&amp; {G(y)}
             \arrow [&quot;{F(f)}&quot;, from=1-1, to=1-3]
             \arrow [&quot;{G(f)}&quot;, from=3-1, to=3-3]
             \arrow [&quot;{ \alpha _x}&quot;, from=1-1, to=3-1]
             \arrow [&quot;{ \alpha _y}&quot;, from=1-3, to=3-3]
         \end {tikzcd}
     
    </fr:embedded-tex-body></fr:embedded-tex></fr:p></fr:mainmatter></fr:tree><fr:p>
    We state the concise functorial definition of diagrams of the shape of categories.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>366</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003H</fr:addr><fr:route>def-003H.xml</fr:route><fr:title>Diagram</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>C</fr:tex> be a category and <fr:tex>J</fr:tex> be a small category.
    A <fr:strong>diagram</fr:strong> of shape <fr:tex>J</fr:tex> in <fr:tex>C</fr:tex> is a functor <fr:tex>X:J \to  C</fr:tex>.
    The category of <fr:tex>J</fr:tex>-shaped diagrams in <fr:tex>C</fr:tex> is the <fr:link href="def-003I.xml" type="local" addr="def-003I">functor category</fr:link> <fr:tex>C^J</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    A limit of a diagram <fr:tex>F:D \to  C</fr:tex> is an object <fr:tex>\lim  F</fr:tex> of <fr:tex>C</fr:tex>
    equipped with morphisms to the objects <fr:tex>F(d)</fr:tex> for all <fr:tex>d \in  D</fr:tex>,
    such that everything in sight commutes.
</fr:p></fr:mainmatter></fr:tree></fr:context><fr:related><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>1245</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003E</fr:addr><fr:route>def-003E.xml</fr:route><fr:title>Category</fr:title></fr:frontmatter><fr:mainmatter>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>359</fr:anchor><fr:title><fr:strong>With one collection</fr:strong></fr:title><fr:parent>def-003E</fr:parent></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex>C</fr:tex> consists
    <fr:ul><fr:li>
            A collection of <fr:strong>objects</fr:strong> <fr:tex>C_0</fr:tex> (<fr:tex>\text {Ob} (C)</fr:tex>).
        </fr:li>
        <fr:li>
            A collection <fr:tex>C_1</fr:tex> (<fr:tex>\text {Mor} (C)</fr:tex>) of <fr:strong>morphisms</fr:strong> (arrows).
        </fr:li>
        <fr:li>
            For every morphism <fr:tex>f</fr:tex> there are an object <fr:tex>s(f)</fr:tex> (<fr:strong>source</fr:strong>, domain) and an object <fr:tex>t(f)</fr:tex> (<fr:strong>target</fr:strong>, codomain).
        </fr:li>
        <fr:li>
            For every pair of morphisms <fr:tex>f, g</fr:tex> such that <fr:tex>t(f) = s(g)</fr:tex>, there is a morphism <fr:tex>g  \circ  f</fr:tex> (<fr:strong>composition</fr:strong>) (Also written <fr:tex>gf</fr:tex> or <fr:tex>f;g</fr:tex>).
        </fr:li>
        <fr:li>
            For every object <fr:tex>x</fr:tex>, there is a morphism <fr:tex>\text {id} _x</fr:tex> (or <fr:tex>1_x</fr:tex>) called <fr:strong>identity</fr:strong>.
        </fr:li>
        <fr:li>
            The following properties hold:
            <fr:ul><fr:li><fr:tex>s(g  \circ  f) = s(f)</fr:tex> and <fr:tex>t(g  \circ  f) = t(g)</fr:tex>.
                </fr:li>
                <fr:li><fr:tex>s(1_x) = x</fr:tex> and <fr:tex>t(1_x) = x</fr:tex>.
                </fr:li>
                <fr:li>
                    Composition is <fr:strong>associative</fr:strong>: <fr:tex>h  \circ  (g  \circ  f) = (h  \circ  g)  \circ  f</fr:tex> when <fr:tex>t(f) = s(g)</fr:tex>, and <fr:tex>t(g) = s(h)</fr:tex>.
                </fr:li>
                <fr:li>
                    Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex>f  \circ   \text {id} _x = f</fr:tex> and <fr:tex>\text {id} _y  \circ  f = f</fr:tex></fr:li></fr:ul></fr:li></fr:ul>
    If the identity map and its axioms are omitted then one speaks of a <fr:strong>semicategory</fr:strong>.
</fr:mainmatter></fr:tree>

    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>360</fr:anchor><fr:title><fr:strong>With a family of collections of morphisms</fr:strong></fr:title><fr:parent>def-003E</fr:parent></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex>C</fr:tex> consists
    <fr:ul><fr:li>
            A collection of <fr:strong>objects</fr:strong> <fr:tex>C_0</fr:tex> (<fr:tex>\text {Ob} (C)</fr:tex>).
        </fr:li>
        <fr:li>
            For every pair of objects <fr:tex>x, y</fr:tex>, a collection <fr:tex>C_1(x, y)</fr:tex> (<fr:tex>\hom _C(x,y)</fr:tex>) of <fr:strong>morphisms</fr:strong> from <fr:tex>x</fr:tex> to <fr:tex>y</fr:tex>.
        </fr:li>
        <fr:li>
            For each pair of morphisms <fr:tex>f</fr:tex> in <fr:tex>C_1(x,y)</fr:tex> and <fr:tex>g</fr:tex> in <fr:tex>C_1(y,z)</fr:tex>, a morphism <fr:tex>g  \circ  f</fr:tex> in <fr:tex>C_1(x,z)</fr:tex>.
            called their <fr:strong>composition</fr:strong>.
        </fr:li>
        <fr:li>
            For each object <fr:tex>x</fr:tex>, a morphism <fr:tex>\text {id} _x</fr:tex> in <fr:tex>C_1(x,x)</fr:tex> called the <fr:strong>identity</fr:strong> on <fr:tex>x</fr:tex>.
        </fr:li>
        <fr:li>
            The following properties hold:
            <fr:ul><fr:li>Composition is <fr:strong>associative</fr:strong>: <fr:tex>h  \circ  (g  \circ  f) = (h  \circ  g)  \circ  f</fr:tex> for all <fr:tex>f</fr:tex> in <fr:tex>C_1(x,y)</fr:tex>, <fr:tex>g</fr:tex> in <fr:tex>C_1(y,z)</fr:tex>, and <fr:tex>h</fr:tex> in <fr:tex>C_1(z,w)</fr:tex>.</fr:li>
                <fr:li>Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex>f  \circ   \text {id} _x = f</fr:tex> and <fr:tex>\text {id} _y  \circ  f = f</fr:tex> for all <fr:tex>f</fr:tex> in <fr:tex>C_1(x,y)</fr:tex>.</fr:li></fr:ul></fr:li></fr:ul>
    Usually we write <fr:tex>\text {Mor} (C)</fr:tex> for the disjoint union <fr:tex>\bigsqcup _{x,y  \in  C_0} C_1(x,y)</fr:tex>.
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree></fr:related><fr:backlinks></fr:backlinks><fr:references></fr:references></fr:backmatter></fr:tree>