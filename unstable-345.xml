<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
  <fr:frontmatter>
    <fr:anchor>809</fr:anchor>
    <fr:addr type="machine">#345</fr:addr>
    <fr:route>unstable-345.xml</fr:route>
    <fr:title text="Algebraic Graphs › Introduction to Graphs"><fr:link type="local" href="cs-0008.xml" addr="cs-0008" title="Algebraic Graphs">Algebraic Graphs</fr:link> › Introduction to Graphs</fr:title>
    <fr:date>
      <fr:year>2024</fr:year>
      <fr:month>10</fr:month>
      <fr:day>3</fr:day>
    </fr:date>
    <fr:authors></fr:authors>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:p>Graphs are ubiquitous in computing. Roughly speaking, a graph is a collection of vertices and edges, where each edge connects two vertices.
        For the most trivial case, a graph is an ordered pair <fr:tex display="inline"> G=(V,E)</fr:tex> comprising:
        <fr:ul><fr:li><fr:tex display="inline"> V </fr:tex> is a set of vertices.</fr:li>
            <fr:li><fr:tex display="inline"> E \subseteq  \{ (x,y) \mid  x, y \in  V\} </fr:tex> is a set of edges.</fr:li></fr:ul>
        We can define a graph type in some programming languages (e.g. Haskell) as:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Graph a = Graph [a] [(a, a)]</html:code></fr:pre>

        Work with such low-level fiddling with sets of vertices and edges is very painful. And we can easily construct a graph that breaks the invariant of the graph structure like <fr:code>Graph [1] [(1,2)]</fr:code> which has an edge connecting a non-existent vertex.</fr:p>
    <fr:p>How the state-of-art libraries deal with this problem? 
        The <fr:strong>container</fr:strong> library in Haskell provides a type <fr:code>Data.Graph</fr:code> which represents graph using adjacency array:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">type Graph a = Array a [a]</html:code></fr:pre>

        which ensures performance and generality. But the consistency invariant is not <fr:strong>statically</fr:strong> checked, which may lead
        to runtime errors like <fr:code>index out of ranges</fr:code>. Another approach is the <fr:strong>fgl</fr:strong> (Martin Erwig&apos;s Functional Graph Library)
        where the graph is introduced as an <fr:strong>inductive type</fr:strong>. The approach is very complex and its API contains partial functions.
        So is there a <fr:strong>safe</fr:strong> graph construction interface we can build on top?</fr:p>
    <fr:p><fr:strong>Andrey Mokhov</fr:strong>&apos;s paper presents a new interface for constructing and transforming graphs in a safe and convenient manner.
        And abstract away from the actual representation details and characterize graphs by a set of axioms, just like numbers are algebraically characterized
        by rings. The core calculus is based on the algebra of parameterized graphs. Algebraic graphs have a safe and minimalistic core of four graph construction primitives, as captured by the following data type:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Graph a
    = Empty
    | Vertex a
    | Overlay (Graph a) (Graph a)
    | Connect (Graph a) (Graph a)</html:code></fr:pre></fr:p>
    <fr:p>The <fr:code>Empty</fr:code> and <fr:code>Vertex</fr:code> construct the empty and single-vertex graphs respectively. <fr:code>Overlay</fr:code> composes two graphs by taking the union of their vertices and edges, and <fr:code>Connect</fr:code> is similar to <fr:code>Overlay</fr:code> but also creates edges between vertices of the two graphs. 
        
        The overlay and connect operations have three properties:
        <fr:ul><fr:li>(Closure)  They are closed on the set of graphs (all total functions)</fr:li>
            <fr:li>(Complete) They can be used to construct any graph starting from the empty and single-vertex graphs</fr:li>
            <fr:li>(Sound) Malformed graphs are impossible to construct</fr:li></fr:ul></fr:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Context">Context</fr:title>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>810</fr:anchor>
            <fr:addr type="user">cs-0008</fr:addr>
            <fr:route>cs-0008.xml</fr:route>
            <fr:title text="Algebraic Graphs">Algebraic Graphs</fr:title>
            <fr:taxon>Graph Theory</fr:taxon>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>10</fr:month>
              <fr:day>3</fr:day>
            </fr:date>
            <fr:authors></fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>This post focus on the the algebra of graphs introduced in paper <fr:strong>Algebraic graphs with class (functional pearl)</fr:strong>,
    which built on rigorous mathematical foundation that allows us to apply equational reasoning for proving the correctness of graph transformation algorithms.</fr:p>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>631</fr:anchor>
                <fr:addr type="machine">#345</fr:addr>
                <fr:route>unstable-345.xml</fr:route>
                <fr:title text="Introduction to Graphs">Introduction to Graphs</fr:title>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>10</fr:month>
                  <fr:day>3</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Graphs are ubiquitous in computing. Roughly speaking, a graph is a collection of vertices and edges, where each edge connects two vertices.
        For the most trivial case, a graph is an ordered pair <fr:tex display="inline"> G=(V,E)</fr:tex> comprising:
        <fr:ul><fr:li><fr:tex display="inline"> V </fr:tex> is a set of vertices.</fr:li>
            <fr:li><fr:tex display="inline"> E \subseteq  \{ (x,y) \mid  x, y \in  V\} </fr:tex> is a set of edges.</fr:li></fr:ul>
        We can define a graph type in some programming languages (e.g. Haskell) as:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Graph a = Graph [a] [(a, a)]</html:code></fr:pre>

        Work with such low-level fiddling with sets of vertices and edges is very painful. And we can easily construct a graph that breaks the invariant of the graph structure like <fr:code>Graph [1] [(1,2)]</fr:code> which has an edge connecting a non-existent vertex.</fr:p>
                <fr:p>How the state-of-art libraries deal with this problem? 
        The <fr:strong>container</fr:strong> library in Haskell provides a type <fr:code>Data.Graph</fr:code> which represents graph using adjacency array:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">type Graph a = Array a [a]</html:code></fr:pre>

        which ensures performance and generality. But the consistency invariant is not <fr:strong>statically</fr:strong> checked, which may lead
        to runtime errors like <fr:code>index out of ranges</fr:code>. Another approach is the <fr:strong>fgl</fr:strong> (Martin Erwig&apos;s Functional Graph Library)
        where the graph is introduced as an <fr:strong>inductive type</fr:strong>. The approach is very complex and its API contains partial functions.
        So is there a <fr:strong>safe</fr:strong> graph construction interface we can build on top?</fr:p>
                <fr:p><fr:strong>Andrey Mokhov</fr:strong>&apos;s paper presents a new interface for constructing and transforming graphs in a safe and convenient manner.
        And abstract away from the actual representation details and characterize graphs by a set of axioms, just like numbers are algebraically characterized
        by rings. The core calculus is based on the algebra of parameterized graphs. Algebraic graphs have a safe and minimalistic core of four graph construction primitives, as captured by the following data type:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Graph a
    = Empty
    | Vertex a
    | Overlay (Graph a) (Graph a)
    | Connect (Graph a) (Graph a)</html:code></fr:pre></fr:p>
                <fr:p>The <fr:code>Empty</fr:code> and <fr:code>Vertex</fr:code> construct the empty and single-vertex graphs respectively. <fr:code>Overlay</fr:code> composes two graphs by taking the union of their vertices and edges, and <fr:code>Connect</fr:code> is similar to <fr:code>Overlay</fr:code> but also creates edges between vertices of the two graphs. 
        
        The overlay and connect operations have three properties:
        <fr:ul><fr:li>(Closure)  They are closed on the set of graphs (all total functions)</fr:li>
            <fr:li>(Complete) They can be used to construct any graph starting from the empty and single-vertex graphs</fr:li>
            <fr:li>(Sound) Malformed graphs are impossible to construct</fr:li></fr:ul></fr:p>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>632</fr:anchor>
                <fr:addr type="machine">#346</fr:addr>
                <fr:route>unstable-346.xml</fr:route>
                <fr:title text="Core of Algebraic Graphs">Core of Algebraic Graphs</fr:title>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>10</fr:month>
                  <fr:day>3</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>633</fr:anchor>
                    <fr:addr type="machine">#347</fr:addr>
                    <fr:route>unstable-347.xml</fr:route>
                    <fr:title text="Graph Construction">Graph Construction</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>3</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The simplest possible graph is the empty graph. We denote it by <fr:tex display="inline"> \epsilon  = (\varnothing , \varnothing ) </fr:tex>.
            A graph with a single vertex is <fr:tex display="inline"> \text {Vertex} x = (\{x\}, \varnothing ) </fr:tex>.
            To construct larger graphs from the above primitives we define binary operations overlay and connect, denoted by <fr:tex display="inline"> + </fr:tex> and <fr:tex display="inline"> \to  </fr:tex> respectively.
            The overlay operation <fr:tex display="inline"> + </fr:tex> is defined as:
            <fr:tex display="block">                 (V_1, E_1) + (V_2, E_2) = (V_1 \cup  V_2, E_1 \cup  E_2)             </fr:tex>
            The connect operation <fr:tex display="inline"> \to  </fr:tex> is defined similarly (We give it a higher precedence than <fr:tex display="inline"> + </fr:tex>):
            <fr:tex display="block">                 (V_1, E_1) \to  (V_2, E_2) = (V_1 \cup  V_2, E_1 \cup  E_2 \cup  V_1 \times  V_2)             </fr:tex></fr:p>
                    <fr:p>As shown above, the core can be represented by a simple data type <fr:code>Graph</fr:code>, parameterized by the type of vertices <fr:code>a</fr:code>.
            We can push this further by defining a type class <fr:code>GraphLike</fr:code> that captures the core operations of the algebraic graph.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>634</fr:anchor>
                    <fr:addr type="machine">#348</fr:addr>
                    <fr:route>unstable-348.xml</fr:route>
                    <fr:title text="Type Class">Type Class</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>3</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>We abstract the graph construction primitives defined above as the type class Graph (Note that associated types requires <fr:code>TypeFamilies</fr:code> GHC extension):
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">class Graph g where
    type Vertex g
    empty :: g
    vertex :: Vertex g -&gt; g
    overlay :: g -&gt; g -&gt; g
    connect :: g -&gt; g -&gt; g</html:code></fr:pre></fr:p>
                    <fr:p>This interface is very simple and easy to use, which allows fewer opportunities for usage errors and greater opportunities for reuse.
            Now let&apos;s create some functions to construct graphs. For instance, a single edge is obtained by connecting two vertices:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">edge :: (Graph g) =&gt; Vertex g -&gt; Vertex g -&gt; g
edge x y = connect (vertex x) (vertex y)</html:code></fr:pre></fr:p>
                    <fr:p>A graph that contains a given list of isolated vertices can be constructed as follows:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">vertices :: Graph g =&gt; [Vertex g] -&gt; g
vertices = foldr (overlay . vertex) empty</html:code></fr:pre>

            which turns each vertex into a singleton graph and overlay the results. By replacing the 
            <fr:code>overlay</fr:code> with <fr:code>connect</fr:code> we can construct a full connected graph.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">clique :: (Graph g) =&gt; [Vertex g] -&gt; g
clique = foldr (connect . vertex) empty</html:code></fr:pre></fr:p>
                    <fr:p>The graph construction functions defined above are total, fully polymorphic, and elegant. 
            Thanks to the minimalistic core type class, it is easy to wrap our favourite graph library into the described interface, 
            and reuse the functions defined with graph class.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>635</fr:anchor>
                <fr:addr type="machine">#349</fr:addr>
                <fr:route>unstable-349.xml</fr:route>
                <fr:title text="Algebraic Structure">Algebraic Structure</fr:title>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>10</fr:month>
                  <fr:day>3</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>In this section we characterise the <fr:code>Graph</fr:code> type class with a set of axioms that reveal an algebraic structure very similar to a semiring. This provides a convenient framework for proving graph properties, using equational reasoning. The presented characterization is generally useful for formal verification, as well as automated testing of graph library APIs.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>636</fr:anchor>
                    <fr:addr type="machine">#350</fr:addr>
                    <fr:route>unstable-350.xml</fr:route>
                    <fr:title text="Axioms">Axioms</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>3</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Notice that the <fr:code>clique</fr:code> and <fr:code>vertices</fr:code> functions use <fr:tex display="inline">\epsilon </fr:tex> as the identity element for the overlay and connect operation respectively.
            Further more we can verify:
            <fr:ul><fr:li><fr:tex display="inline">(G,+,\epsilon )</fr:tex> is an idempotent commutative monoid.</fr:li>
                <fr:li><fr:tex display="inline">(G,\to ,\epsilon )</fr:tex> is a monoid.</fr:li>
                <fr:li><fr:tex display="inline">\to </fr:tex> distributes over <fr:tex display="inline">+</fr:tex>.</fr:li></fr:ul>
            This looks like a semiring, but the identity element are shared between the two operations. 
            What makes the algebra of graphs different is the <fr:strong>decomposition law</fr:strong>:
            <fr:tex display="block">                 x \to  y \to  z = x \to  y + x \to  z + y \to  z             </fr:tex>
            Interestingly, the fact that overlay and connect share the same identity follows from the decomposition law.
            Furthermore, the identity (<fr:tex display="inline">x + \epsilon  = x</fr:tex>) and idempotence (<fr:tex display="inline">x + x = x</fr:tex>) can also be proved from the decomposition law.
            Hence we get a minimal set (8) of axioms that characterize the algebraic graphs.
            <fr:ul><fr:li><fr:tex display="inline">+</fr:tex> is commutative and associative: <fr:tex display="inline">x + y = y + x</fr:tex> and <fr:tex display="inline">(x + y) + z = x + (y + z)</fr:tex></fr:li>
                <fr:li><fr:tex display="inline">(G,\to ,\epsilon )</fr:tex> is a monoid, i.e. <fr:tex display="inline">x \to  y \to  z = x \to  (y \to  z)</fr:tex> and <fr:tex display="inline">\epsilon  \to  x = x, x \to  \epsilon  = x</fr:tex></fr:li>
                <fr:li><fr:tex display="inline">\to </fr:tex> distributes over <fr:tex display="inline">+</fr:tex>: <fr:tex display="inline">(x + y) \to  z = x \to  z + y \to  z</fr:tex></fr:li>
                <fr:li>Decomposition law: <fr:tex display="inline">x \to  y \to  z = x \to  y + x \to  z + y \to  z</fr:tex></fr:li></fr:ul>
            By adding more axioms we can obtain more complex graphs such as directed graphs, hypergraphs, etc.</fr:p>
                    <fr:p>Algebraic graphs are <fr:strong>complete</fr:strong> in the sense that it is possible to describe any graph using the core interface. Indeed, given a graph <fr:tex display="inline">G=(V , E)</fr:tex> we can construct it as <fr:code>graph V E</fr:code>, where the function <fr:code>graph</fr:code> is defined as follows.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">graph :: (Graph g) =&gt; [Vertex g] -&gt; [(Vertex g, Vertex g)] -&gt; g
graph vs es = overlay (vertices vs) (edges es)</html:code></fr:pre>

            where <fr:code>edges</fr:code> is defined as:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">edges :: (Graph g) =&gt; [(Vertex g, Vertex g)] -&gt; g
edges = foldr (overlay . uncurry edge) empty</html:code></fr:pre>

            The absorption theorem <fr:tex display="inline">x \to  y + x + y = x \to  y</fr:tex>, derived from decomposition of <fr:tex display="inline">x \to  y \to  \epsilon </fr:tex>, states that an edge <fr:tex display="inline">(u, v)</fr:tex> 
            contains its two vertices <fr:tex display="inline">u, v</fr:tex> and is inseparable from them. Therefore, if the pair <fr:tex display="inline">(V , E)</fr:tex> is inconsistent, the set of vertices <fr:tex display="inline">V</fr:tex> 
            will be expanded to <fr:tex display="inline">\hat {V}</fr:tex> so that <fr:tex display="inline">E\subseteq  \hat {V} \times  \hat {V}</fr:tex> holds. More generally, the absorption theorem states that in 
            addition to being complete, the algebraic graph API is also sound in the sense that it is impossible to construct an inconsistent pair
            <fr:tex display="inline">(V , E)</fr:tex> using the four Graph methods.</fr:p>
                    <fr:p>There are many other interesting properties of algebraic graphs can be proved using the axioms:
            <fr:ul><fr:li>(Overlay Identity) <fr:tex display="inline">x + \epsilon  = x</fr:tex></fr:li>
                <fr:li>(Overlay Idempotence) <fr:tex display="inline">x + x = x</fr:tex></fr:li>
                <fr:li>(Absorption) <fr:tex display="inline">x \to  y + x + y = x \to  y</fr:tex></fr:li>
                <fr:li>(Saturation) <fr:tex display="inline">x \to  x \to  x = x \to  x</fr:tex></fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>637</fr:anchor>
                    <fr:addr type="machine">#351</fr:addr>
                    <fr:route>unstable-351.xml</fr:route>
                    <fr:title text="Partial Order">Partial Order</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>3</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>It is fairly standard to define <fr:tex display="inline">x \leq  y</fr:tex> as <fr:tex display="inline">x + y = y</fr:tex> for an idempotent operation <fr:tex display="inline">+</fr:tex>, since it gives a <fr:link type="local" href="def-000Y.xml" addr="def-000Y" title="Partial Order">partial order</fr:link> on the elements of the algebra. Formally we call this definition the <fr:strong>subgraph</fr:strong> relation. Therefore, we can check if a graph is a subgraph of another one if we know how to compare graphs for equality.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">isSubgraphOf :: (Graph g, Eq g) =&gt; g -&gt; g -&gt; Bool
isSubgraphOf x y = overlay x y == y</html:code></fr:pre></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>638</fr:anchor>
                <fr:addr type="machine">#352</fr:addr>
                <fr:route>unstable-352.xml</fr:route>
                <fr:title text="Graphs à la Carte">Graphs à la Carte</fr:title>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>10</fr:month>
                  <fr:day>3</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Now we define some instances of the Grpah, and extend the axioms to construct more complex graphs.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>639</fr:anchor>
                    <fr:addr type="machine">#353</fr:addr>
                    <fr:route>unstable-353.xml</fr:route>
                    <fr:title text="Binary Relation">Binary Relation</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>3</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>We start by a direct encoding of the graph construction primitives defined into the abstract data type <fr:code>Relation</fr:code> isomorphic to a pair of sets <fr:tex display="inline">(V , E)</fr:tex>: 
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Relation a = R {domain :: Set a, relation :: Set (a, a)} deriving (Eq)

instance (Ord a) =&gt; Graph (Relation a) where
    type Vertex (Relation a) = a
    empty = R Set.empty Set.empty
    vertex x = R (singleton x) Set.empty
    overlay x y = R (domain x `union` domain y) (relation x `union` relation y)
    connect x y =
        R (domain x `union` domain y)
        ( relation x
            `union` relation y
            `union` fromAscList [(a, b) | a &lt;- elems (domain x), b &lt;- elems (domain y)]
        )</html:code></fr:pre>

            As we have seen, this implementation satisfies the axioms of the graph algebra. Furthermore, it is a free graph in the sense that it does not satisfy any other laws. This follows from the fact that any algebraic graph expression <fr:tex display="inline">g</fr:tex> can be rewritten in the following canonical form:
            <fr:tex display="block">                 g = \left ( \sum _{v\in  V_g} v \right ) + \left ( \sum _{(u,v)\in  E_g} u \to  v \right )             </fr:tex>
            The existence of the canonical form was proved by <fr:strong>Mokhov</fr:strong> in <fr:em>Algebra of Parameterised Graphs</fr:em> for an extended version of the algebra.
            The core idea is to repeatedly apply the decomposition law to rewrite the graph expression in the form of the above equation,
            until no further decomposition is possible.</fr:p>
                    <fr:p>It will be convenient to make <fr:code>Relation</fr:code> an instance of <fr:code>Num</fr:code> type class.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">instance (Ord a, Num a) =&gt; Num (Relation a) where
    fromInteger = vertex . fromInteger
    (+) = overlay
    (*) = connect
    signum = const empty
    abs = id
    negate = id</html:code></fr:pre>

            With these setups we can use the standard <fr:tex display="inline">+</fr:tex> and <fr:tex display="inline">\times </fr:tex> operators as shortcuts for overlay and connect respectively.
            Note that the Num law <fr:code>abs x * signum x == x</fr:code> is satisfied by the above definition since <fr:tex display="inline">x \to  \epsilon  = x</fr:tex>.
            Any Graph instance can be made an instance of <fr:code>Num</fr:code> if needed.</fr:p>
                    <fr:p>Now let&apos;s try to construct some graphs using the <fr:code>Relation</fr:code> type and the <fr:code>Num</fr:code> instance:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">ghci&gt; 1 * (2 + 3) :: Relation Int
R {domain = fromList [1,2,3], relation = fromList [(1,2),(1,3)]}
ghci&gt; 1 * 2 * 3 :: Relation Int
R {domain = fromList [1,2,3], relation = fromList [(1,2),(1,3),(2,3)]}</html:code></fr:pre></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
          </fr:mainmatter>
          <fr:backmatter></fr:backmatter>
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
  </fr:backmatter>
</fr:tree>