<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
  <fr:frontmatter>
    <fr:anchor>1014</fr:anchor>
    <fr:addr type="user">tt-0003</fr:addr>
    <fr:route>tt-0003.xml</fr:route>
    <fr:title text="Natural Numbers {N}">Natural Numbers <fr:tex display="inline">\mathbb {N}</fr:tex></fr:title>
    <fr:taxon>Type Theory</fr:taxon>
    <fr:date>
      <fr:year>2024</fr:year>
      <fr:month>1</fr:month>
      <fr:day>30</fr:day>
    </fr:date>
    <fr:authors></fr:authors>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:p>In previous post, we have seen the basic inference rules of type theory.
    Now we will see the definition of natural numbers as an inductive type.
    Refer to <fr:link type="local" href="hott-book-2013.xml" addr="hott-book-2013" title="Homotopy Type Theory: Univalent Foundations of Mathematics">HoTT Book</fr:link> and <fr:link type="local" href="hott-2022.xml" addr="hott-2022" title="Introduction to Homotopy Type Theory">Egbert Rijke&apos;s</fr:link>.</fr:p>
    <fr:p>In classical mathematics, the <fr:strong>Peano axioms</fr:strong> are a set of axioms for the natural numbers,
    an important object in mathematics.</fr:p>
    <fr:p>In type theory, the type <fr:tex display="inline">\mathbb {N}</fr:tex> of natural number is an <fr:link type="local" href="def-001X.xml" addr="def-001X" title="Inductive Type"><fr:strong>inductive type</fr:strong></fr:link>.
    Just like in dependent function type, we need four inference rules to define the natural numbers.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>726</fr:anchor>
        <fr:addr type="user">def-001Y</fr:addr>
        <fr:route>def-001Y.xml</fr:route>
        <fr:title text="Natural Number">Natural Number</fr:title>
        <fr:taxon>Definition</fr:taxon>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:p>In type theory, <fr:strong>natural number</fr:strong> is defined using <fr:strong>peano encoding</fr:strong>.
    The type <fr:tex display="inline">\mathbb {N}</fr:tex> is formed by the formation rule:
    <fr:tex display="block">         \frac {}{\vdash \mathbb {N}\space \text {type}}\mathbb {N}\text {-form}     </fr:tex></fr:p>
        <fr:p>Peano&apos;s first axiom postulates the existence of a natural number <fr:tex display="inline">0</fr:tex>.
    The introduction rule for <fr:tex display="inline">\mathbb {N}</fr:tex> has a <fr:tex display="inline">0</fr:tex> constructor and a <fr:strong>successor</fr:strong> function.
    <fr:tex display="block">         \frac {}{\vdash 0:\mathbb {N}}\mathbb {N}\text {-intro-0}         \quad          \frac {}{\vdash \text {succ}:\mathbb {N}\to \mathbb {N}} \mathbb {N}\text {-intro-succ}     </fr:tex></fr:p>
        <fr:p>The <fr:strong>elimination rule</fr:strong> is actually the type theoretical <fr:strong>induction principle</fr:strong> of <fr:tex display="inline">\mathbb {N}</fr:tex>:
    In order to show that <fr:tex display="inline">\forall  n:\mathbb {N}.P(n)</fr:tex> holds, it suffices to show that <fr:tex display="inline">P(0)</fr:tex> holds and that <fr:tex display="inline">\forall  n:\mathbb {N}.P(n)\to  P(\text {succ}(n))</fr:tex> holds.
    The type theoretical induction principle is therefore formulated using a type family <fr:tex display="inline">P</fr:tex> over <fr:tex display="inline">\mathbb {N}</fr:tex>:
    <fr:tex display="block">         \frac {             \begin {align*}                 \Gamma &amp;,\,n:\mathbb {N}\vdash  P(n)\space \text {type}                 \\                 \Gamma &amp;\vdash  p_0:P(0)                 \\                 \Gamma &amp;\vdash  p_S:\Pi _{(n:\mathbb {N})}P(n)\to  P(\text {succ}(n))             \end {align*}         }{             \Gamma \vdash \text {ind}_\mathbb {N}(p_0,p_S):\Pi _{(n:\mathbb {N})}P(n)         }(\mathbb {N} \text {-ind})     </fr:tex>
    The induction principle tells us what we need to do in order to construct a dependent function <fr:tex display="inline">\text {ind}_\mathbb {N}</fr:tex> of type <fr:tex display="inline">\Pi _{(n:\mathbb {N})}P(n)</fr:tex>.
    We might alternatively write the induction principle as:
    <fr:tex display="block">         \frac {             \Gamma ,n:\mathbb {N}\vdash  P(n)\space \text {type}         }{             \Gamma \vdash \text {ind}_\mathbb {N}:\left (P(0)\to \left (\Pi _{(n:\mathbb {N})}P(n)\to  P(\text {succ}(n))\right )\to \Pi _{(n:\mathbb {N})}P(n)\right )         }(\mathbb {N} \text {-ind})     </fr:tex></fr:p>
        <fr:p>The <fr:strong>computation rule</fr:strong> asserts that the dependent function <fr:tex display="inline">\text {ind}_\mathbb {N}</fr:tex> behaves as expected:
    <fr:tex display="block">         \frac {             \begin {align*}                 \Gamma &amp;,n:\mathbb {N}\vdash  P(n)\space \text {type}                 \\                 \Gamma &amp;\vdash  p_0:P(0)                 \\                 \Gamma &amp;\vdash  p_S:\Pi _{(n:\mathbb {N})}P(n)\to  P(\text {succ}(n))             \end {align*}         }{             \text {ind}_\mathbb {N}(p_0,p_S,m)\equiv              \begin {cases}                 p_0&amp;\text {if }m=0                 \\                 p_S(n,\text {ind}_\mathbb {N}(p_0,p_S,n))&amp;\text {if }m=\text {succ}(n)             \end {cases}         }(\mathbb {N} \text {-comp})     </fr:tex></fr:p>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
    <fr:p>Now let&apos;s use the type theoretical induction principle of <fr:tex display="inline">\mathbb {N}</fr:tex> to
    perform some basic construction over <fr:tex display="inline">\mathbb {N}</fr:tex>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>727</fr:anchor>
        <fr:addr type="user">def-001Z</fr:addr>
        <fr:route>def-001Z.xml</fr:route>
        <fr:title text="Addition over {N}">Addition over <fr:tex display="inline">\mathbb {N}</fr:tex></fr:title>
        <fr:taxon>Definition</fr:taxon>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter><fr:p>We define addition over <fr:tex display="inline">\mathbb {N}</fr:tex> using the type theoretical induction principle of <fr:tex display="inline">\mathbb {N}</fr:tex>.
    <fr:tex display="block">         \text {add}_\mathbb {N} : \mathbb {N} \to  (\mathbb {N} \to  \mathbb {N})     </fr:tex>
    which satisfies the following specification:
    <fr:tex display="block">         \begin {align*}             \text {add}_\mathbb {N}(n, 0)&amp;:\equiv  n             \\             \text {add}_\mathbb {N}(m,\text {succ}(n))&amp;:\equiv \text {succ}(\text {add}_\mathbb {N}(m,n))         \end {align*}     </fr:tex>
    abbreviated as <fr:tex display="inline">m + n</fr:tex> for <fr:tex display="inline">\text {add}_\mathbb {N}(m,n)</fr:tex>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>728</fr:anchor><fr:addr type="machine">#341</fr:addr><fr:route>unstable-341.xml</fr:route><fr:title text="Construction"><fr:strong>Construction</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    
        <fr:p>We construct the additon by perform induction over the second variable <fr:tex display="inline">n</fr:tex>.
            That is, to construct an element
            <fr:tex display="block">                 m:\mathbb {N} \vdash  \text {add}_\mathbb {N}(m):\mathbb {N} \to  \mathbb {N}             </fr:tex>
            The context <fr:tex display="inline">\Gamma  \equiv  m:\mathbb {N}</fr:tex> is fixed.</fr:p>
        Therefore we need to construct:
        <fr:tex display="block">             \begin {align*}                 \Gamma &amp;\vdash  \text {add-zero}_\mathbb {N}(m):\mathbb {N}                 \\                 \Gamma &amp;\vdash  \text {add-succ}_\mathbb {N}(m):\mathbb {N}\to \mathbb {N}                             \end {align*}            </fr:tex>
        The <fr:tex display="inline">\text {add-zero}_\mathbb {N}</fr:tex> is defined to be identity function trivially. To see how <fr:tex display="inline">\text {add-succ}_\mathbb {N}</fr:tex> is defined, we need to perform induction:
        <fr:tex display="block">             \begin {align*}                 \text {add}_\mathbb {N}(m, \text {succ}(n))&amp;\equiv                  \text {ind}_\mathbb {N}(\text {add-zero}_\mathbb {N}(m), \text {add-succ}_\mathbb {N}(m), \text {succ}(n))                 \\                 &amp;\equiv  \text {add-succ}_\mathbb {N}(m,n, \text {add}_\mathbb {N}(m,n))                 \\                 &amp;\equiv  \text {succ}(\text {add}_\mathbb {N}(m,n))             \end {align*}         </fr:tex>
        Hence <fr:tex display="inline">\text {add-succ}_\mathbb {N}</fr:tex> is defined as:
        <fr:tex display="block">             \text {add-succ}_\mathbb {N}(m,n,x) \equiv  \text {succ}(x)         </fr:tex>
        A formal construction of <fr:tex display="inline">\text {add-succ}_\mathbb {N}</fr:tex> is as follows:
        <fr:tex display="block">             \dfrac {                 \dfrac {                     \dfrac {                         \dfrac {}{\vdash \mathbb {N}\space \text {type}}                         \quad                          \dfrac {                             \dfrac {}{\vdash  \mathbb {N}\space \text {type}}                             \quad                              \dfrac {}{\vdash  \text {succ}:\mathbb {N}\to \mathbb {N}}                         }{                             n:\mathbb {N}\vdash \text {succ}:\mathbb {N}\to \mathbb {N}                         }                     }{                         m:\mathbb {N}, n:\mathbb {N}\vdash  \text {succ}:\mathbb {N}\to \mathbb {N}                     }                  }{                     m:\mathbb {N}\vdash \lambda  n.\text {succ} : \mathbb {N}\to (\mathbb {N}\to \mathbb {N})                 }             }{                 m:\mathbb {N}\vdash  \text {add-succ}_\mathbb {N}(m):\equiv \lambda  m.\text {succ} : \mathbb {N}\to (\mathbb {N}\to \mathbb {N})             }\text {Block-1}         </fr:tex>
        Finally we combine the derivation together:
        <fr:tex display="block">             \dfrac {                 \dfrac {                     \dfrac {                         \dfrac {                             \vdash  \mathbb {N}\space \text {type}                         }{                             m:\mathbb {N}\vdash  m:\mathbb {N}                         }                     }{                         m:\mathbb {N}\vdash \text {add-zero}_\mathbb {N}(m):\equiv  m:\mathbb {N}                     }                     \quad                       \dfrac {\text {Block-1}}{                         m:\mathbb {N}\vdash \text {add-succ}_\mathbb {N}(m):\mathbb {N}\to (\mathbb {N}\to \mathbb {N})                     }                 }{                     m:\mathbb {N}\vdash \text {ind}_\mathbb {N} (\text {add-zero}_\mathbb {N}(m), \text {add-succ}_\mathbb {N}(m)):\mathbb {N}\to \mathbb {N}                 }             }{                 m:\mathbb {N}\vdash \text {add}_\mathbb {N}(m):\equiv \text {ind}_\mathbb {N} (\text {add-zero}_\mathbb {N}(m), \text {add-succ}_\mathbb {N}(m)):\mathbb {N}\to \mathbb {N}             }         </fr:tex>
    
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
    <fr:p>Recall the definition of addition function <fr:tex display="inline">\text {add}: \mathbb {N}\to (\mathbb {N}\to \mathbb {N})</fr:tex> satisfying the specification:
    <fr:tex display="block">         \begin {align*}             m + 0 &amp; :\equiv  m             \\              m + \text {succ}(n) &amp; :\equiv  \text {succ}(m + n)         \end {align*}     </fr:tex>
    Such definition is enough to characterize the addition function.
    Because it postulates te <fr:em>behavior</fr:em> of <fr:tex display="inline">\text {add}_\mathbb {N}</fr:tex> at the constructor of <fr:tex display="inline">\mathbb {N}</fr:tex></fr:p>
    <fr:p>More generally, we can define a dependent function <fr:tex display="inline">f:\Pi  n:\mathbb {N}.P(n)</fr:tex> by induction on <fr:tex display="inline">n</fr:tex> using
    <fr:tex display="block">         \begin {align*}             p_0 &amp; : P(0)             \\             p_S &amp; : \Pi _{(n:\mathbb {N})}P(n)\to  P(\text {succ}(n))         \end {align*}     </fr:tex>
    Just present the definition by writing
    <fr:tex display="block">         \begin {align*}             f(0) &amp; :\equiv  p_0             \\             f(\text {succ}(n)) &amp; :\equiv  p_S(n,f(n))         \end {align*}     </fr:tex>
    <fr:tex display="inline">f</fr:tex> is said to be defined by <fr:strong>pattern matching</fr:strong> on the variable <fr:tex display="inline">n</fr:tex>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>729</fr:anchor>
        <fr:addr type="user">eg-0001</fr:addr>
        <fr:route>eg-0001.xml</fr:route>
        <fr:title text="Fibonacci Function">Fibonacci Function</fr:title>
        <fr:taxon>Example</fr:taxon>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:p>The <fr:strong>Fibonacci function</fr:strong> is a well-known function in mathematics.
    It is defined by pattern matching on the variable <fr:tex display="inline">n</fr:tex> as follows:
    <fr:tex display="block">         \begin {align*}             \text {fib}(0) &amp; :\equiv  0             \\             \text {fib}(1) &amp; :\equiv  1             \\             \text {fib}(n+2) &amp; :\equiv  \text {fib}(n) + \text {fib}(n+1)         \end {align*}     </fr:tex></fr:p>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="References">References</fr:title>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>1015</fr:anchor>
            <fr:addr type="user">hott-book-2013</fr:addr>
            <fr:route>hott-book-2013.xml</fr:route>
            <fr:title text="Homotopy Type Theory: Univalent Foundations of Mathematics">Homotopy Type Theory: Univalent Foundations of Mathematics</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:authors>
              <fr:author>The Univalent Foundations Program</fr:author>
            </fr:authors>
            <fr:meta name="venue">Mathematics</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter></fr:mainmatter>
          <fr:backmatter></fr:backmatter>
        </fr:tree>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>1017</fr:anchor>
            <fr:addr type="user">hott-2022</fr:addr>
            <fr:route>hott-2022.xml</fr:route>
            <fr:title text="Introduction to Homotopy Type Theory">Introduction to Homotopy Type Theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:authors>
              <fr:author>Egbert Rijke</fr:author>
            </fr:authors>
            <fr:meta name="doi">10.48550/arXiv.2212.11082</fr:meta>
            <fr:meta name="venue">Logic, Category Theory</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>This is an introductory textbook to univalent mathematics and homotopy type theory, a mathematical foundation that takes advantage of the structural nature of mathematical definitions and constructions.</fr:p>
          </fr:mainmatter>
          <fr:backmatter></fr:backmatter>
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Context">Context</fr:title>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>1019</fr:anchor>
            <fr:addr type="user">posts</fr:addr>
            <fr:route>posts.xml</fr:route>
            <fr:title text="Blog posts">Blog posts</fr:title>
            <fr:authors></fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>711</fr:anchor>
                <fr:addr type="user">tt-0002</fr:addr>
                <fr:route>tt-0002.xml</fr:route>
                <fr:title text="Introduction to Type Theory">Introduction to Type Theory</fr:title>
                <fr:taxon>Type Theory</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>27</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter><fr:p>This is a note on dependent type theory. Refer to <fr:link type="local" href="hott-book-2013.xml" addr="hott-book-2013" title="Homotopy Type Theory: Univalent Foundations of Mathematics">HoTT Book</fr:link> and <fr:link type="local" href="hott-2022.xml" addr="hott-2022" title="Introduction to Homotopy Type Theory">Egbert Rijke&apos;s</fr:link>.</fr:p><fr:p><fr:strong>Homotopy type theory</fr:strong> is a foundational language for mathematics, an alternative to Zermelo-Fraenkel set theory.
    The set-theoretic foundation has two two layers:
    <fr:ul><fr:li>the deductive system of first-order logic</fr:li>
        <fr:li>the theory of a particular theory, such as ZFC</fr:li></fr:ul> 
    Type theory itself is a deductive system, which has one basic notation: <fr:em>types</fr:em>.
    Propositions are identified with types.
    
    Thus, the activity of proving a theorem is identified with 
    constructing a <fr:em>inhabitant</fr:em> of a certain type.</fr:p><fr:p>Informally, a deductive system is a collection of rules for deriving <fr:strong>judgments</fr:strong>. 
    The judgment is considered to be the external of the theory, living in the <fr:strong>metatheory</fr:strong>.</fr:p><fr:p>In first order logic, there is only one kind of judgment: a proposition has a proof.
    A proposition <fr:tex display="inline">P</fr:tex> gives rise to a judgment &quot;<fr:tex display="inline">P</fr:tex> has a proof&quot;.
    The proposition <fr:tex display="inline">P</fr:tex> lives inside the theory, while the judgment &quot;<fr:tex display="inline">P</fr:tex> has a proof&quot; lives in the metatheory.</fr:p><fr:p>In type theory, analogous to first order logic,
    &quot;<fr:tex display="inline">P</fr:tex> has a proof&quot; is written as &quot;<fr:tex display="inline">p:P</fr:tex>&quot; (Type <fr:tex display="inline">P</fr:tex> has a term <fr:tex display="inline">p</fr:tex>).
    <fr:ul><fr:li>If <fr:tex display="inline">P</fr:tex> is a proposition, then <fr:tex display="inline">p</fr:tex> is a <fr:strong>witness</fr:strong> to the provability of <fr:tex display="inline">P</fr:tex>, 
        or <fr:strong>evidence</fr:strong> of the truth of <fr:tex display="inline">P</fr:tex>.</fr:li>
        <fr:li><fr:tex display="inline">p:P</fr:tex> can also be interpreted as <fr:tex display="inline">p\in  P</fr:tex>,
        but <fr:tex display="inline">p:P</fr:tex> is a judgment while <fr:tex display="inline">p\in  P</fr:tex> is a proposition.</fr:li></fr:ul>
    Working inside type theory we can&apos;t write down statements like
    &quot;if <fr:tex display="inline">p:P</fr:tex> then ...&quot; nor can we disprove the judgment &quot;<fr:tex display="inline">p:P</fr:tex>&quot;.</fr:p><fr:p>A key difference between type theory and set theory is the equality.
    The notion of equality in set theory is simply a proposition.
    Howerver, in type theory, there are two kinds of equality.
    <fr:ul><fr:li>The first kind is the <fr:strong>propositional equality</fr:strong> <fr:tex display="inline">a=_Ab</fr:tex>.
        This is a proposition</fr:li>
        <fr:li>The second kind is the <fr:strong>judgmental equality</fr:strong> <fr:tex display="inline">a\equiv  b:A</fr:tex>.
        This is a judgment</fr:li></fr:ul>
    Two terms <fr:tex display="inline">a:A</fr:tex> and <fr:tex display="inline">b:A</fr:tex> are propositionally equal if you can prove <fr:tex display="inline">a =_A b</fr:tex> , 
    or equivalently if you can construct a term <fr:tex display="inline">h : a =_A b</fr:tex>.</fr:p>
    <fr:p>In type theory there is also a requirement for a judgment-level equality.
        This is called <fr:strong>judgmental equality</fr:strong>, meaning &quot;equal by definition&quot;.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>712</fr:anchor><fr:addr type="user">def-0015</fr:addr><fr:route>def-0015.xml</fr:route><fr:title text="Judgemental Equality">Judgemental Equality</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Judgemental equality</fr:strong> of terms is given by the following judgement:
    <fr:tex display="block">         \Gamma \vdash  a\equiv  a&apos;:A     </fr:tex>
    <fr:tex display="inline">a</fr:tex> and <fr:tex display="inline">a&apos;</fr:tex> are judgementally equal terms of type <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>.</fr:p><fr:p>Note that the notation <fr:tex display="inline">\equiv </fr:tex> binds more loosely than anything else.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
    <fr:p>judgments may depend on <fr:em>assumptions</fr:em> of the form <fr:tex display="inline">x:A</fr:tex> where <fr:tex display="inline">x</fr:tex> is a
        variable and <fr:tex display="inline">A</fr:tex> is a type. And the collection (actually ordered list) of such assumptions is called 
        the <fr:strong>context</fr:strong>, denoted <fr:tex display="inline">\Gamma </fr:tex>. (from a topological point of view it 
        may be thought of as a <fr:strong>parameters space</fr:strong>).
        The role of a context is to declare what <fr:strong>hypothetical terms</fr:strong> are assumed, 
        along with their types.
        The notation <fr:tex display="inline">\vdash </fr:tex> means making conclusion from assumptions.</fr:p>
<fr:p>Remember the difference between axiom and (inference) rules.
    <fr:ul><fr:li>Rules allow us to conclude one judgment from a collection of other judgments.</fr:li>
        <fr:li>Axioms are judgments that are assumed to be true without proof.</fr:li></fr:ul></fr:p><fr:p>We start by introduction to Matrin Lof&apos;s dependent type theory.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>713</fr:anchor><fr:addr type="user">def-0017</fr:addr><fr:route>def-0017.xml</fr:route><fr:title text="Dependent type theory: Judgments">Dependent type theory: Judgments</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>There are four kinds of judgments in Martin Lof&apos;s dependent type theory:</fr:p>
    <fr:ul><fr:li><fr:tex display="inline">A</fr:tex> is a well-formed type in context <fr:tex display="inline">\Gamma </fr:tex>
            <fr:tex display="block">                 \Gamma  \vdash  A \space \text {type}             </fr:tex></fr:li>
        <fr:li><fr:tex display="inline">A</fr:tex> and <fr:tex display="inline">B</fr:tex> are judgmentally equal types in context <fr:tex display="inline">\Gamma </fr:tex>
            <fr:tex display="block">                 \Gamma  \vdash  A \equiv  B \space \text {type}             </fr:tex></fr:li>
        <fr:li><fr:tex display="inline">a</fr:tex> is a term of type <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>
            <fr:tex display="block">                 \Gamma  \vdash  a : A             </fr:tex></fr:li>
        <fr:li><fr:tex display="inline">a</fr:tex> and <fr:tex display="inline">b</fr:tex> are judgmentally equal terms of type <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>
            <fr:tex display="block">                 \Gamma  \vdash  a \equiv  b : A             </fr:tex></fr:li></fr:ul>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>All judgments are context dependent, 
    and indeed that even the types of the variables in a context
    may depend on any previous declared variables.

    To introduce types dependent on terms, 
    we need the notation of type families.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>714</fr:anchor><fr:addr type="user">def-0018</fr:addr><fr:route>def-0018.xml</fr:route><fr:title text="Type Family">Type Family</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Consider a type <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>.
    A <fr:strong>family</fr:strong> of types over <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>
    is a type <fr:tex display="inline">B(x)</fr:tex> in context <fr:tex display="inline">\Gamma , x:A</fr:tex>.
    <fr:tex display="block">         \Gamma , x:A \vdash  B(x) \space \text {type}     </fr:tex>
    <fr:tex display="inline">B</fr:tex> is a family of types over <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>.
    Alternatively, we say that <fr:tex display="inline">B(x)</fr:tex> is a type <fr:strong>indexed</fr:strong> by <fr:tex display="inline">x:A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now we can define a term of a type family, that is, a section of a type family.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>715</fr:anchor><fr:addr type="user">def-0019</fr:addr><fr:route>def-0019.xml</fr:route><fr:title text="Section of Type Family">Section of Type Family</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">B</fr:tex> be a <fr:link type="local" href="def-0018.xml" addr="def-0018" title="Type Family">type family</fr:link> over <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>.
    A <fr:strong>section</fr:strong> of <fr:tex display="inline">B</fr:tex> is a term <fr:tex display="inline">b</fr:tex> of type <fr:tex display="inline">B(x)</fr:tex> in context <fr:tex display="inline">\Gamma ,x:A</fr:tex>.
    <fr:tex display="block">         \Gamma , x:A \vdash  b : B(x)     </fr:tex>
    Alternatively, we say that <fr:tex display="inline">b</fr:tex> is a term of <fr:tex display="inline">B(x)</fr:tex> indexed by <fr:tex display="inline">x:A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We now ready to present the inference rules for dependent type theory.
    These rules are known as the <fr:strong>structual rules</fr:strong> of the theory.
    There are 6 sets of rules:
    <fr:ul><fr:li>Formation contexts, types and terms</fr:li>
        <fr:li>Postulating that judgmental equality is an equivalence relation</fr:li>
        <fr:li>Vairable conversion</fr:li>
        <fr:li>Substitution</fr:li>
        <fr:li>Weakening</fr:li>
        <fr:li>Generic element</fr:li></fr:ul></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>716</fr:anchor><fr:addr type="user">def-001A</fr:addr><fr:route>def-001A.xml</fr:route><fr:title text="
    Formation of contexts, types and terms
">
    Formation of contexts, types and terms
</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The following rules follow from the presuppotion
    about contexts, types and terms, can be used freely.</fr:p><fr:ul><fr:li><fr:tex display="block">             \frac {                 \Gamma ,x:A\vdash  B(x)\space \text {type}             }{                 \Gamma \vdash  A\space \text {type}             }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">             \frac {                 \Gamma \vdash  A\equiv  B\space \text {type}             }{                 \Gamma \vdash  A\space \text {type}             }             \quad              \frac {                 \Gamma \vdash  A\equiv  B\space \text {type}             }{                 \Gamma \vdash  B\space \text {type}             }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">             \frac {                 \Gamma \vdash  a:A             }{                 \Gamma \vdash  A\space \text {type}             }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">             \frac {                 \Gamma \vdash  a\equiv  b:A             }{                 \Gamma \vdash  a:A             }             \quad               \frac {                 \Gamma \vdash  a\equiv  b:A             }{                 \Gamma \vdash  b:A             }         </fr:tex></fr:li></fr:ul></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>717</fr:anchor><fr:addr type="user">def-001B</fr:addr><fr:route>def-001B.xml</fr:route><fr:title text="
    Judgmental equality is equivalence relation
">
    Judgmental equality is equivalence relation
</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Judgmental equality on types and on elements is an <fr:link type="local" href="def-000X.xml" addr="def-000X" title="Equivalence Relation">equivalence relation</fr:link> 
    simply postulate that these relations are reflexive, symmetric, and transitive:</fr:p><fr:ul><fr:li><fr:tex display="block">             \frac {                 \Gamma \vdash  a:A             }{                 \Gamma \vdash  a\equiv  a:A             }             \quad              \frac {                 \Gamma \vdash  a\equiv  b:A             }{                 \Gamma \vdash  b\equiv  a:A             }             \quad              \frac {                 \Gamma \vdash  a\equiv  b:A                 \quad                  \Gamma \vdash  b\equiv  c:A             }{                 \Gamma \vdash  a\equiv  c:A             }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">             \frac {                 \Gamma \vdash  A\space \text {type}             }{                 \Gamma \vdash  A\equiv  A\space \text {type}             }             \quad              \frac {                 \Gamma \vdash  A\equiv  B\space \text {type}             }{                 \Gamma \vdash  B\equiv  A\space \text {type}             }             \quad              \frac {                 \Gamma \vdash  A\equiv  B\space \text {type}                 \quad                  \Gamma \vdash  B\equiv  C\space \text {type}             }{                 \Gamma \vdash  A\equiv  C\space \text {type}             }         </fr:tex></fr:li></fr:ul></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>718</fr:anchor><fr:addr type="user">def-001C</fr:addr><fr:route>def-001C.xml</fr:route><fr:title text="Variable Conversion">Variable Conversion</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This rule postulates that we can
    convert the type of a variable to a judgmentally equal type.
    <fr:tex display="block">         \frac {             \Gamma \vdash  A\equiv  A&apos;\space \text {type}             \quad              \Gamma ,x:A,\Delta \vdash  B(x)\space \text {type}         }{             \Gamma ,x:A&apos;,\Delta \vdash  B(x)\space \text {type}         }     </fr:tex>
    Similarly, we can convert judgmental equality of types and terms.
    We state all of them at once using a <fr:em>generic judgment thesis</fr:em> <fr:tex display="inline">\mathcal {J}</fr:tex>.
    <fr:tex display="block">         \frac {             \Gamma \vdash  A\equiv  A&apos;\space \text {type}             \quad              \Gamma ,x:A,\Delta \vdash  \mathcal {J}         }{             \Gamma ,x:A&apos;,\Delta \vdash  \mathcal {J}         }VC     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Consider a term <fr:tex display="inline">f:B(x)</fr:tex> indexed by <fr:tex display="inline">x:A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>,
    and we also have a term <fr:tex display="inline">a:A</fr:tex>.
    We can simultaneously substitute <fr:tex display="inline">a</fr:tex> for all occurrences of <fr:tex display="inline">x</fr:tex> in <fr:tex display="inline">f</fr:tex>
    to obtain a new term <fr:tex display="inline">f[x:=a]:B(a)</fr:tex>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>719</fr:anchor><fr:addr type="user">def-001D</fr:addr><fr:route>def-001D.xml</fr:route><fr:title text="Substitution">Substitution</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The substitution rule postulates that we can substitute a term for a variable.
    <fr:tex display="block">         \frac {             \Gamma \vdash  a:A             \quad              \Gamma ,x:A,\Delta \vdash  \mathcal {J}         }{             \Gamma ,\Delta [x:=a]\vdash  \mathcal {J}[x:=a]         }S     </fr:tex>
    The notation <fr:tex display="inline">\Gamma ,\Delta [x:=a]</fr:tex> means that we substitute <fr:tex display="inline">a</fr:tex> for <fr:tex display="inline">x</fr:tex> in <fr:tex display="inline">\Delta </fr:tex>.</fr:p><fr:p>With the substitution rule, we need two more <fr:em>congruence rules</fr:em> to
    convert judgmental equality of terms and types.
    <fr:tex display="block">         \frac {             \Gamma \vdash  a\equiv  a&apos;:A             \quad              \Gamma ,x:A,\Delta \vdash  B \space \text {type}         }{             \Gamma ,\Delta [x:=a]\vdash  B[x:=a]\equiv  B[x:=a&apos;] \space \text {type}         }     </fr:tex>

    <fr:tex display="block">         \frac {             \Gamma \vdash  A\equiv  A&apos;\space \text {type}             \quad              \Gamma ,x:A,\Delta \vdash  b:A         }{             \Gamma ,\Delta [x:=a]\vdash  b[x:=a]\equiv  b[x:=a&apos;]:A&apos;[x:=a] \space \text {type}         }     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>720</fr:anchor><fr:addr type="user">def-001G</fr:addr><fr:route>def-001G.xml</fr:route><fr:title text="Fiber and Value">Fiber and Value</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">B</fr:tex> be a <fr:link type="local" href="def-0018.xml" addr="def-0018" title="Type Family">type family</fr:link> over <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>,
    an a well-formed term <fr:tex display="inline">a:A</fr:tex>,
    then we say that <fr:tex display="inline">B[x:=a]</fr:tex> is the <fr:strong>fiber</fr:strong> of <fr:tex display="inline">B</fr:tex> at <fr:tex display="inline">a</fr:tex>, denoted <fr:tex display="inline">B(a)</fr:tex>.</fr:p><fr:p>Let <fr:tex display="inline">b</fr:tex> a <fr:link type="local" href="def-0019.xml" addr="def-0019" title="Section of Type Family">section</fr:link> of <fr:tex display="inline">B</fr:tex> over <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>,
    then we say that <fr:tex display="inline">b(a):\equiv  b[x:=a]</fr:tex> is the <fr:strong>value</fr:strong> of <fr:tex display="inline">b</fr:tex> at <fr:tex display="inline">a</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The process of expanding the context by a fresh variable of type <fr:tex display="inline">A</fr:tex> is called weakening (by <fr:tex display="inline">A</fr:tex>).
    Intuitively, weakening is the process of adding a new hypothesis to the context.
    And the hypothesis will weaken the conclusion.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>721</fr:anchor><fr:addr type="user">def-001E</fr:addr><fr:route>def-001E.xml</fr:route><fr:title text="Weakening">Weakening</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Weakening rule asserts that we can add a variable to the context.
    <fr:tex display="block">         \frac {             \Gamma \vdash  A\space \text {type}             \quad               \Gamma ,\Delta \vdash  \mathcal {J}         }{             \Gamma ,x:A,\Delta \vdash  \mathcal {J}         }W      </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Finally, the generic elemets rule ensures that
    the variables declared in a context.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>722</fr:anchor><fr:addr type="user">def-001F</fr:addr><fr:route>def-001F.xml</fr:route><fr:title text="Generic Elements">Generic Elements</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The rule for the generic element asserts that 
    any hypothetical element <fr:tex display="inline">x:A</fr:tex> in context <fr:tex display="inline">\Gamma ,x:A</fr:tex>
    is also an element of <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma ,x:A</fr:tex>.
    <fr:tex display="block">         \frac {             \Gamma \vdash  A\space \text {type}         }{             \Gamma ,x:A\vdash  x:A         }\delta      </fr:tex>
    This rule is also called the <fr:strong>variable rule</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The next topic is the dependent function type, a fundamental concept of dependent type theory.
    Simply put, a dependent function type is a function whose type of output may depend on the input.</fr:p><fr:p>Consider a section <fr:tex display="inline">b</fr:tex> of a family <fr:tex display="inline">B</fr:tex> over <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>:
    <fr:tex display="block">         \Gamma ,x:A\vdash  b(x):B(x)     </fr:tex>
    Such a section <fr:tex display="inline">b</fr:tex> is an operation or assignment <fr:tex display="inline">x\mapsto  b(x)</fr:tex> that assigns to each element <fr:tex display="inline">x:A</fr:tex>
    to a term <fr:tex display="inline">b(x):B(x)</fr:tex>.
    We may see <fr:tex display="inline">b</fr:tex> as a function takes <fr:tex display="inline">x:A</fr:tex> to <fr:tex display="inline">b(x):B(x)</fr:tex>.
    The function <fr:tex display="inline">x\mapsto  b(x)</fr:tex> is called a <fr:strong>dependent function</fr:strong>.
    The type of all dependent functions from <fr:tex display="inline">A</fr:tex> to <fr:tex display="inline">B</fr:tex> is called the <fr:strong>dependent function type</fr:strong>.
    <fr:tex display="block">         \Pi _{(x:A)}B(x) \text { or } (x:A)\to  B(x)     </fr:tex></fr:p><fr:p>To introduce a type we need the following four rules:
    <fr:ul><fr:li>Formation rule</fr:li>
        <fr:li>Introduction rule</fr:li>
        <fr:li>Elimination rule</fr:li>
        <fr:li>Computation rule</fr:li></fr:ul>
    Besides these we also need the <fr:strong>congruence rule</fr:strong> for judgmental equality.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>723</fr:anchor><fr:addr type="user">def-001T</fr:addr><fr:route>def-001T.xml</fr:route><fr:title text="Dependent Function Type">Dependent Function Type</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Formation Rule</fr:strong>
    For any type family <fr:tex display="inline">B</fr:tex> over <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>:
    <fr:tex display="block">         \frac {             \Gamma ,x:A\vdash  B(x)\space \text {type}         }{             \Gamma \vdash  \Pi _{(x:A)}B(x)\space \text {type}         }\Pi      </fr:tex>
    We also require that the operation of forming dependent function types
    respects judgmental equality.
    <fr:tex display="block">         \frac {             \Gamma \vdash  A\equiv  A&apos;\space \text {type}             \quad              \Gamma ,x:A\vdash  B(x)\equiv  B&apos;(x)\space \text {type}         }{             \Gamma \vdash  \Pi _{(x:A)}B(x)\equiv  \Pi _{(x:A&apos;)}B&apos;(x)\space \text {type}         }\Pi \text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Introduction Rule (<fr:tex display="inline">\lambda </fr:tex>-abstraction)</fr:strong>
    In order to construct a dependent function we have to
    construct a term <fr:tex display="inline">f(x):B(x)</fr:tex> indexed by <fr:tex display="inline">x:A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>:
    <fr:tex display="block">         \frac {             \Gamma ,x:A\vdash  b(x):B(x)         }{             \Gamma \vdash  \lambda  x.b(x):\Pi _{(x:A)}B(x)         }\lambda      </fr:tex>
    And the congruence rule:
    <fr:tex display="block">         \frac {             \Gamma ,x:A\vdash  b(x)\equiv  b&apos;(x):B(x)         }{             \Gamma \vdash  \lambda  x.b(x)\equiv  \lambda  x.b&apos;(x):\Pi _{(x:A)}B(x)         }\lambda \text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Elimination Rule (Evaluation Rule)</fr:strong>
    In order to use dependent function we need to provide an argument of the domain type.
    <fr:tex display="block">         \frac {             \Gamma \vdash  f:\Pi _{(x:A)}B(x)         }{             \Gamma ,x:A\vdash  f(x):B(x)         }ev     </fr:tex>
    Again we require the judgmental equality to be respected:
    <fr:tex display="block">         \frac {             \Gamma \vdash  f\equiv  f&apos;:\Pi _{(x:A)}B(x)         }{             \Gamma ,x:A\vdash  f(x)\equiv  f&apos;(x):B(x)         }ev\text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Computation Rule (<fr:tex display="inline">\beta </fr:tex>-reduction)</fr:strong>
    <fr:tex display="block">         \frac {             \Gamma ,x:A\vdash  b(x):B(x)         }{             \Gamma ,x:A\vdash  (\lambda  y.b(y))(x)\equiv  b(x):B(x)         }\beta      </fr:tex>
    We postulate that all elements of a dependent function type are dependent functions.
    <fr:tex display="block">         \frac {             \Gamma \vdash  f:\Pi _{(x:A)}B(x)         }{             \Gamma \vdash  f\equiv  \lambda  x.f(x):\Pi _{(x:A)}B(x)         }\eta      </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>A degenrated case of dependent function type is the ordinary function type.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>724</fr:anchor><fr:addr type="user">def-001U</fr:addr><fr:route>def-001U.xml</fr:route><fr:title text="Ordinary Function Type">Ordinary Function Type</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A special case of <fr:link type="local" href="def-001T.xml" addr="def-001T" title="Dependent Function Type"><fr:tex display="inline">\Pi </fr:tex>-type</fr:link> is the <fr:strong>ordinary function type</fr:strong>.
    Using weakening rule we can obtain thee type <fr:tex display="inline">A\to  B</fr:tex> of ordinary function from <fr:tex display="inline">A</fr:tex> to <fr:tex display="inline">B</fr:tex>
    <fr:tex display="block">         \frac {             \Gamma \vdash  A\space \text {type}             \quad              \Gamma \vdash  B\space \text {type}         }{\dfrac {             \Gamma ,x:A\vdash  B\space \text {type}         }{             \Gamma \vdash  \Pi _{(x:A)}B\space \text {type}         }\Pi }W     </fr:tex>
    A term <fr:tex display="inline">f: \Pi _{(x:A)}B</fr:tex> is an ordinary function. The type <fr:tex display="inline">A \to  B</fr:tex> is defined:
    <fr:tex display="block">         A\to  B := \Pi _{(x:A)}B     </fr:tex>
    The type <fr:tex display="inline">A</fr:tex> is called <fr:strong>domain</fr:strong> of <fr:tex display="inline">f</fr:tex>,
    and type <fr:tex display="inline">B</fr:tex> is called <fr:strong>codomain</fr:strong> of <fr:tex display="inline">f</fr:tex>.
    The notation <fr:tex display="inline">:=</fr:tex> here means to make a definition.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>725</fr:anchor>
                <fr:addr type="user">tt-0003</fr:addr>
                <fr:route>tt-0003.xml</fr:route>
                <fr:title text="Natural Numbers {N}">Natural Numbers <fr:tex display="inline">\mathbb {N}</fr:tex></fr:title>
                <fr:taxon>Type Theory</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>30</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>In previous post, we have seen the basic inference rules of type theory.
    Now we will see the definition of natural numbers as an inductive type.
    Refer to <fr:link type="local" href="hott-book-2013.xml" addr="hott-book-2013" title="Homotopy Type Theory: Univalent Foundations of Mathematics">HoTT Book</fr:link> and <fr:link type="local" href="hott-2022.xml" addr="hott-2022" title="Introduction to Homotopy Type Theory">Egbert Rijke&apos;s</fr:link>.</fr:p>
                <fr:p>In classical mathematics, the <fr:strong>Peano axioms</fr:strong> are a set of axioms for the natural numbers,
    an important object in mathematics.</fr:p>
                <fr:p>In type theory, the type <fr:tex display="inline">\mathbb {N}</fr:tex> of natural number is an <fr:link type="local" href="def-001X.xml" addr="def-001X" title="Inductive Type"><fr:strong>inductive type</fr:strong></fr:link>.
    Just like in dependent function type, we need four inference rules to define the natural numbers.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>726</fr:anchor>
                    <fr:addr type="user">def-001Y</fr:addr>
                    <fr:route>def-001Y.xml</fr:route>
                    <fr:title text="Natural Number">Natural Number</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>In type theory, <fr:strong>natural number</fr:strong> is defined using <fr:strong>peano encoding</fr:strong>.
    The type <fr:tex display="inline">\mathbb {N}</fr:tex> is formed by the formation rule:
    <fr:tex display="block">         \frac {}{\vdash \mathbb {N}\space \text {type}}\mathbb {N}\text {-form}     </fr:tex></fr:p>
                    <fr:p>Peano&apos;s first axiom postulates the existence of a natural number <fr:tex display="inline">0</fr:tex>.
    The introduction rule for <fr:tex display="inline">\mathbb {N}</fr:tex> has a <fr:tex display="inline">0</fr:tex> constructor and a <fr:strong>successor</fr:strong> function.
    <fr:tex display="block">         \frac {}{\vdash 0:\mathbb {N}}\mathbb {N}\text {-intro-0}         \quad          \frac {}{\vdash \text {succ}:\mathbb {N}\to \mathbb {N}} \mathbb {N}\text {-intro-succ}     </fr:tex></fr:p>
                    <fr:p>The <fr:strong>elimination rule</fr:strong> is actually the type theoretical <fr:strong>induction principle</fr:strong> of <fr:tex display="inline">\mathbb {N}</fr:tex>:
    In order to show that <fr:tex display="inline">\forall  n:\mathbb {N}.P(n)</fr:tex> holds, it suffices to show that <fr:tex display="inline">P(0)</fr:tex> holds and that <fr:tex display="inline">\forall  n:\mathbb {N}.P(n)\to  P(\text {succ}(n))</fr:tex> holds.
    The type theoretical induction principle is therefore formulated using a type family <fr:tex display="inline">P</fr:tex> over <fr:tex display="inline">\mathbb {N}</fr:tex>:
    <fr:tex display="block">         \frac {             \begin {align*}                 \Gamma &amp;,\,n:\mathbb {N}\vdash  P(n)\space \text {type}                 \\                 \Gamma &amp;\vdash  p_0:P(0)                 \\                 \Gamma &amp;\vdash  p_S:\Pi _{(n:\mathbb {N})}P(n)\to  P(\text {succ}(n))             \end {align*}         }{             \Gamma \vdash \text {ind}_\mathbb {N}(p_0,p_S):\Pi _{(n:\mathbb {N})}P(n)         }(\mathbb {N} \text {-ind})     </fr:tex>
    The induction principle tells us what we need to do in order to construct a dependent function <fr:tex display="inline">\text {ind}_\mathbb {N}</fr:tex> of type <fr:tex display="inline">\Pi _{(n:\mathbb {N})}P(n)</fr:tex>.
    We might alternatively write the induction principle as:
    <fr:tex display="block">         \frac {             \Gamma ,n:\mathbb {N}\vdash  P(n)\space \text {type}         }{             \Gamma \vdash \text {ind}_\mathbb {N}:\left (P(0)\to \left (\Pi _{(n:\mathbb {N})}P(n)\to  P(\text {succ}(n))\right )\to \Pi _{(n:\mathbb {N})}P(n)\right )         }(\mathbb {N} \text {-ind})     </fr:tex></fr:p>
                    <fr:p>The <fr:strong>computation rule</fr:strong> asserts that the dependent function <fr:tex display="inline">\text {ind}_\mathbb {N}</fr:tex> behaves as expected:
    <fr:tex display="block">         \frac {             \begin {align*}                 \Gamma &amp;,n:\mathbb {N}\vdash  P(n)\space \text {type}                 \\                 \Gamma &amp;\vdash  p_0:P(0)                 \\                 \Gamma &amp;\vdash  p_S:\Pi _{(n:\mathbb {N})}P(n)\to  P(\text {succ}(n))             \end {align*}         }{             \text {ind}_\mathbb {N}(p_0,p_S,m)\equiv              \begin {cases}                 p_0&amp;\text {if }m=0                 \\                 p_S(n,\text {ind}_\mathbb {N}(p_0,p_S,n))&amp;\text {if }m=\text {succ}(n)             \end {cases}         }(\mathbb {N} \text {-comp})     </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Now let&apos;s use the type theoretical induction principle of <fr:tex display="inline">\mathbb {N}</fr:tex> to
    perform some basic construction over <fr:tex display="inline">\mathbb {N}</fr:tex>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>727</fr:anchor>
                    <fr:addr type="user">def-001Z</fr:addr>
                    <fr:route>def-001Z.xml</fr:route>
                    <fr:title text="Addition over {N}">Addition over <fr:tex display="inline">\mathbb {N}</fr:tex></fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p>We define addition over <fr:tex display="inline">\mathbb {N}</fr:tex> using the type theoretical induction principle of <fr:tex display="inline">\mathbb {N}</fr:tex>.
    <fr:tex display="block">         \text {add}_\mathbb {N} : \mathbb {N} \to  (\mathbb {N} \to  \mathbb {N})     </fr:tex>
    which satisfies the following specification:
    <fr:tex display="block">         \begin {align*}             \text {add}_\mathbb {N}(n, 0)&amp;:\equiv  n             \\             \text {add}_\mathbb {N}(m,\text {succ}(n))&amp;:\equiv \text {succ}(\text {add}_\mathbb {N}(m,n))         \end {align*}     </fr:tex>
    abbreviated as <fr:tex display="inline">m + n</fr:tex> for <fr:tex display="inline">\text {add}_\mathbb {N}(m,n)</fr:tex>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>728</fr:anchor><fr:addr type="machine">#341</fr:addr><fr:route>unstable-341.xml</fr:route><fr:title text="Construction"><fr:strong>Construction</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    
        <fr:p>We construct the additon by perform induction over the second variable <fr:tex display="inline">n</fr:tex>.
            That is, to construct an element
            <fr:tex display="block">                 m:\mathbb {N} \vdash  \text {add}_\mathbb {N}(m):\mathbb {N} \to  \mathbb {N}             </fr:tex>
            The context <fr:tex display="inline">\Gamma  \equiv  m:\mathbb {N}</fr:tex> is fixed.</fr:p>
        Therefore we need to construct:
        <fr:tex display="block">             \begin {align*}                 \Gamma &amp;\vdash  \text {add-zero}_\mathbb {N}(m):\mathbb {N}                 \\                 \Gamma &amp;\vdash  \text {add-succ}_\mathbb {N}(m):\mathbb {N}\to \mathbb {N}                             \end {align*}            </fr:tex>
        The <fr:tex display="inline">\text {add-zero}_\mathbb {N}</fr:tex> is defined to be identity function trivially. To see how <fr:tex display="inline">\text {add-succ}_\mathbb {N}</fr:tex> is defined, we need to perform induction:
        <fr:tex display="block">             \begin {align*}                 \text {add}_\mathbb {N}(m, \text {succ}(n))&amp;\equiv                  \text {ind}_\mathbb {N}(\text {add-zero}_\mathbb {N}(m), \text {add-succ}_\mathbb {N}(m), \text {succ}(n))                 \\                 &amp;\equiv  \text {add-succ}_\mathbb {N}(m,n, \text {add}_\mathbb {N}(m,n))                 \\                 &amp;\equiv  \text {succ}(\text {add}_\mathbb {N}(m,n))             \end {align*}         </fr:tex>
        Hence <fr:tex display="inline">\text {add-succ}_\mathbb {N}</fr:tex> is defined as:
        <fr:tex display="block">             \text {add-succ}_\mathbb {N}(m,n,x) \equiv  \text {succ}(x)         </fr:tex>
        A formal construction of <fr:tex display="inline">\text {add-succ}_\mathbb {N}</fr:tex> is as follows:
        <fr:tex display="block">             \dfrac {                 \dfrac {                     \dfrac {                         \dfrac {}{\vdash \mathbb {N}\space \text {type}}                         \quad                          \dfrac {                             \dfrac {}{\vdash  \mathbb {N}\space \text {type}}                             \quad                              \dfrac {}{\vdash  \text {succ}:\mathbb {N}\to \mathbb {N}}                         }{                             n:\mathbb {N}\vdash \text {succ}:\mathbb {N}\to \mathbb {N}                         }                     }{                         m:\mathbb {N}, n:\mathbb {N}\vdash  \text {succ}:\mathbb {N}\to \mathbb {N}                     }                  }{                     m:\mathbb {N}\vdash \lambda  n.\text {succ} : \mathbb {N}\to (\mathbb {N}\to \mathbb {N})                 }             }{                 m:\mathbb {N}\vdash  \text {add-succ}_\mathbb {N}(m):\equiv \lambda  m.\text {succ} : \mathbb {N}\to (\mathbb {N}\to \mathbb {N})             }\text {Block-1}         </fr:tex>
        Finally we combine the derivation together:
        <fr:tex display="block">             \dfrac {                 \dfrac {                     \dfrac {                         \dfrac {                             \vdash  \mathbb {N}\space \text {type}                         }{                             m:\mathbb {N}\vdash  m:\mathbb {N}                         }                     }{                         m:\mathbb {N}\vdash \text {add-zero}_\mathbb {N}(m):\equiv  m:\mathbb {N}                     }                     \quad                       \dfrac {\text {Block-1}}{                         m:\mathbb {N}\vdash \text {add-succ}_\mathbb {N}(m):\mathbb {N}\to (\mathbb {N}\to \mathbb {N})                     }                 }{                     m:\mathbb {N}\vdash \text {ind}_\mathbb {N} (\text {add-zero}_\mathbb {N}(m), \text {add-succ}_\mathbb {N}(m)):\mathbb {N}\to \mathbb {N}                 }             }{                 m:\mathbb {N}\vdash \text {add}_\mathbb {N}(m):\equiv \text {ind}_\mathbb {N} (\text {add-zero}_\mathbb {N}(m), \text {add-succ}_\mathbb {N}(m)):\mathbb {N}\to \mathbb {N}             }         </fr:tex>
    
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Recall the definition of addition function <fr:tex display="inline">\text {add}: \mathbb {N}\to (\mathbb {N}\to \mathbb {N})</fr:tex> satisfying the specification:
    <fr:tex display="block">         \begin {align*}             m + 0 &amp; :\equiv  m             \\              m + \text {succ}(n) &amp; :\equiv  \text {succ}(m + n)         \end {align*}     </fr:tex>
    Such definition is enough to characterize the addition function.
    Because it postulates te <fr:em>behavior</fr:em> of <fr:tex display="inline">\text {add}_\mathbb {N}</fr:tex> at the constructor of <fr:tex display="inline">\mathbb {N}</fr:tex></fr:p>
                <fr:p>More generally, we can define a dependent function <fr:tex display="inline">f:\Pi  n:\mathbb {N}.P(n)</fr:tex> by induction on <fr:tex display="inline">n</fr:tex> using
    <fr:tex display="block">         \begin {align*}             p_0 &amp; : P(0)             \\             p_S &amp; : \Pi _{(n:\mathbb {N})}P(n)\to  P(\text {succ}(n))         \end {align*}     </fr:tex>
    Just present the definition by writing
    <fr:tex display="block">         \begin {align*}             f(0) &amp; :\equiv  p_0             \\             f(\text {succ}(n)) &amp; :\equiv  p_S(n,f(n))         \end {align*}     </fr:tex>
    <fr:tex display="inline">f</fr:tex> is said to be defined by <fr:strong>pattern matching</fr:strong> on the variable <fr:tex display="inline">n</fr:tex>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>729</fr:anchor>
                    <fr:addr type="user">eg-0001</fr:addr>
                    <fr:route>eg-0001.xml</fr:route>
                    <fr:title text="Fibonacci Function">Fibonacci Function</fr:title>
                    <fr:taxon>Example</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The <fr:strong>Fibonacci function</fr:strong> is a well-known function in mathematics.
    It is defined by pattern matching on the variable <fr:tex display="inline">n</fr:tex> as follows:
    <fr:tex display="block">         \begin {align*}             \text {fib}(0) &amp; :\equiv  0             \\             \text {fib}(1) &amp; :\equiv  1             \\             \text {fib}(n+2) &amp; :\equiv  \text {fib}(n) + \text {fib}(n+1)         \end {align*}     </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>730</fr:anchor>
                <fr:addr type="user">tt-0004</fr:addr>
                <fr:route>tt-0004.xml</fr:route>
                <fr:title text="Inductive Types">Inductive Types</fr:title>
                <fr:taxon>Type Theory</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>30</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter><fr:p>In previous post, we have seen the definition of natural numbers as an inductive type.
    In this post, we will see more examples of inductive types, such as 
    unit type, empty type, product type, sum type and etc.
    Refer to <fr:link type="local" href="hott-2022.xml" addr="hott-2022" title="Introduction to Homotopy Type Theory">Egbert Rijke&apos;s Book</fr:link>.</fr:p><fr:p>This section is much more informal than the previous one.
    Without displaying the inference rules, we will just present the <fr:strong>constructor</fr:strong>
    and <fr:strong>induction principle</fr:strong> of each inductive type.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>731</fr:anchor><fr:addr type="machine">#278</fr:addr><fr:route>unstable-278.xml</fr:route><fr:title text="General Inductive Type"><fr:strong>General Inductive Type</fr:strong></fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>Just like <fr:tex display="inline">\mathbb {N}</fr:tex>, other inductive types can be defined by 
    their constructors and induction principles (and computation rules).</fr:p>
    <fr:ul><fr:li>The constructors specify the structure of the type equipped.</fr:li>
        <fr:li>The induction principle specifies the data required to construct 
            a section of an arbitrary type family over the inductive type.</fr:li>
        <fr:li>The computation rules specify the behavior of the constructors.</fr:li></fr:ul>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>732</fr:anchor><fr:addr type="user">def-0020</fr:addr><fr:route>def-0020.xml</fr:route><fr:title text="Unit Type">Unit Type</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>unit type</fr:strong> is the simplest inductive type.
        It has only one constructor, denoted by <fr:tex display="inline">\star :\textbf {1}</fr:tex>.</fr:p><fr:p>The induction principle of the unit type is trivial.
        It says that to define a dependent function <fr:tex display="inline">f:\Pi  _{(x:\textbf {1})} P(x)</fr:tex>, 
        it suffices to give a value <fr:tex display="inline">p:P(\star )</fr:tex>.
        <fr:tex display="block">             f (\star ) :\equiv  p         </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>A degenrate inductive type is the <fr:strong>empty type</fr:strong>.
    It has no constructor, and its induction principle is trivial.
    Empty type is connected to the <fr:strong>exfalso quodlibet principle</fr:strong> in logic.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>733</fr:anchor><fr:addr type="user">def-0021</fr:addr><fr:route>def-0021.xml</fr:route><fr:title text="Empty Type">Empty Type</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>empty type</fr:strong> is a degenerate inductive type <fr:tex display="inline">\emptyset </fr:tex> satisfying 
    the following induction principle:
    <fr:tex display="block">         \text {ind}_\emptyset  : \Pi _{(x:\emptyset )}P(x)     </fr:tex>
    And a special case is <fr:strong>exfalso</fr:strong>:
    <fr:tex display="block">         \text {exfalso} :\equiv  \text {ind}_\emptyset  : \empty  \to  A      </fr:tex>
    which can draw any conclusion.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>With the empty type we can define the <fr:strong>negation</fr:strong> of a type
    and the <fr:strong>proof of negation</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>734</fr:anchor><fr:addr type="user">def-0022</fr:addr><fr:route>def-0022.xml</fr:route><fr:title text="Type Negation">Type Negation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>negation</fr:strong> of type <fr:tex display="inline">A</fr:tex> is defined as
    <fr:tex display="block">         \neg  A :\equiv  A \to  \emptyset      </fr:tex>
    A type <fr:tex display="inline">A</fr:tex> is said to be <fr:strong>empty</fr:strong> if and only if <fr:tex display="inline">\neg  A</fr:tex> is inhabited.
    <fr:tex display="block">         \text {empty}(A) :\equiv  \neg  A     </fr:tex></fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>735</fr:anchor><fr:addr type="machine">#340</fr:addr><fr:route>unstable-340.xml</fr:route><fr:title text="Proof of negation"><fr:strong>Proof of negation</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:p>To prove <fr:tex display="inline">\neg  A</fr:tex>, we need to show that <fr:tex display="inline">A</fr:tex> implies a contradiction.
            In other words, constructing a function of type <fr:tex display="inline">A \to  \emptyset </fr:tex>.</fr:p>
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>736</fr:anchor><fr:addr type="user">def-0023</fr:addr><fr:route>def-0023.xml</fr:route><fr:title text="Coproduct Type">Coproduct Type</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">A</fr:tex> and <fr:tex display="inline">B</fr:tex> be types. The <fr:strong>coproduct (disjoint sum)</fr:strong> <fr:tex display="inline">A+B</fr:tex> is a typed defined by the following constructors:
    <fr:ul><fr:li><fr:tex display="inline">\text {inl}:A\to  A+B</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">\text {inr}:B\to  A+B</fr:tex></fr:li></fr:ul>
    For any type family indexed by <fr:tex display="inline">x:A+B</fr:tex>, satisfies the following induction principle:
    <fr:tex display="block">         \text {ind}_+: (\Pi _{(x:A)}P(\text {inl}(x)))\to (\Pi _{(y:B)}P(\text {inr}(y)))\to \Pi _{(z:A+B)}P(z)     </fr:tex>
    (Note that sometimes we denoted <fr:tex display="inline">\text {ind}_+(f,g)</fr:tex> as <fr:tex display="inline">[f,g]</fr:tex>) And the computation rule:
    <fr:tex display="block">         \begin {align*}             \text {ind}_+(f,g,\text {inl}(x))&amp;\equiv  f(x)\\             \text {ind}_+(f,g,\text {inr}(y))&amp;\equiv  g(y)         \end {align*}     </fr:tex>
    where <fr:tex display="inline">f</fr:tex> and <fr:tex display="inline">g</fr:tex> are defined:
    <fr:tex display="block">         \begin {align*}             f&amp;:\Pi _{(x:A)}P(\text {inl}(x))\\             g&amp;:\Pi _{(y:B)}P(\text {inr}(y))         \end {align*}     </fr:tex>
    This can be presented by pattern matching to define a function <fr:tex display="inline">h:\Pi  _{(z:A+B)}.P(z)</fr:tex>:
    <fr:tex display="block">         \begin {align*}             h(\text {inl}(x))&amp;:\equiv  f(x)\\             h(\text {inr}(y))&amp;:\equiv  g(y)         \end {align*}     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>737</fr:anchor><fr:addr type="machine">#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:title text="Special Case of Coproduct"><fr:strong>Special Case of Coproduct</fr:strong></fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    The special case of coproduct type is also called the <fr:strong>sum type</fr:strong>.
    <fr:tex display="block">         \text {ind}_+: (A \to  X) \to  (B \to  X) \to  (A+B \to  X)     </fr:tex>
    which is very similar to the <fr:strong>elimination rule</fr:strong> of disjunction in logic.
    <fr:tex display="block">         (P\to  Q) \to  (R\to  Q) \to  (P\vee  R\to  Q)     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:p>The dependent version of sum type is called the <fr:strong>dependent sum type (dependent coproduct)</fr:strong> traditionally.
    Its terms are ordered pairs.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>738</fr:anchor><fr:addr type="user">def-0024</fr:addr><fr:route>def-0024.xml</fr:route><fr:title text="Dependent Pair Type">Dependent Pair Type</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>dependent pair type</fr:strong> is a inductive type <fr:tex display="inline">\Sigma _{(x:A)}B(x)</fr:tex> (<fr:tex display="inline">(x:A) \times  B(x)</fr:tex>)</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>739</fr:anchor><fr:addr type="machine">#335</fr:addr><fr:route>unstable-335.xml</fr:route><fr:title text="
    Formation Rule
">
    <fr:strong>Formation Rule</fr:strong>
</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>Given a type family <fr:tex display="inline">B</fr:tex> over <fr:tex display="inline">A</fr:tex>, we can form the dependent pair type <fr:tex display="inline">\Sigma _{(x:A)}B(x)</fr:tex>.</fr:p>
    <fr:tex display="block">         \frac {             \Gamma \vdash  A\space \text {type}             \quad              \Gamma ,x:A\vdash  B(x)\space \text {type}         }{             \Gamma \vdash  (x:A) \times  B(x)\space \text {type}         }     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>740</fr:anchor><fr:addr type="machine">#336</fr:addr><fr:route>unstable-336.xml</fr:route><fr:title text="
    Introduction Rule
">
    <fr:strong>Introduction Rule</fr:strong>
</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>Given a term <fr:tex display="inline">a:A</fr:tex> and a term <fr:tex display="inline">b(a):B(a)</fr:tex>, we can form a term <fr:tex display="inline">\text {pair}(a,b):(x:A)\times  B(x)</fr:tex>.</fr:p>
    <fr:tex display="block">         \frac {             \Gamma \vdash  a:A             \quad              \Gamma \vdash  b(a):B(a)         }{             \Gamma \vdash  (a,b):(x:A)\times  B(x)         }     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>741</fr:anchor><fr:addr type="machine">#337</fr:addr><fr:route>unstable-337.xml</fr:route><fr:title text="
    Elimination Rule
">
    <fr:strong>Elimination Rule</fr:strong>
</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>The elimination rule is formed with two projections.
        <fr:tex display="block">             \frac {                 \Gamma \vdash  p:(x:A)\times  B(x)             }{                 \begin {align*}                     \Gamma &amp;\vdash  \text {pr}_A(p):A\\                     \Gamma &amp;\vdash  \text {pr}_B(p):B(\text {pr}_A(p))                 \end {align*}             }         </fr:tex></fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>742</fr:anchor><fr:addr type="machine">#338</fr:addr><fr:route>unstable-338.xml</fr:route><fr:title text="
    Computation Rule
">
    <fr:strong>Computation Rule</fr:strong>
</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p><fr:tex display="block">             \frac {                 \Gamma \vdash  x:A                  \quad                   \Gamma \vdash  y:B(x)             }{                 \begin {align*}                     \Gamma &amp;\vdash  \text {pr}_A((x,y))=x:A\\                     \Gamma &amp;\vdash  \text {pr}_B((x,y))=y:B(x)                 \end {align*}             }         </fr:tex></fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>743</fr:anchor><fr:addr type="machine">#339</fr:addr><fr:route>unstable-339.xml</fr:route><fr:title text="
    Special Case
">
    <fr:strong>Special Case</fr:strong>
</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:ul><fr:li>In the special case that <fr:tex display="inline">B(x) = B</fr:tex> is independent of <fr:tex display="inline">A</fr:tex>,
            this reduces to the <fr:strong>product type</fr:strong> <fr:tex display="inline">A\times  B</fr:tex>.</fr:li>
        <fr:li>In the special case that <fr:tex display="inline">D \equiv  \text {Boolean}</fr:tex>,
            this reduces to a <fr:link type="local" href="def-0023.xml" addr="def-0023" title="Coproduct Type">coproduct type</fr:link>.</fr:li></fr:ul>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>744</fr:anchor>
                <fr:addr type="user">tt-0005</fr:addr>
                <fr:route>tt-0005.xml</fr:route>
                <fr:title text="Identity Types">Identity Types</fr:title>
                <fr:taxon>Type Theory</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>31</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>This post discuss the identity types in type theory.
    Refer to <fr:link type="local" href="hott-2022.xml" addr="hott-2022" title="Introduction to Homotopy Type Theory">Introduction to Homotopy Type Theory</fr:link>.</fr:p>
                <fr:p>How can we think of <fr:strong>equality</fr:strong> in type theory?
    Mentioned before, given a type <fr:tex display="inline">A</fr:tex> and two its elements <fr:tex display="inline">a,b:A</fr:tex>
    we can define a new type <fr:tex display="inline">a=_Ab</fr:tex> which is called the <fr:strong>identity type</fr:strong>.
    In this case, a term of <fr:tex display="inline">a=_Ab</fr:tex> is said to be a <fr:em>witness</fr:em> of the equality of <fr:tex display="inline">a</fr:tex> and <fr:tex display="inline">b</fr:tex>.
    And this witness is itself a type.
    We can then define their equality.
    This gives every type a <fr:strong>groupoid structure</fr:strong>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>745</fr:anchor>
                    <fr:addr type="user">def-002N</fr:addr>
                    <fr:route>def-002N.xml</fr:route>
                    <fr:title text="Identity Type">Identity Type</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p>The <fr:strong>identity type</fr:strong> is an inductive type,
    generated by just a <fr:strong>reflexivity</fr:strong> <fr:em>identification</fr:em>
    that providing an equality of a term with itself.</fr:p><fr:p>Consider a type <fr:tex display="inline">A</fr:tex> and let <fr:tex display="inline">a:A</fr:tex> be an element.
    The identity type of <fr:tex display="inline">A</fr:tex> at <fr:tex display="inline">a</fr:tex> is an inductive family of types <fr:tex display="inline">a=_Ax</fr:tex> 
    indexed by <fr:tex display="inline">x:A</fr:tex>.
    <fr:tex display="block">         \frac {             \Gamma \vdash  a:A         }{             \Gamma ,x:A\vdash  a=_Ax\space \text {type}         }     </fr:tex>
    The only constructor is the refl:
    <fr:tex display="block">         \frac {             \Gamma \vdash  a:A         }{             \Gamma \vdash  \text {refl}_a:a=_Ax         }     </fr:tex></fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>746</fr:anchor><fr:addr type="machine">#333</fr:addr><fr:route>unstable-333.xml</fr:route><fr:title text="Path Induction / Identification Elimination"><fr:strong>Path Induction / Identification Elimination</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    The induction principle of the identity type states that
    for any type family <fr:tex display="inline">P(x,p)</fr:tex> indexed by <fr:tex display="inline">x:A</fr:tex> and <fr:tex display="inline">p:a=_Ax</fr:tex>,
    <fr:tex display="block">         \text {ind-eq}_{a}:P(a, \text {refl}_a)\to  (x:A)\to  (p:a=_Ax)\to  P(x,p)     </fr:tex>
    satisfies <fr:tex display="inline">\text {ind-eq}_{a}(u,a,\text {refl}_a)\equiv  u</fr:tex> where <fr:tex display="inline">u:P(a,\text {refl}_a)</fr:tex>.
    Formally we can write:
    <fr:tex display="block">         \frac {             \Gamma \vdash  a:A,\quad  \Gamma ,x:A,p:a=_Ax\vdash  P(x,p)\space \text {type}         }{             \Gamma \vdash  \text {ind-eq}_{a}(a,\text {refl}_a): P(a,\text {refl}_a) \to  (x:A)\to  (p:a=_Ax)\to  P(x,p)         }\text {eq-elim}     </fr:tex>
    <fr:tex display="block">         \frac {             \Gamma \vdash  a:A,\quad  \Gamma ,x:A,p:a=_Ax\vdash  P(x,p)\space \text {type}         }{             \Gamma ,u:P(a,\text {refl}_a)\vdash  \text {ind-eq}_{a}(u,a,\text {refl}_a)\equiv  u:P(a,\text {refl}_a)         }\text {eq-comp}     </fr:tex>

</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:p>A term of <fr:tex display="inline">a=_Ax</fr:tex> is called a <fr:strong>identification</fr:strong> of <fr:tex display="inline">a</fr:tex> and <fr:tex display="inline">x</fr:tex>,
    or the <fr:strong>path</fr:strong> from <fr:tex display="inline">a</fr:tex> to <fr:tex display="inline">x</fr:tex>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>747</fr:anchor><fr:addr type="machine">#334</fr:addr><fr:route>unstable-334.xml</fr:route><fr:title text="Variable Version"><fr:strong>Variable Version</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    We can form an identity type with variables of <fr:tex display="inline">A</fr:tex>.
    <fr:tex display="block">         \Gamma ,x:A,y:A\vdash  x=_Ay\space \text {type}     </fr:tex>
    with the following introduction rule:
    <fr:tex display="block">         \frac {             \Gamma ,x:A\vdash  x:A         }{             \Gamma ,x:A\vdash  \text {refl}_x:x=_Ax         }     </fr:tex>
    and similarly the elimination rule and computation rule.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>748</fr:anchor>
                    <fr:addr type="machine">#274</fr:addr>
                    <fr:route>unstable-274.xml</fr:route>
                    <fr:title text="The groupoid structure of types">The groupoid structure of types</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>31</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The identifications can be <fr:strong>concatenated</fr:strong> and <fr:strong>inverted</fr:strong>,
        which implies the <fr:em>transitivity</fr:em> and <fr:em>symmetry</fr:em> of the identity type.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>749</fr:anchor>
                        <fr:addr type="user">def-002O</fr:addr>
                        <fr:route>def-002O.xml</fr:route>
                        <fr:title text="Concatenation Operation">Concatenation Operation</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Let <fr:tex display="inline">A</fr:tex> be a type.
    The <fr:strong>Concatenation</fr:strong> operation is defined:
    <fr:tex display="block">         \text {concat}: (x:A)\to  (y:A)\to  (z:A)\to  (x=_Ay)\to  (y=_Az)\to  (x=_Az)     </fr:tex></fr:p>
                        <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                          <fr:frontmatter>
                            <fr:anchor>750</fr:anchor>
                            <fr:addr type="machine">#332</fr:addr>
                            <fr:route>unstable-332.xml</fr:route>
                            <fr:title text="Construction of Concatenation">Construction of Concatenation</fr:title>
                            <fr:authors></fr:authors>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <fr:p>We can first construct:
        <fr:tex display="block">             f(x):(y:A)\to  (x=_Ay)\to (z:A)\to  (y=_Az)\to (x=_Az)         </fr:tex>
        For any <fr:tex display="inline">x:A</fr:tex>, it suffices to construct
        <fr:tex display="block">             f(x,x,\text {refl}_x) : (z:A) \to  (x=_Az)\to (x=_Az)         </fr:tex>
        That is the identity function <fr:tex display="inline">\lambda  z. \text {id}_{x=_Az}</fr:tex>.
        Then we can define by induction:
        <fr:tex display="block">             f(x) :\equiv  \text {ind-eq}_{x}(\lambda  z.\text {id})         </fr:tex>
        Finally:
        <fr:tex display="block">             \text {concat}_{x,y,z}(p,q) :\equiv  f(x,y,p,z,q)         </fr:tex>
        Or simply we denote <fr:tex display="inline">\text {concat}(p,q)</fr:tex> as <fr:tex display="inline">p \cdot  q</fr:tex></fr:p>
                          </fr:mainmatter>
                          <fr:backmatter></fr:backmatter>
                        </fr:tree>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>751</fr:anchor>
                        <fr:addr type="user">def-002P</fr:addr>
                        <fr:route>def-002P.xml</fr:route>
                        <fr:title text="Inverse Operation">Inverse Operation</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Let <fr:tex display="inline">A</fr:tex> be a type. The <fr:strong>inverse oepration</fr:strong> is defined:
    <fr:tex display="block">         \text {inv}: (x:A)\to  (y:A)\to  (x=_Ay)\to  (y=_Ax)     </fr:tex>
    Most of the time we write <fr:tex display="inline">p^{-1}</fr:tex> for <fr:tex display="inline">\text {inv}(p)</fr:tex>.</fr:p>
                        <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                          <fr:frontmatter>
                            <fr:anchor>752</fr:anchor>
                            <fr:addr type="machine">#331</fr:addr>
                            <fr:route>unstable-331.xml</fr:route>
                            <fr:title text="Construction of Inverse">Construction of Inverse</fr:title>
                            <fr:authors></fr:authors>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <fr:p>By induction, it suffices to construct:
        <fr:tex display="block">             \text {inv}(x,x,\text {refl}_x) : (x=_Ax)         </fr:tex>
        for any <fr:tex display="inline">x:A</fr:tex>. And trivially we have <fr:tex display="inline">\text {inv}(x,x,\text {refl}_x)\equiv \text {refl}_x</fr:tex>.</fr:p>
                          </fr:mainmatter>
                          <fr:backmatter></fr:backmatter>
                        </fr:tree>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>It is natural to ask whether the identity type is <fr:em>reflexive</fr:em>.
        In the case of associativity we should ask to compare the identifications:
        <fr:tex display="block">             (p\cdot  q)\cdot  r \quad \text {and}\quad  p\cdot (q\cdot  r)         </fr:tex>
        for any <fr:tex display="inline">p:x=y</fr:tex>, <fr:tex display="inline">q:y=z</fr:tex> and <fr:tex display="inline">r:z=w</fr:tex> in a type <fr:tex display="inline">A</fr:tex>. Both <fr:tex display="inline"> (p\cdot  q)\cdot  r</fr:tex> and 
        <fr:tex display="inline">p\cdot (q\cdot  r)</fr:tex> are elements of type <fr:tex display="inline">x=w</fr:tex>. We can ask whether there is an
        identification
        <fr:tex display="block">             (p\cdot  q)\cdot  r = p\cdot (q\cdot  r)         </fr:tex></fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>753</fr:anchor>
                        <fr:addr type="user">def-002W</fr:addr>
                        <fr:route>def-002W.xml</fr:route>
                        <fr:title text="Associator">Associator</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter><fr:p>Let <fr:tex display="inline">A</fr:tex> be a type.
    These are 3 consecutive identifications
    <fr:tex display="block">         p:x=_Ay,q:y=_Az, r:z=_Aw     </fr:tex>
    we define the <fr:strong>associator</fr:strong>:
    <fr:tex display="block">         \text {assoc}: (p,q,r): (p\cdot  q)\cdot  r = p\cdot  (q\cdot  r)     </fr:tex></fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>754</fr:anchor><fr:addr type="machine">#326</fr:addr><fr:route>unstable-326.xml</fr:route><fr:title text="
    Construction of Associator
">
    <fr:strong>Construction of Associator</fr:strong>
</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    By definition it suffices to show that
    <fr:tex display="block">         \Pi _{(z:A)}\Pi _{(q:x=_Az)}         \Pi _{(w:A)}\Pi _{(r:z=_Aw)}         (\text {refl}_x\cdot  q)\cdot  r = \text {refl}_x\cdot  (q\cdot  r)     </fr:tex>
    Let <fr:tex display="inline">q:x=_Az</fr:tex> and <fr:tex display="inline">r:z=_Aw</fr:tex>. By computation rule of identity types
    <fr:tex display="block">         \text {refl}_x\cdot  q \equiv  q     </fr:tex>
    Then we can conclude that
    <fr:tex display="block">         (\text {refl}_x\cdot  q)\cdot  r \equiv  q\cdot  r     </fr:tex>
    similarly <fr:tex display="inline">\text {refl}_x\cdot  (q\cdot  r) \equiv  q\cdot  r</fr:tex>.
    Hence we have the left and right side
    <fr:tex display="block">         (\text {refl}_x\cdot  q)\cdot  r = \text {refl}_x\cdot  (q\cdot  r)     </fr:tex>
    are judgementally equal, 
    so we can simply define the associator as
    <fr:tex display="block">         \text {assoc}(\text {refl}_x,q,r) :\equiv  \text {refl}_{q\cdot  r}     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>755</fr:anchor>
                        <fr:addr type="user">def-002X</fr:addr>
                        <fr:route>def-002X.xml</fr:route>
                        <fr:title text="Unit Law Operations">Unit Law Operations</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter><fr:p>Let <fr:tex display="inline">A</fr:tex> be a type.
    We defined the <fr:strong>unit law</fr:strong> operations for <fr:tex display="inline">x=_Ay</fr:tex>:
    <fr:tex display="block">         \begin {align*}             \text {left-unit} &amp; : (x=_Ay)\to  (\text {refl}_x\cdot  x = x) \\             \text {right-unit} &amp; : (x=_Ay)\to  (x\cdot \text {refl}_y = x)         \end {align*}     </fr:tex></fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>756</fr:anchor><fr:addr type="machine">#325</fr:addr><fr:route>unstable-325.xml</fr:route><fr:title text="
    Construction of Unit Law
">
    <fr:strong>Construction of Unit Law</fr:strong>
</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    By elimination it suffices to construct:
    <fr:tex display="block">         \begin {align*}             \text {left-unit}(\text {refl}_x) &amp;: \text {refl}_x \cdot  \text {refl}_x = \text {refl}_x \\             \text {right-unit}(\text {refl}_x) &amp;: \text {refl}_x \cdot  \text {refl}_x = \text {refl}_x         \end {align*}     </fr:tex>
    In both cases we need only to construct <fr:tex display="inline">\text {refl}_{\text {refl}_x}</fr:tex>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>757</fr:anchor>
                    <fr:addr type="machine">#275</fr:addr>
                    <fr:route>unstable-275.xml</fr:route>
                    <fr:title text="The action on identifications of functions">The action on identifications of functions</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>31</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Every function preserves identifications.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>758</fr:anchor>
                        <fr:addr type="user">def-004C</fr:addr>
                        <fr:route>def-004C.xml</fr:route>
                        <fr:title text="Action on Paths">Action on Paths</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Let <fr:tex display="inline">f:A\to  B</fr:tex> be a map. We define the <fr:strong>action on paths</fr:strong> of <fr:tex display="inline">f</fr:tex> as an operation:
    <fr:tex display="block">         \text {ap}_f : \prod _{x,y:A} (x=y) \to  (f(x)=f(y))     </fr:tex>
    This can be defined by induction principle of identity types:
    <fr:tex display="block">         \text {ap}_f(\text {refl}_x) \equiv  \text {refl}_{f(x)}     </fr:tex>
    And there are operations:
    <fr:tex display="block">         \text {ap-id}_A:       \prod _{(x,y:A)}\prod _{(p:x=y)} p = \text {ap}_{\text {id}_A}(p)     </fr:tex>
    Taking
    <fr:tex display="block">         \text {ap-id}_A(\text {refl}_x) \equiv  \text {refl}_{\text {refl}_x}     </fr:tex>
    Finally we can construct
    <fr:tex display="block">         \text {ap-comp}(f, g): \prod _{(x,y:A)}\prod _{(p:x=y)} \text {ap}_{f\circ  g}(p) = \text {ap}_f(\text {ap}_g(p))     </fr:tex>
    by taking
    <fr:tex display="block">         \text {ap-comp}(f,g,\text {refl}_x) \equiv  \text {refl}_{\text {refl}_{g(f(x))}}     </fr:tex>
    There are identifications:
    <fr:ul><fr:li>Notice that we have <fr:tex display="inline">\text {ap-id}_A(\text {refl}_x) \equiv  \text {refl}_{\text {refl}_x}</fr:tex> so
            <fr:tex display="block">                 \begin {align*}                     \text {ap-refl}(f,x) &amp;:\text {ap}_f(\text {refl}_x) = \text {refl}_{f(x)} \\                     \text {ap-refl}(f,x) &amp;\equiv  \text {refl}_{\text {refl}_{f(x)}}                 \end {align*}             </fr:tex></fr:li>
        <fr:li>The <fr:tex display="inline">\text {ap-inv}</fr:tex> can be constructed by identification elimination on <fr:tex display="inline">p</fr:tex>.
            <fr:tex display="block">                 \begin {align*}                     &amp;\text {ap-inv}(f,p):\text {ap}_f(p^{-1}) = \text {ap}_f(p)^{-1}\\                     &amp;\text {ap-inv}(f,\text {refl}_x)\equiv  \text {refl}_{\text {ap}_f(\text {refl}_x)}                 \end {align*}             </fr:tex></fr:li>
        <fr:li>Similarly, the <fr:tex display="inline">\text {ap-concat}</fr:tex> can be constructed by identification elimination on <fr:tex display="inline">p</fr:tex>.
            <fr:tex display="block">                 \begin {align*}                     &amp;\text {ap-concat}(f,p,q):\text {ap}_f(p\cdot  q) = \text {ap}_f(p)\cdot  \text {ap}_f(q) \\                     &amp;\text {ap-concat}(f,\text {refl}_x,q)\equiv  \text {refl}_{\text {ap}_f(q)}                 \end {align*}             </fr:tex></fr:li></fr:ul></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>To construct dependent action on paths if a dependent function <fr:tex display="inline">f:\Pi _{(x:A)}B(x)</fr:tex>.
        We need a <fr:strong>transport</fr:strong> because type theory can not distinguish between identified 
        elements from different types.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>759</fr:anchor>
                        <fr:addr type="user">def-004D</fr:addr>
                        <fr:route>def-004D.xml</fr:route>
                        <fr:title text="Transport">Transport</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Let <fr:tex display="inline">A</fr:tex> be a type and let <fr:tex display="inline">B</fr:tex> be a type family over <fr:tex display="inline">A</fr:tex>.
    The <fr:strong>transport</fr:strong> operation is defined:
    <fr:tex display="block">         \text {tr}_B:\Pi _{(x,y:A)}(x=y)\to  B(x)\to  B(y)     </fr:tex>
    Simply induction on <fr:tex display="inline">p:x=y</fr:tex> we can construct:
    <fr:tex display="block">         \text {tr}_B(\text {refl}_x) \equiv  \text {id}_{B(x)}     </fr:tex></fr:p>
                        <fr:p>Now for a given dependent function <fr:tex display="inline">f:\Pi _{(a:A)}B(a)</fr:tex> and an identification
    <fr:tex display="inline">p:x=y</fr:tex> in <fr:tex display="inline">A</fr:tex> we can construct
    <fr:tex display="block">         \text {apd}_f(p) : \text {tr}_B(p,f(x)) = f(y)     </fr:tex>
    this can be constructed by the induction principle for identity types,
    it suffices to construct an identification:
    <fr:tex display="block">         \text {apd}_f(\text {refl}_x) : \text {tr}_B(\text {refl}_x,f(x)) = f(x)     </fr:tex>
    which is simply done by taking <fr:tex display="inline">\text {apd}_f(\text {refl}_x)\equiv \text {refl}_{f(x)}</fr:tex></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>760</fr:anchor>
                    <fr:addr type="machine">#276</fr:addr>
                    <fr:route>unstable-276.xml</fr:route>
                    <fr:title text="Uniqueness of refl">Uniqueness of refl</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>31</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p>The identity type is an inductive family of types.
        For instance, while the type <fr:tex display="inline">a=x</fr:tex> indexed by <fr:tex display="inline">x:A</fr:tex> is inductively generated by <fr:tex display="inline">\text {refl}_a</fr:tex>,
        the type <fr:tex display="inline">a=a</fr:tex> is <fr:strong>not</fr:strong>, because the endpoint of <fr:tex display="inline">p:a=a</fr:tex> is not free. 
        We want to show that <fr:tex display="inline">p=\text {refl}_a</fr:tex> for all <fr:tex display="inline">p:a=a</fr:tex>.</fr:p><fr:p>Nevertheless the identity type <fr:tex display="inline">a=x</fr:tex> is generated by a single element <fr:tex display="inline">\text {refl}_a:a=a</fr:tex>,
        so it is natural to wonder in <fr:em>what sense</fr:em> the reflexivity identification is unique.
        We prove that only one pair <fr:tex display="inline">(a,\text {refl}_a)</fr:tex> is unique in the type of all pairs:
        <fr:tex display="block">             (x,p):\Sigma _(x:A) a = x          </fr:tex>
        We restate this as a proposition: Consider an element <fr:tex display="inline">a:A</fr:tex>. Then there is an identification
        <fr:tex display="inline">(a, \text {refl}_a = y)</fr:tex> in the type <fr:tex display="inline">\Sigma _(x:A) a = x</fr:tex> for any <fr:tex display="inline">y:\Sigma _(x:A) a = x </fr:tex></fr:p>
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>761</fr:anchor><fr:addr type="machine">#277</fr:addr><fr:route>unstable-277.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>31</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        By <fr:tex display="inline">\Sigma </fr:tex> induction it suffices to show that there is an identification
        <fr:tex display="block">             (a, \text {refl}_a) = (x, p)         </fr:tex>
        forall <fr:tex display="inline">x:A</fr:tex> and <fr:tex display="inline">p:a=x</fr:tex>. Then perform the induction principle of identity types.
        It suffices to show that
        <fr:tex display="block">             (a,\text {refl}_a) = (a, \text {refl}_a)         </fr:tex>
        which can be obtained by reflexivity.
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 
</fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>762</fr:anchor>
                <fr:addr type="user">tt-0006</fr:addr>
                <fr:route>tt-0006.xml</fr:route>
                <fr:title text="Universe">Universe</fr:title>
                <fr:taxon>Type Theory</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>6</fr:month>
                  <fr:day>14</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>This post discuss the universe in type theory,
    based on Egbert Rijke&apos;s <fr:link type="local" href="hott-2022.xml" addr="hott-2022" title="Introduction to Homotopy Type Theory">Introduction to Homotopy Type Theory</fr:link> and <fr:link type="local" href="ncatlab.xml" addr="ncatlab" title="NLab">NLab</fr:link>.
    In this post, we regard universe as the representation of types in an internal model 
    of the type theory (<fr:strong>Tarski universe</fr:strong> or <fr:strong>universe à la Tarski</fr:strong>).</fr:p>
                <fr:p>A universe consist of a type <fr:tex display="inline">\mathcal {U}</fr:tex> with a type family <fr:tex display="inline">\mathcal {T}</fr:tex> over <fr:tex display="inline">\mathcal {U}</fr:tex>.
    Forall <fr:tex display="inline">X:\mathcal {U}</fr:tex> we think of <fr:tex display="inline">X</fr:tex> as an <fr:strong>encoding</fr:strong> (representation) of the actual type <fr:tex display="inline">\mathcal {T}(X)</fr:tex>.
    The type family <fr:tex display="inline">\mathcal {T}</fr:tex> is therefore called a <fr:strong>unversal type family</fr:strong>.</fr:p>
                <fr:p>There several reasons to equip type theory with universes.
    It enables us to define new type families over inductive types, using induction principle.
    For instance, we can define <fr:strong>relations</fr:strong> over <fr:tex display="inline">\mathbb {N}</fr:tex>, such as ordering relations <fr:tex display="inline">\leq </fr:tex>.
    We will soon meet the idea of <fr:strong>observational equality</fr:strong> for a particular type, different from identity types.
    Another reason is that it allows us to define types equipped with structure such as group.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>763</fr:anchor>
                    <fr:addr type="machine">#272</fr:addr>
                    <fr:route>unstable-272.xml</fr:route>
                    <fr:title text="Specification">Specification</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>6</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>764</fr:anchor>
                        <fr:addr type="user">def-004E</fr:addr>
                        <fr:route>def-004E.xml</fr:route>
                        <fr:title text="Tarski Universe">Tarski Universe</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>A <fr:strong>universe</fr:strong> consists of a type <fr:tex display="inline">\mathcal {U}</fr:tex> of which the elements are representations of types.
    It is equipped with a type family <fr:tex display="inline">\mathcal {T}</fr:tex> indexed by <fr:tex display="inline">\mathcal {U}</fr:tex> called <fr:strong>universal type family</fr:strong>.
    The universe is closed under all the type constructors in the sense that it comes equipped with the following structure:
    <fr:ul><fr:li><fr:tex display="inline">\mathcal {U}</fr:tex> is closed under <fr:tex display="inline">\Pi </fr:tex>, equipped with a function
            <fr:tex display="block">                 \check {\Pi }:\Pi _{(X:\mathcal {U})}(\mathcal {T}(X)\to \mathcal {U})\to \mathcal {U}             </fr:tex>
            for which the judgemental equality
            <fr:tex display="block">                 \mathcal {T}(\check {\Pi }(X,P))\equiv \Pi _{(x:\mathcal {T}(X))}\mathcal {T}(P(x))             </fr:tex>
            holds forall <fr:tex display="inline">X:\mathcal {U}</fr:tex> and <fr:tex display="inline">P:\mathcal {T}(X)\to \mathcal {U}</fr:tex>.</fr:li>
        <fr:li><fr:tex display="inline">\mathcal {U}</fr:tex> is closed under <fr:tex display="inline">\Sigma </fr:tex>, equipped with a function
            <fr:tex display="block">                 \check {\Sigma }:\Pi _{(X:\mathcal {U})}(\mathcal {T}(X)\to \mathcal {U})\to \mathcal {U}             </fr:tex>
            for which the judgemental equality
            <fr:tex display="block">                 \mathcal {T}(\check {\Sigma }(X,P))\equiv \Sigma _{(x:\mathcal {T}(X))}\mathcal {T}(P(x))             </fr:tex>
            holds forall <fr:tex display="inline">X:\mathcal {U}</fr:tex> and <fr:tex display="inline">P:\mathcal {T}(X)\to \mathcal {U}</fr:tex>.</fr:li>
        <fr:li><fr:tex display="inline">\mathcal {U}</fr:tex> is closed under identity types, equipped with a function
            <fr:tex display="block">                 \check {I}:\Pi _{(X:\mathcal {U})}\mathcal {T}(X)\to \mathcal {T}(X)\to \mathcal {U}             </fr:tex>
            for which the judgemental equality
            <fr:tex display="block">                 \mathcal {T}(\check {I}(X,x,y))\equiv  (x=y)             </fr:tex>
            holds forall <fr:tex display="inline">X:\mathcal {U}</fr:tex> and <fr:tex display="inline">x,y:\mathcal {T}(X)</fr:tex>.</fr:li>
        <fr:li><fr:tex display="inline">\mathcal {U}</fr:tex> is closed under coproducts, equipped with a function
            <fr:tex display="block">                 \check {+}:\Pi _{(X:\mathcal {U})}(\mathcal {T}(X)\to \mathcal {U})\to \mathcal {U}             </fr:tex>
            that satisfies the judgemental equality <fr:tex display="inline">\mathcal {T}(X\check {+}P)\equiv \mathcal {T}(X)+\mathcal {T}(P)</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">\mathcal {U}</fr:tex> contains elements <fr:tex display="inline">\check {\textbf {1}}, \check {\textbf {0}}, \check {\mathbb {N}} : \mathcal {U}</fr:tex> that satisfies the judgemental equality
            <fr:tex display="block">                 \mathcal {T}(\check {\textbf {0}})\equiv  \textbf {0},                 \\ \mathcal {T}(\check {\textbf {1}})\equiv  \textbf {1},                 \\ \mathcal {T}(\check {\mathbb {N}})\equiv \mathbb {N}             </fr:tex></fr:li></fr:ul>
    Consider a universe <fr:tex display="inline">\mathcal {U}</fr:tex> and a type <fr:tex display="inline">A</fr:tex> in context <fr:tex display="inline">\Gamma </fr:tex>.
    We say that <fr:tex display="inline">A</fr:tex> is a type in <fr:tex display="inline">\mathcal {U}</fr:tex> or that <fr:tex display="inline">\mathcal {U}</fr:tex> contains <fr:tex display="inline">A</fr:tex>,
    if there is an element <fr:tex display="inline">\check {A}:\mathcal {U}</fr:tex> such that <fr:tex display="inline">\Gamma \vdash \mathcal {T}(\check {A})\equiv  A\space \space \text {type}</fr:tex> holds.</fr:p>
                        <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                          <fr:frontmatter>
                            <fr:anchor>765</fr:anchor>
                            <fr:addr type="machine">#320</fr:addr>
                            <fr:route>unstable-320.xml</fr:route>
                            <fr:title text="Enough Universe">Enough Universe</fr:title>
                            <fr:authors></fr:authors>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <fr:p>Sometimes we may consider the universe <fr:tex display="inline">\mathcal {U}</fr:tex> itself to be a type in some universes.
        If we have only one <fr:tex display="inline">\mathcal {U}</fr:tex>, the <fr:strong>Russell Paradox</fr:strong> may arise.
        Therefore we assume that there are <fr:strong>enough universes</fr:strong></fr:p>
                          </fr:mainmatter>
                          <fr:backmatter></fr:backmatter>
                        </fr:tree>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>766</fr:anchor>
                        <fr:addr type="user">thm-0013</fr:addr>
                        <fr:route>thm-0013.xml</fr:route>
                        <fr:title text="Enough Universe">Enough Universe</fr:title>
                        <fr:taxon>Postulate</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>We assume that there&apos;re <fr:strong>enough universe</fr:strong>, i.e.,
    for every finite list of types in context 
    <fr:tex display="block">         \Gamma _1\vdash  A_1\space \space \text {type},\cdots ,\Gamma _n\vdash  A_n\space \space \text {type}     </fr:tex>
    there is a universe <fr:tex display="inline">\mathcal {U}</fr:tex> that contains each <fr:tex display="inline">A_i</fr:tex> in the sense that <fr:tex display="inline">\mathcal {U}</fr:tex> comes equipped with
    <fr:tex display="block">         \Gamma _i\vdash \check {A_i}:\mathcal {U}     </fr:tex>
    for which the following judgement holds:
    <fr:tex display="block">         \Gamma _i \vdash \mathcal {T}(\check {A_i})\equiv  A_i\space \space \text {type}     </fr:tex></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>Using the assumption we can obtain many specific universes.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>767</fr:anchor>
                        <fr:addr type="user">def-004F</fr:addr>
                        <fr:route>def-004F.xml</fr:route>
                        <fr:title text="Base Universe">Base Universe</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>The <fr:strong>base universee</fr:strong> <fr:tex display="inline">\mathcal {U}_0</fr:tex> is defined using <fr:link type="local" href="thm-0013.xml" addr="thm-0013" title="Enough Universe">universe postulate</fr:link>
    with empty context.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>768</fr:anchor>
                        <fr:addr type="user">def-004G</fr:addr>
                        <fr:route>def-004G.xml</fr:route>
                        <fr:title text="Successor Universe">Successor Universe</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>The <fr:strong>successor universee</fr:strong> <fr:tex display="inline">\mathcal {U}^+</fr:tex> of a universe <fr:tex display="inline">\mathcal {U}</fr:tex> is defined using <fr:link type="local" href="thm-0013.xml" addr="thm-0013" title="Enough Universe">universe postulate</fr:link>
    with the following contexts:
    <fr:tex display="block">         \vdash \mathcal {U}\space \space \text {type}\quad  X:\mathcal {U}\vdash \mathcal {T}(X)\space \space \text {type}     </fr:tex>
    It therefore contains the type <fr:tex display="inline">\mathcal {U}</fr:tex> as well as type in <fr:tex display="inline">\mathcal {U}</fr:tex>, in the following sense
    <fr:tex display="block">         \begin {align*}             &amp;\vdash \check {\mathcal {U}}:\mathcal {U}^+\\              &amp;\vdash \mathcal {T}^+(\check {\mathcal {U}})\equiv \mathcal {U}\space \text {type}\\             &amp;X:\mathcal {U}\vdash \check {\mathcal {T}}(X):\mathcal {U}^+\\              &amp;X:\mathcal {U}\vdash \mathcal {T}^+(\check {\mathcal {T}}(X))\equiv \mathcal {T}(X)\space \text {type}          \end {align*}     </fr:tex></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>Using successor universes we can create an infinite tower of universes.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>769</fr:anchor>
                    <fr:addr type="machine">#273</fr:addr>
                    <fr:route>unstable-273.xml</fr:route>
                    <fr:title text="Observational Equality">Observational Equality</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>6</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Now we give the example of <fr:strong>observational equality</fr:strong> of <fr:tex display="inline">\mathbb {N}</fr:tex>.
        The key idea is to define a recursive function that reduce the arguments.
        Observational equality an inductively defined relation, which gives us an algorithm for checking
        equality on  <fr:tex display="inline">\mathbb {N}</fr:tex>. It can be used to show that equality of natural numbers is <fr:strong>decidable</fr:strong>.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>770</fr:anchor>
                        <fr:addr type="user">def-004H</fr:addr>
                        <fr:route>def-004H.xml</fr:route>
                        <fr:title text="Observational Equality of {N}">Observational Equality of <fr:tex display="inline">\mathbb {N}</fr:tex></fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>The observational equality of <fr:tex display="inline">\mathbb {N}</fr:tex> is a binary relation <fr:tex display="inline">\text {Eq}_\mathbb {N}:\mathbb {N}\to (\mathbb {N}\to \mathcal {U}_0)</fr:tex> satisfies
    <fr:tex display="block">         \begin {align*}             \text {Eq}_\mathbb {N}(0)(0) &amp;\equiv  \textbf {1} \\             \text {Eq}_\mathbb {N}(0)(\text {succ}(n)) &amp;\equiv  \textbf {0} \\             \text {Eq}_\mathbb {N}(\text {succ}(m))(0) &amp;\equiv  \textbf {0} \\             \text {Eq}_\mathbb {N}(\text {succ}(m))(\text {succ}(n)) &amp;\equiv  \text {Eq}_\mathbb {N}(m)(n)         \end {align*}     </fr:tex>
    
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>771</fr:anchor><fr:addr type="machine">#319</fr:addr><fr:route>unstable-319.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        We define <fr:tex display="inline">\text {Eq}</fr:tex> by double induction on <fr:tex display="inline">\mathbb {N}</fr:tex>. By the first application of induction
        it suffices to provide
        <fr:tex display="block">             \begin {align*}                 &amp;E_0:\mathbb {N}\to \mathcal {U}_0 \\                  &amp;E_S:\mathbb {N}\to ((\mathbb {N}\to \mathcal {U}_0)\to (\mathbb {N}\to \mathcal {U}_0))             \end {align*}         </fr:tex>
        we define <fr:tex display="inline">E_0</fr:tex> by induction:
        <fr:tex display="block">             \begin {align*}                 &amp;E_0(0) \equiv \textbf {1}\\                  &amp;E_0(\text {succ}(n)) \equiv \textbf {0}             \end {align*}         </fr:tex>
        and also define <fr:tex display="inline">E_S</fr:tex> by induction:
        <fr:tex display="block">             \begin {align*}                 &amp;E_S(n,X,0)\equiv \textbf {0}\\                  &amp;E_S(n,X,\text {succ}(m))\equiv  X(m)             \end {align*}         </fr:tex>
        Therefore we have by the computation rule for the first induction that 
        the following judgemental equality holds.
        <fr:tex display="block">             \begin {align*}                 \text {Eq}(0,m) &amp;\equiv  E_0(m) \\                 \text {Eq}(\text {succ}(n),m) &amp;\equiv  E_S(n,\text {Eq}(n),m)             \end {align*}         </fr:tex>
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>Observational equality of <fr:tex display="inline">\mathbb {N}</fr:tex> is a reflexive relation, i.e. we have
        <fr:tex display="block">             \text {refl-Eq}_\mathbb {N}:\Pi _{(n:\mathbb {N})}\text {Eq}_\mathbb {N}(n,n)         </fr:tex>
        which is witnessed by induction on <fr:tex display="inline">n</fr:tex>.
        <fr:tex display="block">             \begin {align*}                 \text {refl-Eq}_\mathbb {N}(0) &amp;\equiv \star  \\                  \text {refl-Eq}_\mathbb {N}(\text {succ}(n)) &amp;\equiv \text {refl-Eq}_\mathbb {N}(n)             \end {align*}         </fr:tex></fr:p>
                    <fr:p>This leads to an interesting dual perspective on equality. 
        For any two natural numbers <fr:tex display="inline">m</fr:tex> and <fr:tex display="inline">n</fr:tex> we have
        <fr:tex display="block">             (m=n)\leftrightarrow \text {Eq}_\mathbb {N}(m,n)         </fr:tex></fr:p>
                    <fr:p>Using the observational equality of <fr:tex display="inline">\mathbb {N}</fr:tex> we can prove Peano&apos;s seventh and eighth
        axioms.
        <fr:ul><fr:li>For any two natural numbers <fr:tex display="inline">m</fr:tex> and <fr:tex display="inline">n</fr:tex> we have 
                <fr:tex display="block">                     (m = n)\leftrightarrow (\text {succ}(m) = \text {succ}(n))                 </fr:tex></fr:li>
            <fr:li>For any natural number <fr:tex display="inline">n</fr:tex> we have <fr:tex display="inline">0 \not = \text {succ}(n)</fr:tex></fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>772</fr:anchor>
                <fr:addr type="user">phy-0002</fr:addr>
                <fr:route>phy-0002.xml</fr:route>
                <fr:title text="The Wave Function">The Wave Function</fr:title>
                <fr:taxon>Quantum Mechanics</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>3</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter><fr:p>This post introduces the concept of the wave function in quantum mechanics.
    Refer to <fr:link type="local" href="quantum-2018.xml" addr="quantum-2018" title="Introduction to Quantum Mechanics">Introduction to Quantum Mechanics</fr:link>.</fr:p><fr:p>Consider a particle of mass <fr:tex display="inline">m</fr:tex> moving along <fr:tex display="inline">x</fr:tex>-axis
    subject to force <fr:tex display="inline">F(x, t)</fr:tex>.
    With Newton&apos;s second law, we have:
    <fr:tex display="block">         F = ma     </fr:tex>
    For <fr:strong>conservative systems</fr:strong>, the force
    can be expressed as the derivative of a <fr:strong>potential energy</fr:strong>.
    <fr:tex display="block">         F = -\frac {\partial  V}{\partial  x}     </fr:tex>
    Now the equation of motion becomes:
    <fr:tex display="block">         m \frac {d^2x}{dt^2} = -\frac {\partial  V}{\partial  x}     </fr:tex>
    With appropriate initial conditions we can determine the <fr:tex display="inline">x(t)</fr:tex>,
    this is what we normally do in classic mechanics.</fr:p><fr:p>For <fr:strong>Quantum Mechanics</fr:strong>, we have a different perspective.
    We would like to look for the <fr:strong>wave function</fr:strong>, <fr:tex display="inline">\Psi (x, t)</fr:tex>.
    To determine it we need to solve the <fr:strong>Schrodinger equation</fr:strong>.
    <fr:tex display="block">         i\hbar \frac {\partial }{\partial  t}\Psi (x,t) = -\frac {\hbar ^2}{2m}\frac {\partial ^2\Psi (x,t)}{\partial  x^2} + V(x,t)\Psi (x,t)     </fr:tex></fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>773</fr:anchor><fr:addr type="user">def-0030</fr:addr><fr:route>def-0030.xml</fr:route><fr:title text="Schrodinger&apos;s equation">Schrodinger&apos;s equation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>Schrodinger equation</fr:strong> is a linear partial differential equation that describes the wave function of a quantum system.
    It is given by (the general form):
    <fr:tex display="block">         i\hbar \frac {\partial }{\partial  t}\Psi (\vec {r},t) = \hat {H}\Psi (\vec {r},t)     </fr:tex>
    where:
    <fr:ul><fr:li><fr:tex display="inline">\Psi (\vec {r},t)</fr:tex> is the wave function of the quantum system.</fr:li>
        <fr:li><fr:tex display="inline">\hat {H}</fr:tex> is the <fr:strong>Hamiltonian operator</fr:strong>.</fr:li>
        <fr:li><fr:tex display="inline">\hbar  = 1.054573\times 10^{-34}\text {Js} </fr:tex> is the reduced <fr:strong>Planck constant</fr:strong>.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The role of Schrodinger equation is similar to the role of Newton&apos;s second law in classic mechanics.
    Given proper initial conditions,
    we can determine <fr:tex display="inline">\Psi (x, t)</fr:tex> for all the future time.</fr:p><fr:p>The wave function is quite odd, what information does it carry?
    The wave function is <fr:em>spread out</fr:em> in space.
    How can this be related to the <fr:strong>state</fr:strong> of a particle.</fr:p><fr:p><fr:strong>Born&apos;s statistical interpretation</fr:strong> of the wave function provides an answer.
    For a fixed time <fr:tex display="inline">t</fr:tex>, the probability of finding the particle in the interval <fr:tex display="inline">[a, b]</fr:tex> is given by:
    <fr:tex display="block">         P(a, b) = \int _a^b |{\Psi (x, t)}|^2 dx     </fr:tex></fr:p><fr:p>Here is where the quantum mechanics differs from classic mechanics and behaves weirdly.
    The wave function is not a deterministic function, but a <fr:em>statistical</fr:em> function, which 
    is an <fr:strong>indeterministic</fr:strong> interpretation.</fr:p><fr:p>Suppose I do <fr:strong>measure</fr:strong> the position of the particle,
    and find it at <fr:tex display="inline">\vec {r}_0</fr:tex>.
    Then where it was before the measurement?
    There are many interpretations of this question,
    and I will explain three of them.</fr:p><fr:p><fr:ul><fr:li><fr:strong>Realist interpretation</fr:strong>: The particle has a definite position before the measurement, just at <fr:tex display="inline">\vec {r}_0</fr:tex> but we just don&apos;t know it.</fr:li>
        <fr:li><fr:strong>Orthodox interpretation</fr:strong>: The particle doesn&apos;t have a <fr:em>definite</fr:em> position before the measurement, it is in a <fr:strong>superposition</fr:strong> of all possible positions.
        This is also called the <fr:strong>Copenhagen interpretation</fr:strong>.</fr:li>
        <fr:li><fr:strong>Agnostic interpretation</fr:strong>: The question is meaningless, refuse to answer.</fr:li></fr:ul></fr:p><fr:p>Nowadays, the Copenhagen interpretation is the most widely accepted interpretation.
    The particle does not have a definite position before the measurement.
    The operation of measurement <fr:strong>collapses</fr:strong> the wave function to a definite position.</fr:p><fr:p>Probability is the key concept in quantum mechanics.
    Now I will introduce some terimnologies related to continuous probability.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>774</fr:anchor><fr:addr type="user">def-0031</fr:addr><fr:route>def-0031.xml</fr:route><fr:title text="Probability Density">Probability Density</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>probability density</fr:strong> is a function <fr:tex display="inline">p(x)</fr:tex> such that:
    <fr:ul><fr:li><fr:tex display="inline">p(x)\geq  0</fr:tex> for all <fr:tex display="inline">x</fr:tex>.</fr:li>
        <fr:li><fr:tex display="inline">\int _{-\infty }^{\infty } p(x)dx = 1</fr:tex>.</fr:li></fr:ul>
    With this we can define the <fr:strong>probability function</fr:strong> in an interval <fr:tex display="inline">[a,b]</fr:tex> as:
    <fr:tex display="block">         P(a, b) = \int _a^b p(x)dx     </fr:tex></fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>775</fr:anchor><fr:addr type="machine">#323</fr:addr><fr:route>unstable-323.xml</fr:route><fr:title text="Expectation Value">Expectation Value</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    The <fr:strong>expectation value</fr:strong> of a function <fr:tex display="inline">f(x)</fr:tex> with respect to the probability density <fr:tex display="inline">p(x)</fr:tex> is defined:
    <fr:tex display="block">         \langle  f(x) \rangle  = \int _{-\infty }^{\infty } f(x)p(x)dx     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>776</fr:anchor><fr:addr type="machine">#324</fr:addr><fr:route>unstable-324.xml</fr:route><fr:title text="Variance">Variance</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    The <fr:strong>variance</fr:strong> of a function <fr:tex display="inline">f(x)</fr:tex> with respect to the probability density <fr:tex display="inline">p(x)</fr:tex> is defined:
    <fr:tex display="block">         \sigma ^2 :\equiv  \langle  x^2 \rangle  - \langle  x \rangle ^2     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Now go back to quantum mechanics.
    We have seen that the squared wave function <fr:tex display="inline">|\Psi (x,t)|^2</fr:tex> is a probability density.
    So it satisfies
    <fr:tex display="block">         \int _{-\infty }^{\infty } |\Psi (x,t)|^2 dx = 1     </fr:tex></fr:p><fr:p>Solve the equations we will get a set of solutions.
    We should pick a proper factor to make the wave function <fr:strong>normalized</fr:strong>.
    But if I have normalized the wave function at time <fr:tex display="inline">t_0</fr:tex>,
    will it stay normalized at all future time?
    Fortunately the Schrodinger equation guarantees the normalization of 
    the wave function.</fr:p>
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>777</fr:anchor><fr:addr type="machine">#303</fr:addr><fr:route>unstable-303.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        Differentiate the normalization condition with respect to time:
        <fr:tex display="block">             \frac {d}{dt}\int _{-\infty }^{\infty } |\Psi (x,t)|^2 dx =              \int _{-\infty }^{\infty } \frac {\partial }{\partial  t}|\Psi (x,t)|^2 dx         </fr:tex>
        With the product rule:
        <fr:tex display="block">             \frac {\partial }{\partial  t}|\Psi (x,t)|^2 =              \frac {\partial }{\partial  t}\Psi (x,t)\Psi ^*(x,t) + \Psi (x,t)\frac {\partial }{\partial  t}\Psi ^*(x,t)         </fr:tex>
        where <fr:tex display="inline">\Psi ^*(x,t)</fr:tex> is the <fr:strong>complex conjugate</fr:strong> of <fr:tex display="inline">\Psi (x,t)</fr:tex>.
        The Schrodinger equation gives
        <fr:tex display="block">             \frac {\partial \Psi }{\partial  t} = \frac {i\hbar }{2m}\frac {\partial ^2\Psi }{\partial  x^2} + \frac {iV}{\hbar }\Psi          </fr:tex>
        and also the complex conjugate
        <fr:tex display="block">             \frac {\partial \Psi ^*}{\partial  t} = -\frac {i\hbar }{2m}\frac {\partial ^2\Psi ^*}{\partial  x^2} + \frac {iV}{\hbar }\Psi ^*         </fr:tex>
        so
        <fr:tex display="block">             \begin {align*}                 \frac {\partial }{\partial  t}|\Psi (x,t)|^2 &amp;=                  \frac {i\hbar }{2m}\left ( \frac {\partial ^2\Psi }{\partial  x^2}\Psi ^* - \frac {\partial ^2\Psi ^*}{\partial  x^2}\Psi  \right )\\                 &amp;= \frac {i\hbar }{2m}\frac {\partial }{\partial  x}\left ( \frac {\partial \Psi }{\partial  x}\Psi ^* - \frac {\partial \Psi ^*}{\partial  x}\Psi  \right )             \end {align*}         </fr:tex>
        Now the integral becomes:
        <fr:tex display="block">             \frac {d}{dt}\int _{-\infty }^{\infty } |\Psi (x,t)|^2 dx =              \frac {i\hbar }{2m}\left ( \Psi \frac {\partial \Psi ^*}{\partial  x} - \Psi ^*\frac {\partial \Psi }{\partial  x} \right )\Big |_{-\infty }^{\infty }         </fr:tex>
        Because the <fr:strong>normalization condition</fr:strong>
        <fr:tex display="block">             \int _{-\infty }^{\infty } |\Psi (x,t)|^2 dx = 1         </fr:tex>
        implies that the wave function vanishes at infinity,
        that is, converges to zero at infinity. Hence we have
        <fr:tex display="block">             \lim _{|x|\to \infty }|\Psi (x,t)| = 0         </fr:tex>
        this indicates that the integral is zero.
        <fr:tex display="block">             \frac {d}{dt}\int _{-\infty }^{\infty } |\Psi (x,t)|^2 dx = 0         </fr:tex>
        Now we can conclude that the wave function stays normalized at all future time.
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 
<fr:p>For a particle in state <fr:tex display="inline">\Psi </fr:tex>, we have defined its <fr:strong>expectation value</fr:strong>:
    <fr:tex display="block">         \langle  x \rangle  = \int _{-\infty }^{\infty } x|\Psi (x,t)|^2 dx     </fr:tex>
    Can we give a meaning to it? Is it the <fr:strong>average</fr:strong> position of the particle? 
    No, the first measurement of the position of the particle will give a definite position,
    and the subsequent measurements will give the same result.</fr:p><fr:p>Actually, the expectation value is the <fr:em>average</fr:em> of 
    repeated measurements on an ensemble of identical prepared systems,
    not the average of repeated measurements on a <fr:em>single</fr:em> system.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>778</fr:anchor><fr:addr type="machine">#304</fr:addr><fr:route>unstable-304.xml</fr:route><fr:title text="Construction."><fr:strong>Construction.</fr:strong></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    As times goes on, the expectation values varies.
    We naturally ask how fast it moves?
    Use simple calculus we can get the answer.
    <fr:tex display="block">         \begin {align*}             \frac {d}{dt}\langle  x \rangle  &amp;= \int _{-\infty }^{\infty } x\frac {\partial }{\partial  t}|\Psi (x,t)|^2 dx \\             &amp;= \frac {i\hbar }{2m}\int _{-\infty }^{\infty } x\frac {\partial }{\partial  x} (\frac {\partial \Psi }{\partial  x}\Psi ^* + \Psi \frac {\partial \Psi ^*}{\partial  x}) dx         \end {align*}     </fr:tex>
    Simplify using integration by parts, we get
    <fr:tex display="block">         \frac {d}{dt}\langle  x \rangle  = -\frac {i\hbar }{2m}\int _{-\infty }^{\infty } \left ( \Psi ^*\frac {\partial \Psi }{\partial  x} - \Psi \frac {\partial \Psi ^*}{\partial  x} \right ) dx     </fr:tex>
    Note that the boundary term was eliminated because the wave function vanishes at infinity.
    Perform integration by parts again on the second term
    <fr:tex display="block">         \langle  v \rangle  :\equiv \frac {d}{dt}\langle  x \rangle  = -\frac {i\hbar }{m}\int _{-\infty }^{\infty } \Psi ^*\frac {\partial \Psi }{\partial  x} dx     </fr:tex>
    Note that we give a name to the integral, <fr:tex display="inline">v</fr:tex>, indicating the <fr:strong>velocity</fr:strong> of the expectation value.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:p>To work with <fr:strong>momentum</fr:strong>, we can define:
    <fr:tex display="block">         \langle  p \rangle  = m \langle  v \rangle  = -i\hbar \int _{-\infty }^{\infty } \Psi ^*\frac {\partial \Psi }{\partial  x} dx     </fr:tex>
    Rewrite as an <fr:strong>operator</fr:strong> form:
    <fr:tex display="block">         \langle  p \rangle  = \int _{-\infty }^{\infty } \Psi ^*\left ( \frac {\hbar }{i}\frac {\partial }{\partial  x} \right )\Psi  dx     </fr:tex>
    Compare with 
    <fr:tex display="block">         \langle  x \rangle  = \int _{-\infty }^{\infty } \Psi ^*(x)\Psi  dx     </fr:tex></fr:p><fr:p>That&apos;s interesting, an operator that acts on the wave function and gives position and momentum.
    We can generalize this to any function of position and momentum.
    Just simply do substitution:
    <fr:tex display="block">         \langle  Q(x,p) \rangle  =          \int _{-\infty }^{\infty } \Psi ^*(x)Q\left ( x, -i\hbar \frac {\partial }{\partial  x} \right )\Psi  dx     </fr:tex>
    Momentum and position are just special cases of this general formula.
    We will give a firmer theoretical foundation to this equation later.
    Now we just use it as an <fr:em>axiom</fr:em>.</fr:p><fr:p>Now we discuss about the <fr:strong>uncertainty principle</fr:strong>.
    The more precise a wave&apos;s position is, the less precise its momentum (or the wavelength) is, and vice versa.
    A theorem in Fourier Analysis gives a precise statement of this principle (explain later).
    For this moment we only concerned with the qualitative argument.</fr:p><fr:p>The wavelength of a wave function <fr:tex display="inline">\Psi </fr:tex> is related to the momentum of the particle.
    This result from the <fr:strong>de Broglie formula</fr:strong>.
    <fr:tex display="block">         p = \frac {h}{\lambda } = \frac {2\pi \hbar }{\lambda }     </fr:tex>
    Now we can give a qualitative argument for the uncertainty principle.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>779</fr:anchor><fr:addr type="user">def-0033</fr:addr><fr:route>def-0033.xml</fr:route><fr:title text="Heisenberg Uncertainty Principle">Heisenberg Uncertainty Principle</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>Heisenberg Uncertainty Principle</fr:strong> states that
    it is impossible to measure simultaneously the position and the momentum of a particle
    with arbitrary precision.
    The product of the uncertainties in position and momentum is bounded by:
    <fr:tex display="block">         \Delta  x \Delta  p \geq  \frac {\hbar }{2}     </fr:tex>
    where <fr:tex display="inline">\Delta  x</fr:tex> and <fr:tex display="inline">\Delta  p</fr:tex> are the uncertainties in position and momentum, respectively.
    The constant <fr:tex display="inline">\hbar </fr:tex> is the reduced Planck constant.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>780</fr:anchor>
                <fr:addr type="user">phy-0003</fr:addr>
                <fr:route>phy-0003.xml</fr:route>
                <fr:title text="Time-independent Schrodinger Equation">Time-independent Schrodinger Equation</fr:title>
                <fr:taxon>Quantum Mechanics</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>4</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter><fr:p>Refer to chapter 2 in <fr:link type="local" href="quantum-2018.xml" addr="quantum-2018" title="Introduction to Quantum Mechanics">Introduction to Quantum Mechanics</fr:link></fr:p><fr:p>In previous section we use the <fr:link type="local" href="def-0030.xml" addr="def-0030" title="Schrodinger&apos;s equation">Schrodinger equation</fr:link> to compute things.
    The variable <fr:tex display="inline">t</fr:tex> is annoying which makes things complicated, and we would like to get rid of it.
    In this section we shall assume that the potential energy <fr:tex display="inline">V</fr:tex> is independent of time.
    In that case the Schrodinger equation becomes:
    <fr:tex display="block">         i\hbar \frac {\partial }{\partial  t}\psi (x,t) = -\frac {\hbar ^2}{2m}\frac {\partial ^2\psi (x,t)}{\partial  x^2} + V(x)\psi (x,t)     </fr:tex>
    This equation can be solved by <fr:strong>separation of variables</fr:strong>.
    We assume the spatial and time dependencies of the solution can be separated.
    In other words we look for solutions of the <fr:em>product form</fr:em>:
    <fr:tex display="block">         \Psi (x,t) = \psi (x)\phi (t)     </fr:tex>
    This is an absurd restriction, but it works and we can get interesting results.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>781</fr:anchor><fr:addr type="machine">#301</fr:addr><fr:route>unstable-301.xml</fr:route><fr:title text="Solve the equation"><fr:strong>Solve the equation</fr:strong></fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>Now substitute the product form into the Schrodinger equation:
        <fr:tex display="block">             i\hbar  \psi (x) \frac {\partial }{\partial  t}(\phi (t)) = -\frac {\hbar ^2}{2m}\phi (t)\frac {\partial ^2(\psi (x))}{\partial  x^2} + V(x)\psi (x)\phi (t)         </fr:tex>
        Divide both sides by <fr:tex display="inline">\psi (x)\phi (t)</fr:tex>:
        <fr:tex display="block">             i\hbar  \frac {1}{\phi (t)} \frac {\partial }{\partial  t}(\phi (t)) = -\frac {\hbar ^2}{2m\psi (x)}\frac {\partial ^2(\psi (x))}{\partial  x^2} + V(x)         </fr:tex>
        Notice that the left side depends only on <fr:tex display="inline">t</fr:tex> and the right side depends only on <fr:tex display="inline">x</fr:tex>.
        They are equal if and only if they are both equal to a <fr:em>constant</fr:em>.
        Otherwise if I change the left side and level the right side unchanged, I get a contradiction.
        The constant is the energy of the system, and we denote it by <fr:tex display="inline">E</fr:tex>.
        <fr:tex display="block">             E:\equiv  i\hbar  \frac {1}{\phi (t)} \frac {\partial }{\partial  t}(\phi (t))          </fr:tex>
        and 
        <fr:tex display="block">             E:\equiv  -\frac {\hbar ^2}{2m\psi (x)}\frac {\partial ^2(\psi (x))}{\partial  x^2} + V(x)         </fr:tex>
        We have two equations:
        <fr:tex display="block">             \begin {align*}                 \frac {d\phi }{dt} &amp;= -\frac {iE}{\hbar }\phi \\                 -\frac {\hbar ^2}{2m}\frac {d^2\psi }{dx^2} + V\psi  &amp;= E\psi              \end {align*}         </fr:tex>
        Now the partial differential equation has been reduced to two <fr:strong>ordinary differential equations</fr:strong>.
        The first one is easy to solve:
        <fr:tex display="block">             \phi (t) = \phi (0)e^{-iEt/\hbar }         </fr:tex>
        Thus the complete solution is (note that the constant <fr:tex display="inline">\phi (0)</fr:tex> was absorbed into <fr:tex display="inline">\psi (x)</fr:tex>):
        <fr:tex display="block">             \Psi (x,t) = \psi (x)e^{-iEt/\hbar }         </fr:tex>
        The second one is the <fr:strong>time-independent Schrodinger equation</fr:strong>,
        we can&apos;t go further unless we know the potential energy <fr:tex display="inline">V(x)</fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:p>Now we give a name to the time-independent Schrodinger equation.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>782</fr:anchor><fr:addr type="user">def-0034</fr:addr><fr:route>def-0034.xml</fr:route><fr:title text="Stationary State">Stationary State</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>stationary state</fr:strong> is a quantum state with all observables independent of time.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Thought the wave function is time-dependent,
    <fr:tex display="block">         \Psi (x,t) = \psi (x)e^{-iEt/\hbar }     </fr:tex>
    But if we compute the probability density, it is time-independent:
    <fr:tex display="block">         |\Psi (x,t)|^2 = \psi ^*(x)e^{+iEt/\hbar }\psi (x)e^{-iEt/\hbar } = |\psi (x)|^2      </fr:tex>
    Hence the expectation value is constant in time. 
    Then <fr:tex display="inline">\langle  p \rangle  = 0</fr:tex> all the time.
    Nothing happens in the stationary state.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>783</fr:anchor><fr:addr type="machine">#302</fr:addr><fr:route>unstable-302.xml</fr:route><fr:title text="
    Conservation of energy
">
    <fr:strong>Conservation of energy</fr:strong>
</fr:title><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    This also means that the energy of the system is conserved.
    In classical mechanics, the <fr:strong>total energy</fr:strong> (kinetic + potential) of a system is called the <fr:strong>Hamiltonian</fr:strong>.
    <fr:tex display="block">         H(x,p) = \frac {p^2}{2m} + V(x)     </fr:tex>
    In quantum mechanics, the Hamiltonian is an operator,
    obtained by substituting <fr:tex display="inline">p\to  -i\hbar \frac {\partial }{\partial  x}</fr:tex>:
    <fr:tex display="block">         \hat {H} = -\frac {\hbar ^2}{2m}\frac {\partial ^2}{\partial  x^2} + V(x)     </fr:tex>
    Thus the time-independent Schrodinger equation can be written as:
    <fr:tex display="block">         \hat {H}\psi (x) = E\psi (x)     </fr:tex>
    The expectation value of the total energy gives the energy of the system:
    <fr:tex display="block">         \begin {align*}             \langle  H \rangle  &amp;= \int  \psi ^*(x)\hat {H}\psi (x)dx              \\             &amp;= \int  \psi ^*(x)E\psi (x)dx             \\             &amp;= E\int  |\psi (x)|^2dx             \\             &amp;= E\int  |\Psi (x)|^2dx             \\             &amp;= E                    \end {align*}     </fr:tex>
    and
    <fr:tex display="block">         \begin {align*}             \langle  H^2 \rangle  &amp;=              \int  \psi ^*(x)\hat {H}^2\psi (x)dx             \\             &amp;= E^2\int  |\psi (x)|^2 dx                   \\             &amp;= E^2               \end {align*}     </fr:tex>
    where 
    <fr:tex display="block">         \hat {H}^2\psi  = \hat {H}(\hat {H}\psi ) = \hat {H}(E\psi ) = E(\hat {H}\psi ) = E^2\psi      </fr:tex>
    Hence the variance of the energy is zero given by
    <fr:tex display="block">         \Delta  H = \sqrt {\langle  H^2 \rangle  - \langle  H \rangle ^2} = 0     </fr:tex>
    This implies that the energy of the system is conserved.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>784</fr:anchor>
                <fr:addr type="user">phy-0001</fr:addr>
                <fr:route>phy-0001.xml</fr:route>
                <fr:title text="Special Relativity and Extra Dimensions">Special Relativity and Extra Dimensions</fr:title>
                <fr:taxon>String Theory</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>29</fr:day>
                </fr:date>
                <fr:authors>
                  <fr:author>CAIMEO</fr:author>
                </fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>This is a summary of the first chapter of <fr:link type="local" href="string-theory-2009.xml" addr="string-theory-2009" title="A First Course in String Theory">A First Course in String Theory</fr:link> by Barton Zwiebach.
    I will make it as understandable as possible.</fr:p>
                <fr:p>Speical relativity is based on the exprimental fact that the speed of light is the same for all inertial observers.
    In comparing the coordinates of events, two inertial observers (<fr:strong>Lorentz observers</fr:strong>) find that the
    appropriate coordinate transformations mix space and time.</fr:p>
                <fr:p>In special relativity events are characterized by their coordinates in space <fr:tex display="inline">(x,y,z)</fr:tex> and time (<fr:tex display="inline">t</fr:tex>).
    It&apos;s convenient to combine these into a four-vector where the <fr:tex display="inline">t</fr:tex> coordinate is multiplied by <fr:tex display="inline">c</fr:tex> (<fr:strong>Speed of light</fr:strong>): so 
    that all four coordinates have the same units (length).
    <fr:tex display="block">x^\mu  = (x^0,x^1,x^2,x^3) = (ct,x,y,z)</fr:tex>
    The superscript <fr:tex display="inline">\mu </fr:tex> is called a <fr:strong>Lorentz index</fr:strong> and runs from 0 to 3.</fr:p>
                <fr:p>Consider a Lorentz frame <fr:tex display="inline">S</fr:tex> where two events are represented by the coordinates 
    <fr:tex display="inline">x^\mu </fr:tex> and <fr:tex display="inline">x^\mu  + \Delta  x^\mu </fr:tex>.
    Let <fr:tex display="inline">S&apos;</fr:tex> be another Lorentz frame where the same two events are represented by the coordinates
    <fr:tex display="inline">x&apos;^\mu </fr:tex> and <fr:tex display="inline">x&apos;^\mu  + \Delta  x&apos;^\mu </fr:tex>.
    The value of <fr:tex display="inline">x&apos;^\mu </fr:tex> is different from <fr:tex display="inline">x^\mu </fr:tex> and so as <fr:tex display="inline">\Delta  x&apos;^\mu </fr:tex> from <fr:tex display="inline">\Delta  x^\mu </fr:tex>.
    However there is an invariant <fr:strong>interval</fr:strong> <fr:tex display="inline">\Delta  s^2</fr:tex> defined by
    <fr:tex display="block">         -\Delta  s^2 = -(\Delta  x^0)^2 + (\Delta  x^1)^2 + (\Delta  x^2)^2 + (\Delta  x^3)^2     </fr:tex>
    The minus sign in front of <fr:tex display="inline">(x^0)^2</fr:tex> encodes the fundamental difference between space and time coordinates.</fr:p>
                <fr:p>The invariant interval implies the following equation:
    <fr:tex display="block">         \Delta  s ^2 = \Delta  s&apos;^2     </fr:tex>
    The minus sign on the left of <fr:tex display="inline">\Delta  s^2</fr:tex> implies that <fr:tex display="inline">\Delta  s^2 &gt;0</fr:tex> for events that are <fr:strong>timelike separated</fr:strong>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>786</fr:anchor>
                    <fr:addr type="user">def-001H</fr:addr>
                    <fr:route>def-001H.xml</fr:route>
                    <fr:title text="Timelike Separated Events">Timelike Separated Events</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>An event <fr:tex display="inline">S</fr:tex> is said to be timelike separated if
    <fr:tex display="block">         (\Delta  x^0)^2 &gt; (\Delta  x^1)^2 + (\Delta  x^2)^2 + (\Delta  x^3)^2     </fr:tex>
    or briefly <fr:tex display="inline">\Delta  s^2 &gt; 0</fr:tex>. The spatial separation is less than the distance light travels.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>The history of a particle is represented in spacetime as a curve called a <fr:strong>world-line</fr:strong>.
    Any two events on the world-line are timelike separated, because no particle can 
    move faster than light.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>787</fr:anchor>
                    <fr:addr type="user">def-001I</fr:addr>
                    <fr:route>def-001I.xml</fr:route>
                    <fr:title text="Lightlike Separated Events">Lightlike Separated Events</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Events connected by the world-line of a <fr:strong>photon</fr:strong> are said to be <fr:strong>lightlike separated</fr:strong>.
    For which <fr:tex display="inline">\Delta  s^2 = 0</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>788</fr:anchor>
                    <fr:addr type="user">def-001J</fr:addr>
                    <fr:route>def-001J.xml</fr:route>
                    <fr:title text="Spacelike Separated Events">Spacelike Separated Events</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Two events for which <fr:tex display="inline">\Delta  s^2 &lt; 0</fr:tex> are said to be <fr:strong>spacelike separated</fr:strong>.
    Events that are simultaneous in a Lorentz frame but in different position are spacelike separated.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>For timelike event we can define
    <fr:tex display="block">         \Delta  s \equiv  \sqrt {\Delta  s^2}     </fr:tex></fr:p>
                <fr:p>It is useful to consider events that are <fr:em>infinitesimally close</fr:em> to each other.
    Small coordinate difference are needed to define velocity.
    Infinitesimal coordinate differences are written as <fr:tex display="inline">dx^\mu </fr:tex>.
    <fr:tex display="block">         -ds^2 = -(dx^0)^2 + (dx^1)^2 + (dx^2)^2 + (dx^3)^2     </fr:tex>
    The equality of intervals is the statement
    <fr:tex display="block">         ds^2 = ds&apos;^2     </fr:tex>
    Let&apos;s define a better notation:
    <fr:tex display="block">         dx_0 \equiv  -dx^0,         dx_1 \equiv  dx^1,         dx_2 \equiv  dx^2,         dx_3 \equiv  dx^3              </fr:tex>
    Notice that the inclusion of the minus sign in the definition of <fr:tex display="inline">dx_0</fr:tex> is a matter of convention.
    <fr:tex display="block">         dx_\mu  = (dx_0,dx_1,dx_2,dx_3)     </fr:tex>
    Now rewrite <fr:tex display="inline">ds^2</fr:tex> in terms of <fr:tex display="inline">dx_\mu </fr:tex> and <fr:tex display="inline">dx^\mu </fr:tex>:
    <fr:tex display="block">         -ds^2 = dx_0dx^0 + dx_1dx^1 + dx_2dx^2 + dx_3dx^3 = \sum _{\mu =0}^3 dx_\mu  dx^\mu      </fr:tex>
    Using <fr:link type="local" href="def-001K.xml" addr="def-001K" title="Einstein&apos;s Summation Convention">Einstein&apos;s Summation Convention</fr:link> we can rewrite
    <fr:tex display="block">         ds^2 = dx_\mu  dx^\mu      </fr:tex>
    And for Infinitesimal timelike intervals we can define
    <fr:tex display="block">         ds \equiv  \sqrt {ds^2}      </fr:tex>
    We can also express the interval <fr:tex display="inline">ds^2</fr:tex> using the <fr:strong>Minkowski Metric</fr:strong>:
    <fr:tex display="block">         -ds^2= \eta _{\mu \nu } dx^\mu  dx^\nu      </fr:tex>
    and the metric is defined by</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>789</fr:anchor>
                    <fr:addr type="user">def-001L</fr:addr>
                    <fr:route>def-001L.xml</fr:route>
                    <fr:title text="Minkowski Metric">Minkowski Metric</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The <fr:strong>Minkowski Metric</fr:strong>, aka <fr:strong>Minkowski Tensor</fr:strong>, is a tensor <fr:tex display="inline">\eta _{\mu \nu }</fr:tex> whose elements are defined by the matrix
    <fr:tex display="block">         \eta _{\mu \nu } = \begin {pmatrix}             -1 &amp; 0 &amp; 0 &amp; 0 \\             0 &amp; 1 &amp; 0 &amp; 0 \\             0 &amp; 0 &amp; 1 &amp; 0 \\             0 &amp; 0 &amp; 0 &amp; 1          \end {pmatrix}     </fr:tex>
    where <fr:tex display="inline">\mu </fr:tex> and <fr:tex display="inline">\nu </fr:tex> are Lorentz indices run over <fr:tex display="inline">0,1,2,3</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>How can we derive the Minkowski Metric? First we require <fr:tex display="inline">\eta _{\mu \nu }</fr:tex> to be a symmetric matrix,
    because any antisymmetric part would not contribute to the interval.
    <fr:tex display="block">         \eta _{\mu \nu } = \eta _{\nu \mu }     </fr:tex>
    And for any two-indexed object <fr:tex display="inline">M_{\mu \nu }</fr:tex> can be decomposed into symmetric and antisymmetric parts:
    <fr:tex display="block">         M_{\mu \nu } = \frac {1}{2}(M_{\mu \nu } + M_{\nu \mu }) + \frac {1}{2}(M_{\mu \nu } - M_{\nu \mu })     </fr:tex>
    With the antisymmetric part (denoted <fr:tex display="inline">\delta </fr:tex>) which we can see
    <fr:tex display="block">         \delta _{\mu \nu }dx^\mu  dx^\nu  = (-\delta _{\nu \mu }) dx^\mu  dx^\nu  = -\delta _{\mu \nu }dx^\nu  dx^\mu  = -\delta _{\mu \nu }dx^\mu  dx^\nu      </fr:tex>
    Note that the second step relabeled the dummy indices <fr:tex display="inline">\mu </fr:tex> and <fr:tex display="inline">\nu </fr:tex>.
    The third step we swapped the order of the two terms. Hence the antisymmetric part is zero.</fr:p>
                <fr:p>The equation <fr:tex display="inline">dx_\mu  = (dx_0,dx_1,dx_2,dx_3)</fr:tex> can be rewritten as
    <fr:tex display="block">         dx_\mu  = \eta _{\mu \nu } dx^\nu      </fr:tex>
    For more general case:
    <fr:tex display="block">         b_\mu  \equiv  \eta _{\mu \nu } b^\nu      </fr:tex>
    Given <fr:tex display="inline">a^\mu </fr:tex> and <fr:tex display="inline">b^\mu </fr:tex> we can define the dot scalar product as 
    <fr:tex display="block">         a \cdot  b \equiv  a^\mu  b_\mu  = a^\mu  \eta _{\mu \nu } b^\nu  = -a^0 b^0 + a^1 b^1 + a^2 b^2 + a^3 b^3     </fr:tex>
    Note that <fr:tex display="inline">a^\mu  b_\mu  = a_\mu  b^\mu </fr:tex> because <fr:tex display="inline">\eta _{\mu \nu }</fr:tex> is symmetric.</fr:p>
                <fr:p>It&apos;s convenient to introduce the inverse matrix of <fr:tex display="inline">\eta _{\mu \nu }</fr:tex>:
    <fr:tex display="block">         \eta ^{\mu \nu } =          \begin {pmatrix}             -1 &amp; 0 &amp; 0 &amp; 0 \\             0 &amp; 1 &amp; 0 &amp; 0 \\             0 &amp; 0 &amp; 1 &amp; 0 \\             0 &amp; 0 &amp; 0 &amp; 1         \end {pmatrix}     </fr:tex>
    And the inverse property is
    <fr:tex display="block">         \eta ^{\mu \rho } \eta _{\rho \nu } = \delta ^\mu _\nu      </fr:tex>
    where <fr:tex display="inline">\delta ^\mu _\nu </fr:tex> is the <fr:link type="local" href="def-001P.xml" addr="def-001P" title="Kronecker Delta">Kronecker Delta</fr:link>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>790</fr:anchor>
                    <fr:addr type="user">thm-0004</fr:addr>
                    <fr:route>thm-0004.xml</fr:route>
                    <fr:title text="Raise Indices">Raise Indices</fr:title>
                    <fr:taxon>Trick</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p><fr:tex display="block">         \eta ^{\rho \mu }b_\mu          = \eta ^{\rho \mu } (\eta _{\mu \nu } b^\nu )         = \eta ^{\rho \mu } \eta _{\mu \nu } b^\nu          = \delta ^\rho _\nu  b^\nu          = b^\rho      </fr:tex>
    The lower index of <fr:tex display="inline">b_\mu </fr:tex> is raised to <fr:tex display="inline">b^\rho </fr:tex> by <fr:tex display="inline">\eta ^{\rho \mu }</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p><fr:strong>Lorentz transformations</fr:strong> are the relations between coordinates in two different
    inertial frames.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>791</fr:anchor>
                    <fr:addr type="user">def-001Q</fr:addr>
                    <fr:route>def-001Q.xml</fr:route>
                    <fr:title text="Lorentz Transformations">Lorentz Transformations</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Consider a frame <fr:tex display="inline">S</fr:tex> and <fr:tex display="inline">S&apos;</fr:tex> which is moving along the <fr:tex display="inline">+x</fr:tex> direction of the <fr:tex display="inline">S</fr:tex> frame
    with a velocity <fr:tex display="inline">v</fr:tex>.
    Assume that the origins of the two frames coincide at <fr:tex display="inline">t=t&apos;=0</fr:tex> and coordinate axes are parallel.

    We say that <fr:tex display="inline">S&apos;</fr:tex> is boosted along the <fr:tex display="inline">x</fr:tex> direction with velocity parameter <fr:tex display="inline">\beta \equiv \frac {v}{c}</fr:tex>.
    The <fr:strong>Lorentz transformations</fr:strong> are defined by a set of equations that relate the coordinates of an event in the two frames.
    <fr:tex display="block">         \begin {align*}             x&apos; &amp;= \gamma (x-\beta  ct) \\             y&apos; &amp;= y \\             z&apos; &amp;= z \\             ct&apos; &amp;= \gamma (ct-\beta  x)         \end {align*}     </fr:tex>
    where <fr:tex display="inline">\gamma \equiv \dfrac {1}{\sqrt {1-\beta ^2}} = \dfrac {1}{\sqrt {1-\frac {v^2}{c^2}}}</fr:tex> is the <fr:strong>Lorentz factor</fr:strong>.
    The coordinates orthogonal to the <fr:tex display="inline">x</fr:tex> direction remains unchanged.</fr:p>
                    <fr:p>Lorentz transformations are the linear transformations of coordinates that remains the <fr:tex display="inline">\Delta  s^2</fr:tex> unchanged. 
    We can write the Lorentz transformations in matrix form:
    <fr:tex display="block">         \begin {pmatrix}             ct&apos; \\             x&apos; \\             y&apos; \\             z&apos;          \end {pmatrix}         =         \begin {pmatrix}             \gamma  &amp; -\beta \gamma  &amp; 0 &amp; 0 \\             -\beta \gamma  &amp; \gamma  &amp; 0 &amp; 0 \\             0 &amp; 0 &amp; 1 &amp; 0 \\             0 &amp; 0 &amp; 0 &amp; 1          \end {pmatrix}         \begin {pmatrix}             ct \\             x \\             y \\             z          \end {pmatrix}     </fr:tex>
    Or in a more compact form:
    <fr:tex display="block">         x&apos;^\mu  = L^\mu _\nu  x^\nu      </fr:tex>
    where <fr:tex display="inline">L^\mu _\nu </fr:tex> is the <fr:strong>Lorentz transformation matrix</fr:strong> presented above.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>We now introduce a coordinate system that will be extremely useful in string theory,
    the <fr:strong>light-cone coordinates</fr:strong>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>792</fr:anchor>
                    <fr:addr type="user">def-001R</fr:addr>
                    <fr:route>def-001R.xml</fr:route>
                    <fr:title text="Light-cone Coordinates">Light-cone Coordinates</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The <fr:strong>light-cone coordinates</fr:strong> can be defined as
    two independent <fr:link type="local" href="def-000L.xml" addr="def-000L" title="Linear Combination">linear combinations</fr:link> of the time 
    and a chosen spatial coordinate (conventionally <fr:tex display="inline">x^1</fr:tex>):
    <fr:tex display="block">         \begin {align*}             x^+ \equiv  \frac {1}{\sqrt {2}} (X^0 + X^1) \\             x^- \equiv  \frac {1}{\sqrt {2}} (X^0 - X^1)         \end {align*}     </fr:tex>
    while other spatial coordinates remain unchanged. Thus the complete set of 
    light-cone coordinates is <fr:tex display="inline">(x^+,x^-,x^2,x^3)</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>The name <fr:strong>light-cone coordinates</fr:strong> comes from the fact that the associated coordinates axes
    are the world-lines of beams of light emitted form the origin along the <fr:tex display="inline">x^1</fr:tex> axis.
    <fr:ul><fr:li>For a beam of light moving in the positive <fr:tex display="inline">x^1</fr:tex> direction,
            we have <fr:tex display="inline">x^1=ct=x^0</fr:tex> and thus <fr:tex display="inline">x^-=0</fr:tex>. By definition <fr:tex display="inline">x^-=0</fr:tex>
            is actually the <fr:tex display="inline">x^+</fr:tex> axis.</fr:li>
        <fr:li>For a beam of light moving in the negative <fr:tex display="inline">x^1</fr:tex> direction,
            we have <fr:tex display="inline">x^1=-ct=-x^0</fr:tex> and thus <fr:tex display="inline">x^+=0</fr:tex>. By definition <fr:tex display="inline">x^+=0</fr:tex>
            is actually the <fr:tex display="inline">x^-</fr:tex> axis.</fr:li></fr:ul>
    The <fr:tex display="inline">x^+</fr:tex> and <fr:tex display="inline">x^-</fr:tex> axes are perpendicular to each other and at <fr:tex display="inline">45^\circ </fr:tex> to the <fr:tex display="inline">x^0</fr:tex> and <fr:tex display="inline">x^1</fr:tex> axis.</fr:p>
                <fr:p>Both <fr:tex display="inline">x^+</fr:tex> and <fr:tex display="inline">x^-</fr:tex> can be a time coordinate although neither is a time coordinate
    in the standard sense of the world (Not ordinary time).
    For definiteness we will take <fr:tex display="inline">x^+</fr:tex> as the light-cone time coordinate and <fr:tex display="inline">x^-</fr:tex> as the spatial coordinate.</fr:p>
                <fr:p>Take differentials and multiply of the light-cone coordinates:
    <fr:tex display="block">         2dx^+ dx^- = (dx^0 + dx^1)(dx^0 - dx^1) = (dx^0)^2 - (dx^1)^2     </fr:tex>
    which follows the invariant interval
    <fr:tex display="block">         -ds^2 = -2dx^+ dx^- + (dx^2)^2 + (dx^3)^2     </fr:tex>
    As we did before, we can represent this with index notation:
    <fr:tex display="block">         -ds^2 = \hat {\eta }_{\mu \nu } dx^\mu  dx^\nu      </fr:tex>
    where the <fr:strong>light-cone metric</fr:strong> is
    <fr:tex display="block">         \hat {\eta }_{\mu \nu } =          \begin {pmatrix}             0 &amp; -1 &amp; 0 &amp; 0 \\             -1 &amp; 0 &amp; 0 &amp; 0 \\             0 &amp; 0 &amp; 1 &amp; 0 \\             0 &amp; 0 &amp; 0 &amp; 1         \end {pmatrix}     </fr:tex>
    This is easy to derive from the symmetric.</fr:p>
                <fr:p>The light-cone coordinates looks unusual but if you see some
    calculations you will find the results very surprising.</fr:p>
                <fr:p>Consider a particle moving in the <fr:tex display="inline">x^1</fr:tex> direction with velocity <fr:tex display="inline">v</fr:tex>.
    At the initial time the positions are all <fr:tex display="inline">0</fr:tex>.
    (The velocity parameter is denote <fr:tex display="inline">\beta </fr:tex>)
    <fr:tex display="block">         \begin {align*}             x^1 = vt = \beta  x^0             \\             x^2(t) = x^3(t) = 0         \end {align*}     </fr:tex>
    Now compute the light-cone coordinates:
    <fr:tex display="block">         \begin {align*}             x^+ = \frac {1}{\sqrt {2}}(x^0 + x^1) = \frac {1}{\sqrt {2}}(x^0 + \beta  x^0) = \frac {1+\beta }{\sqrt {2}}x^0             \\             x^- = \frac {1}{\sqrt {2}}(x^0 - x^1) = \frac {1}{\sqrt {2}}(x^0 - \beta  x^0) = \frac {1-\beta }{\sqrt {2}}x^0         \end {align*}     </fr:tex>
    And we identify the ratio 
    <fr:tex display="block">         \frac {dx^+}{dx^-} = \frac {1+\beta }{1-\beta }     </fr:tex>
    as the light-cone velocity of the particle. This looks strange:
    <fr:ul><fr:li>For <fr:tex display="inline">\beta =-1</fr:tex> the light-cone velocity is <fr:tex display="inline">\infty </fr:tex>.</fr:li>
        <fr:li>For a particle moving at the speed of light (<fr:tex display="inline">\beta =1</fr:tex>), the light-cone velocity is <fr:tex display="inline">0</fr:tex>.</fr:li>
        <fr:li>More interestingly, a static particle (<fr:tex display="inline">\beta =0</fr:tex>) is moving quite fast in the light-cone coordinates.</fr:li></fr:ul>
    Note that the light-cone coordinates can&apos;t be acquired by Lorentz transformation.</fr:p>
                <fr:p>Just get the idea of the light-cone coordinates, now let&apos;s dive into the relativistic energy and momentum.
    In special relativity there is relationship between energy and momentum.
    <fr:tex display="block">         \frac {E^2}{c^2}-\vec {p}^2 = m^2c^2     </fr:tex>
    where <fr:tex display="inline">m</fr:tex> is the rest mass of the particle, and <fr:tex display="inline">c</fr:tex> is the speed of light.
    <fr:tex display="block">         E = \gamma  mc^2,         \quad           \vec {p} = \gamma  m\vec {v}     </fr:tex>
    The energy and momentum can be used to define a momentum four-vector
    <fr:tex display="block">         p^\mu  = (\frac {E}{c},p_x, p_y, p_z)     </fr:tex>
    or shortly
    <fr:tex display="block">         p^\mu  = (\frac {E}{c},\vec {p}) = m\gamma  (c, \vec {v})     </fr:tex>
    Using operator <fr:tex display="inline">\eta _{\mu \nu }</fr:tex> to lower the index:
    <fr:tex display="block">         p_\mu  = (p_0, p_1, p_2, p_3) = \eta _{\mu \nu } p^\nu  = (-\frac {E}{c},p_x, p_y, p_z)     </fr:tex>
    And make use of the relationship above.
    <fr:tex display="block">         p_\mu  p^\mu  = \eta _{\mu \nu } p^\mu  p^\nu  = -\frac {E^2}{c^2} + p_x^2 + p_y^2 + p_z^2 = -m^2c^2     </fr:tex>
    Using the relativistic scalar product notation:
    <fr:tex display="block">         p ^2 \equiv  p \cdot  p = p_\mu  p^\mu  = -m^2c^2     </fr:tex></fr:p>
                <fr:p>A central concept in special relativity is <fr:strong>proper time</fr:strong>,
    which is a Lorentz invariant measure of time.
    Consider a world-line and two events <fr:tex display="inline">A</fr:tex> and <fr:tex display="inline">B</fr:tex> on the world-line.
    Different Lorentz observers will measure different time intervals between the two events.
    But imagine a clock that moves along the world-line.
    The time measured by the clock is called the <fr:strong>proper time</fr:strong> between the two events.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>793</fr:anchor>
                    <fr:addr type="user">def-001S</fr:addr>
                    <fr:route>def-001S.xml</fr:route>
                    <fr:title text="Proper Time">Proper Time</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The <fr:strong>proper time</fr:strong> along a timelike world-line is defined as the
    time as measured by a clock following that line.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>By this definition, proper time is a invariant. Consider an invariant interval 
    for the motion of a particle along <fr:tex display="inline">x</fr:tex> axis:
    <fr:tex display="block">         -ds^2 = -c^2 dt^2 + dx^2 = -c^2 dt^2 (1 - \beta ^2)     </fr:tex>
    Now attach a Lorentz frame to the particle does not move
    and the time is recorded by the clock that is moving with the particle.
    Hence <fr:tex display="inline">dx=0</fr:tex> and <fr:tex display="inline">dt=dt_p</fr:tex> is the proper time.
    <fr:tex display="block">         -ds^2 = -c^2 dt_p^2      </fr:tex>
    Cancel the minus sign and the square root
    <fr:tex display="block">         dt_p = c dt_p     </fr:tex>
    This shows that for timelike intervals,
    the <fr:strong>proper time interval</fr:strong> is <fr:tex display="inline">\frac {ds}{c}</fr:tex>.
    Similarly, 
    <fr:tex display="block">         ds = cdt \sqrt {1-\beta ^2} \implies  \frac {dt}{ds} = \frac {\gamma }{c}     </fr:tex>
    The invariant <fr:tex display="inline">ds</fr:tex> can be used to construct nre Lorentz vectors.
    For instance, we can construct velocity four-vector:
    <fr:tex display="block">         u^\mu  = c \frac {dx^\mu }{ds} = c (\frac {d(ct)}{ds}, \frac {dx}{ds}, \frac {dy}{ds}, \frac {dz}{ds})     </fr:tex>
    This can be simplified by using the definition of proper time:
    <fr:tex display="block">         \frac {dx}{ds} = \frac {dx}{dt} \frac {dt}{ds} = \frac {v_x\gamma }{c}     </fr:tex>
    Hence we find
    <fr:tex display="block">         u^\mu  = (\gamma  c, \gamma  v_x, \gamma  v_y, \gamma  v_z) = \gamma  (c, \vec {v})     </fr:tex>
    We see that the momentum four-vector is just the velocity four-vector multiplied by the rest mass.
    <fr:tex display="block">         p^\mu  = m u^\mu      </fr:tex></fr:p>
                <fr:p>The light-cone components <fr:tex display="inline">p^+</fr:tex> and <fr:tex display="inline">p^-</fr:tex> of the momentum Lorentz vector are obtained:
    <fr:tex display="block">         \begin {align*}             p^+ = \frac {1}{\sqrt {2}}(p^0+p^1) = -p_-             \\             p^- = \frac {1}{\sqrt {2}}(p^0-p^1) = -p_+         \end {align*}     </fr:tex>
    Note that light-cone coordinates do not transform as Lorentz ones do. 
    Both <fr:tex display="inline">p^\pm </fr:tex> are energy-like since both are positive for physical particles.
    <fr:tex display="block">         p^0 = \frac {E}{c} \sqrt {\vec {p}^2 + m^2c^2} &gt; |\vec {p}|\geq  |p^1|     </fr:tex>
    Hence <fr:tex display="inline">p^0\pm  p^1 &gt; 0</fr:tex> and <fr:tex display="inline">p^\pm &gt;0</fr:tex>, which both are possible candidates for energy.
    We finally choose <fr:tex display="inline">p^-</fr:tex> as the component, we explain this later.</fr:p>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>794</fr:anchor>
                <fr:addr type="user">cs-0008</fr:addr>
                <fr:route>cs-0008.xml</fr:route>
                <fr:title text="Algebraic Graphs">Algebraic Graphs</fr:title>
                <fr:taxon>Graph Theory</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>10</fr:month>
                  <fr:day>3</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>This post focus on the the algebra of graphs introduced in paper <fr:strong>Algebraic graphs with class (functional pearl)</fr:strong>,
    which built on rigorous mathematical foundation that allows us to apply equational reasoning for proving the correctness of graph transformation algorithms.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>631</fr:anchor>
                    <fr:addr type="machine">#345</fr:addr>
                    <fr:route>unstable-345.xml</fr:route>
                    <fr:title text="Introduction to Graphs">Introduction to Graphs</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>3</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Graphs are ubiquitous in computing. Roughly speaking, a graph is a collection of vertices and edges, where each edge connects two vertices.
        For the most trivial case, a graph is an ordered pair <fr:tex display="inline"> G=(V,E)</fr:tex> comprising:
        <fr:ul><fr:li><fr:tex display="inline"> V </fr:tex> is a set of vertices.</fr:li>
            <fr:li><fr:tex display="inline"> E \subseteq  \{ (x,y) \mid  x, y \in  V\} </fr:tex> is a set of edges.</fr:li></fr:ul>
        We can define a graph type in some programming languages (e.g. Haskell) as:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Graph a = Graph [a] [(a, a)]</html:code></fr:pre>

        Work with such low-level fiddling with sets of vertices and edges is very painful. And we can easily construct a graph that breaks the invariant of the graph structure like <fr:code>Graph [1] [(1,2)]</fr:code> which has an edge connecting a non-existent vertex.</fr:p>
                    <fr:p>How the state-of-art libraries deal with this problem? 
        The <fr:strong>container</fr:strong> library in Haskell provides a type <fr:code>Data.Graph</fr:code> which represents graph using adjacency array:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">type Graph a = Array a [a]</html:code></fr:pre>

        which ensures performance and generality. But the consistency invariant is not <fr:strong>statically</fr:strong> checked, which may lead
        to runtime errors like <fr:code>index out of ranges</fr:code>. Another approach is the <fr:strong>fgl</fr:strong> (Martin Erwig&apos;s Functional Graph Library)
        where the graph is introduced as an <fr:strong>inductive type</fr:strong>. The approach is very complex and its API contains partial functions.
        So is there a <fr:strong>safe</fr:strong> graph construction interface we can build on top?</fr:p>
                    <fr:p><fr:strong>Andrey Mokhov</fr:strong>&apos;s paper presents a new interface for constructing and transforming graphs in a safe and convenient manner.
        And abstract away from the actual representation details and characterize graphs by a set of axioms, just like numbers are algebraically characterized
        by rings. The core calculus is based on the algebra of parameterized graphs. Algebraic graphs have a safe and minimalistic core of four graph construction primitives, as captured by the following data type:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Graph a
    = Empty
    | Vertex a
    | Overlay (Graph a) (Graph a)
    | Connect (Graph a) (Graph a)</html:code></fr:pre></fr:p>
                    <fr:p>The <fr:code>Empty</fr:code> and <fr:code>Vertex</fr:code> construct the empty and single-vertex graphs respectively. <fr:code>Overlay</fr:code> composes two graphs by taking the union of their vertices and edges, and <fr:code>Connect</fr:code> is similar to <fr:code>Overlay</fr:code> but also creates edges between vertices of the two graphs. 
        
        The overlay and connect operations have three properties:
        <fr:ul><fr:li>(Closure)  They are closed on the set of graphs (all total functions)</fr:li>
            <fr:li>(Complete) They can be used to construct any graph starting from the empty and single-vertex graphs</fr:li>
            <fr:li>(Sound) Malformed graphs are impossible to construct</fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>632</fr:anchor>
                    <fr:addr type="machine">#346</fr:addr>
                    <fr:route>unstable-346.xml</fr:route>
                    <fr:title text="Core of Algebraic Graphs">Core of Algebraic Graphs</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>3</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>633</fr:anchor>
                        <fr:addr type="machine">#347</fr:addr>
                        <fr:route>unstable-347.xml</fr:route>
                        <fr:title text="Graph Construction">Graph Construction</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>10</fr:month>
                          <fr:day>3</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>The simplest possible graph is the empty graph. We denote it by <fr:tex display="inline"> \epsilon  = (\varnothing , \varnothing ) </fr:tex>.
            A graph with a single vertex is <fr:tex display="inline"> \text {Vertex} x = (\{x\}, \varnothing ) </fr:tex>.
            To construct larger graphs from the above primitives we define binary operations overlay and connect, denoted by <fr:tex display="inline"> + </fr:tex> and <fr:tex display="inline"> \to  </fr:tex> respectively.
            The overlay operation <fr:tex display="inline"> + </fr:tex> is defined as:
            <fr:tex display="block">                 (V_1, E_1) + (V_2, E_2) = (V_1 \cup  V_2, E_1 \cup  E_2)             </fr:tex>
            The connect operation <fr:tex display="inline"> \to  </fr:tex> is defined similarly (We give it a higher precedence than <fr:tex display="inline"> + </fr:tex>):
            <fr:tex display="block">                 (V_1, E_1) \to  (V_2, E_2) = (V_1 \cup  V_2, E_1 \cup  E_2 \cup  V_1 \times  V_2)             </fr:tex></fr:p>
                        <fr:p>As shown above, the core can be represented by a simple data type <fr:code>Graph</fr:code>, parameterized by the type of vertices <fr:code>a</fr:code>.
            We can push this further by defining a type class <fr:code>GraphLike</fr:code> that captures the core operations of the algebraic graph.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>634</fr:anchor>
                        <fr:addr type="machine">#348</fr:addr>
                        <fr:route>unstable-348.xml</fr:route>
                        <fr:title text="Type Class">Type Class</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>10</fr:month>
                          <fr:day>3</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>We abstract the graph construction primitives defined above as the type class Graph (Note that associated types requires <fr:code>TypeFamilies</fr:code> GHC extension):
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">class Graph g where
    type Vertex g
    empty :: g
    vertex :: Vertex g -&gt; g
    overlay :: g -&gt; g -&gt; g
    connect :: g -&gt; g -&gt; g</html:code></fr:pre></fr:p>
                        <fr:p>This interface is very simple and easy to use, which allows fewer opportunities for usage errors and greater opportunities for reuse.
            Now let&apos;s create some functions to construct graphs. For instance, a single edge is obtained by connecting two vertices:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">edge :: (Graph g) =&gt; Vertex g -&gt; Vertex g -&gt; g
edge x y = connect (vertex x) (vertex y)</html:code></fr:pre></fr:p>
                        <fr:p>A graph that contains a given list of isolated vertices can be constructed as follows:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">vertices :: Graph g =&gt; [Vertex g] -&gt; g
vertices = foldr (overlay . vertex) empty</html:code></fr:pre>

            which turns each vertex into a singleton graph and overlay the results. By replacing the 
            <fr:code>overlay</fr:code> with <fr:code>connect</fr:code> we can construct a full connected graph.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">clique :: (Graph g) =&gt; [Vertex g] -&gt; g
clique = foldr (connect . vertex) empty</html:code></fr:pre></fr:p>
                        <fr:p>The graph construction functions defined above are total, fully polymorphic, and elegant. 
            Thanks to the minimalistic core type class, it is easy to wrap our favourite graph library into the described interface, 
            and reuse the functions defined with graph class.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>635</fr:anchor>
                    <fr:addr type="machine">#349</fr:addr>
                    <fr:route>unstable-349.xml</fr:route>
                    <fr:title text="Algebraic Structure">Algebraic Structure</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>3</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>In this section we characterise the <fr:code>Graph</fr:code> type class with a set of axioms that reveal an algebraic structure very similar to a semiring. This provides a convenient framework for proving graph properties, using equational reasoning. The presented characterization is generally useful for formal verification, as well as automated testing of graph library APIs.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>636</fr:anchor>
                        <fr:addr type="machine">#350</fr:addr>
                        <fr:route>unstable-350.xml</fr:route>
                        <fr:title text="Axioms">Axioms</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>10</fr:month>
                          <fr:day>3</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Notice that the <fr:code>clique</fr:code> and <fr:code>vertices</fr:code> functions use <fr:tex display="inline">\epsilon </fr:tex> as the identity element for the overlay and connect operation respectively.
            Further more we can verify:
            <fr:ul><fr:li><fr:tex display="inline">(G,+,\epsilon )</fr:tex> is an idempotent commutative monoid.</fr:li>
                <fr:li><fr:tex display="inline">(G,\to ,\epsilon )</fr:tex> is a monoid.</fr:li>
                <fr:li><fr:tex display="inline">\to </fr:tex> distributes over <fr:tex display="inline">+</fr:tex>.</fr:li></fr:ul>
            This looks like a semiring, but the identity element are shared between the two operations. 
            What makes the algebra of graphs different is the <fr:strong>decomposition law</fr:strong>:
            <fr:tex display="block">                 x \to  y \to  z = x \to  y + x \to  z + y \to  z             </fr:tex>
            Interestingly, the fact that overlay and connect share the same identity follows from the decomposition law.
            Furthermore, the identity (<fr:tex display="inline">x + \epsilon  = x</fr:tex>) and idempotence (<fr:tex display="inline">x + x = x</fr:tex>) can also be proved from the decomposition law.
            Hence we get a minimal set (8) of axioms that characterize the algebraic graphs.
            <fr:ul><fr:li><fr:tex display="inline">+</fr:tex> is commutative and associative: <fr:tex display="inline">x + y = y + x</fr:tex> and <fr:tex display="inline">(x + y) + z = x + (y + z)</fr:tex></fr:li>
                <fr:li><fr:tex display="inline">(G,\to ,\epsilon )</fr:tex> is a monoid, i.e. <fr:tex display="inline">x \to  y \to  z = x \to  (y \to  z)</fr:tex> and <fr:tex display="inline">\epsilon  \to  x = x, x \to  \epsilon  = x</fr:tex></fr:li>
                <fr:li><fr:tex display="inline">\to </fr:tex> distributes over <fr:tex display="inline">+</fr:tex>: <fr:tex display="inline">(x + y) \to  z = x \to  z + y \to  z</fr:tex></fr:li>
                <fr:li>Decomposition law: <fr:tex display="inline">x \to  y \to  z = x \to  y + x \to  z + y \to  z</fr:tex></fr:li></fr:ul>
            By adding more axioms we can obtain more complex graphs such as directed graphs, hypergraphs, etc.</fr:p>
                        <fr:p>Algebraic graphs are <fr:strong>complete</fr:strong> in the sense that it is possible to describe any graph using the core interface. Indeed, given a graph <fr:tex display="inline">G=(V , E)</fr:tex> we can construct it as <fr:code>graph V E</fr:code>, where the function <fr:code>graph</fr:code> is defined as follows.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">graph :: (Graph g) =&gt; [Vertex g] -&gt; [(Vertex g, Vertex g)] -&gt; g
graph vs es = overlay (vertices vs) (edges es)</html:code></fr:pre>

            where <fr:code>edges</fr:code> is defined as:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">edges :: (Graph g) =&gt; [(Vertex g, Vertex g)] -&gt; g
edges = foldr (overlay . uncurry edge) empty</html:code></fr:pre>

            The absorption theorem <fr:tex display="inline">x \to  y + x + y = x \to  y</fr:tex>, derived from decomposition of <fr:tex display="inline">x \to  y \to  \epsilon </fr:tex>, states that an edge <fr:tex display="inline">(u, v)</fr:tex> 
            contains its two vertices <fr:tex display="inline">u, v</fr:tex> and is inseparable from them. Therefore, if the pair <fr:tex display="inline">(V , E)</fr:tex> is inconsistent, the set of vertices <fr:tex display="inline">V</fr:tex> 
            will be expanded to <fr:tex display="inline">\hat {V}</fr:tex> so that <fr:tex display="inline">E\subseteq  \hat {V} \times  \hat {V}</fr:tex> holds. More generally, the absorption theorem states that in 
            addition to being complete, the algebraic graph API is also sound in the sense that it is impossible to construct an inconsistent pair
            <fr:tex display="inline">(V , E)</fr:tex> using the four Graph methods.</fr:p>
                        <fr:p>There are many other interesting properties of algebraic graphs can be proved using the axioms:
            <fr:ul><fr:li>(Overlay Identity) <fr:tex display="inline">x + \epsilon  = x</fr:tex></fr:li>
                <fr:li>(Overlay Idempotence) <fr:tex display="inline">x + x = x</fr:tex></fr:li>
                <fr:li>(Absorption) <fr:tex display="inline">x \to  y + x + y = x \to  y</fr:tex></fr:li>
                <fr:li>(Saturation) <fr:tex display="inline">x \to  x \to  x = x \to  x</fr:tex></fr:li></fr:ul></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>637</fr:anchor>
                        <fr:addr type="machine">#351</fr:addr>
                        <fr:route>unstable-351.xml</fr:route>
                        <fr:title text="Partial Order">Partial Order</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>10</fr:month>
                          <fr:day>3</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>It is fairly standard to define <fr:tex display="inline">x \leq  y</fr:tex> as <fr:tex display="inline">x + y = y</fr:tex> for an idempotent operation <fr:tex display="inline">+</fr:tex>, since it gives a <fr:link type="local" href="def-000Y.xml" addr="def-000Y" title="Partial Order">partial order</fr:link> on the elements of the algebra. Formally we call this definition the <fr:strong>subgraph</fr:strong> relation. Therefore, we can check if a graph is a subgraph of another one if we know how to compare graphs for equality.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">isSubgraphOf :: (Graph g, Eq g) =&gt; g -&gt; g -&gt; Bool
isSubgraphOf x y = overlay x y == y</html:code></fr:pre></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>638</fr:anchor>
                    <fr:addr type="machine">#352</fr:addr>
                    <fr:route>unstable-352.xml</fr:route>
                    <fr:title text="Graphs à la Carte">Graphs à la Carte</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>3</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Now we define some instances of the Grpah, and extend the axioms to construct more complex graphs.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>639</fr:anchor>
                        <fr:addr type="machine">#353</fr:addr>
                        <fr:route>unstable-353.xml</fr:route>
                        <fr:title text="Binary Relation">Binary Relation</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>10</fr:month>
                          <fr:day>3</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>We start by a direct encoding of the graph construction primitives defined into the abstract data type <fr:code>Relation</fr:code> isomorphic to a pair of sets <fr:tex display="inline">(V , E)</fr:tex>: 
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Relation a = R {domain :: Set a, relation :: Set (a, a)} deriving (Eq)

instance (Ord a) =&gt; Graph (Relation a) where
    type Vertex (Relation a) = a
    empty = R Set.empty Set.empty
    vertex x = R (singleton x) Set.empty
    overlay x y = R (domain x `union` domain y) (relation x `union` relation y)
    connect x y =
        R (domain x `union` domain y)
        ( relation x
            `union` relation y
            `union` fromAscList [(a, b) | a &lt;- elems (domain x), b &lt;- elems (domain y)]
        )</html:code></fr:pre>

            As we have seen, this implementation satisfies the axioms of the graph algebra. Furthermore, it is a free graph in the sense that it does not satisfy any other laws. This follows from the fact that any algebraic graph expression <fr:tex display="inline">g</fr:tex> can be rewritten in the following canonical form:
            <fr:tex display="block">                 g = \left ( \sum _{v\in  V_g} v \right ) + \left ( \sum _{(u,v)\in  E_g} u \to  v \right )             </fr:tex>
            The existence of the canonical form was proved by <fr:strong>Mokhov</fr:strong> in <fr:em>Algebra of Parameterised Graphs</fr:em> for an extended version of the algebra.
            The core idea is to repeatedly apply the decomposition law to rewrite the graph expression in the form of the above equation,
            until no further decomposition is possible.</fr:p>
                        <fr:p>It will be convenient to make <fr:code>Relation</fr:code> an instance of <fr:code>Num</fr:code> type class.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">instance (Ord a, Num a) =&gt; Num (Relation a) where
    fromInteger = vertex . fromInteger
    (+) = overlay
    (*) = connect
    signum = const empty
    abs = id
    negate = id</html:code></fr:pre>

            With these setups we can use the standard <fr:tex display="inline">+</fr:tex> and <fr:tex display="inline">\times </fr:tex> operators as shortcuts for overlay and connect respectively.
            Note that the Num law <fr:code>abs x * signum x == x</fr:code> is satisfied by the above definition since <fr:tex display="inline">x \to  \epsilon  = x</fr:tex>.
            Any Graph instance can be made an instance of <fr:code>Num</fr:code> if needed.</fr:p>
                        <fr:p>Now let&apos;s try to construct some graphs using the <fr:code>Relation</fr:code> type and the <fr:code>Num</fr:code> instance:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">ghci&gt; 1 * (2 + 3) :: Relation Int
R {domain = fromList [1,2,3], relation = fromList [(1,2),(1,3)]}
ghci&gt; 1 * 2 * 3 :: Relation Int
R {domain = fromList [1,2,3], relation = fromList [(1,2),(1,3),(2,3)]}</html:code></fr:pre></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
          </fr:mainmatter>
          <fr:backmatter></fr:backmatter>
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Related">Related</fr:title>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>1020</fr:anchor>
            <fr:addr type="user">def-001X</fr:addr>
            <fr:route>def-001X.xml</fr:route>
            <fr:title text="Inductive Type">Inductive Type</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors></fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>In type theory, a system has <fr:strong>inductive type</fr:strong> if it can create new types from
    constants and functions that create terms of that type.
    Inductive types usually come with a function to prove properties about them.</fr:p>
          </fr:mainmatter>
          <fr:backmatter></fr:backmatter>
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
  </fr:backmatter>
</fr:tree>