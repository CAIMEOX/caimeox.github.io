<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>730</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003N</fr:addr><fr:route>def-003N.xml</fr:route><fr:title>Accepts</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    If the string <fr:tex>x</fr:tex> consists characters <fr:tex>x_1, x_2,  \ldots , x_n</fr:tex> then the
    FA <fr:tex>(S, \Sigma , \delta ,s_0,S_A)</fr:tex> <fr:strong>accpets</fr:strong> <fr:tex>x</fr:tex> iff there is a sequence
    <fr:tex display="block">          \delta (              \delta (                  \dots \delta ( \delta (                      \delta (s_0,x_1),x_2),x_3) \dots ,                 x_{n-1}             )             ,x_n         ) \in  S_A     </fr:tex></fr:p></fr:mainmatter><fr:backmatter><fr:contributions></fr:contributions><fr:context><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>729</fr:anchor><fr:taxon>Computer Science</fr:taxon><fr:addr>cs-0004</fr:addr><fr:route>cs-0004.xml</fr:route><fr:title>Scanners</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The scanner&apos;s task is to transform a stream of characters into a stream 
    of words in the input language. Each word must be classified into a 
    <fr:strong>syntactic category</fr:strong>.
    This note refers to <fr:link href="eng-compiler-2022.xml" type="local" addr="eng-compiler-2022">Engineering a compiler</fr:link></fr:p><fr:p>
    The first stage of a compiler is to perform <fr:strong>lexical analysis</fr:strong> by a scanner.
    The parser or <fr:strong>syntax analyzer</fr:strong> will fit the stream of words to a grammatical 
    model of the input language.
</fr:p><fr:p>
    Scanner construction has a strong foundation in formal language theory.
    Scanners are based on <fr:strong>recognizers</fr:strong> that simulate <fr:strong>deterministic finite automata</fr:strong>.
    We can specify the lexical structure using a set of <fr:strong>regular expression</fr:strong>.
</fr:p><fr:p>
    Each time a scanner recognizes a word, it will return a <fr:strong>token</fr:strong> that
    contains the word (<fr:strong>lexeme</fr:strong>) and its syntactic category.
    The scanner uses <fr:strong>microsyntax</fr:strong> (the lexical structure of a language) to 
    find and classify words. <fr:strong>Keywords</fr:strong> are <fr:strong>identifiers</fr:strong> but have special meanings.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>384</fr:anchor><fr:title>A first look at recognizers</fr:title><fr:parent>cs-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
        A char-by-char algorithm to recognize words is trivial.
        Consider we want to recognize the word <fr:code>new</fr:code>.
        We can write down the following code.
    </fr:p><fr:pre>    c &lt;- nextChar();
    if (c == &apos;n&apos;) {
        c &lt;- nextChar();
        if (c == &apos;e&apos;) {
            c &lt;- nextChar();
            if (c == &apos;w&apos;) {
                return newToken();
            }
        }
    }
    reportError();</fr:pre><fr:p>
        We can also represent the code fragment using the simple <fr:strong>transition diagram</fr:strong>.
    </fr:p>
    <fr:embedded-tex hash="6e7465cf950ac87387ac76b9da5fb72d"><fr:embedded-tex-preamble>
       \usepackage {tikz-cd}
       \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
         
         \begin {tikzcd}
            {S_0} &amp; {S_1} &amp; {S_2} &amp; {S_3}
             \arrow [&quot;n&quot;, from=1-1, to=1-2]
             \arrow [&quot;e&quot;, from=1-2, to=1-3]
             \arrow [&quot;w&quot;, from=1-3, to=1-4]
         \end {tikzcd}
     
    </fr:embedded-tex-body></fr:embedded-tex>
</fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>387</fr:anchor><fr:title>A formalism for recognizers</fr:title><fr:parent>cs-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
        Transition diagrams can be viewed as formal mathematics objects called <fr:strong>finite automata</fr:strong>.
    </fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>385</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003M</fr:addr><fr:route>def-003M.xml</fr:route><fr:title>Finite Automata</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    A <fr:strong>finite automata (FA)</fr:strong> is a five-tuple <fr:tex>(S, \Sigma , \delta ,s_0,S_A)</fr:tex> where
    <fr:ul><fr:li><fr:tex>S</fr:tex> is the finite set of states in the recognizer including <fr:tex>s_e</fr:tex>,
            the error state.
        </fr:li>
        <fr:li><fr:tex>\Sigma</fr:tex> is the finite alphabet used by the recognizer. 
            <fr:tex>\Sigma</fr:tex> is the union of the edge labels in the transition diagram.
        </fr:li>
        <fr:li><fr:tex>\delta (s, c)</fr:tex> is the recognizer&apos;s transition function, which 
            maps each state <fr:tex>s \in  S</fr:tex> and character <fr:tex>c \in \Sigma</fr:tex> into some next state.
            In state <fr:tex>s_i</fr:tex> with input character <fr:tex>c</fr:tex> the FA takes the transition
            <fr:tex>s_i  \xrightarrow {c}  \delta (s_i, c)</fr:tex>.
        </fr:li>
        <fr:li><fr:tex>s_0 \in  S</fr:tex> is the initial state of the recognizer.
        </fr:li>
        <fr:li><fr:tex>S_A</fr:tex> is the set of accepting states, <fr:tex>S_A \subseteq  S</fr:tex>.
        </fr:li></fr:ul>
    <fr:tex>\delta</fr:tex> is only partially defined. For all other combinations of the 
    state <fr:tex>s_i</fr:tex> and input char <fr:tex>c</fr:tex> we can define <fr:tex>\delta (s_i,c)=s_e</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
        An FA <fr:strong>accpets</fr:strong> a string <fr:tex>x</fr:tex> and iff starting in <fr:tex>s_0</fr:tex>,
        the sequence of chars in  <fr:tex>x</fr:tex> takes the FA to an accepting state
        when the entire string has been consumed.
    </fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>386</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-003N</fr:addr><fr:route>def-003N.xml</fr:route><fr:title>Accepts</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    If the string <fr:tex>x</fr:tex> consists characters <fr:tex>x_1, x_2,  \ldots , x_n</fr:tex> then the
    FA <fr:tex>(S, \Sigma , \delta ,s_0,S_A)</fr:tex> <fr:strong>accpets</fr:strong> <fr:tex>x</fr:tex> iff there is a sequence
    <fr:tex display="block">          \delta (              \delta (                  \dots \delta ( \delta (                      \delta (s_0,x_1),x_2),x_3) \dots ,                 x_{n-1}             )             ,x_n         ) \in  S_A     </fr:tex></fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>388</fr:anchor><fr:title>Recognize more complex words</fr:title><fr:parent>cs-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
        The char-by-char model is very simple and now we consider about numbers.
        For simplicity, we consider only unsigned integers: An unsigned integer is either
        zero or series of one or more digits where the first one is non-zero.
    </fr:p>
    <fr:embedded-tex hash="50bfeb9a1f9d7a5d006a58e636b046a2"><fr:embedded-tex-preamble>
       \usepackage {tikz-cd}
       \usepackage {amssymb}
    </fr:embedded-tex-preamble><fr:embedded-tex-body>
         
         \begin {tikzcd}
            &amp; {S_2}
             \arrow [out=65, in=25 ,loop,&quot;0..9&quot;]
             \\ 
            {S_0}  \\ 
            &amp; {S_1}
             \arrow [&quot;0&quot;, from=2-1, to=3-2]
             \arrow [&quot;{1..9}&quot;, from=2-1, to=1-2]
         \end {tikzcd}
     
    </fr:embedded-tex-body></fr:embedded-tex>
<fr:p>
        And the code implementation can be:
    </fr:p><fr:pre>    state &lt;- s0;
    char &lt;-nextChar();
    while (state != se and char != eof) {
        state &lt;- delta(state, char);
        char &lt;- nextChar();
    }
    if (state in SA) {
        return Acceptance();
    } else {
        reportError();
    }</fr:pre><fr:p>
        Another example is to recognize <fr:strong>identifiers</fr:strong> which are sequences of letters and digits,
        starting with a letter. Many languages include other special characters for identifiers.
        The FA for unsigned integers and identifiers are different in syntactic categories.
    </fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>389</fr:anchor><fr:title>Regular Expressions</fr:title><fr:parent>cs-0004</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>
        The set of words accpeted by a finite automata <fr:tex>F</fr:tex> forms a language <fr:tex>L(F)</fr:tex>.
        The transition diagram of <fr:tex>F</fr:tex> specifies the syntactic structure of <fr:tex>L(F)</fr:tex>.
        But such representation is complex and non-intuitive.
        Most systems use a notation called <fr:strong>regular expressions</fr:strong> to specify the language.
        Any language described by an RE is considered a <fr:strong>regular language</fr:strong>.
        RE is equivalent to FA.
    </fr:p><fr:p>
        To work with REs in a rigorous way, we need a foraml definition.
    </fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:context><fr:related></fr:related><fr:backlinks></fr:backlinks><fr:references></fr:references></fr:backmatter></fr:tree>