<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
  <fr:frontmatter>
    <fr:anchor>1705</fr:anchor>
    <fr:addr type="user">cs-0004</fr:addr>
    <fr:route>cs-0004.xml</fr:route>
    <fr:title text="Scanners">Scanners</fr:title>
    <fr:taxon>Computer Science</fr:taxon>
    <fr:authors></fr:authors>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:p>The scanner&apos;s task is to transform a stream of characters into a stream 
    of words in the input language. Each word must be classified into a 
    <fr:strong>syntactic category</fr:strong>.
    This note refers to <fr:link type="local" href="eng-compiler-2022.xml" addr="eng-compiler-2022" title="Engineering a Compiler">Engineering a compiler</fr:link></fr:p>
    <fr:p>The first stage of a compiler is to perform <fr:strong>lexical analysis</fr:strong> by a scanner.
    The parser or <fr:strong>syntax analyzer</fr:strong> will fit the stream of words to a grammatical 
    model of the input language.</fr:p>
    <fr:p>Scanner construction has a strong foundation in formal language theory.
    Scanners are based on <fr:strong>recognizers</fr:strong> that simulate <fr:strong>deterministic finite automata</fr:strong>.
    We can specify the lexical structure using a set of <fr:strong>regular expression</fr:strong>.</fr:p>
    <fr:p>Each time a scanner recognizes a word, it will return a <fr:strong>token</fr:strong> that
    contains the word (<fr:strong>lexeme</fr:strong>) and its syntactic category.
    The scanner uses <fr:strong>microsyntax</fr:strong> (the lexical structure of a language) to 
    find and classify words. <fr:strong>Keywords</fr:strong> are <fr:strong>identifiers</fr:strong> but have special meanings.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>654</fr:anchor>
        <fr:addr type="machine">#368</fr:addr>
        <fr:route>unstable-368.xml</fr:route>
        <fr:title text="A first look at recognizers">A first look at recognizers</fr:title>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter><fr:p>A char-by-char algorithm to recognize words is trivial.
        Consider we want to recognize the word <fr:code>new</fr:code>.
        We can write down the following code.</fr:p><fr:pre>    c &lt;- nextChar();
    if (c == &apos;n&apos;) {
        c &lt;- nextChar();
        if (c == &apos;e&apos;) {
            c &lt;- nextChar();
            if (c == &apos;w&apos;) {
                return newToken();
            }
        }
    }
    reportError();</fr:pre><fr:p>We can also represent the code fragment using the simple <fr:strong>transition diagram</fr:strong>.</fr:p>
 
  
  <fr:figure><fr:resource hash="f4faee11facb506838a5d69a56ea34ed"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIyMi41NDAyNjlwdCcgaGVpZ2h0PScyMy4zOTEzOTJwdCcgdmlld0JveD0nLTcyIC03MiAxNDguMzYwMTc5IDE1LjU5NDI2Mic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVRQUFvQUFBQUFCZXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZQjFJR050WVhBQUFBRTRBQUFBTXdBQUFFUUFnZ0ZHWjJ4NVpnQUFBV3dBQUFKQkFBQUNySTFQcVl0b1pXRmtBQUFEc0FBQUFDOEFBQUEyS2JZdDdHaG9aV0VBQUFQZ0FBQUFIZ0FBQUNRR1VRS0NhRzEwZUFBQUJBQUFBQUFRQUFBQUVBc1NBS1ZzYjJOaEFBQUVFQUFBQUFvQUFBQUtBYXdBem0xaGVIQUFBQVFjQUFBQUdBQUFBQ0FBQndCWmJtRnRaUUFBQkRRQUFBRFBBQUFCT1BOaEtxTndiM04wQUFBRkJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbU9zSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWlNoblp2Z1A1RE5EcEpIVS9BY0tBd0QydGcyUWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VSU0dmSVl5di8vUjdEK3ovay81WDhQV0MwWUFBRHpoZ3ZDQUhqYUpaRTliOU5nRklYZmUvM1YyTTVyTzNsdHAyM2lPblpxeDAzbGZOcW1jdUs0TkZXQmdxZ0FVWW1CZ1kyRmdhK05nYi9CeUIvZ1R5RDRKUXpzcUF0RHNjTjRwSE9Qem5NdVFYSitld04vNFRzSlNFcEk1b3NhT0RDMzFwQm1xUU1tMDBDVVlrZ3FsYVh6bVdWYm9pUks0ZHlxZFJhREgxUlMvRlUyQUNFZDY2dFdtY3ROWmJaWHZIL3hrcjluZHA0K3l5NEEvRHZIazgrejN2TFFTM2dZKzlhY05wUGZROU1wQ2xRRnZWUkFGV21rRDNsOGMvVjJ3N1JrTXVxc1RNcnZnaWhRbGprdXh5VFpKVUFtdHpmNEZYNlF4NFNzdVRSWkJDRUZpY0lZNHFwdWdaWmRRSlphdGxpWHBtQ0s5cXh1YlR0UWw1UzhJRnhzdWJLME91UTBwRndRZmhxcGlxaTFIVThSSkZrUmdSbU44R3dqMmRmbDhYTU9HYmJWcHN4MTNieUZoaXlDclJoK01id0RuS3BaRmlJYm5WeU9xTlJqUXNQc01qajlOb2x0M2V3Q2xERlRBRkU3ZGRvRFBFcjZPV0o4UDE2SytYNi9iM2k0WHJVUTdZbHR4Znc0VWhWM2NQZHMycHB6dUN6NnZROVhUS09nRzJUTCs0YzdnSi9rdWhJYVVMQXR1K0tzR0pORkdJVC9ZVm1OV3JOUkNNVXhCR0dRMVI3SnE1RDl5clhZZnNvQm05VUprZ1BiZ0dvSnJnQWI5M3VVNTVyYVNYbkllanQ2b0hIZ21Uc1JCaDY5M0V3ZXRnYWxIczNOc1lDeUhDbmNycnRzZzFHTjFLbG1XQitsd0xkMEZ6QS8yT3ZMQTRsWEhkWmM4WER4cmpBSHZpOEl1WFB1cnBTWkszWE1QbUEzQzc5cy9DZTg1MDFOeExiU3ZXb0h3OWZXQXlqV09tS0RUaTB6Rm1CNnFOSTRlaFhsQVFKcmpyck1PUG40YUI4T0NDSC9BSjNGV05FQUFBQjQybU5nWkdCZ0FHSzV5ZDN0OGZ3Mlh4bVlXUmhBNFBIK3I3TVE5UDh2elBLTXg0RmNEZ1lta0NnQVZnQU10UUI0Mm1OZ1pHQmdadmpQQUNUOUdBd1k5Sm5sR1lBaUtJQUZBREUrQWRzQUFBTEdBQUFDS3dCRkF0TUFNQU5PQURBQUFBQUFBRllBemdGV0FBQjQybU5nWkdCZ1lHR0lZR0JpQUFGR0JqUUFBQW1DQUdGNDJrMk1QVy9DTUJDR240Z0VpVEN3b0E0ZGlvZk9FUVFrdGk0TVRLeE1MSUJkbE1FMmNrSWtwS3BqZjNjdnJvZWU1TlB6ZnB5QmttOHloc21ZeFQxTVRpSHFqd3VtekJPUFJTMFNsN3p5em9nc240anp4a2ZpWEpKVDRvSVhQaE9QeGY5S1hMTGhaK2Z0L2RHWm9BNWVtK0N1MWpiYm93bHQ0NTFhVmN1bzk4YVpjTzZNVnBlbjBuM1Q5amVyMWxWZDFlendXTzQ4NkRBRUZBZHhkR1RIVlRKTHc1WmpkRnBoTDc1aVJjWHlYNzZYM01YT09mNmtwWFBoS1Z2VFM2T1ZmWk91WWkyWDlmQitBY3dyTC9rQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9vQUFvQUFBQUFCQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXNTByV050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNtWjJ4NVpnQUFBV1FBQUFEb0FBQUE2S0tzVjhkb1pXRmtBQUFDVEFBQUFDOEFBQUEyS1MwdTYyaG9aV0VBQUFKOEFBQUFJQUFBQUNRRnpnRlhhRzEwZUFBQUFwd0FBQUFJQUFBQUNBVHFBRFZzYjJOaEFBQUNwQUFBQUFZQUFBQUdBSFFBQUcxaGVIQUFBQUtzQUFBQUZ3QUFBQ0FBQkFCS2JtRnRaUUFBQXNRQUFBRFVBQUFCUHBrUmRjZHdiM04wQUFBRG1BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9HTXdRek0vd0g4cGtoMGtocS9nT0ZBZFBCRFFzQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqQi8vOUR5UC9yd0h3R0FGUVJCcThBQUFBQUFRQTEvK2dDbGdMU0FFZ0FBQUVIQmljbUp6WTNMZ0VIRGdFSEhnRWZBUjRCRng0QkZ3WVBBUVlIQmlZbkR3SWlKejhCUGdFek5oY0hCaFVXSHdFV056NEJOeTRCTHdFdUFTYzJQd0UyTnhZWFB3SVdBcFEzQXd3SkFnRUNBVkpCUzJZQ0FTY1dSVUl4RHcwakFnSkFHRWhpTGwwaU1nd0dDd0VlRGc4SEJnb0NCUU1FTXhRNE1FNW9Bd005SDIwcFFBSURSQTVKWDJnck1Rd0dEUUxJNFJjREFRY0xNVlZLQVFObFFpa3RCeElSRWhFS09UUmFUQnBFQkFFZkxEb05Bd3Q0T2pnS0FnMGJFQk5WSHd3WUFnTnhTVDBxQlIwTFNENWJSUTVCQXdGSk93MENBd0FBZU5wallHUmdZQURpWGVscnRzZnoyM3hsWUdaaEFJSEgrNy9PUXREL1h6Qk5ZN29FNUhJd01JRkVBWDNXRGV3QWVOcGpZR1JnWUdiNHo4REF3RlRHWVByL0h0TTBCcUFJQ21BQ0FHS0RCQ2tDZGdBQUFuUUFOUUFBQUFBQWRBQUFlTnBqWUdSZ1lHQmk4R1FBMFF4UUVna0FBQWUrQUU4QWVOcE5qckZxd3pBVVJZK3BZNmhieUpRTUhZcW1qTVoyK2dHRkRKbXlaaXdra1FndVNBcXlZOGdTK2dIOTZENHJHdnFFSGtmblhRa0JKWGN5cHNxWXh6NVZUaUduQjg5NFlaRzRrS1VTbDd5eDRva3NmeGJ6em1maW5GZStFczlZOHAyNEVQK1R1T1NEMzQyM2wrdGdndHA1YllJN1dkczE5ZDZFdnZOT05WWDlFRnZqVERnTVJxdmpUZW14NjhlelZldXFyVm8yZUN3WHJnd1lndnhzSjBaSGRweGtadWxvcU5sSDE4dkp5MFNKcThUK1Qyd2w0V0xxRUYvVGtqcHlrNjRaSmROTFAwdGFzWmE3N2JUL0FPQ0NNTDE0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUTUFBb0FBQUFBQlhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVXQwZTJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDR1oyeDVaZ0FBQVdRQUFBSUZBQUFDUkVwYnltWm9aV0ZrQUFBRGJBQUFBQzhBQUFBMktXb3V4bWhvWldFQUFBT2NBQUFBSHdBQUFDUUZSd0lMYUcxMGVBQUFBN3dBQUFBT0FBQUFEZ1hCQUhSc2IyTmhBQUFEekFBQUFBd0FBQUFNQVJZQm9HMWhlSEFBQUFQWUFBQUFHQUFBQUNBQUNBQThibUZ0WlFBQUEvQUFBQURKQUFBQk11MEtrZXh3YjNOMEFBQUV2QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1TbWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvYU1CZ3pNL3dIOHBraDBraHEvZ09GQWNWYURMWUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2akcvLzhEU1lQLy8vOWZCUE1aQUZGbEJvOTQya1dSeTI3VFVCQ0d6OHh4Yk9KS1NYT3huVGdYeDNadGl5VGs0c2cyTkdwQ0VHbEphV2hFbTBhb2dJb1FSUlFLRVNEV0NGV3c0RUdBQlR4QTM0RDNZSWxZSUNSV0ZDWXJWa2Yvek5ITTk4L1BrSFgrZnNjMGZtUTZhekVHcXBRQVNaUmNyd0dlRzdsUkQ2SXdLb05XQnE2R3BJS1FPcllyMGpkTnBTb3VZMXd5eXAxbmM5OG9uNHNqcVFxcHRmMjhyZjh3SittNElDakpZYzBhcDVkaXlPWFVGbXg0NCtyTTdndEMzNTVWeDU2M1ZiKzFNaERBZDRMWFo4ZlFHcmFmWG5xN2U2RUY5Vzd0K1BOcW8rOHpZSE1pKzRhZldKN2VsS2gyUVdsQ0VvS09IM3FwQkhnQm9ZVXF6SGhsNUQyY3pOZTlVWVhYZDdQbXk0NnloTy8vZk5VVmh3T2lvK2dvWitPd2dtb0RaQnJGQm94aGpMeWZaOHlSekNqc1F3OWRqOXlWZ1F6YW91dVJmM0tmb0cyaUZDME9FR0hNT05zSGxINFhydkR0c2J1WDkxUUFLeU5YRVY3Y2UvQ080N1E3cmQ3NDZTekpDVHc5TFlyaXI4TGh5UUZDTFVBbldTeUE0bzRlYzNoMGQrT29QclNHQUlKOE9iTmdpU2lIQkg1Z3F5UnNNUWkxeFRJNmVBTWtBbEsxN0NLVkh2aXFwaTc0aUVtaWpQNFhJanBDQXlCM1VSZEUwKzNrbEN4ZmQ0eHB5ZWZGZkZ2QStaZFhDRmNuMDl1QWI1NGNuSEN3bWdhQWJsbEhWbk9IdzNYWTQ2bGw1SkFzNWdibW9FbURUTEdwbFFEQzN1YjJXdnUra1Ruc1RaNXptRjZyRkN2NWxNUHJKY0ROT3pkMzJEKy9jRnFTQUFBQWVOcGpZR1JnWUFEaUE5OGFoT1A1YmI0eU1MTXdnTURqL1Y5bkllai9iNWd1TTYwRWNqa1ltRUNpQUhhRERja0FlTnBqWUdSZ1lHYjR6OERBd0hTWndaakJsRW1JQVNpQ0FwZ0FQZGNDV0FBQzB3QUFBa2NBTXdCd0FFRUFOd0FBQUFBQUFBQlNBSDRBeEFFaWVOcGpZR1JnWUdCbHNHWmdZZ0FCUmdZMEFBQUd5QUJGZU5vOWpERUx3akFRaGI5aUZhMkRnK0RnSU1FZlVMUUtMbTRPVHE0T2J0WUU2ZEJVMGxwMEVYKzYxeEM4a09PNzk5NGRrUEFob3F1SWllOWR4ZkltZ2Z1TW1RWWVpTDRJbkRCblNZOG9Ib215WUI4NFpzZ2xjSjhaZWVDQjZLL0FDVnUraDZwOFBCdmoxS25TeHRsYjZYWm40K3Fpc21xZHJycnhhS3h4MThab2xiK1Zib3U2dlpkcWsyWnB4b0dLa2dkUEdnd094VWtVN2RseUU4K3g0K3pubWtJOEs1azFLYXUvZXhUWCtzVFZYOUdTeUhsTDE3U3lVMHUvUzFheGtiMnMrejlaTWk1TkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyLjE4MDA4OCwtNjQuMjAyODczKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03NC40NTgyNywtMi42NjY2NyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMi4xODAwODgsLTY0LjIwMjg3MylzY2FsZSgtMSwtMSknPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTEuNzU4NzQ2LC02NC4yMDI4NzMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjMwOTA0LDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTEuNzU4NzQ2LC02NC4yMDI4NzMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTEuNzU4NzQ2JyB5PSctNjQuMjAyODczJz5TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzE3Ljg2Nzc5MScgeT0nLTYyLjcwODQ5Mic+MDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1NC44MjYzNjgsLTY0LjIwMjg3MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMzA5MDQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg1NC44MjYzNjgsLTY0LjIwMjg3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSc1NC44MjYzNjgnIHk9Jy02NC4yMDI4NzMnPlM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNjAuOTM1NDE0JyB5PSctNjIuNzA4NDkyJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDk3Ljg5Mzk5MSwtNjQuMjAyODczKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4zMDkwNCwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDk3Ljg5Mzk5MSwtNjQuMjAyODczKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jzk3Ljg5Mzk5MScgeT0nLTY0LjIwMjg3Myc+UzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScxMDQuMDAzMDM2JyB5PSctNjIuNzA4NDkyJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE0MC45NjE2MTMsLTY0LjIwMjg3MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMzA5MDQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxNDAuOTYxNjEzLC02NC4yMDI4NzMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTQwLjk2MTYxMycgeT0nLTY0LjIwMjg3Myc+UzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScxNDcuMDcwNjU4JyB5PSctNjIuNzA4NDkyJz4zPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00tNTUuMDI5MTEtLjE2NjY3SC0zMS44MjkxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMS42MjkxMiwtMC4xNjY2NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDUuNzAwNzksMi4xODYwOCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMi4xODAwODgsLTY0LjIwMjg3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PScyLjE4MDA4OCcgeT0nLTY0LjIwMjg3Myc+bjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00tMTEuNzk5OTktLjE2NjY3SDExLjQwMDAyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDExLjYsLTAuMTY2NjcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEuODk3MDUsMi4xODYwOCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMi4xODAwODgsLTY0LjIwMjg3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PScyLjE4MDA4OCcgeT0nLTY0LjIwMjg3Myc+ZTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00zMS40MjkxNC0uMTY2NjdINTQuNjI5MTUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTQuODI5MTMsLTAuMTY2NjcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDAuMjQyNDMsMi4xODYwOCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMi4xODAwODgsLTY0LjIwMjg3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PScyLjE4MDA4OCcgeT0nLTY0LjIwMjg3Myc+dzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+"></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            {S_0} &amp; {S_1} &amp; {S_2} &amp; {S_3}
            \arrow [&quot;n&quot;, from=1-1, to=1-2]
            \arrow [&quot;e&quot;, from=1-2, to=1-3]
            \arrow [&quot;w&quot;, from=1-3, to=1-4]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure>
 
</fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>655</fr:anchor>
        <fr:addr type="machine">#369</fr:addr>
        <fr:route>unstable-369.xml</fr:route>
        <fr:title text="A formalism for recognizers">A formalism for recognizers</fr:title>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:p>Transition diagrams can be viewed as formal mathematics objects called <fr:strong>finite automata</fr:strong>.</fr:p>
        <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>656</fr:anchor>
            <fr:addr type="user">def-003M</fr:addr>
            <fr:route>def-003M.xml</fr:route>
            <fr:title text="Finite Automata">Finite Automata</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors></fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>A <fr:strong>finite automata (FA)</fr:strong> is a five-tuple <fr:tex display="inline">(S,\Sigma ,\delta ,s_0,S_A)</fr:tex> where
    <fr:ul><fr:li><fr:tex display="inline">S</fr:tex> is the finite set of states in the recognizer including <fr:tex display="inline">s_e</fr:tex>,
            the error state.</fr:li>
        <fr:li><fr:tex display="inline">\Sigma </fr:tex> is the finite alphabet used by the recognizer. 
            <fr:tex display="inline">\Sigma </fr:tex> is the union of the edge labels in the transition diagram.</fr:li>
        <fr:li><fr:tex display="inline">\delta (s, c)</fr:tex> is the recognizer&apos;s transition function, which 
            maps each state <fr:tex display="inline">s\in  S</fr:tex> and character <fr:tex display="inline">c\in \Sigma </fr:tex> into some next state.
            In state <fr:tex display="inline">s_i</fr:tex> with input character <fr:tex display="inline">c</fr:tex> the FA takes the transition
            <fr:tex display="inline">s_i \xrightarrow {c} \delta (s_i, c)</fr:tex>.</fr:li>
        <fr:li><fr:tex display="inline">s_0\in  S</fr:tex> is the initial state of the recognizer.</fr:li>
        <fr:li><fr:tex display="inline">S_A</fr:tex> is the set of accepting states, <fr:tex display="inline">S_A\subseteq  S</fr:tex>.</fr:li></fr:ul>
    <fr:tex display="inline">\delta </fr:tex> is only partially defined. For all other combinations of the 
    state <fr:tex display="inline">s_i</fr:tex> and input char <fr:tex display="inline">c</fr:tex> we can define <fr:tex display="inline">\delta (s_i,c)=s_e</fr:tex>.</fr:p>
          </fr:mainmatter>
          <fr:backmatter></fr:backmatter>
        </fr:tree>
        <fr:p>An FA <fr:strong>accpets</fr:strong> a string <fr:tex display="inline">x</fr:tex> and iff starting in <fr:tex display="inline">s_0</fr:tex>,
        the sequence of chars in  <fr:tex display="inline">x</fr:tex> takes the FA to an accepting state
        when the entire string has been consumed.</fr:p>
        <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>657</fr:anchor>
            <fr:addr type="user">def-003N</fr:addr>
            <fr:route>def-003N.xml</fr:route>
            <fr:title text="Accepts">Accepts</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors></fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>If the string <fr:tex display="inline">x</fr:tex> consists characters <fr:tex display="inline">x_1, x_2, \ldots , x_n</fr:tex> then the
    FA <fr:tex display="inline">(S,\Sigma ,\delta ,s_0,S_A)</fr:tex> <fr:strong>accpets</fr:strong> <fr:tex display="inline">x</fr:tex> iff there is a sequence
    <fr:tex display="block">         \delta (             \delta (                 \dots \delta (\delta (                     \delta (s_0,x_1),x_2),x_3)\dots ,                 x_{n-1}             )             ,x_n         )\in  S_A     </fr:tex></fr:p>
          </fr:mainmatter>
          <fr:backmatter></fr:backmatter>
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>658</fr:anchor>
        <fr:addr type="machine">#370</fr:addr>
        <fr:route>unstable-370.xml</fr:route>
        <fr:title text="Recognize more complex words">Recognize more complex words</fr:title>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter><fr:p>The char-by-char model is very simple and now we consider about numbers.
        For simplicity, we consider only unsigned integers: An unsigned integer is either
        zero or series of one or more digits where the first one is non-zero.</fr:p>
 
  
  <fr:figure><fr:resource hash="a55a074002c90d74861b032ab9b21f15"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzMS4xNzA1OHB0JyBoZWlnaHQ9JzE1NC4xNTU2OTFwdCcgdmlld0JveD0nLTcyIC03MiA4Ny40NDcwNTQgMTAyLjc3MDQ2MSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQUxvQUFvQUFBQUFBMUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVbDBJMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNCWjJ4NVpnQUFBV1FBQUFBc0FBQUFMTXNMM0lab1pXRmtBQUFCa0FBQUFDMEFBQUEyS1Z3c3FXaG9aV0VBQUFIQUFBQUFJQUFBQUNRRVhnSThhRzEwZUFBQUFlQUFBQUFJQUFBQUNBUWhBSFJzYjJOaEFBQUI2QUFBQUFZQUFBQUdBQllBQUcxaGVIQUFBQUh3QUFBQUZ3QUFBQ0FBQkFBTWJtRnRaUUFBQWdnQUFBRFBBQUFCT1BOaEtxTndiM04wQUFBQzJBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHJxTWVneE0vd0g4cGtoMGtocS9nT0ZBYVprREZ3QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoNi8vOUR5UCtYd1h3R0FGRUlCb29BQUFBQUFRQjBBQUFBNkFCMkFBb0FBRGNPQVFjaUpqUTJOeklXNkFFZ0doVWtJQm9XSXpvWElnRWdNeUlCSUhqYVkyQmtZR0FBNGwzS3pxM3gvRFpmR1poWkdFRGc4ZjZ2czVGcHBtTU1aVUNLZzRFSnhBTUFPSG9LK2dBQUFIamFZMkJrWUdCbStNL0F3TUIwaktHRW9aamhCUU5RQkFVd0FRQlhPUU9lQXNZQUFBRmJBSFFBQUFBQUFCWUFBSGphWTJCa1lHQmdZdUJtQU5FTVVCSUpBQUFCc0FBUkFIamFUWXc5YjhJd0VJYWZpQVNKTUxDZ0RoMktoODRSQkNTMkxneE1yRXdzZ0YyVXdUWnlRaVNrcW1OL2R5K3VoNTdrMC9OK25JR1NiektHeVpqRlBVeE9JZXFQQzZiTUU0OUZMUktYdlBMT2lDeWZpUFBHUitKY2tsUGlnaGMrRTQvRi8wcGNzdUZuNSszOTBabWdEbDZiNEs3V050dWpDVzNqblZwVnk2ajN4cGx3N294V2w2ZlNmZFAyTjZ2V1ZWM1Y3UEJZN2p6b01BUVVCM0YwWk1kVk1rdkRsbU4wV21FdnZtSkZ4ZkpmdnBmY3hjNDUvcVNsYytFcFc5TkxvNVY5azY1aUxaZjE4SDRCekNzditRQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT29BQW9BQUFBQUJCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFc1MHJXTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ21aMng1WmdBQUFXUUFBQURvQUFBQTZLS3NWOGRvWldGa0FBQUNUQUFBQUM4QUFBQTJLUzB1N1dob1pXRUFBQUo4QUFBQUlBQUFBQ1FGemdGWGFHMTBlQUFBQXB3QUFBQUlBQUFBQ0FUcUFEVnNiMk5oQUFBQ3BBQUFBQVlBQUFBR0FIUUFBRzFoZUhBQUFBS3NBQUFBRndBQUFDQUFCQUJLYm1GdFpRQUFBc1FBQUFEVUFBQUJQcGtSZGNkd2IzTjBBQUFEbUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb0dNd1F6TS93SDhwa2gwa2hxL2dPRkFkUEJEUXNBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpCLy85RHlQL3J3SHdHQUZRUkJxOEFBQUFBQVFBMS8rZ0NsZ0xTQUVnQUFBRUhCaWNtSnpZM0xnRUhEZ0VISGdFZkFSNEJGeDRCRndZUEFRWUhCaVluRHdJaUp6OEJQZ0V6TmhjSEJoVVdId0VXTno0Qk55NEJMd0V1QVNjMlB3RTJOeFlYUHdJV0FwUTNBd3dKQWdFQ0FWSkJTMllDQVNjV1JVSXhEdzBqQWdKQUdFaGlMbDBpTWd3R0N3RWVEZzhIQmdvQ0JRTUVNeFE0TUU1b0F3TTlIMjBwUUFJRFJBNUpYMmdyTVF3R0RRTEk0UmNEQVFjTE1WVktBUU5sUWlrdEJ4SVJFaEVLT1RSYVRCcEVCQUVmTERvTkF3dDRPamdLQWcwYkVCTlZId3dZQWdOeFNUMHFCUjBMU0Q1YlJRNUJBd0ZKT3cwQ0F3QUFlTnBqWUdSZ1lBRGlYZWxyTnNmejIzeGxZR1poQUlISCs3L09SdEQvWHpCTlk3b0U1SEl3TUlGRUFYMVlEZW9BZU5wallHUmdZR2I0ejhEQXdGVEdZUHIvSHRNMEJxQUlDbUFDQUdLREJDa0NkZ0FBQW5RQU5RQUFBQUFBZEFBQWVOcGpZR1JnWUdCaThHUUEwUXhRRWdrQUFBZStBRThBZU5wTmpyRnF3ekFVUlkrcFk2aGJ5SlFNSFlxbWpNWjIrZ0dGREpteVppd2trUWd1U0FxeVk4Z1MrZ0g5NkQ0ckd2cUVIa2ZuWFFrQkpYY3lwc3FZeHo1VlRpR25CODk0WVpHNGtLVVNsN3l4NG9rc2Z4Ynp6bWZpbkZlK0VzOVk4cDI0RVArVHVPU0QzNDIzbCt0Z2d0cDViWUk3V2RzMTlkNkV2dk5PTlZYOUVGdmpURGdNUnF2alRlbXg2OGV6VmV1cXJWbzJlQ3dYcmd3WWd2eHNKMFpIZHB4a1p1bG9xTmxIMTh2SnkwU0pxOFQrVDJ3bDRXTHFFRi9Ua2pweWs2NFpKZE5MUDB0YXNaYTc3YlQvQU9DQ01MMTQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVRnQUFvQUFBQUFCWUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVdDBnV050WVhBQUFBRTRBQUFBTWdBQUFEd0FWQUNJWjJ4NVpnQUFBV3dBQUFJVUFBQUNURUlUUmZKb1pXRmtBQUFEZ0FBQUFDOEFBQUEyS1dvdXlXaG9aV0VBQUFPd0FBQUFId0FBQUNRRlJ3SUxhRzEwZUFBQUE5QUFBQUFPQUFBQURnWEJBSFJzYjJOaEFBQUQ0QUFBQUF3QUFBQU1BUllCcEcxaGVIQUFBQVBzQUFBQUdBQUFBQ0FBQ0FBOWJtRnRaUUFBQkFRQUFBREpBQUFCTXUwS2tleHdiM04wQUFBRTBBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVNtYWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9hTUZneU0vd0g4cGtoMGtocS9nT0ZBY1lJREx3QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS0dqRlkvdjhQNUJ1QTZQOFgvNThHcXdJQ0FJMVpDTllBQUhqYUhaSExidE5BRklibm5QR2xjU0RCU1R4dUxzM0ZyajBsU1pNMHdiWWdKV21KUW9uYVFLbmFwaWkwQXBXTEFCVWl3UmFwQ3dSSWlFZGd4d0lRdkVERkMvQWVMQkVMVklrVmhUR3IwVDh6bXZQOTh4RWtyYjgvTUlFZlNJWTBDQUdteGtCVlZKZlhnTHVCRzNRZzhJTThtSG1nekJmSjg4V0o3U3JpbXNuRUxwN0JpRnJJdDU1TW1vWDhWQVJGS29wMGNaeTJNejlMNjRtSUpCbnhmc1VhSnFJeVVrMWZneFUrTEkvc3JpUjE3VkY1eVBsYTljYnNzZ1JOeHpzOE9ZQkdmK0h4K1plYjh3Mm90aXNIWHk3VXVrMENaQ0xJdnVOSGtoYXJyckEyR0hXSWc5ZHErbHlQQWZjRW1zOWdSSXNEZm45OWNwa1BpclM2bVNvOWF4bFJmUFBuVzhad0tDQTZSZ2ExVkFSbWtkVkFFMCtSWlVKUUZ0M1BFdUtvcGNEdlFnZGRMdHJsUVJTMEZaZUwvcUo5VEV4VDFDRDhnQURsd3NrWVVQMmR2VVN2RGQzdE5HY0FWbElySXp5OWZmY1Z4YTMyVnZucUx5ZXF4ZkRvS0tjb3g5bDdMMjRoVkR4MDRya3NHTzdnRVlVSGV5c1BxMzJyRHlCcFMwbUJRUUxoSVlhZnlCeHBDelJQYUJBS3hMd09tRDR6bFJEQWNua293MkFoWU1BRWo4L0Q2djl0aFVwU29STDRyRjlaM0Qya1VNL05qN083cjZsMFhkNllyRzRBMXFlbklWNHd1OGs1Yjlxb3ZXMk5LRVNOVXcwK3RJMklxck1BRmd5bmcvajhUbS9WTERQQWQxL2Y3OGszY2ZGY25VSTJOV1hMN0RSUVN5OHM3Y1BPL3N5T1pUaUFRYjYzM1p1eHNvVDhBMUxTWFVaNDJtTmdaR0JnQU9JTDN6dUM0L2x0dmpJd3N6Q0F3T1A5WDJjajZQOXZtQzR6clFKeU9SaVlRS0lBaGVrT0pRQjQybU5nWkdCZ1p2alB3TURBZEpuQm1NR1VTWWdCS0lJQ21BQTkxd0pZQUFMVEFBQUNSd0F6QUhBQVFRQTNBQUFBQUFBQUFGSUFmZ0RFQVNaNDJtTmdaR0JnWUdXd1lXQmlBQUZHQmpRQUFBYmhBRVo0MmoyTU1RdkNNQkNGdjJJVnJZT0Q0T0Fnd1I5UXRBb3ViZzVPcmc1dTFnVHAwRlRTV25RUmY3clhFTHlRNDd2MzNoMlE4Q0dpcTRpSjcxM0Y4aWFCKzR5WkJoNkl2Z2ljTUdkSmp5Z2VpYkpnSHpobXlDVndueGw1NElIb3I4QUpXNzZIcW53OEcrUFVxZExHMlZ2cGRtZmo2cUt5YXAydXV2Rm9ySEhYeG1pVnY1VnVpN3E5bDJxVFptbkdnWXFTQjA4YURBN0ZTUlR0MlhJVHo3SGo3T2VhUWp3cm1UVXBxNzk3Rk5mNnhOVmYwWkxJZVV2WHRMSlRTNzlMVnJHUnZhejdQMWt5TGswQUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00MC44ODc1MzUsLTEwLjU1MzczMSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzEuMjI5MTQsLTM2LjMxOTQ2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDAuODg3NTM1LC0xMC41NTM3MzEpc2NhbGUoLTEsLTEpJz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMS4zMDg4NzcsLTc3LjYwNzg1MSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMS43NTg3NDYsLTc3LjYwNzg1MSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMzA5MDQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxMS43NTg3NDYsLTc3LjYwNzg1MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PScxMS43NTg3NDYnIHk9Jy03Ny42MDc4NTEnPlM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTcuODY3NzkxJyB5PSctNzYuMTEzNDcnPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMxLjMwODg3NywtNDQuMDgwNzkxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4zMDkwNCwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zMS4zMDg4NzcsLTQ0LjA4MDc5MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzEuMzA4ODc3JyB5PSctNDQuMDgwNzkxJz5TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yNS4xOTk4MzEnIHk9Jy00Mi41ODY0MSc+MDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzEuMzA4ODc3LC0xMC41NTM3MzEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTEuNzU4NzQ2LC0xMC41NTM3MzEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjMwOTA0LDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTEuNzU4NzQ2LC0xMC41NTM3MzEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTEuNzU4NzQ2JyB5PSctMTAuNTUzNzMxJz5TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzE3Ljg2Nzc5MScgeT0nLTkuMDU5MzUnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTTI1LjQzNDQyIDQxLjY3OTE1QzM0LjY2Njk4IDYxLjQ3NjcyIDUxLjIyNjcgNDcuMjk0NyAzMS43OTE2MSAzOC4yMzE0NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC45MDYzLC0wLjQyMjYyLDAuNDIyNjIsLTAuOTA2MywzMS42MTAzOCwzOC4xNDY5NCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MS42NzA4LDUzLjEwOTcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MC44ODc1MzUsLTEwLjU1MzczMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDAuODg3NTM1JyB5PSctMTAuNTUzNzMxJz4wPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0zNi45MTYyOTQnIHk9Jy0xMC41NTM3MzEnPi4uPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zMi4xODQwMTInIHk9Jy0xMC41NTM3MzEnPjk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTExLjc5OTk5LTcuODA1ODVMMTEuNDg0NC0yNS45MzM1NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjc4OTA1LC0wLjYxNDI5LDAuNjE0MjksMC43ODkwNSwxMS42NDIxOCwtMjYuMDU2MzgpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMi4zNTI3NSwtMTQuNjM5NzkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MC44ODc1MzUsLTEwLjU1MzczMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDAuODg3NTM1JyB5PSctMTAuNTUzNzMxJz4wPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS0xMS43OTk5OSA3LjQ3MjVMMTEuNDg0NCAyNS42MDAyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzg5MDUsMC42MTQyOSwtMC42MTQyOSwwLjc4OTA1LDExLjY0MjE4LDI1LjcyMzA0KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNS4wNzUwMSwxOS4wMTE5NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQwLjg4NzUzNSwtMTAuNTUzNzMxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00MC44ODc1MzUnIHk9Jy0xMC41NTM3MzEnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTM2LjkxNjI5NCcgeT0nLTEwLjU1MzczMSc+Li48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTMyLjE4NDAxMicgeT0nLTEwLjU1MzczMSc+OTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+"></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            &amp; {S_2}
            \arrow [out=65, in=25 ,loop,&quot;0..9&quot;]
            \\
            {S_0} \\
            &amp; {S_1}
            \arrow [&quot;0&quot;, from=2-1, to=3-2]
            \arrow [&quot;{1..9}&quot;, from=2-1, to=1-2]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure>
 
<fr:p>And the code implementation can be:</fr:p><fr:pre>    state &lt;- s0;
    char &lt;-nextChar();
    while (state != se and char != eof) {
        state &lt;- delta(state, char);
        char &lt;- nextChar();
    }
    if (state in SA) {
        return Acceptance();
    } else {
        reportError();
    }</fr:pre><fr:p>Another example is to recognize <fr:strong>identifiers</fr:strong> which are sequences of letters and digits,
        starting with a letter. Many languages include other special characters for identifiers.
        The FA for unsigned integers and identifiers are different in syntactic categories.</fr:p></fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>659</fr:anchor>
        <fr:addr type="machine">#371</fr:addr>
        <fr:route>unstable-371.xml</fr:route>
        <fr:title text="Regular Expressions">Regular Expressions</fr:title>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:p>The set of words accpeted by a finite automata <fr:tex display="inline">F</fr:tex> forms a language <fr:tex display="inline">L(F)</fr:tex>.
        The transition diagram of <fr:tex display="inline">F</fr:tex> specifies the syntactic structure of <fr:tex display="inline">L(F)</fr:tex>.
        But such representation is complex and non-intuitive.
        Most systems use a notation called <fr:strong>regular expressions</fr:strong> to specify the language.
        Any language described by an RE is considered a <fr:strong>regular language</fr:strong>.
        RE is equivalent to FA.</fr:p>
        <fr:p>To work with REs in a rigorous way, we need a foraml definition.</fr:p>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="References">References</fr:title>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>1706</fr:anchor>
            <fr:addr type="user">eng-compiler-2022</fr:addr>
            <fr:route>eng-compiler-2022.xml</fr:route>
            <fr:title text="Engineering a Compiler">Engineering a Compiler</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:authors>
              <fr:author>Keith D. Cooper</fr:author>
              <fr:author>Linda Torczon</fr:author>
            </fr:authors>
            <fr:meta name="doi">doi.org/10.1016/C2014-0-01395-0</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter></fr:mainmatter>
          <fr:backmatter></fr:backmatter>
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Context">Context</fr:title>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>1709</fr:anchor>
            <fr:addr type="user">notes</fr:addr>
            <fr:route>notes.xml</fr:route>
            <fr:title text="Notes">Notes</fr:title>
            <fr:authors></fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>500</fr:anchor>
                <fr:addr type="user">tt-0001</fr:addr>
                <fr:route>tt-0001.xml</fr:route>
                <fr:title text="Untyped Lambda Calculus">Untyped Lambda Calculus</fr:title>
                <fr:taxon>Type Theory</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>26</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter><fr:p>Refer to <fr:link type="local" href="ttafp-2014.xml" addr="ttafp-2014" title="Type Theory and Formal Proofs">Type Theory and Formal Proof</fr:link>.</fr:p><fr:p>The idea to generalize the behavior of functions in mathematics and logic led to the development of the lambda calculus.
    The lambda calculus is a formal system for expressing computation based on function abstraction and application using <fr:em>variable binding</fr:em> and <fr:em>substitution</fr:em>. 
    In dealing with functions there are two <fr:strong>construction principles</fr:strong> and one <fr:strong>evalutaion rule</fr:strong>.
    <fr:ul><fr:li><fr:strong>Construction Principles</fr:strong>: note that expressions do not force to be meaningful.</fr:li>
        <fr:ul><fr:li>Function Abstraction: <fr:tex display="inline">\lambda  x.M</fr:tex></fr:li>
            <fr:li>Function Application: <fr:tex display="inline">M N</fr:tex>, this only produces a new expression,
            in which the function has not yet been executed.</fr:li></fr:ul>
    <fr:li><fr:strong>Evaluation Rule</fr:strong></fr:li>
        <fr:ul><fr:li>Beta Reduction: <fr:tex display="inline">(\lambda  x.M)N\to  M[x:=N]</fr:tex></fr:li></fr:ul></fr:ul>
    The beta reduction makes use of the <fr:strong>substitution</fr:strong> <fr:tex display="inline">M[x:=N]</fr:tex> which represents the result of replacing all free occurrences of <fr:tex display="inline">x</fr:tex> in <fr:tex display="inline">M</fr:tex> with <fr:tex display="inline">N</fr:tex>.
    Note that the application is <fr:strong>left associative</fr:strong>, that is, <fr:tex display="inline">MNP</fr:tex> means <fr:tex display="inline">(MN)P</fr:tex>.
    And application has the highest precedence, that is, <fr:tex display="inline">\lambda  x.MN</fr:tex> means <fr:tex display="inline">\lambda  x.(MN)</fr:tex>.</fr:p><fr:p>The multi-argument function <fr:tex display="inline">\lambda  x_1\ldots  x_n.M</fr:tex> is defined as <fr:tex display="inline">\lambda  x_1.(\lambda  x_2.(\ldots (\lambda  x_n.M)\ldots ))</fr:tex> (right associative),
    that is, simulated by a sequence of single-argument functions. The later function is called <fr:strong>curried function</fr:strong> and the
    process of transforming a multi-argument function into a sequence of single-argument functions is called <fr:strong>currying</fr:strong>.</fr:p>
    <fr:strong>Lambda Terms</fr:strong>
    <fr:p>Expressions in the lambda calculus is called <fr:strong>terms</fr:strong>. The set of terms is denoted <fr:tex display="inline">\Lambda </fr:tex>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>501</fr:anchor><fr:addr type="user">def-000F</fr:addr><fr:route>def-000F.xml</fr:route><fr:title text="Set of Lambda Terms">Set of Lambda Terms</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">\Lambda </fr:tex> be the set of lambda terms. Then <fr:tex display="inline">\Lambda </fr:tex> is defined inductively as follows:
(<fr:tex display="inline">V</fr:tex> is the set of variables)
<fr:ul><fr:li>Variable: <fr:tex display="inline">\forall  x\in  V, x\in  \Lambda </fr:tex></fr:li>
<fr:li>Abstraction: <fr:tex display="inline">\forall  x\in  V, M\in  \Lambda , \lambda  x.M\in  \Lambda </fr:tex></fr:li>
<fr:li>Application: <fr:tex display="inline">\forall  M,N\in  \Lambda , (MN)\in  \Lambda </fr:tex></fr:li></fr:ul></fr:p><fr:p>Another way to define <fr:tex display="inline">\Lambda </fr:tex> is to use the following grammar (The 3 possibilities are separated by <fr:code>|</fr:code>):
<fr:tex display="block">\Lambda  = V | \lambda  V.\Lambda  | \Lambda \Lambda </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:p>With the following recursive definition we can determine 
    what the <fr:strong>subterms</fr:strong> of a give <fr:tex display="inline">\lambda \text {-term}</fr:tex> are. Here we use 
    a concept named <fr:link type="local" href="def-0035.xml" addr="def-0035" title="Multiset">multiset</fr:link>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>502</fr:anchor><fr:addr type="user">def-0036</fr:addr><fr:route>def-0036.xml</fr:route><fr:title text="Multiset of Subterms">Multiset of Subterms</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We define a map <fr:tex display="inline">\text {Sub}</fr:tex>:
    <fr:ul><fr:li><fr:strong>Basis</fr:strong>: <fr:tex display="inline">\forall  x\in  V,\text {Sub}(x) =\{ x \}</fr:tex></fr:li>
        <fr:li><fr:strong>Application</fr:strong>: <fr:tex display="inline">\forall  M,N\in \Lambda ,\text {Sub}(MN) = \text {Sub}(M)\cup \text {Sub}(N)\cup \{ MN \}</fr:tex></fr:li>
        <fr:li><fr:strong>Abstraction</fr:strong>: <fr:tex display="inline">\forall  x\in  V,M\in \Lambda ,\text {Sub}(\lambda  x.M) = \text {Sub}(M)\cup \{ \lambda  x.M \}</fr:tex></fr:li></fr:ul>
    <fr:tex display="inline">L</fr:tex> is a subterm of <fr:tex display="inline">M</fr:tex> if <fr:tex display="inline">L\in \text {Sub}(M)</fr:tex>.
    If <fr:tex display="inline">L\not \equiv  M</fr:tex> then we say <fr:tex display="inline">L</fr:tex> is a <fr:strong>proper subterm</fr:strong> of <fr:tex display="inline">M</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The definition above uses a notation <fr:tex display="inline">\equiv </fr:tex> which means <fr:em>syntactic equality</fr:em> here.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>503</fr:anchor><fr:addr type="user">eg-0006</fr:addr><fr:route>eg-0006.xml</fr:route><fr:title text="Subterms">Subterms</fr:title><fr:taxon>Example</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:ul><fr:li><fr:tex display="inline">\text {Sub}((x\space z))</fr:tex> = <fr:tex display="inline">\{ x,z,(x\space z) \}</fr:tex></fr:li>
    <fr:li><fr:tex display="inline">             \text {Sub}(\lambda  x.(x\space x))              = \{ \lambda  x.(x\space x),(x\space x),x,x \}         </fr:tex></fr:li></fr:ul></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The substerm mapping satisfies the following lemma.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>504</fr:anchor><fr:addr type="user">thm-000W</fr:addr><fr:route>thm-000W.xml</fr:route><fr:title text="Lemma of subterms">Lemma of subterms</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:ul><fr:li><fr:strong>Reflexivity</fr:strong>: <fr:tex display="inline">\forall  M\in \Lambda ,M\in \text {Sub}(M)</fr:tex></fr:li>
        <fr:li><fr:strong>Transitivity</fr:strong>: <fr:tex display="inline">\forall  L,M,N\in \Lambda ,L\in \text {Sub}(M)\land  M\in \text {Sub}(N)\implies  L\in \text {Sub}(N)</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Variable occurrences in a <fr:tex display="inline">\lambda \text {-term}</fr:tex> can be divided into 3 categories:
    <fr:ul><fr:li>Bound Occurrences: <fr:tex display="inline">x</fr:tex> is bound in <fr:tex display="inline">M</fr:tex> if <fr:tex display="inline">x</fr:tex> is the argument of an <fr:strong>abstraction</fr:strong> in <fr:tex display="inline">M</fr:tex>.</fr:li>
        <fr:li>Free Occurrences: <fr:tex display="inline">x</fr:tex> is free in <fr:tex display="inline">M</fr:tex> if <fr:tex display="inline">x</fr:tex> is not bound by any <fr:strong>abstraction</fr:strong> in <fr:tex display="inline">M</fr:tex>.</fr:li>
        <fr:li>Binding Occurrences: something after a lambda notation <fr:tex display="inline">\lambda </fr:tex></fr:li></fr:ul>
    We mainly focus on the <fr:strong>free variables</fr:strong> of a term.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>505</fr:anchor><fr:addr type="user">def-0037</fr:addr><fr:route>def-0037.xml</fr:route><fr:title text="Set of Free Variables">Set of Free Variables</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">FV(L)</fr:tex> be the set of free variables in a term <fr:tex display="inline">L</fr:tex>.
    <fr:ul><fr:li><fr:strong>Variable</fr:strong>: <fr:tex display="inline">\forall  x\in  V,\text {FV}(x) = \{ x \}</fr:tex></fr:li>
        <fr:li><fr:strong>Application</fr:strong>: <fr:tex display="inline">\forall  M,N\in \Lambda ,\text {FV}(MN) = \text {FV}(M)\cup \text {FV}(N)</fr:tex></fr:li>
        <fr:li><fr:strong>Abstraction</fr:strong>: <fr:tex display="inline">\forall  x\in  V,M\in \Lambda ,\text {FV}(\lambda  x.M) = \text {FV}(M)\setminus \{ x \}</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>506</fr:anchor><fr:addr type="user">def-0038</fr:addr><fr:route>def-0038.xml</fr:route><fr:title text="Closed Lambda Terms">Closed Lambda Terms</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:tex display="inline">\lambda \text {-term}</fr:tex> <fr:tex display="inline">M</fr:tex> is <fr:strong>closed</fr:strong> if <fr:tex display="inline">\text {FV}(M) = \emptyset </fr:tex>.
    A closed <fr:tex display="inline">\lambda \text {-term}</fr:tex> is also called a <fr:strong>combinator</fr:strong>.
    The set of all combinators is denoted by <fr:tex display="inline">\Lambda ^0</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>507</fr:anchor><fr:addr type="machine">#278</fr:addr><fr:route>unstable-278.xml</fr:route><fr:title text="Alpha conversion">Alpha conversion</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Functions in <fr:tex display="inline">\lambda \text {-calculus}</fr:tex> have the property that the name of 
    the binding variables is irrelevant.
    In order to describe this equality we need to define a relation
    called <fr:tex display="inline">\alpha \text {-conversion}</fr:tex> or <fr:tex display="inline">\alpha \text {-equivalence}</fr:tex>,
    which is based on the process of renaming binding variables.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>508</fr:anchor><fr:addr type="user">def-0039</fr:addr><fr:route>def-0039.xml</fr:route><fr:title text="Renaming">Renaming</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">M^{x\to y}</fr:tex> be the result of replacing all free occurrences of <fr:tex display="inline">x</fr:tex> in <fr:tex display="inline">M</fr:tex> with <fr:tex display="inline">y</fr:tex>.
    The relation <fr:strong>renaming</fr:strong> is expression with the symbol <fr:tex display="inline">=_\alpha </fr:tex>:
    <fr:tex display="inline">\lambda  x.M=_\alpha \lambda  y.M^{x\to y}</fr:tex> if <fr:tex display="inline">y\not \in \text {FV}(M)</fr:tex> and <fr:tex display="inline">y</fr:tex> is not a binding variable in <fr:tex display="inline">M</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The definition of <fr:strong>renaming</fr:strong> should be extended to more general terms.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>509</fr:anchor><fr:addr type="user">def-003A</fr:addr><fr:route>def-003A.xml</fr:route><fr:title text="Alpha Equivalence">Alpha Equivalence</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:tex display="inline">\alpha </fr:tex> equivalence is a relation between <fr:tex display="inline">\lambda \text {-term}</fr:tex>, defined as follows:
    <fr:ul><fr:li><fr:strong>Renaming</fr:strong>: <fr:tex display="inline">\lambda  x. M =_\alpha  \lambda  y. M^{x\to y}</fr:tex> if <fr:tex display="inline">y\not \in \text {FV}(M)</fr:tex> and <fr:tex display="inline">y</fr:tex> is not a binding variable in <fr:tex display="inline">M</fr:tex>.</fr:li>
        <fr:li><fr:strong>Compatibility</fr:strong>: If <fr:tex display="inline">M=_\alpha  N</fr:tex> then <fr:tex display="inline">\lambda  x.M=_\alpha \lambda  x.N</fr:tex> and <fr:tex display="inline">ML =_\alpha  NL, LM =_\alpha  LN</fr:tex>.</fr:li>
        <fr:li><fr:strong>Reflexivity</fr:strong>: <fr:tex display="inline">M=_\alpha  M</fr:tex>.</fr:li>
        <fr:li><fr:strong>Symmetry</fr:strong>: If <fr:tex display="inline">M=_\alpha  N</fr:tex> then <fr:tex display="inline">N=_\alpha  M</fr:tex>.</fr:li>
        <fr:li><fr:strong>Transitivity</fr:strong>: If <fr:tex display="inline">M=_\alpha  N</fr:tex> and <fr:tex display="inline">N=_\alpha  L</fr:tex> then <fr:tex display="inline">M=_\alpha  L</fr:tex>.</fr:li></fr:ul>
    The first principle is the basis of alpha equivalence, which is the same as <fr:link type="local" href="def-0039.xml" addr="def-0039" title="Renaming">renaming</fr:link>.
    The last 3 properties ensures that <fr:tex display="inline">=_\alpha </fr:tex> is an <fr:link type="local" href="def-000X.xml" addr="def-000X" title="Equivalence Relation">equivalence relation</fr:link>.</fr:p><fr:p>If <fr:tex display="inline">M=_\alpha  N</fr:tex> then we say <fr:tex display="inline">M</fr:tex> and <fr:tex display="inline">N</fr:tex> are <fr:tex display="inline">\alpha \text {-equivalent}</fr:tex> or <fr:tex display="inline">\alpha \text {-convertible}</fr:tex>.
    <fr:tex display="inline">M</fr:tex> is an <fr:tex display="inline">\alpha \text {-variant}</fr:tex> of <fr:tex display="inline">N</fr:tex> and vice versa.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>In previous sections we informally mentioned the concept of <fr:strong>substitution</fr:strong>.
    Now we give a precise formulation</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>510</fr:anchor><fr:addr type="user">def-003B</fr:addr><fr:route>def-003B.xml</fr:route><fr:title text="Substitution">Substitution</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>substitution</fr:strong> is defined by the following rules:
    <fr:ul><fr:li><fr:tex display="inline">M[x:=N]:\equiv  N</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">y[x:=N]:\equiv  y</fr:tex> if <fr:tex display="inline">y\not \equiv  x</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">(PQ)[x:=N]:\equiv (P[x:=N])(Q[x:=N])</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">(\lambda  y.P)[x:=N]:\equiv \lambda  z.P^{y\to z}[x:=N]</fr:tex> 
            if <fr:tex display="inline">\lambda  z.P^{y\to z} =_\alpha  \lambda  y.P</fr:tex> and <fr:tex display="inline">z\not \in \text {FV}(N)</fr:tex></fr:li></fr:ul>
    The terms with form <fr:tex display="inline">P[x:=N]</fr:tex> are not <fr:tex display="inline">\lambda \text {-term}</fr:tex>,
    but we can regard them as a <fr:em>meta notation</fr:em> that appears
    in the substitution process and the result contains no such terms.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Renaming can be considered as a special case of substitution.
    We can show that <fr:tex display="inline">M^{x\to u}=_\alpha M[x:=u]</fr:tex> if the conditions of renaming are satisfied.</fr:p><fr:p>We may do <fr:strong>sequential substitution</fr:strong> in a term,
    that is, doing a number of substitutions consecutively.
    And we have the following lemma, which states that the order of substitution is important.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>511</fr:anchor><fr:addr type="user">thm-000X</fr:addr><fr:route>thm-000X.xml</fr:route><fr:title text="Substitution is not commutative">Substitution is not commutative</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">x\not \equiv  y</fr:tex> and assume <fr:tex display="inline">x\not \in \text {FV}(L)</fr:tex>.
    Then <fr:tex display="inline">L[y:=N][x:=M] \equiv  L[x:=M][y:=N[x:=M]]</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>512</fr:anchor><fr:addr type="machine">#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:title text="{-Term} modulo {-equivalence}"><fr:tex display="inline">\lambda \text {-term}</fr:tex> modulo <fr:tex display="inline">\alpha \text {-equivalence}</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>As we have seen, the relation <fr:tex display="inline">=_\alpha </fr:tex> is an equivalence relation.
    Hence we can define the set of equivalence classes of terms with respect to <fr:tex display="inline">=_\alpha </fr:tex>.
    Now we can identify a term with its equivalence class.
    We still use <fr:tex display="inline">\equiv </fr:tex> for syntactic equality modulo <fr:tex display="inline">\alpha \text {-equivalence}</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p><fr:tex display="inline">\alpha \text {-equivalence}</fr:tex> is a congruence relation, which means that it is conserved by elementary process of term construction.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>513</fr:anchor><fr:addr type="user">thm-000Y</fr:addr><fr:route>thm-000Y.xml</fr:route><fr:title text="Congruence Property of Substitution">Congruence Property of Substitution</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">L=_\alpha  M</fr:tex> and <fr:tex display="inline">N=_\alpha  P</fr:tex>.
    <fr:ul><fr:li><fr:tex display="inline">                 LN =_\alpha  MP             </fr:tex></fr:li>
        <fr:li><fr:tex display="inline">                 \lambda  x.L =_\alpha  \lambda  x.M             </fr:tex></fr:li>
        <fr:li><fr:tex display="inline">                 L[x:=N] =_\alpha  M[x:=P]             </fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>514</fr:anchor><fr:addr type="machine">#280</fr:addr><fr:route>unstable-280.xml</fr:route><fr:title text="Barendregt Convention">Barendregt Convention</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The Barendregt Convention states that we should avoid using the same variable name in different abstractions.
    This is to avoid the confusion of free variables. It states that 
    we choose the names for the binding variables in a <fr:tex display="inline">\lambda \text {-term}</fr:tex> in such a manner
    that they are all different, and each of them differs from 
    all free variables occurring in the term.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>515</fr:anchor><fr:addr type="machine">#281</fr:addr><fr:route>unstable-281.xml</fr:route><fr:title text="Beta Reduction">Beta Reduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since we have formally defined the <fr:strong>substitution</fr:strong>,
        we can rephrase the reduction as a relation on <fr:tex display="inline">\lambda \text {-term}</fr:tex>, namely <fr:tex display="inline">\beta \text {-reduction}</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>516</fr:anchor><fr:addr type="user">def-003C</fr:addr><fr:route>def-003C.xml</fr:route><fr:title text="One Step Beta Reduction">One Step Beta Reduction</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>One step beta reduction</fr:strong> (<fr:tex display="inline">\to _\beta </fr:tex>) is defined as follows:
    <fr:ul><fr:li><fr:strong>Basis</fr:strong>:
            <fr:tex display="inline">                 (\lambda  x.M)N\to _\beta M[x:=N]             </fr:tex></fr:li>
        <fr:li><fr:strong>Compatibility</fr:strong>:
            If <fr:tex display="inline">M\to _\beta  N</fr:tex> then <fr:tex display="inline">\lambda  x.M\to _\beta \lambda  x.N</fr:tex>,
            <fr:tex display="inline">ML\to _\beta  NL</fr:tex> and <fr:tex display="inline">LM\to _\beta  LN</fr:tex>.</fr:li></fr:ul></fr:p><fr:p>The term of the form <fr:tex display="inline">(\lambda  x.M)N</fr:tex> is called a <fr:strong>redex (reducible expression)</fr:strong>.
    The term of the form <fr:tex display="inline">M[x:=N]</fr:tex> is called the <fr:strong>contractum</fr:strong> (of the redex).</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>517</fr:anchor><fr:addr type="user">eg-0007</fr:addr><fr:route>eg-0007.xml</fr:route><fr:title text="Divergent Combinator">Divergent Combinator</fr:title><fr:taxon>Example</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An interesting example named <fr:strong>omega combinator</fr:strong> of beta reduction is the following:
    <fr:tex display="block">         ((\lambda  x.(x\space x))\space (\lambda  x.(x\space x)))         \to _\beta          ((\lambda  x.(x\space x))\space (\lambda  x.(x\space x)))     </fr:tex>
    The result of the beta reduction is the same term as the original term,
    and never terminates.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We can often perform a sequence of beta reductions. This leads to the definition.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>518</fr:anchor><fr:addr type="user">def-003D</fr:addr><fr:route>def-003D.xml</fr:route><fr:title text="Beta Reduction">Beta Reduction</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>(zero-or-more-step) beta reduction</fr:strong> (<fr:tex display="inline">\twoheadrightarrow _{\beta }</fr:tex>) is a
    generalized version of the <fr:link type="local" href="def-003C.xml" addr="def-003C" title="One Step Beta Reduction">one step beta reduction</fr:link>.
    <fr:tex display="inline">M\twoheadrightarrow _{\beta } N</fr:tex> if there exists <fr:tex display="inline">n\geq  0</fr:tex> and there are terms <fr:tex display="inline">M_0,M_1,\ldots ,M_n</fr:tex>
    such that <fr:tex display="inline">M_0=M</fr:tex>, <fr:tex display="inline">M_n=N</fr:tex> and <fr:tex display="inline">M_i\to _\beta  M_{i+1}</fr:tex> for <fr:tex display="inline">0\leq  i&lt;n</fr:tex>.
    In other words there exists a chain of one-step beta reductions from <fr:tex display="inline">M</fr:tex> to <fr:tex display="inline">N</fr:tex>.
    <fr:tex display="block">         M\equiv  M_0\to _\beta  M_1\to _\beta \cdots \to _\beta  M_n\equiv  N     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>519</fr:anchor><fr:addr type="user">thm-000Z</fr:addr><fr:route>thm-000Z.xml</fr:route><fr:title text="Properties of Beta Reduction">Properties of Beta Reduction</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:ul><fr:li><fr:strong>Compatibility</fr:strong>:
            <fr:tex display="inline">\twoheadrightarrow _{\beta }</fr:tex> extends <fr:tex display="inline">\to _\beta </fr:tex>, i.e. if <fr:tex display="inline">M\to _\beta  N</fr:tex> then <fr:tex display="inline">M\twoheadrightarrow _{\beta } N</fr:tex>.</fr:li>
        <fr:li><fr:strong>Reflixivity</fr:strong>:
            <fr:tex display="inline">                 M\twoheadrightarrow _{\beta } M             </fr:tex></fr:li>
        <fr:li><fr:strong>Transitivity</fr:strong>:
            <fr:tex display="inline">                 M\twoheadrightarrow _{\beta } N \land  N\twoheadrightarrow _{\beta } P \implies  M\twoheadrightarrow _{\beta } P             </fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>520</fr:anchor>
                <fr:addr type="user">tt-0007</fr:addr>
                <fr:route>tt-0007.xml</fr:route>
                <fr:title text="Contextual Modal Type Theory">Contextual Modal Type Theory</fr:title>
                <fr:taxon>Type Theory</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>27</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter><fr:p>Recently I have been studying some work on <fr:strong>Hole</fr:strong>, and found some interesting things.
    As stated in <fr:link type="local" href="smpe.xml" addr="smpe" title="Toward Semantic Foundations for Program Editors">Semantic Foundations for Program Editors</fr:link>, expression hole can be seen as
    <fr:strong>metavariables</fr:strong> of <fr:strong>contextual modal type theory (CMTT)</fr:strong>. That is, expression 
    holes can have types and are surrounded by contexts, just as metavariables in CMTT are 
    associated with types and contexts. This note is a brief summary of the paper <fr:link type="local" href="cmtt.xml" addr="cmtt" title="Contextual Modal Type Theory">Contextual Modal Type Theory</fr:link>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>521</fr:anchor><fr:addr type="machine">#252</fr:addr><fr:route>unstable-252.xml</fr:route><fr:title text="Introduction and Motivation">Introduction and Motivation</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>Contextual modal type theory provides an elegant and uniform foundation for understanding metavariables and explicit
        substitutions. Context is common in logic because the truth of a proposition can depend on the context we consider it in
        rather than being absolute. Narrowing our scope we may think of a context as consisting of the hypothesis that we made
        to establish a final conclusion.</fr:p>
    <fr:p>There arre two main approaches to intuitionistic modal logic.
        <fr:ul><fr:li><fr:strong>Nominal</fr:strong>: Assign names to contexts and includes explicit judgments to relate them.</fr:li>
            <fr:li><fr:strong>Structural</fr:strong>: Identifies the context with propositions it contains. In this article we
            carry this idea further which allows arbitrary contexts to be captured within  a proposition.</fr:li></fr:ul></fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>522</fr:anchor><fr:addr type="machine">#253</fr:addr><fr:route>unstable-253.xml</fr:route><fr:title text="Contextual Modal Logic">Contextual Modal Logic</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The philosophical foundation of our development is MLTT approaches of separating 
        judgments and propositions. The most basic judgment is the truth of a proposition,
        <fr:tex display="inline">A\space \text {true}</fr:tex>. We explain the <fr:em>meaning</fr:em> of a proposition by 
        presenting the means of inferring its truth via introduction rules, and exploiting
        the knowledge of its truth via elimination rules. In this section we assume there are
        some atomic proposition <fr:tex display="inline">P</fr:tex> and we define implication <fr:tex display="inline">A\to  B</fr:tex> and a contextual
        modal operator <fr:tex display="inline">[\Psi ]A</fr:tex> where <fr:tex display="inline">\Psi </fr:tex> is a context.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>523</fr:anchor><fr:addr type="machine">#260</fr:addr><fr:route>unstable-260.xml</fr:route><fr:title text="Hypothesis judgments">Hypothesis judgments</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:p>We write 
            <fr:tex display="block">                 x_1:A_1\space \text {true}, \ldots , x_n:A_n\space \text {true}\vdash  A\space \text {true}             </fr:tex>
            to express that <fr:tex display="inline">A</fr:tex> is true if all hypotheses <fr:tex display="inline">x_1:A_1,\ldots ,x_n:A_n</fr:tex> are true.
            At this moment we can view contexts as unordered, later contexts are reified in 
            modal operators and may even be <fr:strong>internally dependent</fr:strong>, at which point the
            order is important.</fr:p>
        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>524</fr:anchor><fr:addr type="machine">#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:title text="Hypothesis Rule">Hypothesis Rule</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            <fr:p><fr:tex display="block">                     \frac {}{                         \Gamma , x:A\space \text {true}, \Gamma &apos; \vdash  A\space \text {true}                     }(\text {hyp}_x)                 </fr:tex>
                The distinct labels for assumptions are necessary (?)</fr:p>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>525</fr:anchor><fr:addr type="machine">#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:title text="Substitution Rule">Substitution Rule</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            If <fr:tex display="inline">\Gamma \vdash  A\space \text {true}</fr:tex> and <fr:tex display="inline">\Gamma ,x:A\space \text {true},\Gamma &apos;\vdash  C\space \space \text {true}</fr:tex>
            then <fr:tex display="inline">\Gamma ,\Gamma &apos;\vdash  C\space \text {true}</fr:tex>. (Note that this rule is <fr:em>admissible</fr:em>)
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>526</fr:anchor><fr:addr type="machine">#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:title text="Implication Introduction">Implication Introduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                 \frac {                     \Gamma , x:A\space \text {true}\vdash  B\space \text {true}                 }{                     \Gamma \vdash  A\to  B\space \text {true}                 }(\to \text {I}^x)             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>527</fr:anchor><fr:addr type="machine">#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:title text="Implication Elimination">Implication Elimination</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                 \frac {                     \Gamma \vdash  A\to  B\space \text {true}\quad \Gamma \vdash  A\space \text {true}                 }{                     \Gamma \vdash  B\space \text {true}                 }(\to \text {E})             </fr:tex>
            It implies that elimination rule cannot extract more knowledge from 
            a proposition than contributed by its proof (Soundness). 
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>528</fr:anchor><fr:addr type="machine">#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:title text="Local Reduction for Implication (Computational Rule)">Local Reduction for Implication (Computational Rule)</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                 \frac {                     \dfrac {                         \Gamma , x:A\space \text {true}\vdash  B\space \text {true}                     }{                         \Gamma \vdash  A\to  B\space \text {true}                     }(\to \text {I}^x)                     \quad                      \Gamma \vdash  A\space \text {true}                 }{                     \Gamma \vdash  B\space \text {true}                 }(\to \text {E})                 \mapsto  _R \Gamma \vdash  B\space \text {true}             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>529</fr:anchor><fr:addr type="machine">#259</fr:addr><fr:route>unstable-259.xml</fr:route><fr:title text="Local Expansion for Implication">Local Expansion for Implication</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                 \Gamma \vdash  A\to  B\space \text {true} \mapsto _E                 \frac {                     \Gamma ,x:A\space \text {true}\vdash  A\to  B\space \text {true}\quad  \dfrac {}{\Gamma ,x:A\space \text {true}\vdash  A\space \text {true}}(\text {hyp}_x)                 }{                     \dfrac {\Gamma ,x:A\space \text {true}\vdash  B\space \text {true}}{\Gamma \vdash  A\to  B\space \text {true}}(\to \text {I}^x)                 }             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>530</fr:anchor><fr:addr type="machine">#263</fr:addr><fr:route>unstable-263.xml</fr:route><fr:title text="Categorical judgments">Categorical judgments</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:p><fr:tex display="inline">A</fr:tex> is <fr:strong>categorically true</fr:strong> or valid if its truth does not depend on any hypotheses
            about the truth of other propositions. Instead it may depend on the validity of other proposition,
            because their validity may not depend on truth assumptions.</fr:p>
        <fr:p>We weite <fr:tex display="inline">\Delta </fr:tex> for a labeled list <fr:tex display="inline">u_1 :: A_1\space \text {valid},\ldots ,u_n :: A_n\space \text {valid}</fr:tex> of assumptions
            about the validity of propositions. We separate validity and truth:
            <fr:tex display="block">                 \Delta ;\Gamma \vdash  \mathcal {J}             </fr:tex>
            where <fr:tex display="inline">\mathcal {J}</fr:tex> is a judgment <fr:tex display="inline">A\space \text {true}</fr:tex> or <fr:tex display="inline">A\space \text {valid}</fr:tex>.</fr:p>
        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>531</fr:anchor><fr:addr type="machine">#261</fr:addr><fr:route>unstable-261.xml</fr:route><fr:title text="Validity">Validity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            <fr:p><fr:tex display="block">                     \frac {\Delta ;\cdot \vdash  A\space \text {true}}{\Delta ;\Gamma \vdash  A\space \text {valid}}                 </fr:tex></fr:p>
            
            <fr:p>Conversely if <fr:tex display="inline">A</fr:tex> is valid we can conclude that it is true</fr:p>
            <fr:tex display="block">                 \frac {}{                     (\Delta ,u::A\space \text {valid},\Delta &apos;);\Gamma \vdash  A\space \text {true}                 }(\text {vldhyp}_u)             </fr:tex>
            <fr:p>In terms of a multiple world semantics, we say taht <fr:tex display="inline">A</fr:tex> is valid if <fr:tex display="inline">A</fr:tex> is
                true in <fr:strong>every</fr:strong> possible world. We require that <fr:tex display="inline">A</fr:tex> must be true in a 
                world about which we assume nothing (<fr:tex display="inline">\Gamma  = \cdot </fr:tex>), except the constant-true
                propositions <fr:tex display="inline">\Delta </fr:tex>.</fr:p>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>532</fr:anchor><fr:addr type="machine">#262</fr:addr><fr:route>unstable-262.xml</fr:route><fr:title text="Substitution Principle for Validity">Substitution Principle for Validity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            <fr:p>Note that by the definition of validity we can immediately reduce the goal
                of proving <fr:tex display="inline">A\space \text {valid}</fr:tex> into proving <fr:tex display="inline">A\space \text {true}</fr:tex>, which is captured by the principle
                of substitution.</fr:p>
            <fr:p>If <fr:tex display="inline">\Delta ;\cdot \vdash  A\space \text {true}</fr:tex> and <fr:tex display="inline">(\Delta ,u::A\space \text {valid},\Delta &apos;);\Gamma \vdash  C\space \text {true}</fr:tex>,
                then <fr:tex display="inline">(\Delta ,\Delta &apos;);\Gamma \vdash  C\space \text {true}</fr:tex>.</fr:p>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        <fr:p>With the categorical judgment we can introduce the <fr:strong>modal operator</fr:strong> for necessary
            truth <fr:tex display="inline">\square  A</fr:tex>.</fr:p>
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>533</fr:anchor><fr:addr type="machine">#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:title text="Contextual Validity">Contextual Validity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:p><fr:tex display="inline">A\space \text {valid}</fr:tex> expresses that <fr:tex display="inline">A</fr:tex> is true in <fr:strong>any</fr:strong> world.
            In this section we <fr:strong>relativize</fr:strong> this judgment:
            let <fr:tex display="inline">\Psi  = y_1:B_1\space \text {true}, \cdots , y_n:B_n\space \text {true}</fr:tex> be a list of assumptions.
            We say that <fr:tex display="inline">A</fr:tex> is <fr:strong>valid relative</fr:strong> <fr:tex display="inline">\Psi </fr:tex> (denoted <fr:tex display="inline">A\space \text {valid}[\Psi ]</fr:tex>) if <fr:tex display="inline">A</fr:tex> is true in every
            world in which <fr:tex display="inline">B_1,\cdots ,B_n</fr:tex> are true.
            Similarly we generalized assumptions about validity so that <fr:tex display="inline">\Delta </fr:tex> 
            now has the form <fr:tex display="inline">u_1::A_1\space \text {valid}[\Psi _1], \cdots , u_n::A_n\space \text {valid}[\Psi _n]</fr:tex>.</fr:p>
        <fr:p>As common in PL, we refer to <fr:tex display="inline">\Psi </fr:tex> as a context and to the judgment 
            <fr:tex display="inline">A\space \text {valid}[\Psi ]</fr:tex> as <fr:strong>contextual validity</fr:strong>.</fr:p>
        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>534</fr:anchor><fr:addr type="machine">#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:title text="Contextual Validity">Contextual Validity</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            <fr:p>To prove <fr:tex display="inline">A\space \text {valid}[\Psi ]</fr:tex> we only required to prove <fr:tex display="inline">A</fr:tex> using only <fr:tex display="inline">\Psi </fr:tex>
                without any hypotheses about the truth:</fr:p>
            <fr:tex display="block">                 \frac {                     \Delta ;\Psi \vdash  A\space \text {true}                 }{                     \Delta ;\Gamma \vdash  A\space \text {valid}[\Psi ]                 }             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>535</fr:anchor><fr:addr type="machine">#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:title text="Contextual Entailment">Contextual Entailment</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            We write
            <fr:tex display="block">                 \Delta ;\Gamma \vdash \Psi              </fr:tex>
            to express that all the propositions in <fr:tex display="inline">\Psi </fr:tex> are true using the assumptions from <fr:tex display="inline">\Gamma </fr:tex>.
            <fr:tex display="block">                 \frac {                     \Delta ;\Gamma \vdash  B_1\space \text {true} \quad \cdot \quad  \Delta ;\Gamma \vdash  B_n\space \text {true}                 }{                     \Delta ;\Gamma \vdash  y_1:B_1\space \text {true},\ldots ,y_n:B_n\space \text {true}                 }(\text {ctx})             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>536</fr:anchor><fr:addr type="machine">#266</fr:addr><fr:route>unstable-266.xml</fr:route><fr:title text="Contextual Hypothesis Rule">Contextual Hypothesis Rule</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                 \frac {                     (\Delta ,u::A\space \text {valid}[\Psi ],\Delta &apos;);\Gamma \vdash \Psi                  }{                     (\Delta ,u::A\space \text {valid}[\Psi ],\Delta &apos;);\Gamma \vdash  A\space \text {true}                 }(\text {ctxhyp}_u)             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>537</fr:anchor><fr:addr type="machine">#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:title text="Contextual Substitution Principle">Contextual Substitution Principle</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            <fr:p>If <fr:tex display="inline">\Delta ;\Psi \vdash  A\space \text {true}</fr:tex> and <fr:tex display="inline">(\Delta ,u::A\space \text {valid}[\Psi ],\Delta &apos;);\Gamma \vdash  C\space \text {true}</fr:tex>
                then <fr:tex display="inline">(\Delta ,\Delta &apos;);\Gamma \vdash  C\space \text {true}</fr:tex>.</fr:p>
            <fr:p>The precondition implies <fr:tex display="inline">\Delta ;\Gamma \vdash  A\space \text {valid}[\Psi ]</fr:tex> and by the substitution principle
                of hypotheses judgments we can justify this rule.</fr:p>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

        
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>538</fr:anchor><fr:addr type="machine">#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:title text="Contextual Identity Principle">Contextual Identity Principle</fr:title><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>27</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                 \Delta ;\Psi \vdash \Psi              </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>539</fr:anchor>
                <fr:addr type="user">math-0003</fr:addr>
                <fr:route>math-0003.xml</fr:route>
                <fr:title text="Set Theory">Set Theory</fr:title>
                <fr:taxon>Set Theory</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>26</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Refer to <fr:link type="local" href="cat-sci-2013.xml" addr="cat-sci-2013" title="Category theory for scientists">Category Theory for Scientists</fr:link>.</fr:p>
                <fr:p><fr:strong>Set</fr:strong> is a common concept in mathematics.
    This post is a brief introduction to set theory aimed at 
    complete all basic knowledge of set theory.
    The following topics will be covered
    <fr:ul><fr:li><fr:strong>Zermelo-Fraenkel Axioms</fr:strong> and <fr:strong>Axiom of Choice</fr:strong></fr:li>
        <fr:li>Cardinality</fr:li>
        <fr:li>Set theory constructions</fr:li></fr:ul></fr:p>
                <fr:p>In this post, we use the Zermelo-Fraenkel set theory with the Axiom of Choice (<fr:strong>ZFC</fr:strong>).</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>540</fr:anchor>
                    <fr:addr type="user">def-000S</fr:addr>
                    <fr:route>def-000S.xml</fr:route>
                    <fr:title text="ZFC Set">ZFC Set</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p><fr:strong>ZFC</fr:strong> is the abbreviation of Zermelo-Fraenkel set theory with the Axiom of Choice.
    The axioms of ZFC are listed below.
    <fr:ul><fr:li><fr:strong>Axiom of Extensionality</fr:strong>:
            Two sets are equal if and only if they have the same elements.</fr:li>
        <fr:li><fr:strong>Axiom of Pairing</fr:strong>:
            For any two sets <fr:tex display="inline">a</fr:tex> and <fr:tex display="inline">b</fr:tex>,
            there exists a set <fr:tex display="inline">\{ a,b \}</fr:tex> whose elements are exactly <fr:tex display="inline">a</fr:tex> and <fr:tex display="inline">b</fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom schema of Separation</fr:strong>:
            Let <fr:tex display="inline">P</fr:tex> is a property of sets.
            <fr:tex display="inline">P(u)</fr:tex> means <fr:tex display="inline">u</fr:tex> satisfies the property <fr:tex display="inline">P</fr:tex>.
            then for any set <fr:tex display="inline">X</fr:tex> exists <fr:tex display="inline">Y = \{ u \in  X | P(u) \}</fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom of Union</fr:strong>:
            For any set <fr:tex display="inline">X</fr:tex> (a family of sets), exists union set <fr:tex display="inline">\bigcup  X :\equiv  \{                  u:\exists  v\in  X \text { such that } u\in  v              \}</fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom of Power Set</fr:strong>:
            For any set <fr:tex display="inline">X</fr:tex>, exists the power <fr:tex display="inline">P(X) :\equiv  \{ Y:Y\subseteq  X \}</fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom of Infinity</fr:strong>:
            There exists a set <fr:tex display="inline">\omega </fr:tex> such that <fr:tex display="inline">\emptyset \in \omega </fr:tex> and for any <fr:tex display="inline">x\in \omega </fr:tex>, <fr:tex display="inline">x\cup \{ x \}\in \omega </fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom of Regularity</fr:strong>:
            For any non-empty set there is a minimal element with respect to the membership relation.</fr:li>
        <fr:li><fr:strong>Axiom schema of Replacement</fr:strong>:
            Let <fr:tex display="inline">F</fr:tex> be a function where <fr:tex display="inline">\text {dom } f = X</fr:tex>, then for any set <fr:tex display="inline">X</fr:tex> exists a set <fr:tex display="inline">Y = \{ F(x):x\in  X \}</fr:tex>.
            <fr:p>This function is not the normal function but some logical stuff.</fr:p></fr:li>
        <fr:li><fr:strong>Axiom of Choice</fr:strong>:
            For any family of non-empty sets <fr:tex display="inline">X</fr:tex>, there exists a function <fr:tex display="inline">f:X\to \bigcup  X</fr:tex> such that for any <fr:tex display="inline">x\in  X</fr:tex>, <fr:tex display="inline">f(x)\in  x</fr:tex>.</fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>541</fr:anchor>
                    <fr:addr type="user">def-002V</fr:addr>
                    <fr:route>def-002V.xml</fr:route>
                    <fr:title text="Set Operations">Set Operations</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">(X_i)_{i\in  I}</fr:tex> be a family of sets.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>542</fr:anchor>
                        <fr:addr type="machine">#242</fr:addr>
                        <fr:route>unstable-242.xml</fr:route>
                        <fr:title text="Union">Union</fr:title>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>
                          <fr:tex display="block">         \bigcup _{i\in  I}X_i = \set {x:\exists  i\in  I \text { such that } x\in  X_i}     </fr:tex>
                        </fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>543</fr:anchor>
                        <fr:addr type="machine">#243</fr:addr>
                        <fr:route>unstable-243.xml</fr:route>
                        <fr:title text="Intersection">Intersection</fr:title>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p><fr:tex display="block">         \bigcap _{i\in  I}X_i = \set {x:\forall  i\in  I, x\in  X_i}     </fr:tex>
    Note that <fr:tex display="inline">I \neq  \emptyset </fr:tex> here.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>544</fr:anchor>
                        <fr:addr type="machine">#244</fr:addr>
                        <fr:route>unstable-244.xml</fr:route>
                        <fr:title text="Disjoint Union">Disjoint Union</fr:title>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>
                          <fr:tex display="block">         \bigsqcup _{i\in  I}X_i = \set {(x,i):x\in  X_i, i\in  I}     </fr:tex>
                        </fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>545</fr:anchor>
                        <fr:addr type="machine">#245</fr:addr>
                        <fr:route>unstable-245.xml</fr:route>
                        <fr:title text="Product">Product</fr:title>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>
                          <fr:tex display="block">         \prod _{i\in  I}X_i = \set {(x_i)_{i\in  I}:\forall  i\in  I, x_i\in  X_i}     </fr:tex>
                        </fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>And principles of set theory</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>546</fr:anchor>
                    <fr:addr type="user">def-000T</fr:addr>
                    <fr:route>def-000T.xml</fr:route>
                    <fr:title text="Principle of Extensionality">Principle of Extensionality</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Two sets are equal if and only if they have the same elements.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>547</fr:anchor>
                    <fr:addr type="user">def-000U</fr:addr>
                    <fr:route>def-000U.xml</fr:route>
                    <fr:title text="Principle of Comprehension">Principle of Comprehension</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Given a set <fr:tex display="inline">A</fr:tex> and a property <fr:tex display="inline">P(x)</fr:tex>, there exists a set <fr:tex display="inline">B</fr:tex> such that
    <fr:tex display="inline">x\in  B \iff  x\in  A \land  P(x)</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>We then define the Cartesian product of two sets</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>548</fr:anchor>
                    <fr:addr type="user">def-000V</fr:addr>
                    <fr:route>def-000V.xml</fr:route>
                    <fr:title text="Cartesian product">Cartesian product</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Given two sets <fr:tex display="inline">A</fr:tex> and <fr:tex display="inline">B</fr:tex>, the Cartesian product <fr:tex display="inline">A\times  B</fr:tex> is the set
    of all ordered pairs <fr:tex display="inline">(a,b)</fr:tex> where <fr:tex display="inline">a\in  A</fr:tex> and <fr:tex display="inline">b\in  B</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>With the Cartesian product, we can define the relation</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>549</fr:anchor>
                    <fr:addr type="user">def-000W</fr:addr>
                    <fr:route>def-000W.xml</fr:route>
                    <fr:title text="Relation">Relation</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A <fr:strong>relation</fr:strong> <fr:tex display="inline">R</fr:tex> is a subset of the Cartesian product of two sets <fr:tex display="inline">A</fr:tex> and
    <fr:tex display="inline">B</fr:tex>, i.e. <fr:tex display="inline">R\subseteq  A\times  B</fr:tex>.
    If <fr:tex display="inline">(a,b)\in  R</fr:tex>, we write <fr:tex display="inline">aRb</fr:tex>.

    A relation that between <fr:tex display="inline">X</fr:tex> and itself is called <fr:strong>homogeneous relation</fr:strong>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>550</fr:anchor>
                    <fr:addr type="user">def-000X</fr:addr>
                    <fr:route>def-000X.xml</fr:route>
                    <fr:title text="Equivalence Relation">Equivalence Relation</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>An equivalence relation <fr:tex display="inline">R</fr:tex> on a set <fr:tex display="inline">A</fr:tex> is a <fr:link type="local" href="def-000W.xml" addr="def-000W" title="Relation">relation</fr:link> that is reflexive,
    symmetric, and transitive.
    <fr:ul><fr:li>Reflexive:
            <fr:tex display="inline">\forall  x\in  A, xRx</fr:tex></fr:li>
        <fr:li>Symmetric:
            <fr:tex display="inline">\forall  x,y\in  A, xRy\implies  yRx</fr:tex></fr:li>
        <fr:li>Transitive:
            <fr:tex display="inline">\forall  x,y,z\in  A, xRy\land  yRz\implies  xRz</fr:tex></fr:li></fr:ul>
    We often denote the equivalence relation by <fr:tex display="inline">\sim </fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>551</fr:anchor>
                    <fr:addr type="user">def-002U</fr:addr>
                    <fr:route>def-002U.xml</fr:route>
                    <fr:title text="Equivalence Class">Equivalence Class</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">\sim </fr:tex> be an <fr:link type="local" href="def-000X.xml" addr="def-000X" title="Equivalence Relation">equivalence relation</fr:link> on a set <fr:tex display="inline">A</fr:tex>.
    For any element <fr:tex display="inline">a\in  A</fr:tex>, the <fr:strong>equivalence class</fr:strong> of <fr:tex display="inline">a</fr:tex> is the set
    <fr:tex display="inline">[a] = \set {b\in  A:b\sim  a}</fr:tex>.
    The set of all equivalence classes is denoted by <fr:tex display="inline">A/\sim </fr:tex>,
    which is called the <fr:strong>quotient set</fr:strong> of <fr:tex display="inline">A</fr:tex> by <fr:tex display="inline">\sim </fr:tex>.
    <fr:p>The equivalence class of <fr:tex display="inline">a</fr:tex> is also denoted by <fr:tex display="inline">\overline {a}</fr:tex>.</fr:p></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>One of the most important relations is the order relation.
    The basic order relation is the preorder.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>552</fr:anchor>
                    <fr:addr type="user">def-000Z</fr:addr>
                    <fr:route>def-000Z.xml</fr:route>
                    <fr:title text="Preorder">Preorder</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A <fr:strong>preorder</fr:strong> is a relation <fr:tex display="inline">\leq </fr:tex> that is reflexive and transitive.
    <fr:ul><fr:li>Reflexive: <fr:tex display="inline">a\leq  a</fr:tex></fr:li>
        <fr:li>Transitive: <fr:tex display="inline">a\leq  b</fr:tex> and <fr:tex display="inline">b\leq  c</fr:tex> implies <fr:tex display="inline">a\leq  c</fr:tex></fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>553</fr:anchor>
                    <fr:addr type="user">def-000Y</fr:addr>
                    <fr:route>def-000Y.xml</fr:route>
                    <fr:title text="Partial Order">Partial Order</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A <fr:strong>(non-strict) partial order</fr:strong> is a relation <fr:tex display="inline">\leq </fr:tex> that is reflexive, antisymmetric and transitive.
    <fr:ul><fr:li>Reflexive: <fr:tex display="inline">a\leq  a</fr:tex></fr:li>
        <fr:li>Antisymmetric: <fr:tex display="inline">a\leq  b</fr:tex> and <fr:tex display="inline">b\leq  a</fr:tex> implies <fr:tex display="inline">a=b</fr:tex></fr:li>
        <fr:li>Transitive: <fr:tex display="inline">a\leq  b</fr:tex> and <fr:tex display="inline">b\leq  c</fr:tex> implies <fr:tex display="inline">a\leq  c</fr:tex></fr:li></fr:ul>
    A non-strict partial order is also known as an antisymmetric <fr:link type="local" href="def-000Z.xml" addr="def-000Z" title="Preorder">preorder</fr:link>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>And the strict partial order (notice the difference between asymmetric and antisymmetric)</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>554</fr:anchor>
                    <fr:addr type="user">def-0010</fr:addr>
                    <fr:route>def-0010.xml</fr:route>
                    <fr:title text="Strict partial orders">Strict partial orders</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A strict partial order is a relation <fr:tex display="inline">&lt;</fr:tex> that is irreflexive, asymmetric and transitive.
    <fr:ul><fr:li>Irreflexive: <fr:tex display="inline">\neg (a&lt;a)</fr:tex></fr:li>
        <fr:li>Asymmetric: <fr:tex display="inline">a&lt;b</fr:tex> implies <fr:tex display="inline">\neg (b&lt;a)</fr:tex></fr:li>
        <fr:li>Transitive: <fr:tex display="inline">a&lt;b</fr:tex> and <fr:tex display="inline">b&lt;c</fr:tex> implies <fr:tex display="inline">a&lt;c</fr:tex></fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>With the definition of order, we can define the upper bound and lower bound</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>555</fr:anchor>
                    <fr:addr type="user">def-0011</fr:addr>
                    <fr:route>def-0011.xml</fr:route>
                    <fr:title text="Upper Bound and Lower Bound">Upper Bound and Lower Bound</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p>Let a subset <fr:tex display="inline">S</fr:tex> of a <fr:link type="local" href="def-000Y.xml" addr="def-000Y" title="Partial Order">partially ordered</fr:link> set <fr:tex display="inline">(P, \leq )</fr:tex>,
    <fr:tex display="inline">S</fr:tex> is bounded above if there exists <fr:tex display="inline">x \in  P</fr:tex> such that <fr:tex display="inline">\forall  y \in  S, y \leq  x</fr:tex>. And <fr:tex display="inline">x</fr:tex> is called an <fr:strong>upper bound</fr:strong> of <fr:tex display="inline">S</fr:tex>.
    Dually, <fr:tex display="inline">S</fr:tex> is bounded below if there exists <fr:tex display="inline">x \in  P</fr:tex> such that <fr:tex display="inline">\forall  y \in  S, x \leq  y</fr:tex>. And <fr:tex display="inline">x</fr:tex> is called a <fr:strong>lower bound</fr:strong> of <fr:tex display="inline">S</fr:tex>.</fr:p>
    <fr:p><fr:strong>Supremum (least upper bound)</fr:strong></fr:p>
    <fr:p>An element <fr:tex display="inline">x\in  P</fr:tex> is a supremum of <fr:tex display="inline">S</fr:tex>,
    if for all upper bounds <fr:tex display="inline">z \in  P</fr:tex> of <fr:tex display="inline">S</fr:tex>, <fr:tex display="inline">x \leq  z</fr:tex>.
    Denoted as <fr:tex display="inline">x = \sup  S</fr:tex>.</fr:p>
    <fr:p><fr:strong>Infimum (greatest lower bound)</fr:strong></fr:p>
    <fr:p>An element <fr:tex display="inline">x\in  P</fr:tex> is a infimum of <fr:tex display="inline">S</fr:tex>,
    if for all lower bounds <fr:tex display="inline">z \in  P</fr:tex> of <fr:tex display="inline">S</fr:tex>, <fr:tex display="inline">z \leq  x</fr:tex>.
    Denoted as <fr:tex display="inline">x = \inf  S</fr:tex>.</fr:p>
</fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>556</fr:anchor>
                    <fr:addr type="user">def-002G</fr:addr>
                    <fr:route>def-002G.xml</fr:route>
                    <fr:title text="Function">Function</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets then a <fr:strong>function</fr:strong> <fr:tex display="inline">f:X \to  Y</fr:tex>
    is a mapping that sends each element of <fr:tex display="inline">X</fr:tex> to a unique element of <fr:tex display="inline">Y</fr:tex>,
    denoted by <fr:tex display="inline">f(x) = y</fr:tex>.
    Function is a special case of <fr:link type="local" href="def-000W.xml" addr="def-000W" title="Relation">relation</fr:link>, and it is a relation that is left-total and right-unique.
    <fr:tex display="block">         f \in  X \times  Y \text { and } \forall  x \in  X, \exists ! y \in  Y, (x,y) \in  f     </fr:tex>
    <fr:tex display="inline">X</fr:tex> is said to be the <fr:strong>domain</fr:strong> of <fr:tex display="inline">f</fr:tex> and <fr:tex display="inline">Y</fr:tex> is said to be the <fr:strong>codomain</fr:strong> of <fr:tex display="inline">f</fr:tex>,
    where we denote <fr:tex display="inline">X = \text {dom } f</fr:tex> and <fr:tex display="inline">Y = \text {cod } f</fr:tex>.</fr:p>
                    <fr:p>Two functions <fr:tex display="inline">f:X\to  Y</fr:tex> and <fr:tex display="inline">g:Y\to  Z</fr:tex> can be <fr:strong>composed</fr:strong> to form a new function <fr:tex display="inline">g \circ  f : X \to  Z</fr:tex>,
    where the composition is defined by
    <fr:tex display="block">         (g \circ  f)(x) = g(f(x))      </fr:tex></fr:p>
                    <fr:p>The set of all functions from <fr:tex display="inline">X</fr:tex> to <fr:tex display="inline">Y</fr:tex> is denoted by <fr:tex display="inline">\hom _\text {set}(X, Y)</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>The isomorphism function is defined as follows</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>557</fr:anchor>
                    <fr:addr type="user">def-002H</fr:addr>
                    <fr:route>def-002H.xml</fr:route>
                    <fr:title text="Set Isomorphism">Set Isomorphism</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets and <fr:tex display="inline">f: X \to  Y</fr:tex> be a function.
    The function <fr:tex display="inline">f</fr:tex> is called an <fr:strong>isomorphism</fr:strong> if it is both <fr:link type="local" href="def-002D.xml" addr="def-002D" title="Injective">injective</fr:link> and <fr:link type="local" href="def-002F.xml" addr="def-002F" title="Surjective">surjective</fr:link>.
    In other words, there exists a function <fr:tex display="inline">g: Y \to  X</fr:tex> such that
    <fr:tex display="block">         g \circ  f = \text {id}_X \text { and } f \circ  g = \text {id}_Y     </fr:tex>
    where <fr:tex display="inline">\text {id}_X</fr:tex> and <fr:tex display="inline">\text {id}_Y</fr:tex> are the <fr:strong>identity functions</fr:strong> on <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> respectively.
    And we say <fr:tex display="inline">f</fr:tex> is <fr:strong>invertible</fr:strong> and <fr:tex display="inline">g</fr:tex> is the <fr:strong>inverse</fr:strong> of <fr:tex display="inline">f</fr:tex>.
    If there is a isomorphism between <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex>, we say <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> are <fr:strong>isomorphic</fr:strong>,
    denoted by <fr:tex display="inline">X \cong  Y</fr:tex>.
    Isomorphism is an <fr:link type="local" href="def-000X.xml" addr="def-000X" title="Equivalence Relation">equivalence relation</fr:link>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>With isomorphism, we can define the cardinality of a set.
    Two isomorphic sets have the same cardinality.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>558</fr:anchor>
                    <fr:addr type="user">def-002I</fr:addr>
                    <fr:route>def-002I.xml</fr:route>
                    <fr:title text="Cardinality">Cardinality</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">X</fr:tex> be a set and <fr:tex display="inline">n \in  \mathbb {N}</fr:tex>. 
    <fr:tex display="inline">A</fr:tex> si said to have <fr:strong>cardinality</fr:strong> <fr:tex display="inline">n</fr:tex>, denoted by <fr:tex display="inline"> |A|= n</fr:tex>,
    if there exists an isomorphism between <fr:tex display="inline">A</fr:tex> and <fr:tex display="inline">S_n = \{ 1,2,\cdots ,n \}</fr:tex>.
    If <fr:tex display="inline">A</fr:tex> has finite cardinality, we say <fr:tex display="inline">A</fr:tex> is <fr:strong>finite</fr:strong>, otherwise
    we say <fr:tex display="inline">A</fr:tex> is <fr:strong>infinite</fr:strong>, denoted by <fr:tex display="inline">|A| \geq  \infty </fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>The next topic is the product of sets</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>559</fr:anchor>
                    <fr:addr type="user">def-002J</fr:addr>
                    <fr:route>def-002J.xml</fr:route>
                    <fr:title text="Product of Sets">Product of Sets</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets, then the <fr:strong>Cartesian product</fr:strong> of <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> is the set
    <fr:tex display="block">         X \times  Y = \set {(x,y) \mid  x \in  X \text { and } y \in  Y}     </fr:tex>
    There are two natural projections from the Cartesian product to the original sets, namely
    <fr:tex display="block">         \pi _1 : X \times  Y \to  X \text { and } \pi _2 : X \times  Y \to  Y     </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>This leads to an improtant concept named <fr:strong>universal property</fr:strong>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>560</fr:anchor>
                    <fr:addr type="user">thm-000J</fr:addr>
                    <fr:route>thm-000J.xml</fr:route>
                    <fr:title text="Universal Property for Product of Sets">Universal Property for Product of Sets</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets.
    For any set <fr:tex display="inline">A</fr:tex> and function
    <fr:tex display="inline">f: A \to  X</fr:tex> and <fr:tex display="inline">g: A \to  Y</fr:tex>,
    there exists a <fr:em>unique</fr:em> function <fr:tex display="inline">h: A \to  X \times  Y</fr:tex> such that
    the following diagram commutes:
    
 
  
  <fr:figure><fr:resource hash="92f681daf98951ac5bde9b0833c22328"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3OS43MDA3MTdwdCcgaGVpZ2h0PScxMTguNDkzMjNwdCcgdmlld0JveD0nLTcyIC03MiAxMTkuODAwNDc4IDc4Ljk5NTQ4Nyc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTU1BQW9BQUFBQUEzUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFR4MEZXTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQjBaMng1WmdBQUFXUUFBQUJVQUFBQVZKNVA3NTFvWldGa0FBQUJ1QUFBQUMwQUFBQTJLV2t2RG1ob1pXRUFBQUhvQUFBQUlBQUFBQ1FFVEFKQmFHMTBlQUFBQWdnQUFBQUlBQUFBQ0FRZUFHcHNiMk5oQUFBQ0VBQUFBQVlBQUFBR0FDb0FBRzFoZUhBQUFBSVlBQUFBRmdBQUFDQUFCUUFYYm1GdFpRQUFBakFBQUFESkFBQUJNdTBLa2V4d2IzTjBBQUFDL0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtNG1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb3FNaWd5TS93SDhwa2gwa2hxL2dPRkFhTDdERUVBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlLLy85RHlQOFB3SHdHQUUvM0JuMEFBQUFBQWdCcUFBQUE0QUxiQUFzQUZRQUFFd01PQVNJbUp3TStBVElXRXc0Q0xnRTJOeDRCNENnQkNCTUpBU2dDSWkwa0FRRWhNU0VDSUJ3WUlRS2ovanNQQ1FrUUFjUWFIaDM5ZlJraEFTQXpJZ0VCSVFCNDJtTmdaR0JnQUdJRkQ0LzM4ZncyWHhtWVdSaEE0UEgrcjdPUmFhYkxUTGVCRkFjREU0Z0hBRHNSQzJnQUFBQjQybU5nWkdCZ1p2alB3TURBZEpraGl5R2I0UUVEVUFRRk1BRUFWbGdEa1FMVEFBQUJTd0JxQUFBQUFBQXFBQUI0Mm1OZ1pHQmdZR0lRQTJJUVlHUkFBd0FDMmdBZEFBQjQyajJNTVF2Q01CQ0Z2MklWcllPRDRPQWd3UjlRdEFvdWJnNU9yZzV1MWdUcDBGVFNXblFSZjdyWEVMeVE0N3YzM2gyUThDR2lxNGlKNzEzRjhpYUIrNHlaQmg2SXZnaWNNR2RKanlnZWliSmdIemhteUNWd254bDU0SUhvcjhBSlc3Nkhxbnc4RytQVXFkTEcyVnZwZG1majZxS3lhcDJ1dXZGb3JISFh4bWlWdjVWdWk3cTlsMnFUWm1uR2dZcVNCMDhhREE3RlNSVHQyWElUejdIajdPZWFRandybVRVcHE3OTdGTmY2eE5WZjBaTEllVXZYdExKVFM3OUxWckdSdmF6N1Axa3lMazBBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFORUFBb0FBQUFBQTZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdpT1J6RzJOdFlYQUFBQUZBQUFBQUtRQUFBRFFBREFFcVoyeDVaZ0FBQVd3QUFBQjRBQUFBZUpNU1BKRm9aV0ZrQUFBQjVBQUFBQzBBQUFBMktiSXVLMmhvWldFQUFBSVVBQUFBSGdBQUFDUUdOZi9kYUcxMGVBQUFBalFBQUFBR0FBQUFCZ093QUFCc2IyTmhBQUFDUEFBQUFBWUFBQUFHQUR3QUFHMWhlSEFBQUFKRUFBQUFGd0FBQUNBQUJBQWtibUZ0WlFBQUFsd0FBQURWQUFBQlBxODNkZU53YjNOMEFBQUROQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1sbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFVEF4SklLUzVMQjBwZVo3ak9MUFZIazRHQldZcjVPbENZRWFIaS8zOEdCZ0RyblE3dkFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hDQytOZi8vNGVRLzdYQWZBWUFYdVVITXdBQUFBQUJBSlFBQ1FLR0FmZ0FJZ0FBQVRjMkZ4WVhCZzhDSHdFV0J3WUhKaThCQnc0Qkl5WW5KajhCSnlZM05qY3lGd0dPeXc0S0V3RUNBeHE3cFRJRUFRRVRDd1hVeXdrSUJoRURBeEROelJBREF4RUdCQUVkeWhFQkFoTUtBeHE3cFRJSUF4TUNBZ1RVeXdvRkFoTUhEYzdPRFFjVEFnSUFBSGphWTJCa1lHQUE0dVc1YnpmSDg5dDhaV0JtWVFDQngvdS96a2FtbVdVWWZ3QXBEZ1ltRUE4QVpCSUw0d0FBQUhqYVkyQmtZR0NXK3FNSkpHVVlwakJNWTJwakFJcWdBRVlBVE1vREZ3QUFBeHdBQUFDVUFBQUFBQUFBQUR3QUFIamFZMkJrWUdCZ1lsQm1BTkVNVUJJSkFBQUVDQUFwQUhqYVRZNnhhc013RkVXUHFXT29HK2lVREIyS3BvekdkdklCaFF5WnNtWXNKSkVJTGxnT2ttUHdVdm9CK2VnOEt4cjZoQjVIOTk3M0VKRHpTOEpVQ2UraFQ1V1N5ZXZKTTk1WVJNN2txTWc1SDZ4NElVbGZSZm5rSzNMS25PL0lNNWI4Uk01RS80dWNzK0crN2RycnJUZE83VHR0bkQyM2ZxektnM0crNmF5cWl2SXA3SXcxN3RnYnJVNmowa1BqaDB1cjFrVmQxR3pwYUxseW84Zmc1R2Q3VVhSZ3kxazh6MGhGeVNGb25rWjhLN21LUXRUL2laMGtiRWdkd3pZdHFaTjRTbWlRT1MvOUlubkZXbWJyNlQ0QUNkOHhGUUFBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUa0FBb0FBQUFBQmVnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxQkdOdFlYQUFBQUU0QUFBQU5RQUFBRHdBZ2dDSFoyeDVaZ0FBQVhBQUFBSU5BQUFDcUFHSlVKUm9aV0ZrQUFBRGdBQUFBQzhBQUFBMktmNHZEMmhvWldFQUFBT3dBQUFBSGdBQUFDUUdoZ0diYUcxMGVBQUFBOUFBQUFBUUFBQUFFQXNZQUdSc2IyTmhBQUFENEFBQUFBb0FBQUFLQWFnQTVtMWhlSEFBQUFQc0FBQUFHQUFBQUNBQUJ3QmhibUZ0WlFBQUJBUUFBQURVQUFBQlBwa1JkY2R3YjNOMEFBQUUyQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1Pc1k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpJaGtadmdQNURORHBKSFUvQWNLQXdEdnJnMVFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPakpFL3Y4UDVEc3lSUHovLy8vQS8xVmdWVUFBQUpLK0NRTUFBQUI0MmxXUlQ0dlRRQmpHODc3VHpDVHBUS2F4a3dsMTIyUnJTOE9DMjJxN202Q3c3VVVSUENndWkzZ1FGR1QvbkR5c29uaVJkZlhtSi9BRDZBZndvQ0NDVnorQ0J6MTRFd1RCZzBkYko4bjZiMDd6UHZPK3cvTjdYZ3V0L21LQm4vR1ROYkxHbHBWRGxvOTExRlI2a21rNkFwWU8wclVzMGxrK2dpNmpTa2RaNUlQUkMza3loWHhDWHNNMlZZTENWSytHd08yN0I0NE5vdDVjSXk2Ykx5NkpkbE1RRVBidU5RN2NQVEY5OXJWN0Q2ODJ3SlUvRDdRa0hRYUVBRHFTQWZCbzUvd1QxVzhBU3A4V3NpY3A5TjdEcG1VT1dPM0ZndXppVyt1R0tmSXNIMkk2aFFSeW5ZQ2lQUjhZbFdEdU1Vd2lIWllXMHlPUDZ5T1FZQnJLcHlQM0l5aWZaa2lHMEtQVlQxRU14VWNoZkgvUklKZzB3ZGplditraWNtODRDMXY1WWRDLzdIVk9jNGFjN2o5eWJlQk9ITnQ3MS9mcXhuTGlzSnBCc085VUErbkZnZmp3d0c2ZkRMRVFxKzdsTmp4LzZVZUtnK2VYM0RYcVV4SXJ2ZkYwdVBVbWxvQmVDWTdnQ2xZN3h1U1A3ZHYxU0tnNm92TjdRRkpjVHZrWGlCc0I4U3NSUTFZTDdUSWpzMHZDVFViblRFRjhnMDFEbWtEMk53Nnp5Um1tLzBMclNORUJaVXNtMHlHa2cvVlNIVmVSNHEwNXRjbXFqZkdnQTV3K0xqQjgvMnpDdXFMMjBENWV3SWtLVG9TbnlQMXZzZzVMQVFWQmQ3WUVkeVliR2kvTVAxTHV2MUxNd1AyM2JMVnllQ2FBSzgzR0h3cURpRzR3ZndlQmtoMnZxSXNzV3RSZWFWbldMNUlRVnk4QUFBQjQybU5nWkdCZ0FPSlhuQ3ZaNC9sdHZqSXdzekNBd09QOVgyY2o2UC8vbWRPWjdnSzVIQXhNSUZFQVY0Y05BUUI0Mm1OZ1pHQmdadmpQQUNRREdHVCt1ekduTXdCRlVBQUxBRXpKQXljQUFBSjJBQUFEQUFBa0ExQUFIQUpTQUNRQUFBQUFBRlFBNWdGVUFBQjQybU5nWkdCZ1lHRklZR0JpQUFGR0JqUUFBQXBLQUdsNDJrMk9zV3JETUJSRmo2bGpxRnZJbEF3ZGlxYU14bmI2QVlVTW1iSm1MQ1NSQ0M1SUNySmp5Qkw2QWYzb1Bpc2Erb1FlUitkZENRRWxkektteXBqSFBsVk9JYWNIejNoaGtiaVFwUktYdkxIaWlTeC9GdlBPWitLY1Y3NFN6MWp5bmJnUS81TzQ1SVBmamJlWDYyQ0Mybmx0Z2p0WjJ6WDEzb1MrODA0MVZmMFFXK05NT0F4R3ErTk42YkhyeDdOVjY2cXRXalo0TEJldURCaUMvR3duUmtkMm5HUm02V2lvMlVmWHk4bkxSSW1yeFA1UGJDWGhZdW9RWDlPU09uS1RyaGtsMDBzL1MxcXhscnZ0dFA4QTRJSXd2WGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUTUFBb0FBQUFBQlpRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0SG1OdFlYQUFBQUU4QUFBQU1nQUFBRHdISy8xcloyeDVaZ0FBQVhBQUFBSDhBQUFDWEgrL081OW9aV0ZrQUFBRGJBQUFBQzhBQUFBMktWMHVNV2hvWldFQUFBT2NBQUFBSUFBQUFDUUZ3Z0diYUcxMGVBQUFBN3dBQUFBUUFBQUFFQW5tQUtWc2IyTmhBQUFEekFBQUFBb0FBQUFLQVpRQTFHMWhlSEFBQUFQWUFBQUFHQUFBQUNBQUJ3QkZibUZ0WlFBQUEvQUFBQURQQUFBQk9QTmhLcU53YjNOMEFBQUV3QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1SOWdadmdQNURNek1JS0VHUkVxL2dPRkFmMjFEaElBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZekgvai9IOGhQQTlIL1ovOXhCcXNDQWdDalpnbVVBQUI0MmtXUlAyL1RRQmpHL2R5NWRwMC9QdHV4enlRa2poMDdkaXJhdU5TTkxiVlYzRFR0VUlvb1RGRVFnb21GQ1FrR3hJQVFINEFCR0JqaFk4RGNMOEIzb1FOTHdya00zRTMzL3Q3aCtUMG5RYnBZcCtRRitTVWRTeElvZzZMcVVBZHhNa1hHWGE2b3ZJOHBTaG9xY2U1bVV4Uml2c2RkSFdHY3hIa1JwOUFKUTVaekpjSDNBME0yT3Ryczd1Z0FpSnlZZ3ZVWlkxRkFlMk4yM3lNdDlvZzVPajhKdDQ2QWtBdHVlSXhabGxmYjdEeXJNTDZzcnU2WngvdjJuTWFoNTVOSVNlb2FnWHpoZkwxZTBJR0t4ZkoyRWcrai93anRlT2VqUE5pRUpBNlJ0dGM3WklncmFTek5LeHRob3R5WWlNUzJvcm84NDdrUUtJWGtHRWxlVk5lREs2ekVBaTJSSjBKS1Vhc0t1THRYclpMZ3BmYnFUZnBVRm5sTkR0M3Ftb0Y5RkhhNTZoYm5zeVdoTTJhZUwwZVRKdTFZVFFlZlVncmIyZS9NZmNjd0VTZmVTYmVoNHUxcWxqNm14Tm51QmExVzNhdHRFTlM3N1YzL1NTWmo4ZkQ1Z3hZN3BZaTR3V0dZcXo4L1dIMFl5aGhONHRueFpZR2h6NXJDRGRKNGZVMCs0NmVVaTRkYTlUOHB4YzhVWVJVNFJhVXA4cnBCemwxQmsxQmhFR3BjL2RmQkRjYTBORDB2b3ZhdDAwNXBYVzV0NkRVRjVBNFBKaDQrc0M2bzdMYmYxd2lCWTJoQVR3ZzE2cUxoQmw3L1BqdVRleXpaL2JZZ2J0WUFnYVlkMnI0RGFBN1RMRkwwMDNMWmE5VHNOdEFhK29mbHUxUkUvZ3ZwRTAvZGVOcGpZR1JnWUFCaS9XMjVqdkg4Tmw4Wm1Ga1lRT0R4L3ErekVmUi9YYVpqVEJlQlhBNEdKcEFvQUV1M0RIRUFlTnBqWUdSZ1lHYjR6OERBd0hTTVFlZi9CYWJKREVBUkZNQUNBR2duQkdFQ3hnQUFBam9BU3dJNkFDd0NyQUF1QUFBQUFBQm1BTlFCTGdBQWVOcGpZR1JnWUdCaGNHRmdZZ0FCUmdZMEFBQUhqZ0JOZU5wTmpEMXZ3akFRaHArSUJJa3dzS0FPSFlxSHpoRUVKTFl1REV5c1RDeUFYWlRCTm5KQ0pLU3FZMzkzTDY2SG51VFQ4MzZjZ1pKdk1vYkptTVU5VEU0aDZvOExwc3dUajBVdEVwZTg4czZJTEorSTg4Wkg0bHlTVStLQ0Z6NFRqOFgvU2x5eTRXZm43ZjNSbWFBT1hwdmdydFkyMjZNSmJlT2RXbFhMcVBmR21YRHVqRmFYcDlKOTAvWTNxOVpWWGRYczhGanVQT2d3QkJRSGNYUmt4MVV5UzhPV1kzUmFZUysrWWtYRjhsKytsOXpGempuK3BLVno0U2xiMDB1amxYMlRybUl0bC9Yd2ZnSE1LeS81QUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTWdBQW9BQUFBQUE0d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncWt5VVRtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSldaMng1WmdBQUFXd0FBQUJjQUFBQWFKNWdWSVpvWldGa0FBQUJ5QUFBQUM4QUFBQTJLaWd1K21ob1pXRUFBQUg0QUFBQUhnQUFBQ1FGdXdBVWFHMTBlQUFBQWhnQUFBQUlBQUFBQ0FZbkFGQnNiMk5oQUFBQ0lBQUFBQVlBQUFBR0FEUUFBRzFoZUhBQUFBSW9BQUFBRndBQUFDQUFCQUFmYm1GdFpRQUFBa0FBQUFEUEFBQUJPQk9CS3J0d2IzTjBBQUFERUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1hY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeG9BQUhHQ09sdUN5ZGdVMkpXWW1aV2ZHUEVRTURzeUx6T2FBd0kwTHAvLzhNREFETHhBM09BQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJNLy85RHlMdi93UElNQUZCdEJvRUFBSGphWTJCa0NQai9uOG1ENlFTRExBTURvNkFZbTdvaW01cUptYmlpSUJwdEpzYmt6aWdvK1MrS1QwcVNuM0hPdjBJZVNSayt4cTUvS1dEK01rbEJwdmwvTzZYNEdSazVWRGdZR1NVaGxEZ2pwekluSTZNQUF3RDdOaEhOZU5wallHUmdZQURpaHBsblhlUDViYjR5TUxNd2dNRGovVjluSStqLy81a25NcDBBY2prWW1FQ2lBRytnRFo0QWVOcGpZR1JnWUZiOFl3UWtKeklFTVBneGVUQUFSVkFBRXdCSmVBTFRBQUFEa1FBQUFwWUFVQUFBQUFBQU5BQUFlTnBqWUdSZ1lHQmlrR01BMFF4UUVna0FBQU9MQUNRQWVOcE5qRDF2d2pBUWhwK0lCSWt3c0ZRZE9vQUg1Z2hDSmJZdURFeXNUQ3lBRGNvUUI5a2hVcVNxWTM5M0w2NEhUdkxwZVQvT1FNNFBDY01rek1JZUppVVQ5YzhaVTk0aWowVXRJdWQ4c0dSRWtrN0VtZk1WT1pYa0ZEbmpuVnZrc2ZqZmtYTSsrZDAxOWVQWkdxY09qVGJPWG12ZmI0L0crYXF4YWwyc2d0NGJhOXk1TlZwZGVxVzd5bmYzV20yS3NpalowVkR6NEVtTHdhRTRpS01EVzY2U2VYcTJISVBqcVNTMTBscFRzSHJKOTVMYjBEbUhuN1IwTHBJb29VNnV2T3k3dEJVYnVTeUg5d2YwQXpCUkFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU93QUFvQUFBQUFCQmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVeDFBbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNGWjJ4NVpnQUFBV1FBQUFEMEFBQUE5TnUrK1pKb1pXRmtBQUFDV0FBQUFDMEFBQUEyS2VndTNtaG9aV0VBQUFLSUFBQUFIZ0FBQUNRRnVnS3lhRzEwZUFBQUFxZ0FBQUFLQUFBQUNnWm5BSkpzYjJOaEFBQUN0QUFBQUFnQUFBQUlBRElBZW0xaGVIQUFBQUs4QUFBQUZ3QUFBQ0FBQlFBdGJtRnRaUUFBQXRRQUFBREpBQUFCTXVzSWtlaHdiM04wQUFBRG9BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWVzMDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFEwWkRCaVp2Z1A1RE5EcEpIVS9BY0tBd0QyeEEwK2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoRy8vOERTY1AvLy85ZkFQTVpBRkZZQm80QUFRQ1NBQUFDTndLckFCNEFBQUVSQmhZN0FSVW1KeU1HQnpVek1qWW5FUTRCSnlNMU14WS9BVFkzTmhZQm1BUWlUak1zT3RFNkxETk9JUU11VkJNU0VoSStCejg1R0E0Q2kvM05GeFF0QXdFQkF5MFVGd0lBRWd3QkxRSUtBZ291QVFrQUFBRUFYUUFBQWxzQ3FnQXJBQUFsQnlFMU5EOENQZ0UzTGdFbklnWUhIZ0VYRGdFakJpWW5QZ0UzTWhZWERnRUhCZzhCSlRZM1BnRTNBbHNpL2lRRENmbzlUUUVDYUUwMFVoWVlJUUVCSmhVT0xBSUNoR3B3bXdNQ2FFZ3ZOV2tCQWlvS0RROEN4c1lmQlFJSjFERnFQMHhUQVNvakFoOGJJQjBCR1NkTlpRSnBZMUJwTGlBblRnRUJCQXRCRWdBQWVOcGpZR1JnWUFEaUJaZDB1T1A1YmI0eU1MTXdnTURqL1Y5bkk5UE1RVXlyZ1JRSEF4T0lCd0EycUFyQ0FBQUFlTnBqWUdSZ1lHYjR6d0FrZ3hoaUdXS1pvaG1BSWlpQUNRQTkwUUp6QUFBRFVnQUFBcmdBa2dCZEFBQUFBQUFBQURJQWVuamFZMkJrWUdCZ1p0QmhBTkVNVUJJSkFBQUZCQUF6QUhqYVBZd3hDOEl3RUlXL1loV3RnNFBnNENEQkgxQzA2dWJtNE9UcTRHWk5rQTVOSmExRkYvR25ldzNCQ3ptK2UrL2RBUWtmSXJxS21QamVWU3h2RXJqUG1HbmdnZWlMd0Fsemx2U0k0cEVvQy9hQlk0WmNBdmVaa1FjZWlQNEtuTERsZTZqS3g3TXhUcDBxYlp5OWxXNTNOcTR1S3F2VzZhb2JqOFlhZDIyTVZ2bGI2YmFvMjN1cE5tbVdaaHlvS0hud3BNSGdVSnhFMFo0dE4vRWNPODUrcmluRXM1SlprN0w2dTBkeHJVOWMvUlV0aVp5M2RFMHJPN1gwdTJRVkc5bkx1djhEVmJndVJRQUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEyLjA5OTc2NywtMzIuNTAyMjYyKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02MC4xMjQ4NiwtMzUuOTg2MTMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xMi4wOTk3NjcsLTMyLjUwMjI2MilzY2FsZSgtMSwtMSknPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuMjkyNTM5LC05Ny4zOTc4NSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4zMTkzNTIsLTk3LjM5Nzg1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTQuNjU5NjcsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg0OC4zMTkzNTIsLTk3LjM5Nzg1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzQ4LjMxOTM1MicgeT0nLTk3LjM5Nzg1Jz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzU5LjU2ODc3MycgeT0nLTk3LjM5Nzg1Jz7DlzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc2OS41MzEzODcnIHk9Jy05Ny4zOTc4NSc+WTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy4yOTI1MzksLTY0LjUzNDk1NilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuNTM0NzEsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMy4yOTI1MzksLTY0LjUzNDk1NilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMy4yOTI1MzknIHk9Jy02NC41MzQ5NTYnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMzE5MzUyLC02NC41MzQ5NTYpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTkuNDEyMzYsLTY0LjUzNDk1NilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuMDEzODksMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg5OS40MTIzNiwtNjQuNTM0OTU2KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jzk5LjQxMjM2JyB5PSctNjQuNTM0OTU2Jz5ZPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjI5MjUzOSwtMzIuNTAyMjYyKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjMxOTM1MiwtMzIuNTAyMjYyKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDQ4LjMxOTM1MiwtMzIuNTAyMjYyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzQ4LjMxOTM1MicgeT0nLTMyLjUwMjI2Mic+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTEwLjc3MjQgMjQuNDU5NzhMLTQxLjkwNyA0LjYzNzQyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjg0MzUsLTAuNTM3MDMsMC41MzcwMywtMC44NDM1LC00Mi4wNzU2Nyw0LjUzMDA0KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zNy40NDAyNiwxNy43OTM5NiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTEyLjA5OTc2NywtMzIuNTAyMjYyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xMi4wOTk3NjcnIHk9Jy0zMi41MDIyNjInPs+APC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy03LjQ0MDkyMycgeT0nLTMxLjUwNTk5OCc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00xMS43MDEzNCAyNC40NTk3OEw0Mi45NDk2NiA0LjM1ODg2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuODQwOTcsLTAuNTQwOTcsMC41NDA5NywwLjg0MDk3LDQzLjExNzgzLDQuMjUwNjkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjkuODQ2NDIsMTcuNjUzOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTEyLjA5OTc2NywtMzIuNTAyMjYyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xMi4wOTk3NjcnIHk9Jy0zMi41MDIyNjInPs+APC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy03LjQ0MDkyMycgeT0nLTMxLjUwNTk5OCc+MjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00tNy43MzQ3MS0yOC4zNjM5N0wtNDEuOTA0NTYtNy4xNTQ3OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC44NDk2MSwwLjUyNzM0LC0wLjUyNzM0LC0wLjg0OTYxLC00Mi4wNzQ0NSwtNy4wNDkzMyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzIuMDI2MzcsLTI0Ljg2Nzc4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTIuMDk5NzY3LC0zMi41MDIyNjIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTEyLjA5OTc2NycgeT0nLTMyLjUwMjI2Mic+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J004Ljc3NjM3LTI4LjMxMTE5TDQyLjk0NzE3LTYuODgzMycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjg0NzE4LDAuNTMxMjUsLTAuNTMxMjUsMC44NDcxOCw0My4xMTY2LC02Ljc3NzA3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI4LjM4Mzk0LC0yMi44NTc2NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTEyLjA5OTc2NywtMzIuNTAyMjYyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xMi4wOTk3NjcnIHk9Jy0zMi41MDIyNjInPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8ZyBzdHJva2UtZGFzaGFycmF5PScyLjc5OTg1LDEuNTk5OTEnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNLjUyMDgzLTI1LjI5MzA5VjI0LjA1OTgxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsMC41MjA4MywyNC4yNTk4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04LjYyMzYxLC0yLjg0NzIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xMi4wOTk3NjcsLTMyLjUwMjI2MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTIuMDk5NzY3JyB5PSctMzIuNTAyMjYyJz7iiIM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTcuNTg4ODgzJyB5PSctMzIuNTAyMjYyJz4hPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg=="></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            &amp; {X\times  Y} \\
            X &amp;&amp; Y \\
            &amp; A
            \arrow [&quot;{\pi _1}&quot;&apos;, from=1-2, to=2-1]
            \arrow [&quot;{\pi _2}&quot;, from=1-2, to=2-3]
            \arrow [&quot;f&quot;, from=3-2, to=2-1]
            \arrow [&quot;g&quot;&apos;, from=3-2, to=2-3]
            \arrow [&quot;{\exists !}&quot;, dashed, from=3-2, to=1-2]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure>
 

    We might denote the unique function by <fr:tex display="inline">\langle  f,g \rangle : A \to  X \times  Y</fr:tex>.
    It is sufficient to define <fr:tex display="inline">\langle  f,g \rangle (a) = (f(a),g(a))</fr:tex> for all <fr:tex display="inline">a\in  A</fr:tex> as the unique function.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Dual to the product of sets, we have the coproduct of sets</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>561</fr:anchor>
                    <fr:addr type="user">def-002K</fr:addr>
                    <fr:route>def-002K.xml</fr:route>
                    <fr:title text="Coproduct of Sets">Coproduct of Sets</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets, then the <fr:strong>coproduct</fr:strong> of <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> is 
    defined as the <fr:strong>disjoint union</fr:strong> of <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex>, denoted by <fr:tex display="inline">X \sqcup  Y</fr:tex>.
    There are two natural injections from the original sets to the coproduct, namely
    <fr:tex display="block">         i_1 : X \to  X \sqcup  Y \text { and } i_2 : Y \to  X \sqcup  Y     </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>562</fr:anchor>
                    <fr:addr type="user">thm-000K</fr:addr>
                    <fr:route>thm-000K.xml</fr:route>
                    <fr:title text="Universal Property for Coproduct of Sets">Universal Property for Coproduct of Sets</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets. For any set <fr:tex display="inline">A</fr:tex> and function
    <fr:tex display="inline">f : X \to  A</fr:tex> and <fr:tex display="inline">g : Y \to  A</fr:tex>, there exists a <fr:em>unique</fr:em> function
    <fr:tex display="inline">h : X \sqcup  Y \to  A</fr:tex> such that the following diagram commutes:
    
 
  
  <fr:figure><fr:resource hash="ff3277e11704ef081135052cfcbb1ac5"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3OC4wNDAyNjRwdCcgaGVpZ2h0PScxMTcuMjQ3OTJwdCcgdmlld0JveD0nLTcyIC03MiAxMTguNjkzNTA5IDc4LjE2NTI4Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNTUFBb0FBQUFBQTNRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVHgwRldOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFCMFoyeDVaZ0FBQVdRQUFBQlVBQUFBVko1UDc1MW9aV0ZrQUFBQnVBQUFBQzBBQUFBMktXa3ZEbWhvWldFQUFBSG9BQUFBSUFBQUFDUUVUQUpCYUcxMGVBQUFBZ2dBQUFBSUFBQUFDQVFlQUdwc2IyTmhBQUFDRUFBQUFBWUFBQUFHQUNvQUFHMWhlSEFBQUFJWUFBQUFGZ0FBQUNBQUJRQVhibUZ0WlFBQUFqQUFBQURKQUFBQk11MEtrZXh3YjNOMEFBQUMvQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm00bWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvcU1pZ3lNL3dIOHBraDBraHEvZ09GQWFMN0RFRUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aUsvLzlEeVA4UHdId0dBRS8zQm4wQUFBQUFBZ0JxQUFBQTRBTGJBQXNBRlFBQUV3TU9BU0ltSndNK0FUSVdFdzRDTGdFMk54NEI0Q2dCQ0JNSkFTZ0NJaTBrQVFFaE1TRUNJQndZSVFLai9qc1BDUWtRQWNRYUhoMzlmUmtoQVNBeklnRUJJUUI0Mm1OZ1pHQmdBR0lGRDQvMzhmdzJYeG1ZV1JoQTRQSCtyN09SYWFiTFRMZUJGQWNERTRnSEFEc1JDMmdBQUFCNDJtTmdaR0JnWnZqUHdNREFkSmtoaXlHYjRRRURVQVFGTUFFQVZsZ0RrUUxUQUFBQlN3QnFBQUFBQUFBcUFBQjQybU5nWkdCZ1lHSVFBMklRWUdSQUF3QUMyZ0FkQUFCNDJqMk1NUXZDTUJDRnYySVZyWU9ENE9BZ3dSOVF0QW91Ymc1T3JnNXUxZ1RwMEZUU1duUVJmN3JYRUx5UTQ3djMzaDJROENHaXE0aUo3MTNGOGlhQis0eVpCaDZJdmdpY01HZEpqeWdlaWJKZ0h6aG15Q1Z3bnhsNTRJSG9yOEFKVzc2SHFudzhHK1BVcWRMRzJWdnBkbWZqNnFLeWFwMnV1dkZvckhIWHhtaVZ2NVZ1aTdxOWwycVRabW5HZ1lxU0IwOGFEQTdGU1JUdDJYSVR6N0hqN09lYVFqd3JtVFVwcTc5N0ZOZjZ4TlZmMFpMSWVVdlh0TEpUUzc5TFZyR1J2YXo3UDFreUxrMEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVRrQUFvQUFBQUFCZWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDFCR050WVhBQUFBRTRBQUFBTlFBQUFEd0FnZ0NIWjJ4NVpnQUFBWEFBQUFJTkFBQUNxQUdKVUpSb1pXRmtBQUFEZ0FBQUFDOEFBQUEyS2Y0dkQyaG9aV0VBQUFPd0FBQUFIZ0FBQUNRR2hnR2JhRzEwZUFBQUE5QUFBQUFRQUFBQUVBc1lBR1JzYjJOaEFBQUQ0QUFBQUFvQUFBQUtBYWdBNW0xaGVIQUFBQVBzQUFBQUdBQUFBQ0FBQndCaGJtRnRaUUFBQkFRQUFBRFVBQUFCUHBrUmRjZHdiM04wQUFBRTJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbU9zWTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkloa1p2Z1A1RE5EcEpIVS9BY0tBd0R2cmcxUWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS09qSkUvdjhQNURzeVJQei8vLy9BLzFWZ1ZVQUFBSksrQ1FNQUFBQjQybFdSVDR2VFFCakc4NzdUekNUcFRLYXhrd2wxMjJSclM4T0MyMnE3bTZDdzdVVVJQQ2d1aTNnUUZHVC9uRHlzb25pUmRmWG1KL0FENkFmd29DQ0NWeitDQnoxNEV3VEJnMGRiSjhuNmIwN3pQdk8rdy9ON1hndXQvbUtCbi9HVE5iTEdscFZEbG85MTFGUjZrbWs2QXBZTzByVXMwbGsrZ2k2alNrZFo1SVBSQzNreWhYeENYc00yVllMQ1ZLK0d3TzI3QjQ0Tm90NWNJeTZiTHk2SmRsTVFFUGJ1TlE3Y1BURjk5clY3RDY4MndKVS9EN1FrSFFhRUFEcVNBZkJvNS93VDFXOEFTcDhXc2ljcDlON0RwbVVPV08zRmd1emlXK3VHS2ZJc0gySTZoUVJ5bllDaVBSOFlsV0R1TVV3aUhaWVcweU9QNnlPUVlCcktweVAzSXlpZlpraUcwS1BWVDFFTXhVY2hmSC9SSUpnMHdkamV2K2tpY204NEMxdjVZZEMvN0hWT2M0YWM3ajl5YmVCT0hOdDcxL2ZxeG5MaXNKcEJzTzlVQStuRmdmand3RzZmRExFUXErN2xOangvNlVlS2crZVgzRFhxVXhJcnZmRjB1UFVtbG9CZUNZN2dDbFk3eHVTUDdkdjFTS2c2b3ZON1FGSmNUdmtYaUJzQjhTc1JRMVlMN1RJanMwdkNUVWJuVEVGOGcwMURta0QyTnc2enlSbW0vMExyU05FQlpVc20weUdrZy9WU0hWZVI0cTA1dGNtcWpmR2dBNXcrTGpCOC8yekN1cUwyMEQ1ZXdJa0tUb1NueVAxdnNnNUxBUVZCZDdZRWR5WWJHaS9NUDFMdXYxTE13UDIzYkxWeWVDYUFLODNHSHdxRGlHNHdmd2VCa2gydnFJc3NXdFJlYVZuV0w1SVFWeThBQUFCNDJtTmdaR0JnQU9KWG5Ddlo0L2x0dmpJd3N6Q0F3T1A5WDJjajZQLy9tZE9aN2dLNUhBeE1JRkVBVjRjTkFRQjQybU5nWkdCZ1p2alBBQ1FER0dUK3V6R25Nd0JGVUFBTEFFekpBeWNBQUFKMkFBQURBQUFrQTFBQUhBSlNBQ1FBQUFBQUFGUUE1Z0ZVQUFCNDJtTmdaR0JnWUdGSVlHQmlBQUZHQmpRQUFBcEtBR2w0MmsyT3NXckRNQlJGajZsanFGdklsQXdkaXFhTXhuYjZBWVVNbWJKbUxDU1JDQzVJQ3JKanlCTDZBZjNvUGlzYStvUWVSK2RkQ1FFbGR6S215cGpIUGxWT0lhY0h6M2hoa2JpUXBSS1h2TEhpaVN4L0Z2UE9aK0tjVjc0U3oxanluYmdRLzVPNDVJUGZqYmVYNjJDQzJubHRnanRaMnpYMTNvUys4MDQxVmYwUVcrTk1PQXhHcStOTjZiSHJ4N05WNjZxdFdqWjRMQmV1REJpQy9Hd25Sa2QybkdSbTZXaW8yVWZYeThuTFJJbXJ4UDVQYkNYaFl1b1FYOU9TT25LVHJoa2wwMHMvUzFxeGxydnR0UDhBNElJd3ZYamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNY0FBb0FBQUFBQTN3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhSUJpZjJOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9ESFoyeDVaZ0FBQVd3QUFBQlFBQUFBVU1QRmhyVm9aV0ZrQUFBQnZBQUFBQzhBQUFBMktiTXVsV2hvWldFQUFBSHNBQUFBSGdBQUFDUUZ4ZitGYUcxMGVBQUFBZ3dBQUFBSUFBQUFDQVhHQUQxc2IyTmhBQUFDRkFBQUFBWUFBQUFHQUNnQUFHMWhlSEFBQUFJY0FBQUFGd0FBQUNBQUJBQVhibUZ0WlFBQUFqUUFBQURWQUFBQlBxODNkZU53YjNOMEFBQUREQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1lc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFBQkpIWktjVms2QTl1RGtnY2x6RkovTkJrWW1LV1lyd09GR1JFcS92OW5ZQUFBVlY4UXZRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROUsvditIa1BLOVlIa0dBR29HQjdBQUFBQUJBRDMvL3dKdEFtTUFGUUFBQVJFV0JpY2hCaVkzRVNZMk1oWUhFU0VSSmpZeUZnSnNBUTRZL2h3WER3RUJDQndIQVFIY0FRY2NDQUkvL2VZWkRRRUJEaGdDR2c4VkZRLzk2Z0lXRHhVVmVOcGpZR1JnWUFEaTV1VjdsT1A1YmI0eU1MTXdnTURqL1Y5bkkrai8vNWxsbUpLQlhBNEdKcEFvQUYrMkRLSUFlTnBqWUdSZ1lKYjZvd2trWlJoc0dXeVpjaG1BSWlpQUNRQTcwZ0pQQUFBREhBQUFBcW9BUFFBQUFBQUFLQUFBZU5wallHUmdZR0JpRUdNQTBReFFFZ2tBQUFMREFCd0FlTnBOanJGcXd6QVVSWStwWTZnYjZKUU1IWXFtak1aMjhnR0ZESm15Wml3a2tRZ3VXQTZTWS9CUytnSDU2RHdyR3ZxRUhrZjMzdmNRa1BOTHdsUUo3NkZQbFpMSjY4a3ozbGhFenVTb3lEa2ZySGdoU1Y5RitlUXJjc3FjNzhnemx2eEV6a1QvaTV5ejRiN3QydXV0TjA3dE8yMmNQYmQrck1xRGNiN3ByS3FLOGluc2pEWHUyQnV0VHFQU1ErT0hTNnZXUlYzVWJPbG91WEtqeCtEa1ozdFJkR0RMV1R6UFNFWEpJV2llUm53cnVZcEMxUCtKblNSc1NCM0ROaTJwazNoS2FKQTVMLzBpZWNWYVp1dnBQZ0FKM3pFVkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVFFBQW9BQUFBQUJhQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMGhHTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWZnRENaMng1WmdBQUFXd0FBQUlFQUFBQ2FFMjZYbFpvWldGa0FBQURjQUFBQUM4QUFBQTJLVjB1TVdob1pXRUFBQU9nQUFBQUlBQUFBQ1FGbVFHYmFHMTBlQUFBQThBQUFBQVFBQUFBRUFqWUFLZHNiMk5oQUFBRDBBQUFBQW9BQUFBS0Fab0ExRzFoZUhBQUFBUGNBQUFBR0FBQUFDQUFCd0JGYm1GdFpRQUFBL1FBQUFEUEFBQUJPUE5oS3FOd2IzTjBBQUFFeEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtTW1PY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F5TS93SDhwa2gwa2hxL2dPRkFjR3BEUFVBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpOay92OFA1S2VCNlArei84OENxd0lDQUpreENUb0FBSGphUmRDOWt0SlFHQWJndk9lRVpDSENTVUp5UXBBTmhFQ0M3aTUvZ1RDenl3SUJMZGJkOGFkaWNCeXR0TEJ5eHNheDhnb3NIQXRiQzcwSCs3MkJ2UTVybmJFUVBGbkg4WHpkZWIvaWZUNEowdm11UjE2U0sya2hTYUFNaWxxQzJneWpHV0x1Y0VYbGRjd3dwNEVTSms0OHcwVDhEN2xUUWhCR1lUSUpleWdSaGpqaFNvVFB4N3FzVi9QcG9ITU10T3lRZ3RVWll5MmY3bmZaaFVmSzdCR3pTM3daM0pvQ0FSZTU3akZtbWw1aHIvb3NpL0Z4ZTNuUFdJeXNGUTBEcjBGYVNxVGxDZVJ6KzlPUE5XMnFXRzl1Um1HNzlUK0NHeDY5bDV0N2tNUWowdUh1aUxSeEtYV2xWYVlSRXVWYUlocGJpdXJ3bUNjQ01CZklMcUpra28wSFI2akVBcDBqaVFSS1ViTVRjR2VZclJML1ZmNzFtOTVUV2ZRMU9FcG16ZkN0YVZEanFqTTVTemVFcHN3NDIzVEdSVm8xaXpZKzlDZ3NlMVJkTld6ZFFCaDV5OW9ORlcrM2FlOHhKZmJodmw4dWExNGhSNkRWM0g3alNTeGovZkQ1L1RLN1E5SGlPb2R1Ykg5OVkxbzdrTkVaaCtuaXdRVHRCaXRlMi9xN24zaEJ2a29GYVNwc2d0YkZlSVloejNxUFIycFQ5QTVFLzlFL2xjSklCc2tjU2V4NDRoVHFYell1NEZjc0c4R0JkYldvS3E0M3RXQm9DaXFhRWN3T3hrRE9kVTJtMDFyOXBFeU12QUt1bWNHcENBaDV4MzNBWWR4M2YzLy9zclQwaUo0c2RVTHlwUUczdXprTVc0YWVwcDNiamJ1WW41cUVPSDJIZDJVTTJwVS8xMnBTZm5qYVkyQmtZR0FBNGlWMTZsL2orVzIrTWpDek1JREE0LzFmWnlQby83cE14NWd1QXJrY0RFd2dVUUJwR1EwY0FIamFZMkJrWUdCbStNL0F3TUIwakVIbi93V21MQWFnQ0FwZ0FRQmxIQVE0QXNZQUFBSTZBRXNDT2dBc0FaNEFNQUFBQUFBQVpnRFVBVFFBQUhqYVkyQmtZR0JnWVhCaFlHSUFBVVlHTkFBQUI0NEFUWGphVFl3OWI4SXdFSWFmaUFTSk1MQ2dEaDJLaDg0UkJDUzJMZ3hNckV3c2dGMlV3VFp5UWlTa3FtTi9keSt1aDU3azAvTituSUdTYnpLR3laakZQVXhPSWVxUEM2Yk1FNDlGTFJLWHZQTE9pQ3lmaVBQR1IrSmNrbFBpZ2hjK0U0L0YvMHBjc3VGbjUrMzkwWm1nRGw2YjRLN1dOdHVqQ1czam5WcFZ5NmozeHBsdzdveFdsNmZTZmRQMk42dldWVjNWN1BCWTdqem9NQVFVQjNGMFpNZFZNa3ZEbG1OMFdtRXZ2bUpGeGZKZnZwZmN4YzQ1L3FTbGMrRXBXOU5MbzVWOWs2NWlMWmYxOEg0QnpDc3YrUUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU93QUFvQUFBQUFCQmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVeDFBbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNGWjJ4NVpnQUFBV1FBQUFEMEFBQUE5TnUrK1pKb1pXRmtBQUFDV0FBQUFDMEFBQUEyS2VndTNtaG9aV0VBQUFLSUFBQUFIZ0FBQUNRRnVnS3lhRzEwZUFBQUFxZ0FBQUFLQUFBQUNnWm5BSkpzYjJOaEFBQUN0QUFBQUFnQUFBQUlBRElBZW0xaGVIQUFBQUs4QUFBQUZ3QUFBQ0FBQlFBdGJtRnRaUUFBQXRRQUFBREpBQUFCTXVzSWtlaHdiM04wQUFBRG9BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWVzMDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFEwWkRCaVp2Z1A1RE5EcEpIVS9BY0tBd0QyeEEwK2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoRy8vOERTY1AvLy85ZkFQTVpBRkZZQm80QUFRQ1NBQUFDTndLckFCNEFBQUVSQmhZN0FSVW1KeU1HQnpVek1qWW5FUTRCSnlNMU14WS9BVFkzTmhZQm1BUWlUak1zT3RFNkxETk9JUU11VkJNU0VoSStCejg1R0E0Q2kvM05GeFF0QXdFQkF5MFVGd0lBRWd3QkxRSUtBZ291QVFrQUFBRUFYUUFBQWxzQ3FnQXJBQUFsQnlFMU5EOENQZ0UzTGdFbklnWUhIZ0VYRGdFakJpWW5QZ0UzTWhZWERnRUhCZzhCSlRZM1BnRTNBbHNpL2lRRENmbzlUUUVDYUUwMFVoWVlJUUVCSmhVT0xBSUNoR3B3bXdNQ2FFZ3ZOV2tCQWlvS0RROEN4c1lmQlFJSjFERnFQMHhUQVNvakFoOGJJQjBCR1NkTlpRSnBZMUJwTGlBblRnRUJCQXRCRWdBQWVOcGpZR1JnWUFEaUJaZDB1T1A1YmI0eU1MTXdnTURqL1Y5bkk5UE1RVXlyZ1JRSEF4T0lCd0EycUFyQ0FBQUFlTnBqWUdSZ1lHYjR6d0FrZ3hoaUdXS1pvaG1BSWlpQUNRQTkwUUp6QUFBRFVnQUFBcmdBa2dCZEFBQUFBQUFBQURJQWVuamFZMkJrWUdCZ1p0QmhBTkVNVUJJSkFBQUZCQUF6QUhqYVBZd3hDOEl3RUlXL1loV3RnNFBnNENEQkgxQzA2dWJtNE9UcTRHWk5rQTVOSmExRkYvR25ldzNCQ3ptK2UrL2RBUWtmSXJxS21QamVWU3h2RXJqUG1HbmdnZWlMd0Fsemx2U0k0cEVvQy9hQlk0WmNBdmVaa1FjZWlQNEtuTERsZTZqS3g3TXhUcDBxYlp5OWxXNTNOcTR1S3F2VzZhb2JqOFlhZDIyTVZ2bGI2YmFvMjN1cE5tbVdaaHlvS0hud3BNSGdVSnhFMFo0dE4vRWNPODUrcmluRXM1SlprN0w2dTBkeHJVOWMvUlV0aVp5M2RFMHJPN1gwdTJRVkc5bkx1djhEVmJndVJRQUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTWdBQW9BQUFBQUE0d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncWt5VVRtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSldaMng1WmdBQUFXd0FBQUJjQUFBQWFKNWdWSVpvWldGa0FBQUJ5QUFBQUM4QUFBQTJLaWd1K21ob1pXRUFBQUg0QUFBQUhnQUFBQ1FGdXdBVWFHMTBlQUFBQWhnQUFBQUlBQUFBQ0FZbkFGQnNiMk5oQUFBQ0lBQUFBQVlBQUFBR0FEUUFBRzFoZUhBQUFBSW9BQUFBRndBQUFDQUFCQUFmYm1GdFpRQUFBa0FBQUFEUEFBQUJPQk9CS3J0d2IzTjBBQUFERUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1hY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeG9BQUhHQ09sdUN5ZGdVMkpXWW1aV2ZHUEVRTURzeUx6T2FBd0kwTHAvLzhNREFETHhBM09BQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJNLy85RHlMdi93UElNQUZCdEJvRUFBSGphWTJCa0NQai9uOG1ENlFTRExBTURvNkFZbTdvaW01cUptYmlpSUJwdEpzYmt6aWdvK1MrS1QwcVNuM0hPdjBJZVNSayt4cTUvS1dEK01rbEJwdmwvTzZYNEdSazVWRGdZR1NVaGxEZ2pwekluSTZNQUF3RDdOaEhOZU5wallHUmdZQURpaHBsblhlUDViYjR5TUxNd2dNRGovVjluSStqLy81a25NcDBBY2prWW1FQ2lBRytnRFo0QWVOcGpZR1JnWUZiOFl3UWtKeklFTVBneGVUQUFSVkFBRXdCSmVBTFRBQUFEa1FBQUFwWUFVQUFBQUFBQU5BQUFlTnBqWUdSZ1lHQmlrR01BMFF4UUVna0FBQU9MQUNRQWVOcE5qRDF2d2pBUWhwK0lCSWt3c0ZRZE9vQUg1Z2hDSmJZdURFeXNUQ3lBRGNvUUI5a2hVcVNxWTM5M0w2NEhUdkxwZVQvT1FNNFBDY01rek1JZUppVVQ5YzhaVTk0aWowVXRJdWQ4c0dSRWtrN0VtZk1WT1pYa0ZEbmpuVnZrc2ZqZmtYTSsrZDAxOWVQWkdxY09qVGJPWG12ZmI0L0crYXF4YWwyc2d0NGJhOXk1TlZwZGVxVzd5bmYzV20yS3NpalowVkR6NEVtTHdhRTRpS01EVzY2U2VYcTJISVBqcVNTMTBscFRzSHJKOTVMYjBEbUhuN1IwTHBJb29VNnV2T3k3dEJVYnVTeUg5d2YwQXpCUkFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5MTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTIuNjUzMjQ5LC0zMi45MTczNjIpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTU5LjU2OTMsLTM1LjU2OTQ3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTIuNjUzMjQ5LC0zMi45MTczNjIpc2NhbGUoLTEsLTEpJz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjg0NjAyMSwtOTYuOTgyNzUpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuMjEyMzg4LC05Ni45ODI3NSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg0Ny4yMTIzODgsLTk2Ljk4Mjc1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzQ3LjIxMjM4OCcgeT0nLTk2Ljk4Mjc1Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjg0NjAyMSwtNjQuOTUwMDU2KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNC41MzQ3MSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zLjg0NjAyMSwtNjQuOTUwMDU2KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zLjg0NjAyMScgeT0nLTY0Ljk1MDA1Nic+WDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ny4yMTIzODgsLTY0Ljk1MDA1NilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5Ny43NTE5MTUsLTY0Ljk1MDA1NilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuMDEzODksMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg5Ny43NTE5MTUsLTY0Ljk1MDA1NilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSc5Ny43NTE5MTUnIHk9Jy02NC45NTAwNTYnPlk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuODQ2MDIxLC0zMi45MTczNjIpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuMjEyMzg4LC0zMi45MTczNjIpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNC4xMDQxMSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDQ3LjIxMjM4OCwtMzIuOTE3MzYyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzQ3LjIxMjM4OCcgeT0nLTMyLjkxNzM2Mic+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc1OC40NjE4MScgeT0nLTMyLjkxNzM2Mic+7oG0PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzY3LjMxNzQ1OCcgeT0nLTMyLjkxNzM2Mic+WTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTQxLjY4ODgtNi41ODQ4OEwtMTIuODc1NDctMjQuNjYzODYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC44NDcwMywtMC41MzE0OCwwLjUzMTQ4LDAuODQ3MDMsLTEyLjcwNjA5LC0yNC43NzAxNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzYuMTk3NjIsLTIyLjcxNTMzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTIuNjUzMjQ5LC0zMi45MTczNjIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTEyLjY1MzI0OScgeT0nLTMyLjkxNzM2Mic+aTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctOS44MzQ1MjInIHk9Jy0zMS45MjEwOTgnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNNDIuNzMwNDUtNi4zMTQzNUwxMy43ODMzOS0yNC42NjIzMicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC44NDQ1OSwtMC41MzUzNCwwLjUzNTM0LC0wLjg0NDU5LDEzLjYxNDQ5LC0yNC43NjkzOCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzMC40NDA3OCwtMjIuNTgwMDYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xMi42NTMyNDksLTMyLjkxNzM2MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTIuNjUzMjQ5JyB5PSctMzIuOTE3MzYyJz5pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy05LjgzNDUyMicgeT0nLTMxLjkyMTA5OCc+MjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00tNDEuNjg4OCA0Ljc1NDQ2TC04LjA3MzQ3IDI1Ljg0NzM4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuODQ3MDIsMC41MzE1LC0wLjUzMTUsMC44NDcwMiwtNy45MDQxLDI1Ljk1MzY3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMS43NDg2LDE5LjEyMTA1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTIuNjUzMjQ5LC0zMi45MTczNjIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTEyLjY1MzI0OScgeT0nLTMyLjkxNzM2Mic+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J000Mi43MzA0NSA0LjQ4MDI2TDkuMTE0MTQgMjUuNzkzMTUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuODQ0NTMsMC41MzU0MywtMC41MzU0MywtMC44NDQ1Myw4Ljk0NTI1LDI1LjkwMDIyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI4LjEwNjE3LDE4Ljk1NzYxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTIuNjUzMjQ5LC0zMi45MTczNjIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTEyLjY1MzI0OScgeT0nLTMyLjkxNzM2Mic+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzIuNzk5ODUsMS41OTk5MScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00uNTIwODMtMjQuODc2NDNWMjQuNDc2NDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwwLjUyMDgzLDI0LjY3NjQ1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04LjYyMzYxLC0yLjQzMDU0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTIuNjUzMjQ5LC0zMi45MTczNjIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTEyLjY1MzI0OScgeT0nLTMyLjkxNzM2Mic+4oiDPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy04LjE0MjM2NCcgeT0nLTMyLjkxNzM2Mic+ITwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4="></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            &amp; A \\
            X &amp;&amp; Y \\
            &amp; {X\sqcup  Y}
            \arrow [&quot;{i_1}&quot;&apos;, from=2-1, to=3-2]
            \arrow [&quot;{i_2}&quot;, from=2-3, to=3-2]
            \arrow [&quot;f&quot;, from=2-1, to=1-2]
            \arrow [&quot;g&quot;&apos;, from=2-3, to=1-2]
            \arrow [&quot;{\exists !}&quot;, dashed, from=3-2, to=1-2]
        \end {tikzcd}   
    </fr:resource-source></fr:resource></fr:figure>
 

    We might denote the unique as <fr:tex display="inline">f\sqcup  g: X \sqcup  Y \to  A</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>In this section we discuss the <fr:em>limits</fr:em> of variously-shaped diagrams of sets.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>563</fr:anchor>
                    <fr:addr type="user">def-002L</fr:addr>
                    <fr:route>def-002L.xml</fr:route>
                    <fr:title text="Pullback of Sets">Pullback of Sets</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Suppose we have sets <fr:tex display="inline">X</fr:tex>, <fr:tex display="inline">Y</fr:tex>, and <fr:tex display="inline">Z</fr:tex> and functions
    <fr:tex display="inline">f : X \to  Z</fr:tex> and <fr:tex display="inline">g : Y \to  Z</fr:tex>.
    
 
  
  <fr:figure><fr:resource hash="97aeab91001df32bef920b3982fb7fb0"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9Jzg3LjY1ODA4N3B0JyBoZWlnaHQ9Jzc2LjAyNTI2cHQnIHZpZXdCb3g9Jy03MiAtNzIgNTguNDM4NzI1IDUwLjY4MzUwNyc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVE0QUFvQUFBQUFCTkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjB0R050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFGMUFBQUJxQlc2ckhob1pXRmtBQUFDM0FBQUFDOEFBQUEyS1YwdUwyaG9aV0VBQUFNTUFBQUFJQUFBQUNRRm1RR1phRzEwZUFBQUF5d0FBQUFLQUFBQUNnVXNBRXRzYjJOaEFBQURPQUFBQUFnQUFBQUlBR1lBMUcxaGVIQUFBQU5BQUFBQUdBQUFBQ0FBQmdCRmJtRnRaUUFBQTFnQUFBRFBBQUFCT1BOaEtxTndiM04wQUFBRUtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXltQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTWFRek0vd0g4cGtoMGtocS9nT0ZBZE9aRFNVQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOER5YlQvLy8vUEJ2TVpBRld4QnNONDJrV1FQVS9DVUJTRzczdHZiVVdrdHdWNkd4RXIwSEtMQ1ZDMTJpYkdBQlVYUCtMSFJEQkdKeGNuRXhmamozQXdEcTcrREhmL2dEL0d3UVc5ZGZHYzdUenY4RDZIZ0J6OVJQU1dmcElSSVdBY3VtSENhTWx3Z0ZpNFFqZkVLZ1lZTWwrWGlSc1BrS3I3cG5CTitES1VTU29qbUpRalRvUWU0bTNIMHF4YUlkdm83QUNCSXhuNEt1YzhhTEtWUGovMmFJV2ZjOGNVZS83YUx1QUx4UzJQODNMWlc1aXZYZWNZTDdPUFEzdTBWUjB6NlhzTkd1aGhzVUNoSFRtdlh4UFdNakNaTG9leUhmd2pMTW5lazlhYUIxRkRTZmVuUjl2NElIMHl6bTJVaWY1bm9ocFhkY01Wc1VpVXdGQko5aEVtYWI0ZVhHV2xBbXlJSkZSU3VwRy9RTGliZVpRMjd3cjNEOUdWcHZyYUFtYTViamVydTM1ZEdHNTZrRTBweTdoOU1PMXNsMWl0WEhMd0hERlVuYTNhdU9GWU5tVG83ZFVYRFR6T3N1aUNVYWU3MHF4VWl0N0NIRVd4dnJUZXVJdzFUTTV1VGlwOG55RVFsb0Jsejc3ZmViSHRhK2hzeTJ4MG1xTGQ0Q1ZDZmdFRk9EbktBQUFBZU5wallHUmdZQUJpZWVWSjNmSDhObDhabUZrWVFPRHgvcSt6RVBSL1hhWmpUQmVCWEE0R0pwQW9BRUdjRERzQWVOcGpZR1JnWUdiNHo4REF3SFNNUWVmL0JhWXNCcUFJQ21BQ0FHVWFCRFlDeGdBQUFqb0FTd0FzQUFBQUFBQUFBR1lBMUhqYVkyQmtZR0JnWm5CaFlHSUFBVVlHTkFBQUIzTUFUSGphVFl3OWI4SXdFSWFmaUFTSk1MQ2dEaDJLaDg0UkJDUzJMZ3hNckV3c2dGMlV3VFp5UWlTa3FtTi9keSt1aDU3azAvTituSUdTYnpLR3laakZQVXhPSWVxUEM2Yk1FNDlGTFJLWHZQTE9pQ3lmaVBQR1IrSmNrbFBpZ2hjK0U0L0YvMHBjc3VGbjUrMzkwWm1nRGw2YjRLN1dOdHVqQ1czam5WcFZ5NmozeHBsdzdveFdsNmZTZmRQMk42dldWVjNWN1BCWTdqem9NQVFVQjNGMFpNZFZNa3ZEbG1OMFdtRXZ2bUpGeGZKZnZwZmN4YzQ1L3FTbGMrRXBXOU5MbzVWOWs2NWlMWmYxOEg0QnpDc3YrUUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVRFQUFvQUFBQUFCYmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hYTjA4Mk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUN0WjJ4NVpnQUFBV1FBQUFINkFBQUNnT3BGVWxab1pXRmtBQUFEWUFBQUFDOEFBQUEyS2Y0dTdHaG9aV0VBQUFPUUFBQUFIZ0FBQUNRR2hnR2JhRzEwZUFBQUE3QUFBQUFRQUFBQUVBclNBSHBzYjJOaEFBQUR3QUFBQUFvQUFBQUtBZElCQUcxaGVIQUFBQVBNQUFBQUZ3QUFBQ0FBQmdCaGJtRnRaUUFBQStRQUFBRFVBQUFCUHBrUmRjZHdiM04wQUFBRXVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbTJzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFNNWUloaVp2Z1A1RE5EcEpIVS9BY0tBd0RzQ2cxV2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoUi8vOER5WWovLy8rdkJQTVpBRlNjQnJaNDJrMlJUWXZUVUJTRzg1NmIzSnVrK1dpbSthQzJUYVoyVEJqUVZxZE9xZ050RmdxQ0lDTE1Ua0ZSMUJFR2tSRVJOenFPUzMrR3FFdkZoWWdvYnZ3Ukx0eTQwcFdnNEhJNjNpVDRzYnZuUGVkZXp2TmNCVXAzYjQ5ZHAzZktSVVhCSko4TUtac2h3U1JNNFBPQkE4RmR5SE9NY1JRR0RrWVFXWm9kemNjenJJN2dRZzVVcmFocXBTTlVyWUxZRUFOZXZ4VEZLQjhLOE9OWmsxSFNBbXh0NjVKQlpKbkRJbWhQZHJ5bHMyYnZpQ1hJNGxzUERRMldIc2ZheG9XTlJoT1U2RUlGTE8xMmZTRTduZHFmN21uZGd3R1ZZVDI5Mk1YVFYwN2tXekFkQWNhZ2NvZXoyQStuajRmcmIyTVhaRHBjNWdUREZ1cUNjSDlkdmRtSWJMOUJwUCs1NEhKYXpLeHZpSnNlYytxUUFxRUdtaUsxS0V2U2tTVWRuWlFGY3lRMkQzaUMvSitPS013THl2NkhEaU9mcDF4MHBOTWhzblMxU2xkcXBYUmx6alYyU0tNNDdjSGlqMG9NeDFsTFJOOVc3MnY3U2ppN2hyT0R3K3p1ZDdlQmpzZGg4MnZydHFXUHB5R2Rtbi9tbHZQYUZ4S085ZXAxZFZjQS92TE9jUS9uV3MyL0ZCS1JERy8rQVo3djlzeXlMbDIwdWJiY3J0alc5dWIwbGQ0ckJ4VEZ3SGdsTDVDUHcwQTR5UHE4QUFiN3VlRFZ4eGFZSWVybmdyN3Nmbnp4NEZaUFY3bDlSalVYNWljNlVHbjYvTTVtQjVZQnBoNlRJVjUyR1QzWjNkNjg0V3RrL0pTN1VLTkYyNWZQaTlLMlpyNnBFdVUzZUI5Vm1RQUFlTnBqWUdSZ1lBQml5YzVseCtQNWJiNHlNTE13Z01Eai9WOW5JZWovLzVqVG1mWUN1UndNVENCUkFHYVlEVW9BZU5wallHUmdZR2I0endBa0F4aGsvcnN4cHpNQVJWQUFDd0JNeVFNbkFBQUNkZ0FBQTFBQUhBSlNBQ1FDdWdBNkFBQUFBQUNTQVFBQlFBQUFlTnBqWUdSZ1lHQmhTR0FBMFF4UUVna0FBQW96QUdnQWVOcE5qckZxd3pBVVJZK3BZNmhieUpRTUhZcW1qTVoyK2dHRkRKbXlaaXdra1FndVNBcXlZOGdTK2dIOTZENHJHdnFFSGtmblhRa0JKWGN5cHNxWXh6NVZUaUduQjg5NFlaRzRrS1VTbDd5eDRva3NmeGJ6em1maW5GZStFczlZOHAyNEVQK1R1T1NEMzQyM2wrdGdndHA1YllJN1dkczE5ZDZFdnZOT05WWDlFRnZqVERnTVJxdmpUZW14NjhlelZldXFyVm8yZUN3WHJnd1lndnhzSjBaSGRweGtadWxvcU5sSDE4dkp5MFNKcThUK1Qyd2w0V0xxRUYvVGtqcHlrNjRaSmROTFAwdGFzWmE3N2JUL0FPQ0NNTDE0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00Mi45NDkyNzcsLTQ4LjkzMzcxNylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjkuMTU5NjcsLTE5LjQ5MzA2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDIuOTQ5Mjc3LC00OC45MzM3MTcpc2NhbGUoLTEsLTEpJz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zNC4xNDIwNDgsLTgwLjk2NjQxMSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2Ljg2MzgzMywtODAuOTY2NDExKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNC4wMTM4OSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDYuODYzODMzLC04MC45NjY0MTEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nNi44NjM4MzMnIHk9Jy04MC45NjY0MTEnPlk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTM0LjE0MjA0OCwtNDguOTMzNzE3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNC41MzQ3MSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zNC4xNDIwNDgsLTQ4LjkzMzcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzQuMTQyMDQ4JyB5PSctNDguOTMzNzE3Jz5YPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYuODYzODMzLC00OC45MzM3MTcpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc3MDgzLDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNi44NjM4MzMsLTQ4LjkzMzcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSc2Ljg2MzgzMycgeT0nLTQ4LjkzMzcxNyc+WjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTExLjI3OTE2LTE2Ljk5MzA2SDEyLjE2MzkxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEyLjM2Mzg5LC0xNi45OTMwNiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMS42OTk2OSwtMjQuMjA2OTEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Mi45NDkyNzcsLTQ4LjkzMzcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDIuOTQ5Mjc3JyB5PSctNDguOTMzNzE3Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTTIwLjg0MDI0IDguODAwMDNWLTguNDAwMDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwyMC44NDAyNCwtOC42MDAwNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMy4xOTMsLTAuODI2MzkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Mi45NDkyNzcsLTQ4LjkzMzcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDIuOTQ5Mjc3JyB5PSctNDguOTMzNzE3Jz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4="></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            &amp; Y \\
            X &amp; Z
            \arrow [&quot;f&quot;&apos;, from=2-1, to=2-2]
            \arrow [&quot;g&quot;, from=1-2, to=2-2]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure>
 

    Its <fr:strong>fiber product</fr:strong> is the set
    <fr:tex display="block">         X \times _Z Y = \{ (x,w,y) \mid  f(x) = w = g(y) \}     </fr:tex>
    There are obvious projections 
    <fr:tex display="inline">         \pi _1 : X \times _Z Y \to  X \text { and } \pi _2 : X \times _Z Y \to  Y     </fr:tex>
    such that the following diagram commutes (<fr:tex display="inline">W = X \times _Z Y</fr:tex>):
    
 
  
  <fr:figure><fr:resource hash="546b6a73a9b55f631584614d7b8db8f6"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9Jzk1LjMxODg5OXB0JyBoZWlnaHQ9Jzc2LjgxMTg4cHQnIHZpZXdCb3g9Jy03MiAtNzIgNjMuNTQ1OTMzIDUxLjIwNzkyJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPd0FBb0FBQUFBQkJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVXgxQW1OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDRloyeDVaZ0FBQVdRQUFBRDBBQUFBOU51KytaSm9aV0ZrQUFBQ1dBQUFBQzBBQUFBMktlZ3UzbWhvWldFQUFBS0lBQUFBSGdBQUFDUUZ1Z0t5YUcxMGVBQUFBcWdBQUFBS0FBQUFDZ1puQUpKc2IyTmhBQUFDdEFBQUFBZ0FBQUFJQURJQWVtMWhlSEFBQUFLOEFBQUFGd0FBQUNBQUJRQXRibUZ0WlFBQUF0UUFBQURKQUFBQk11c0lrZWh3YjNOMEFBQURvQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1lczA0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBRMFpEQmladmdQNURORHBKSFUvQWNLQXdEMnhBMCtlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aEcvLzhEU2NQLy8vOWZBUE1aQUZGWUJvNEFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FBQUVBWFFBQUFsc0NxZ0FyQUFBbEJ5RTFORDhDUGdFM0xnRW5JZ1lISGdFWERnRWpCaVluUGdFM01oWVhEZ0VIQmc4QkpUWTNQZ0UzQWxzaS9pUURDZm85VFFFQ2FFMDBVaFlZSVFFQkpoVU9MQUlDaEdwd213TUNhRWd2TldrQkFpb0tEUThDeHNZZkJRSUoxREZxUDB4VEFTb2pBaDhiSUIwQkdTZE5aUUpwWTFCcExpQW5UZ0VCQkF0QkVnQUFlTnBqWUdSZ1lBRGlCWmQwdU9QNWJiNHlNTE13Z01Eai9WOW5JOVBNUVV5cmdSUUhBeE9JQndBMnFBckNBQUFBZU5wallHUmdZR2I0endBa2d4aGlHV0tab2htQUlpaUFDUUE5MFFKekFBQURVZ0FBQXJnQWtnQmRBQUFBQUFBQUFESUFlbmphWTJCa1lHQmdadEJoQU5FTVVCSUpBQUFGQkFBekFIamFQWXd4QzhJd0VJVy9ZaFd0ZzRQZzRDREJIMUMwNnVibTRPVHE0R1pOa0E1TkphMUZGL0duZXczQkN6bStlKy9kQVFrZklycUttUGplVlN4dkVyalBtR25nZ2VpTHdBbHpsdlNJNHBFb0MvYUJZNFpjQXZlWmtRY2VpUDRLbkxEbGU2akt4N014VHAwcWJaeTlsVzUzTnE0dUtxdlc2YW9iajhZYWQyMk1WdmxiNmJhbzIzdXBObW1XWmh5b0tIbndwTUhnVUp4RTBaNHROL0VjTzg1K3JpbkVzNUpaazdMNnUwZHhyVTljL1JVdGlaeTNkRTByTzdYMHUyUVZHOW5MdXY4RFZiZ3VSUUFBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFWa0FBb0FBQUFBQnFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoWEoxS21OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDdFoyeDVaZ0FBQVdRQUFBS1dBQUFEYktsRkdENW9aV0ZrQUFBRC9BQUFBQzhBQUFBMktzZ3UxbWhvWldFQUFBUXNBQUFBSGdBQUFDUUhVQUlUYUcxMGVBQUFCRXdBQUFBVUFBQUFGQTZaQUxOc2IyTmhBQUFFWUFBQUFBd0FBQUFNQWV3Q3ZtMWhlSEFBQUFSc0FBQUFGd0FBQUNBQUJ3QmhibUZ0WlFBQUJJUUFBQURVQUFBQlBwa1JkY2R3YjNOMEFBQUZXQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lczA0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBRTVo0aGladmdQNURORHBKSFUvQWNLQXdELzVnMk1lTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aFIvLzhEeWZELy8vK3ZBdk1aQUZTWUJyWjQybFdTVFdzVFVSU0c1ejEzNXQ1a01uTW5hZWJEbUdUUzlHUEdnaWEyYVNkdG9jMUNSUkdrQ080VUZFV3R0b2hVUkZ4WWExMzZNMFJkdUxDNGtDS0tDLzBIYmx5NDBZVzZFaFFVWENSMVpsS3Q3dWE4NTk3aFBNODlDcFNaclUvcU9MMVFqaWhLRmhJaEF3OTVtMDBHdzN3eXFxSHR1WjdOUXdtdmlEQUp3M244bjBaVERmeUpYY2Ztd3hMc2NXK0REeUhvdmRWbGtScUYwWkpVbDFZekhESXp2WXRDTU83VVBZTFVsbTVsTlVoenltVUJIQk43YklQQjVKY1hERU0wSitoUWR6TXZmTks2UHoyZ1FpdE9nVlU1R0FObHBBQ1Y5TzR2dkY2UUJwTnh5UmlSU0dJLzMxUHhzV2k1QXlSbGNweXlrcXZqaWdLbHNyWEZMc2FzcCtPaUhiVWJ0RDExRGVuWWdsdUl2MzIwUE5lUmFFS0VRVGdadGVZeDFZUVZ5eEZweTB0YlFSTnBxME5zaDkvemtmekl3YmVIZVVhMUltQnFLMmV5UkliZTZEaWw5bnBoWkVHdmpodUNETDV5SjJZM01yNnZMWjVhek9WQnRZeFFBVU83MXI4UUhnM01kemUxeWw2SGtyQi9lckNDQjArbFp4dlFVMmFvWEhMbTIrN2N2Y2FKNTc0RjB2dk15SnBDSFJEV2ovTlhjcDVwNXloMWxsNndPQTJHeGhmNCtjSzJPWkFqVkVkVEVrY2pzU01qZG5Rd0xwaU1zYm5EYTRoMmRIaHUxS0h3WCtoa0Z3SXV5ckhUQnNKZ0trMG4ra3JwWEk5cmJKOUdmbENGd2U4bUdGTE8xa1RkVkZlMTNRbWMyWWN6bmYzc3hsY3JoM0tCeDB0dzRZUnBaRnB6TGgzdXZlZUdmR2FMR0k1VisrTm1MQUhZWStzekJSd3Y1djlTeElpVUxmUmVvV0JiVlQycEV4Y2xybzJWVXJiWnJSNTlwcGZLYUxMcnJZbW9nNmpsT2lMZStqcnZBTU5EWFBEMFlUdVloMWVQQkgzb3ZubHkrMm8xbzNMem1Lb1A5QTZVb2RMY28rdkxaUmhaTUhVNkRyRlJZWFMvdTdaOHlkWW8rejNad1Z5UjFzNmVGSWx0VGQ5TUUrVTNsTmwxN2dBQWVOcGpZR1JnWUFEaUNRdjRFdVA1YmI0eU1MTXdnTURqL1Y5bkkrai96MWdNbWZZQ3VSd01UQ0JSQUZEWkRJOEFlTnBqWUdSZ1lHYjR6d0FranpQSS9IZGpNV1FBaXFBQVZnQlVld05xQUFBQ2RnQUFBOGNBT1FOUUFCd0NVZ0FrQXJvQU9nQUFBQUFBZGdFSUFYWUJ0bmphWTJCa1lHQmdaVWhnQU5FTVVCSUpBQUFLVGdCcEFIamFUWTZ4YXNNd0ZFV1BxV09vVzhpVURCMktwb3pHZHZvQmhReVpzbVlzSkpFSUxrZ0tzbVBJRXZvQi9lZytLeHI2aEI1SDUxMEpBU1YzTXFiS21NYytWVTRocHdmUGVHR1J1SkNsRXBlOHNlS0pMSDhXODg1bjRweFh2aExQV1BLZHVCRC9rN2prZzkrTnQ1ZnJZSUxhZVcyQ08xbmJOZlhlaEw3elRqVlYvUkJiNDB3NERFYXI0MDNwc2V2SHMxWHJxcTFhTm5nc0Y2NE1HSUw4YkNkR1IzYWNaR2JwYUtqWlI5Zkx5Y3RFaWF2RS9rOXNKZUZpNmhCZjA1STZjcE91R1NYVFN6OUxXckdXdSsyMC93RGdnakM5ZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5Om1zYW03O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFMd0FBb0FBQUFBQTB3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhREZsaFdOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9ETVoyeDVaZ0FBQVd3QUFBQkVBQUFBUk1iSTRFUm9aV0ZrQUFBQnNBQUFBQzhBQUFBMktpZ3R2MmhvWldFQUFBSGdBQUFBSUFBQUFDUUd3Z0d2YUcxMGVBQUFBZ0FBQUFBSUFBQUFDQVhvQUZGc2IyTmhBQUFDQ0FBQUFBWUFBQUFHQUNJQUFHMWhlSEFBQUFJUUFBQUFGd0FBQUNBQUJBQVNibUZ0WlFBQUFpZ0FBQUMxQUFBQkdrK3hFckp3YjNOMEFBQUM0QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm0rc0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFBQkpIWktjVms2QTl1RHlnZVZMQmwvVHpNd3NHUXdtUUtGR1JFcS92OW5ZQUFBYjF3UmRnQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROHEvLytIa1BJZFlIa0dBR3B2QjdVQUFBQUJBRkgvNmdJSEFhSUFFQUFBQVJFV0JpY2hCaVkwTmhjaEVTWTJNaFlDQmdFUEd2NmFEeGdaRGdGY0FRZ2tDQUY4L3BZWEVRSUNDU1FJQVFGWkRoMGFBQUFBZU5wallHUmdZQUJpSzhQanh2SDhObDhabUZrWVFPRHgvcSt6RWZUL1Y4d1RHUmNCdVJ3TVRDQlJBRW5OREp3QWVOcGpZR1JnWU1uNGU1cUJnWGtpUXlCREFCTTdBMUFFQlRBQkFGOFNBM2NEa1FBQUFsY0FVUUFBQUFBQUlnQUFlTnBqWUdSZ1lHQmlFR1FBMFF4UUVna0FBQUpHQUJjQWVOcE5pOEVLZ2tBUWhqOUpoZXhjaDA3N0JKSVdkT3NtOWdRZWd4VVhFOVRBTGFGTHo5NnM3YUZaOXAvdm4va0hTUGdRNENvZ1d0UlZLQng1anRoSTZzZXh1SzNuaEwyOEZVRzRsa25DeVhNb2ZQRWNzZVBxT1piNXpiTkwzNHRYYjZiQjZ1RmNtY2wyajFGbDZXSHhwUm5OcEorbVVmVmJOWE5uNTNaUXh6UlBjd3BlOUJnbUJpeGE5RXkxZUV2SGd4RkZSc3JoYjEvS2Zsd3ltcWYwUmpJMWI5R0dXYTZzYUN0SnhWRXVjL2UvNlIwbm93QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVE1BQW9BQUFBQUJaUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGNEhtTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SEsvMXJaMng1WmdBQUFYQUFBQUg4QUFBQ1hIKy9PNTlvWldGa0FBQURiQUFBQUM4QUFBQTJLVjB1TVdob1pXRUFBQU9jQUFBQUlBQUFBQ1FGd2dHYmFHMTBlQUFBQTd3QUFBQVFBQUFBRUFubUFLVnNiMk5oQUFBRHpBQUFBQW9BQUFBS0FaUUExRzFoZUhBQUFBUFlBQUFBR0FBQUFDQUFCd0JGYm1GdFpRQUFBL0FBQUFEUEFBQUJPUE5oS3FOd2IzTjBBQUFFd0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NUjlnWnZnUDVETXpNSUtFR1JFcS9nT0ZBZjIxRGhJQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlxWXpIL2ovSDhoUEE5SC9aLzl4QnFzQ0FnQ2paZ21VQUFCNDJrV1JQMi9UUUJqRy9keTVkcDAvUHR1eHp5UWtqaDA3ZGlyYXVOU05MYlZWM0RUdFVJb29URkVRZ29tRkNRa0d4SUFRSDRBQkdCamhZOERjTDhCM29RTkx3cmtNM0UzMy90N2grVDBuUWJwWXArUUYrU1VkU3hJb2c2THFVQWR4TWtYR1hhNm92SThwU2hvcWNlNW1VeFJpdnNkZEhXR2N4SGtScDlBSlE1WnpKY0gzQTBNMk90cnM3dWdBaUp5WWd2VVpZMUZBZTJOMjN5TXQ5b2c1T2o4SnQ0NkFrQXR1ZUl4WmxsZmI3RHlyTUw2c3J1Nlp4L3Yybk1haDU1TklTZW9hZ1h6aGZMMWUwSUdLeGZKMkVnK2ovd2p0ZU9lalBOaUVKQTZSdHRjN1pJZ3JhU3pOS3h0aG90eVlpTVMyb3JvODQ3a1FLSVhrR0VsZVZOZURLNnpFQWkyUkowSktVYXNLdUx0WHJaTGdwZmJxVGZwVUZubE5EdDNxbW9GOUZIYTU2aGJuc3lXaE0yYWVMMGVUSnUxWVRRZWZVZ3JiMmUvTWZjY3dFU2ZlU2JlaDR1MXFsajZteE5udUJhMVczYXR0RU5TNzdWMy9TU1pqOGZENWd4WTdwWWk0d1dHWXF6OC9XSDBZeWhoTjR0bnhaWUdoejVyQ0RkSjRmVTArNDZlVWk0ZGE5VDhweGM4VVlSVTRSYVVwOHJwQnpsMUJrMUJoRUdwYy9kZkJEY2EwTkQwdm92YXQwMDVwWFc1dDZEVUY1QTRQSmg0K3NDNm83TGJmMXdpQlkyaEFUd2cxNnFMaEJsNy9QanVUZXl6Wi9iWWdidFlBZ2FZZDJyNERhQTdUTEZMMDAzTFphOVRzTnRBYStvZmx1MVJFL2d2cEUwL2RlTnBqWUdSZ1lBQmkvVzI1anZIOE5sOFptRmtZUU9EeC9xK3pFZlIvWGFaalRCZUJYQTRHSnBBb0FFdTNESEVBZU5wallHUmdZR2I0ejhEQXdIU01RZWYvQmFiSkRFQVJGTUFDQUdnbkJHRUN4Z0FBQWpvQVN3STZBQ3dDckFBdUFBQUFBQUJtQU5RQkxnQUFlTnBqWUdSZ1lHQmhjR0ZnWWdBQlJnWTBBQUFIamdCTmVOcE5qRDF2d2pBUWhwK0lCSWt3c0tBT0hZcUh6aEVFSkxZdURFeXNUQ3lBWFpUQk5uSkNKS1NxWTM5M0w2NkhudVRUODM2Y2daSnZNb2JKbU1VOVRFNGg2bzhMcHN3VGowVXRFcGU4OHM2SUxKK0k4OFpINGx5U1UrS0NGejRUajhYL1NseXk0V2ZuN2YzUm1hQU9YcHZncnRZMjI2TUpiZU9kV2xYTHFQZkdtWER1akZhWHA5SjkwL1kzcTlaVlhkWHM4Rmp1UE9nd0JCUUhjWFJreDFVeVM4T1dZM1JhWVMrK1lrWEY4bCsrbDl6RnpqbitwS1Z6NFNsYjAwdWpsWDJUcm1JdGwvWHdmZ0hNS3kvNUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5Om1zYW03O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTM4LjcyMDczNCwtNDguNDA5MzAxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMC4wNDE2MywtMTkuNDkzMDYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zOC43MjA3MzQsLTQ4LjQwOTMwMSlzY2FsZSgtMSwtMSknPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTI5LjAzNDg0MiwtODAuNDQxOTk1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS40MTY2NywwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yOS4wMzQ4NDIsLTgwLjQ0MTk5NSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMjkuMDM0ODQyJyB5PSctODAuNDQxOTk1Jz5XPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEyLjg0OTcwMiwtODAuNDQxOTk1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNC4wMTM4OSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDEyLjg0OTcwMiwtODAuNDQxOTk1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9JzEyLjg0OTcwMicgeT0nLTgwLjQ0MTk5NSc+WTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjkuMDM0ODQyLC00OC40MDkzMDEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00LjUzNDcxLDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTI5LjAzNDg0MiwtNDguNDA5MzAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0yOS4wMzQ4NDInIHk9Jy00OC40MDkzMDEnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTIuODQ5NzAyLC00OC40MDkzMDEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc3MDgzLDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTIuODQ5NzAyLC00OC40MDkzMDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTIuODQ5NzAyJyB5PSctNDguNDA5MzAxJz5aPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00tMTEuMjc5MTYtMTYuOTkzMDZIMTMuMDQ1ODcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTMuMjQ1ODUsLTE2Ljk5MzA2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xLjI1ODcxLC0yNC4yMDY5MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTM4LjcyMDczNCwtNDguNDA5MzAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zOC43MjA3MzQnIHk9Jy00OC40MDkzMDEnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNMjEuNzIyMiA4LjgwMDAzVi04LjQwMDA1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMjEuNzIyMiwtOC42MDAwNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4wNzQ5NSwtMC44MjYzOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTM4LjcyMDczNCwtNDguNDA5MzAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zOC43MjA3MzQnIHk9Jy00OC40MDkzMDEnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTEwLjM5NzIgMTUuMTU5NzZIMTIuODAyODEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTMuMDAyNzksMTUuMTU5NzYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIuODg2NzgsMTguNTEyNTEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zOC43MjA3MzQsLTQ4LjQwOTMwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMzguNzIwNzM0JyB5PSctNDguNDA5MzAxJz7PgDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzQuMDYxODg5JyB5PSctNDcuNDEzMDM3Jz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS0yMC4zMTk0MSA4LjgwMDAzVi04LjQwMDA1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsLTIwLjMxOTQxLC04LjYwMDA0KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMS4yNTEzLC0xLjAwNjkzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMzguNzIwNzM0LC00OC40MDkzMDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTM4LjcyMDczNCcgeT0nLTQ4LjQwOTMwMSc+z4A8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTM0LjA2MTg4OScgeT0nLTQ3LjQxMzAzNyc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMC44NzM3LDQuODU5NzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zOC43MjA3MzQsLTQ4LjQwOTMwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzguNzIwNzM0JyB5PSctNDguNDA5MzAxJz7ugbk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg=="></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            W &amp; Y \\
            X &amp; Z
            \arrow [&quot;f&quot;&apos;, from=2-1, to=2-2]
            \arrow [&quot;g&quot;, from=1-2, to=2-2]
            \arrow [&quot;{\pi _2}&quot;, from=1-1, to=1-2]
            \arrow [&quot;{\pi _1}&quot;&apos;, from=1-1, to=2-1]
            \arrow [&quot;\lrcorner &quot;{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure>
 

    The <fr:strong>pullback</fr:strong> is defined to be any set <fr:tex display="inline">W \cong  X\times _Z Y</fr:tex>
    The corner symbol indicates <fr:tex display="inline">W</fr:tex> is a <fr:em>pullback</fr:em></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>The pullback also satisfies the universal property.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>564</fr:anchor>
                    <fr:addr type="user">thm-000L</fr:addr>
                    <fr:route>thm-000L.xml</fr:route>
                    <fr:title text="Universal Property for Pullback">Universal Property for Pullback</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Suppose the given diagram:
    
 
  
  <fr:figure><fr:resource hash="8ff9a605435ec667aaf6cdcc4b549baa"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9Jzg4LjUxODI5MXB0JyBoZWlnaHQ9JzczLjE2MTAxMXB0JyB2aWV3Qm94PSctNzIgLTcyIDU5LjAxMjE5NCA0OC43NzQwMDcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQktRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWTkwd0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFESVoyeDVaZ0FBQVdRQUFBRlpBQUFCZkxycms5cG9aV0ZrQUFBQ3dBQUFBQzhBQUFBMktWMHVwMmhvWldFQUFBTHdBQUFBSHdBQUFDUUZzQUg2YUcxMGVBQUFBeEFBQUFBTUFBQUFEQWN5QUZ0c2IyTmhBQUFESEFBQUFBZ0FBQUFJQUVnQXZtMWhlSEFBQUFNa0FBQUFGd0FBQUNBQUJRQk9ibUZ0WlFBQUF6d0FBQURQQUFBQk9QTmhLcU53YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1TbU9jd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBxV01KUXlNL3dIOHBraDBraHEvZ09GQWRZbkRUOEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWwvLzhEeVpMLy8vLzNndmtNQUZiWEJ0RjQyaFhQVFU3Q1VCQUg4RGREKzFvS3RKUzI3MWtSQ3ExUVByUnRLRkR3bzVBWXhSZ1RMK0NHamRFanVETXhMdHg3QnZiZXdTdTQ4aHJHbFJIYnpHeitNNW5rTndUSWNQc0RML2hFRGdneENoSkxVc2c2NWsyUWFGWnUxeDhuaGtlN1V4NHZZSm93THNValpwblUvNzJpNkE0dm1TZ1hpeFNhR2grZUhTNUJYSzBiV05QdUhWbnB0ckcvVnZXYUJtOS9YNE1KNHNXb0lpR3lhSWNGUWh5VU9OUUxyZ1NQN2dEUjJRaEtWUVpDZ0VUYmIzeUdEM0pOU0NlVGpMaXBvUXFXeVhnS21jQUJ4czFjUnJ1K21objlBS2ZKTkJsTGJqYnkvSnliNXhIalZNcjMrVm1XNFgxQ3pibEFQVWFMcXRIeVpGa29LUlNNMnQ2a3ZETHQwL0FvcXBlaDF0UEJkazRNMEVzVWVGbjMwdDRNb01KZFFCYUhxWWJpNXRQZWR5VCtlbXNGcXRVQVBQZnJGQkFWY2RrZVo3K0ZkaC9RcytldG16dlA3Y0FpclNJVzFZaGJnUmoxZUhQMkVPb0xFWTkzQ3lZaC8xNFFNZkFBQUFCNDJtTmdaR0JnQU9JTEt3OWJ4L1BiZkdWZ1ptRUFnY2Y3djg1RzBQKy9NQjFqYWdCeU9SaVlRS0lBZkZBTnl3QjQybU5nWkdCZ1p2alB3TURBZEl4Qm04R0FxWmtCS0lJQ21BRkQxUUt3QUFMR0FBQUJ1UUFyQXJNQU1BQUFBQUFBU0FDK2VOcGpZR1JnWUdCbThHVUEwUXhRRWdrQUFBZzlBRlFBZU5wTmpEMXZ3akFRaHArSUJJa3dzS0FPSFlxSHpoRUVKTFl1REV5c1RDeUFYWlRCTm5KQ0pLU3FZMzkzTDY2SG51VFQ4MzZjZ1pKdk1vYkptTVU5VEU0aDZvOExwc3dUajBVdEVwZTg4czZJTEorSTg4Wkg0bHlTVStLQ0Z6NFRqOFgvU2x5eTRXZm43ZjNSbWFBT1hwdmdydFkyMjZNSmJlT2RXbFhMcVBmR21YRHVqRmFYcDlKOTAvWTNxOVpWWGRYczhGanVQT2d3QkJRSGNYUmt4MVV5UzhPV1kzUmFZUysrWWtYRjhsKytsOXpGempuK3BLVno0U2xiMDB1amxYMlRybUl0bC9Yd2ZnSE1LeS81QUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVRFQUFvQUFBQUFCYmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hYTjA4Mk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUN0WjJ4NVpnQUFBV1FBQUFINkFBQUNnT3BGVWxab1pXRmtBQUFEWUFBQUFDOEFBQUEyS2Y0dTdtaG9aV0VBQUFPUUFBQUFIZ0FBQUNRR2hnR2JhRzEwZUFBQUE3QUFBQUFRQUFBQUVBclNBSHBzYjJOaEFBQUR3QUFBQUFvQUFBQUtBZElCQUcxaGVIQUFBQVBNQUFBQUZ3QUFBQ0FBQmdCaGJtRnRaUUFBQStRQUFBRFVBQUFCUHBrUmRjZHdiM04wQUFBRXVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbTJzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFNNWUloaVp2Z1A1RE5EcEpIVS9BY0tBd0RzQ2cxV2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoUi8vOER5WWovLy8rdkJQTVpBRlNjQnJaNDJrMlJUWXZUVUJTRzg1NmIzSnVrK1dpbSthQzJUYVoyVEJqUVZxZE9xZ050RmdxQ0lDTE1Ua0ZSMUJFR2tSRVJOenFPUzMrR3FFdkZoWWdvYnZ3Ukx0eTQwcFdnNEhJNjNpVDRzYnZuUGVkZXp2TmNCVXAzYjQ5ZHAzZktSVVhCSko4TUtac2h3U1JNNFBPQkE4RmR5SE9NY1JRR0RrWVFXWm9kemNjenJJN2dRZzVVcmFocXBTTlVyWUxZRUFOZXZ4VEZLQjhLOE9OWmsxSFNBbXh0NjVKQlpKbkRJbWhQZHJ5bHMyYnZpQ1hJNGxzUERRMldIc2ZheG9XTlJoT1U2RUlGTE8xMmZTRTduZHFmN21uZGd3R1ZZVDI5Mk1YVFYwN2tXekFkQWNhZ2NvZXoyQStuajRmcmIyTVhaRHBjNWdUREZ1cUNjSDlkdmRtSWJMOUJwUCs1NEhKYXpLeHZpSnNlYytxUUFxRUdtaUsxS0V2U2tTVWRuWlFGY3lRMkQzaUMvSitPS013THl2NkhEaU9mcDF4MHBOTWhzblMxU2xkcXBYUmx6alYyU0tNNDdjSGlqMG9NeDFsTFJOOVc3MnY3U2ppN2hyT0R3K3p1ZDdlQmpzZGg4MnZydHFXUHB5R2Rtbi9tbHZQYUZ4S085ZXAxZFZjQS92TE9jUS9uV3MyL0ZCS1JERy8rQVo3djlzeXlMbDIwdWJiY3J0alc5dWIwbGQ0ckJ4VEZ3SGdsTDVDUHcwQTR5UHE4QUFiN3VlRFZ4eGFZSWVybmdyN3Nmbnp4NEZaUFY3bDlSalVYNWljNlVHbjYvTTVtQjVZQnBoNlRJVjUyR1QzWjNkNjg0V3RrL0pTN1VLTkYyNWZQaTlLMlpyNnBFdVUzZUI5Vm1RQUFlTnBqWUdSZ1lBQml5YzVsaCtQNWJiNHlNTE13Z01Eai9WOW5JK2ovLzVqVG1mWUN1UndNVENCUkFHWWFEVWdBZU5wallHUmdZR2I0endBa0F4aGsvcnN4cHpNQVJWQUFDd0JNeVFNbkFBQUNkZ0FBQTFBQUhBSlNBQ1FDdWdBNkFBQUFBQUNTQVFBQlFBQUFlTnBqWUdSZ1lHQmhTR0FBMFF4UUVna0FBQW96QUdnQWVOcE5qckZxd3pBVVJZK3BZNmhieUpRTUhZcW1qTVoyK2dHRkRKbXlaaXdra1FndVNBcXlZOGdTK2dIOTZENHJHdnFFSGtmblhRa0JKWGN5cHNxWXh6NVZUaUduQjg5NFlaRzRrS1VTbDd5eDRva3NmeGJ6em1maW5GZStFczlZOHAyNEVQK1R1T1NEMzQyM2wrdGdndHA1YllJN1dkczE5ZDZFdnZOT05WWDlFRnZqVERnTVJxdmpUZW14NjhlelZldXFyVm8yZUN3WHJnd1lndnhzSjBaSGRweGtadWxvcU5sSDE4dkp5MFNKcThUK1Qyd2w0V0xxRUYvVGtqcHlrNjRaSmROTFAwdGFzWmE3N2JUL0FPQ0NNTDE0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00Mi45NDkyNzcsLTQ4LjkzMzcxNylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjkuMTU5NjcsLTE5LjQ5MzA2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDIuOTQ5Mjc3LC00OC45MzM3MTcpc2NhbGUoLTEsLTEpJz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zNC4xNDIwNDgsLTgwLjk2NjQxMSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2Ljg2MzgzMywtODAuOTY2NDExKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNC4wMTM4OSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDYuODYzODMzLC04MC45NjY0MTEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nNi44NjM4MzMnIHk9Jy04MC45NjY0MTEnPlk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTM0LjE0MjA0OCwtNDguOTMzNzE3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNC41MzQ3MSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zNC4xNDIwNDgsLTQ4LjkzMzcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzQuMTQyMDQ4JyB5PSctNDguOTMzNzE3Jz5YPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYuODYzODMzLC00OC45MzM3MTcpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc3MDgzLDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNi44NjM4MzMsLTQ4LjkzMzcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSc2Ljg2MzgzMycgeT0nLTQ4LjkzMzcxNyc+WjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTExLjI3OTE2LTE2Ljk5MzA2SDEyLjE2MzkxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEyLjM2Mzg5LC0xNi45OTMwNiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMC44NjgwNywtMjMuNjUxMzUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Mi45NDkyNzcsLTQ4LjkzMzcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDIuOTQ5Mjc3JyB5PSctNDguOTMzNzE3Jz50PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTTIwLjg0MDI0IDguODAwMDNWLTguNDAwMDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwyMC44NDAyNCwtOC42MDAwNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMy4xOTMsLTEuNTA2OTMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Mi45NDkyNzcsLTQ4LjkzMzcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDIuOTQ5Mjc3JyB5PSctNDguOTMzNzE3Jz51PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4="></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            &amp; Y \\
            X &amp; Z
            \arrow [&quot;t&quot;&apos;, from=2-1, to=2-2]
            \arrow [&quot;u&quot;, from=1-2, to=2-2]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure>
 

    For any set <fr:tex display="inline">A</fr:tex> and commutative solid arrow diagram as below
    (functions <fr:tex display="inline">f:A\to  X</fr:tex> and <fr:tex display="inline">g:A\to  Y</fr:tex> such that <fr:tex display="inline">t\circ  f = u\circ  g</fr:tex>):
    
 
  
  <fr:figure><fr:resource hash="d17ac9129059285e63101f6ea3eb3012"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5NC4zMDQyOTlwdCcgaGVpZ2h0PScxOTQuNDM3NzE5cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTI5LjUzNjE5OSAxMjkuNjI1MTQ2Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPd0FBb0FBQUFBQkJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVXgxQW1OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDRloyeDVaZ0FBQVdRQUFBRDBBQUFBOU51KytaSm9aV0ZrQUFBQ1dBQUFBQzBBQUFBMktlZ3UzbWhvWldFQUFBS0lBQUFBSGdBQUFDUUZ1Z0t5YUcxMGVBQUFBcWdBQUFBS0FBQUFDZ1puQUpKc2IyTmhBQUFDdEFBQUFBZ0FBQUFJQURJQWVtMWhlSEFBQUFLOEFBQUFGd0FBQUNBQUJRQXRibUZ0WlFBQUF0UUFBQURKQUFBQk11c0lrZWh3YjNOMEFBQURvQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1lczA0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBRMFpEQmladmdQNURORHBKSFUvQWNLQXdEMnhBMCtlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aEcvLzhEU2NQLy8vOWZBUE1aQUZGWUJvNEFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FBQUVBWFFBQUFsc0NxZ0FyQUFBbEJ5RTFORDhDUGdFM0xnRW5JZ1lISGdFWERnRWpCaVluUGdFM01oWVhEZ0VIQmc4QkpUWTNQZ0UzQWxzaS9pUURDZm85VFFFQ2FFMDBVaFlZSVFFQkpoVU9MQUlDaEdwd213TUNhRWd2TldrQkFpb0tEUThDeHNZZkJRSUoxREZxUDB4VEFTb2pBaDhiSUIwQkdTZE5aUUpwWTFCcExpQW5UZ0VCQkF0QkVnQUFlTnBqWUdSZ1lBRGlCWmQwdU9QNWJiNHlNTE13Z01Eai9WOW5JOVBNUVV5cmdSUUhBeE9JQndBMnFBckNBQUFBZU5wallHUmdZR2I0endBa2d4aGlHV0tab2htQUlpaUFDUUE5MFFKekFBQURVZ0FBQXJnQWtnQmRBQUFBQUFBQUFESUFlbmphWTJCa1lHQmdadEJoQU5FTVVCSUpBQUFGQkFBekFIamFQWXd4QzhJd0VJVy9ZaFd0ZzRQZzRDREJIMUMwNnVibTRPVHE0R1pOa0E1TkphMUZGL0duZXczQkN6bStlKy9kQVFrZklycUttUGplVlN4dkVyalBtR25nZ2VpTHdBbHpsdlNJNHBFb0MvYUJZNFpjQXZlWmtRY2VpUDRLbkxEbGU2akt4N014VHAwcWJaeTlsVzUzTnE0dUtxdlc2YW9iajhZYWQyMk1WdmxiNmJhbzIzdXBObW1XWmh5b0tIbndwTUhnVUp4RTBaNHROL0VjTzg1K3JpbkVzNUpaazdMNnUwZHhyVTljL1JVdGlaeTNkRTByTzdYMHUyUVZHOW5MdXY4RFZiZ3VSUUFBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFORUFBb0FBQUFBQTZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdpT1J6RzJOdFlYQUFBQUZBQUFBQUtRQUFBRFFBREFFcVoyeDVaZ0FBQVd3QUFBQjRBQUFBZUpNU1BKRm9aV0ZrQUFBQjVBQUFBQzBBQUFBMktiSXVLMmhvWldFQUFBSVVBQUFBSGdBQUFDUUdOZi9kYUcxMGVBQUFBalFBQUFBR0FBQUFCZ093QUFCc2IyTmhBQUFDUEFBQUFBWUFBQUFHQUR3QUFHMWhlSEFBQUFKRUFBQUFGd0FBQUNBQUJBQWtibUZ0WlFBQUFsd0FBQURWQUFBQlBxODNkZU53YjNOMEFBQUROQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1sbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFVEF4SklLUzVMQjBwZVo3ak9MUFZIazRHQldZcjVPbENZRWFIaS8zOEdCZ0RyblE3dkFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hDQytOZi8vNGVRLzdYQWZBWUFYdVVITXdBQUFBQUJBSlFBQ1FLR0FmZ0FJZ0FBQVRjMkZ4WVhCZzhDSHdFV0J3WUhKaThCQnc0Qkl5WW5KajhCSnlZM05qY3lGd0dPeXc0S0V3RUNBeHE3cFRJRUFRRVRDd1hVeXdrSUJoRURBeEROelJBREF4RUdCQUVkeWhFQkFoTUtBeHE3cFRJSUF4TUNBZ1RVeXdvRkFoTUhEYzdPRFFjVEFnSUFBSGphWTJCa1lHQUE0dVc1YnpmSDg5dDhaV0JtWVFDQngvdS96a2FtbVdVWWZ3QXBEZ1ltRUE4QVpCSUw0d0FBQUhqYVkyQmtZR0NXK3FNSkpHVVlwakJNWTJwakFJcWdBRVlBVE1vREZ3QUFBeHdBQUFDVUFBQUFBQUFBQUR3QUFIamFZMkJrWUdCZ1lsQm1BTkVNVUJJSkFBQUVDQUFwQUhqYVRZNnhhc013RkVXUHFXT29HK2lVREIyS3BvekdkdklCaFF5WnNtWXNKSkVJTGxnT2ttUHdVdm9CK2VnOEt4cjZoQjVIOTk3M0VKRHpTOEpVQ2UraFQ1V1N5ZXZKTTk1WVJNN2txTWc1SDZ4NElVbGZSZm5rSzNMS25PL0lNNWI4Uk01RS80dWNzK0crN2RycnJUZE83VHR0bkQyM2ZxektnM0crNmF5cWl2SXA3SXcxN3RnYnJVNmowa1BqaDB1cjFrVmQxR3pwYUxseW84Zmc1R2Q3VVhSZ3kxazh6MGhGeVNGb25rWjhLN21LUXRUL2laMGtiRWdkd3pZdHFaTjRTbWlRT1MvOUlubkZXbWJyNlQ0QUNkOHhGUUFBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFWTUFBb0FBQUFBQm13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxQW1OdFlYQUFBQUU0QUFBQU5RQUFBRHdBZ3dDSFoyeDVaZ0FBQVhBQUFBSnlBQUFES0tveFlEdG9aV0ZrQUFBRDVBQUFBQzhBQUFBMktmNHZEbWhvWldFQUFBUVVBQUFBSGdBQUFDUUdoZ0djYUcxMGVBQUFCRFFBQUFBVUFBQUFGQTNTQUo1c2IyTmhBQUFFU0FBQUFBd0FBQUFNQWFnQ2VtMWhlSEFBQUFSVUFBQUFHQUFBQUNBQUNBQmhibUZ0WlFBQUJHd0FBQURVQUFBQlBwa1JkY2R3YjNOMEFBQUZRQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1Pc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpJaGladmdQNURORHBKSFUvQWNLQXdEdXRBMU9lTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPakpFL2Y4UDVEc3lSUHovLy8vQS8xVmdWVUFBQUpMVkNRUUFBQUI0MmxXU3pXc1RRUmpHOTMxbloyWjNNN09iTlB0QlRiSnBUTTFTc0lrbTdhNFdtaHhVQkVGRktTSW9LRW8vaENKU3YvQ2lzWHJ6TC9BczZsSHhvQ0tLRncvK0NSNzAwSk9DSUNoNGJPTHNwbjdOYWQ1blpsNmUzL09PaHRya2NJZ2IrRWxyYVcxTlN5Qk8ybjVRZFAxTzdMTVc4S2dSemNTQkh5Y3RxSEhtK2tFYzJLRDBWTzUwSWVtUUY3RElYTW1nNjA5N0lPaVZ2a0ZCNW9venhPU0Q0UkZaTGtvQ2tpNmZGQ0RNN2QzN1gydlg4RVFlVEdlejd6dWt3b0VRUU1QaEFDSllPbkRYbmN3RE9qWkxaY3RoVUg4UHh6VzFRQ3NQaDJRWlgydG5WSkhFU1JPakxsUWg4YXZnc3JvTm5EbWc5aUYwQXQvTExFWmJIbWRiNElDNmtCMXR1VzlCZHRSRDBvUTZHM1VLUWtnYmVmRDlVWjVndFFqSzl0cFpFMUZZelo0M25xd1hKbzlhbGQyQ28yQnJ0MDBLd2doRHVuSjZKYWNzVncydUt3UjZlZlFnT3RTUUgyN1E4azRQVTNGMGU2SU1ENS9aZ1N2QXNqTnVuZG1NaEs0L2Y2KzU4Q3AwQUswTUhNR1VYQi9qenMvRmk3bEF1amxFNC9jRGgrRkVKTDVBbUM4UWV5U2l4M1dQWmhtcFdSS2hNdHF2Q21JcmJPYXhLc1IvNDFDVDdHSDBMN1FmdUt6QmVFbGwyb1NvTVp1cDdWR2tlSDdBS0ptbUdEWXFJTmlkRk1PMjU2cThKdldiZEZzS0owZHcwdHRGcm45emNsQXFNSkJzYVVFS296UHY0OEhCUnliczV5NVhjUDhOMjUxYTMxdUFZOFg4SHdxRmlHWmg4QllLcmxPeDBqck5ZcHpScWZHTWJXNDR3TS80UnR1aGFTWjAybkVQNG83dmNSdWlHdXNCMUxjenpyTEI5cUFMUVMzbXVMSDU3c210U3hWRFovS3dibzBOOXBWQXgvbkhWMWRMNmlzQzBmY29FWjZXQ1Q3WTdLOWVjQ21hUDVRWHpCV3hmKzRVVDlPbTFzdE0wWDRCZUlSdkpBQUFlTnBqWUdSZ1lBRGl5WTVOM1BIOE5sOFptRmtZUU9EeC9xK3pFZlQvZjh6cFRIZUJYQTRHSnBBb0FFdW1ETDRBZU5wallHUmdZR2I0endBa0F4aGsvcnN4cHpNQVJWQUFLd0JNeWdNb0FBQUNkZ0FBQXdBQUpBTlFBQndDVWdBa0Fyb0FPZ0FBQUFBQVZBRG1BVlFCbEhqYVkyQmtZR0JnWlVoZ1lHSUFBVVlHTkFBQUNtVUFhbmphVFk2eGFzTXdGRVdQcVdPb1c4aVVEQjJLcG96R2R2b0JoUXlac21Zc0pKRUlMa2dLc21QSUV2b0IvZWcrS3hyNmhCNUg1MTBKQVNWM01xYkttTWMrVlU0aHB3ZlBlR0dSdUpDbEVwZThzZUtKTEg4Vzg4NW40cHhYdmhMUFdQS2R1QkQvazdqa2c5K050NWZyWUlMYWVXMkNPMW5iTmZYZWhMN3pUalZWL1JCYjQwdzRERWFyNDAzcHNldkhzMVhycXExYU5uZ3NGNjRNR0lMOGJDZEdSM2FjWkdicGFLalpSOWZMeWN0RWlhdkUvazlzSmVGaTZoQmYwNUk2Y3BPdUdTWFRTejlMV3JHV3UrMjAvd0RnZ2pDOWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWjRBQW9BQUFBQUI3Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGZWNEltTnRZWEFBQUFFOEFBQUFRQUFBQUV3SG1mM3ZaMng1WmdBQUFYd0FBQU9NQUFBRVlIYlFLZmRvWldGa0FBQUZDQUFBQUM4QUFBQTJLY2d1TVdob1pXRUFBQVU0QUFBQUhnQUFBQ1FHWHdIMWFHMTBlQUFBQlZnQUFBQWNBQUFBSEJGdkFWSnNiMk5oQUFBRmRBQUFBQkFBQUFBUUF6SUVPbTFoZUhBQUFBV0VBQUFBR0FBQUFDQUFDZ0JPYm1GdFpRQUFCWndBQUFEUEFBQUJPUE5oS3FOd2IzTjBBQUFHYkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcEdNUjlnWnZnUDVETXpNSUtFR1JFcS9nT0ZBZjIxRGdvQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ3NnRFFYQXdkUWpva2hpaUdkb1pUNXdQLy9RTEVvaGpTR0VoRDcvL0wvYy81UCtPTUcxZ0VGQUd3eURvTjQya1ZUVFc4YlJSamU5NTMxckhkdDcrem5UT3pZNjQrMWQ1MG04YnB4N0cwKzhEcE5RMmxhTllDRW9xQUtWQ1FRaEFzU1BRQUhxSW80Y09GQUVlSUlsMTQ0Y1NzY3VOQS93S0VuSkc3OGd4WUppY1RNT2dkMlR1ODhzOUx6OVNxZ3ZEby9JNWZ4VnlWV0ZCMUdHNU4wQ3FNQUdKb1F0K2w0a2tJWVVZMXFVWVpURU8ySlJrbm43TWZmSHR4ckZZcDZwUURxb1dwNDUzYWRtUGphNDdjKzY0TGpnTHBWTUZ6NHN3R0FEOCsrUFQyMVNsQkc2eTlUQTJJdUdYaUt0OTluUUVyMjQ4V05vOGdQbEp2elJDSy9Lek01RUFaVU0wSHJSTEZrd3dXbkdtL0NGRElTMG1naVJsUElXVzV3WVVwMmNUUkpvd1JNWkRDYWNCckREOXVXYXRYMHZjdjliWUN1SHhGZ1RjWll0MDBhQTNZclFKZTl3bnlUWHcxWGRnRkNMbkVyWU14eEFxTlllek9INFp2eko0ZjJiTlBiSjFFWXRMQkw0NUtPb043MHYzdCtURG9hSEo4c3gxR3YrejhFMVdqOUs3VlRoRndMS212emRlekJFMldnN09kcXBCSzZVQ0laZTFRVGZNUnptek1wY2dEeEpNMVBBRUtxa2c5SUJwTllpc3BOTjRHTFJTTFkva0QvOEtQa0RWWHl0VG1ZVHQxdWU3dGhuV3NpdmJGM2dtU1AyVGRPK3VNS3FUa1ZINzVPQ0hqK1ptMi81VnMyUkhGd3RWN1c0SlB6dmVSMWd2NWFvKzI2cGNBb0lKVHExV0hyemtpRjQ1ZmZ2dTJ5YXdTNjNPSmcyZWYvL014S3ZWQ0YvamphbXgybDBHdXh5aUtuMWZuZjhBWGVWOVlVeFNVYVR5K3lFSUhVS0k5TWJETjFMMUtTUWxJdU5LbmE5Mmo4N3lIRnp1cExYTlpHcHhBd3NicS9Qb1BDOWJzTmROaTd6YUlSdFhIbHJtazd1ZjEvWEJvanZyaFIwUkQ1Y0lrUDFOR2dKR0E1OS83anppWEU1aVBWc0hLM1FSbk9uK0huMHV0Yml0S1RURGFFbDNmWDk3aklIWjQwWWVFNXpSUEljNGdIbU51OXFYWGtWUmpuZFBOWkdyOW9ITTEva3pQOE5LYmVsa3BEVG5YVGJZWEZvbG95S0xoT2ZWeSs3bFZmU0xhSHkyVncralpVbTdzdTJDVUtvbXlIMC80VmdJcm9BUEpSTW1WWWVQUzAybTFxNHNzNy9zRDBHNEFIOFRJRlJLTXdhMjlLYlVsMUJUQ3NicldPM2drN1BjaW1GcUp1RG9VL0tBejdJcmp5WG1KbkJkeXBFVy9oL1dEK0hCL0NMOHBFRGxyZS9YRW10eUpkYkdnQ2VjWFN4WkpLMStYNmhwU0JyQlhYTHZxM2dHR2EyVUhRSmQ3U3RWcm1ISzBVVEtrS1YzbDdITUFEVmdlaWl1cDlBeEY4U3dkb3lES1ZTN0xkWmJqMzdPQkFiYkI0K1AweGlsRVpFSFI5eDJ2NUFMclBkQWZUWnBLZE5NcUdWd1Z3ZTYyZDdOTkVVdjRQcThLWTlYamFZMkJrWUdBQVlwMmMwdW54L0RaZkdaaFpHRURnOGY2dnN4SDBmMTFtUTZhTFFDNEhBeE5JRkFCR2VndnVBSGphWTJCa1lHQm0rTThBSkdVWnRQOWZZRFprQUlxZ0FIWUFVSG9EV2dBQUFzWUFBQU1kQUZJQ09nQkxBam9BTEFHNUFDc0Nzd0F3QXF3QUxnQUFBQUFBUkFDcUFSZ0JZQUhXQWpCNDJtTmdaR0JnWUdmd1pXQmlBQUZHQmpRQUFBakFBRmw0MmsyTVBXL0NNQkNHbjRnRWlUQ3dvQTRkaW9mT0VRUWt0aTRNVEt4TUxJQmRsTUUyY2tJa3BLcGpmM2N2cm9lZTVOUHpmcHlCa204eWhzbVl4VDFNVGlIcWp3dW16Qk9QUlMwU2w3enl6b2dzbjRqenhrZmlYSkpUNG9JWFBoT1B4ZjlLWExMaForZnQvZEdab0E1ZW0rQ3UxamJib3dsdDQ1MWFWY3VvOThhWmNPNk1WcGVuMG4zVDlqZXIxbFZkMWV6d1dPNDg2REFFRkFkeGRHVEhWVEpMdzVaamRGcGhMNzVpUmNYeVg3NlgzTVhPT2Y2a3BYUGhLVnZUUzZPVmZaT3VZaTJYOWZCK0Fjd3JML2tBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNZ0FBb0FBQUFBQTR3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxa3lVVG1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKV1oyeDVaZ0FBQVd3QUFBQmNBQUFBYUo1Z1ZJWm9aV0ZrQUFBQnlBQUFBQzhBQUFBMktpZ3UrbWhvWldFQUFBSDRBQUFBSGdBQUFDUUZ1d0FVYUcxMGVBQUFBaGdBQUFBSUFBQUFDQVluQUZCc2IyTmhBQUFDSUFBQUFBWUFBQUFHQURRQUFHMWhlSEFBQUFJb0FBQUFGd0FBQUNBQUJBQWZibUZ0WlFBQUFrQUFBQURQQUFBQk9CT0JLcnR3YjNOMEFBQURFQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1GbWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4b0FBSEdDT2x1Q3lkZ1UySldZbVpXZkdQRVFNRHN5THpPYUF3STBMcC8vOE1EQURMeEEzT0FBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVck0vLzlEeUx2L3dQSU1BRkJ0Qm9FQUFIamFZMkJrQ1BqL244bUQ2UVNETEFNRG82QVltN29pbTVxSm1iaWlJQnB0SnNia3ppZ28rUytLVDBxU24zSE92MEllU1JrK3hxNS9LV0QrTWtsQnB2bC9PNlg0R1JrNVZEZ1lHU1VobERnanB6SW5JNk1BQXdEN05oSE5lTnBqWUdSZ1lBRGlocGxuWGVQNWJiNHlNTE13Z01Eai9WOW5JK2ovLzVrbk1wMEFjamtZbUVDaUFHK2dEWjRBZU5wallHUmdZRmI4WXdRa0p6SUVNUGd4ZVRBQVJWQUFFd0JKZUFMVEFBQURrUUFBQXBZQVVBQUFBQUFBTkFBQWVOcGpZR1JnWUdCaWtHTUEwUXhRRWdrQUFBT0xBQ1FBZU5wTmpEMXZ3akFRaHArSUJJa3dzRlFkT29BSDVnaENKYll1REV5c1RDeUFEY29RQjlraFVxU3FZMzkzTDY0SFR2THBlVC9PUU00UENjTWt6TUllSmlVVDljOFpVOTRpajBVdEl1ZDhzR1JFa2s3RW1mTVZPWlhrRkRuam5WdmtzZmpma1hNKytkMDE5ZVBaR3FjT2pUYk9YbXZmYjQvRythcXhhbDJzZ3Q0YmE5eTVOVnBkZXFXN3luZjNXbTJLc2lqWjBWRHo0RW1Md2FFNGlLTURXNjZTZVhxMkhJUGpxU1MxMGxwVHNIcko5NUxiMERtSG43UjBMcElvb1U2dXZPeTd0QlVidVN5SDl3ZjBBekJSQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTU1BQW9BQUFBQUEzUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFR4MEZXTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQjBaMng1WmdBQUFXUUFBQUJVQUFBQVZKNVA3NTFvWldGa0FBQUJ1QUFBQUMwQUFBQTJLV2t2RG1ob1pXRUFBQUhvQUFBQUlBQUFBQ1FFVEFKQmFHMTBlQUFBQWdnQUFBQUlBQUFBQ0FRZUFHcHNiMk5oQUFBQ0VBQUFBQVlBQUFBR0FDb0FBRzFoZUhBQUFBSVlBQUFBRmdBQUFDQUFCUUFYYm1GdFpRQUFBakFBQUFESkFBQUJNdTBLa2V4d2IzTjBBQUFDL0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtNG1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb3FNaWd5TS93SDhwa2gwa2hxL2dPRkFhTDdERUVBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlLLy85RHlQOFB3SHdHQUUvM0JuMEFBQUFBQWdCcUFBQUE0QUxiQUFzQUZRQUFFd01PQVNJbUp3TStBVElXRXc0Q0xnRTJOeDRCNENnQkNCTUpBU2dDSWkwa0FRRWhNU0VDSUJ3WUlRS2ovanNQQ1FrUUFjUWFIaDM5ZlJraEFTQXpJZ0VCSVFCNDJtTmdaR0JnQUdJRkQ0LzM4ZncyWHhtWVdSaEE0UEgrcjdPUmFhYkxUTGVCRkFjREU0Z0hBRHNSQzJnQUFBQjQybU5nWkdCZ1p2alB3TURBZEpraGl5R2I0UUVEVUFRRk1BRUFWbGdEa1FMVEFBQUJTd0JxQUFBQUFBQXFBQUI0Mm1OZ1pHQmdZR0lRQTJJUVlHUkFBd0FDMmdBZEFBQjQyajJNTVF2Q01CQ0Z2MklWcllPRDRPQWd3UjlRdEFvdWJnNU9yZzV1MWdUcDBGVFNXblFSZjdyWEVMeVE0N3YzM2gyUThDR2lxNGlKNzEzRjhpYUIrNHlaQmg2SXZnaWNNR2RKanlnZWliSmdIemhteUNWd254bDU0SUhvcjhBSlc3Nkhxbnc4RytQVXFkTEcyVnZwZG1majZxS3lhcDJ1dXZGb3JISFh4bWlWdjVWdWk3cTlsMnFUWm1uR2dZcVNCMDhhREE3RlNSVHQyWElUejdIajdPZWFRandybVRVcHE3OTdGTmY2eE5WZjBaTEllVXZYdExKVFM3OUxWckdSdmF6N1Axa3lMazBBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjU3MTQ2OCwtNy4xODc0MzMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYzLjM0NDMxLC02MS4zOTU4OSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTcxNDY4LC03LjE4NzQzMylzY2FsZSgtMSwtMSknPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMy4yMzU3NiwtMTIyLjcxMjY3OSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1OC4wNTUwNzUsLTEyMi43MTI2Nzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNy44NzkxMiwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDU4LjA1NTA3NSwtMTIyLjcxMjY3OSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSc1OC4wNTUwNzUnIHk9Jy0xMjIuNzEyNjc5Jz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzY5LjMwNDQ5NicgeT0nLTEyMi43MTI2NzknPsOXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jzc3LjA1MzI0NCcgeT0nLTEyMS4yMTgyOTgnPlo8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nODUuNjgxOTQzJyB5PSctMTIyLjcxMjY3OSc+WTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzLjIzNTc2LC05OS42Mzk0NTkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMy4yMzU3NiwtNzEuMjUyODIxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU4LjA1NTA3NSwtNzEuMjUyODIxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDU4LjA1NTA3NSwtNzEuMjUyODIxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzU4LjA1NTA3NScgeT0nLTcxLjI1MjgyMSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzLjIzNTc2LC0zOS4yMjAxMjcpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00LjUzNDcxLDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMy4yMzU3NiwtMzkuMjIwMTI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzMuMjM1NzYnIHk9Jy0zOS4yMjAxMjcnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTguMDU1MDc1LC0zOS4yMjAxMjcpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTEyLjM1NTUwNywtMzkuMjIwMTI3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNC4wMTM4OSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDExMi4zNTU1MDcsLTM5LjIyMDEyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScxMTIuMzU1NTA3JyB5PSctMzkuMjIwMTI3Jz5ZPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjM1NzYsLTcuMTg3NDMzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU4LjA1NTA3NSwtNy4xODc0MzMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc3MDgzLDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNTguMDU1MDc1LC03LjE4NzQzMylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSc1OC4wNTUwNzUnIHk9Jy03LjE4NzQzMyc+WjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTcuNzM0NzEgLjU4NjM4TC00NS4xMTg1Mi0yMS4yNTg5MScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC44NjMzNCwtMC41MDQ1LDAuNTA0NSwtMC44NjMzNCwtNDUuMjkxMTUsLTIxLjM1OTc5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMy42MzYxLC02LjcyMzMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU3MTQ2OCwtNy4xODc0MzMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUuNTcxNDY4JyB5PSctNy4xODc0MzMnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNOC43NzYzNyAuNTQwMDJMNDYuMTYxMDEtMjEuNTE1OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjg2MTI0LC0wLjUwODEsMC41MDgxLDAuODYxMjQsNDYuMzMzMjIsLTIxLjYxNzUxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI5Ljk5MzY3LC02Ljg3NTcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU3MTQ2OCwtNy4xODc0MzMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUuNTcxNDY4JyB5PSctNy4xODc0MzMnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTQ1LjQ2MzgtMzIuMDIyMTZMLTguMTAwODMtNTMuODU4MDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC44NjMzMSwtMC41MDQ1NiwwLjUwNDU2LDAuODYzMzEsLTcuOTI4MTgsLTUzLjk1ODk1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMS45ODMyOCwtNDkuNjk5MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTcxNDY4LC03LjE4NzQzMylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNS41NzE0NjgnIHk9Jy03LjE4NzQzMyc+dDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J000Ni41MDU0Ni0zMS43NjY2M0w5LjE0MTYzLTUzLjgxMjA0JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjg2MTIsLTAuNTA4MTUsMC41MDgxNSwtMC44NjEyLDguOTY5NDIsLTUzLjkxMzY1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMwLjAwNDA5LC00OC4yNTc1OCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTcxNDY4LC03LjE4NzQzMylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNS41NzE0NjgnIHk9Jy03LjE4NzQzMyc+dTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzIuNzk5ODUsMS41OTk5MScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00uNTIwODMgMTMuNjAyNzhWNDguODAyOTInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwwLjUyMDgzLDQ5LjAwMjkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTguNjIzNjEsMjguOTcyMjkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU3MTQ2OCwtNy4xODc0MzMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNTcxNDY4JyB5PSctNy4xODc0MzMnPuKIgzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMS4wNjA1ODQnIHk9Jy03LjE4NzQzMyc+ITwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS0xNS4wOTU2NiA0OS4yMDI4OEMtNDEuNTUzODggMzMuODU2NjYtNTQuMDk1MDIgMTIuMDM2NTgtNTQuMDM0OC0xOC4xNTAwOScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAwMiwtMC45OTk5NywwLjk5OTk3LDAuMDAyLC01NC4wMzQ0MSwtMTguMzUwMDUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTU1LjQ0MTQsMjQuMzk0MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTcxNDY4LC03LjE4NzQzMylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNS41NzE0NjgnIHk9Jy03LjE4NzQzMyc+z4A8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS45MTI2MjQnIHk9Jy02LjE5MTE2OSc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00xNS45NjI0NSA0OS4yMDI4OEM0Mi4yNDg3MyAzMy44MzU2OCA1NC43NTU1IDExLjg5ODE2IDU0LjU5MjQ4LTE4LjE1MDEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuMDA1NDIsLTAuOTk5OTQsMC45OTk5NCwtMC4wMDU0Miw1NC41OTE0MiwtMTguMzUwMDUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuNTQ4NDIsMjQuMzM0NTMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU3MTQ2OCwtNy4xODc0MzMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUuNTcxNDY4JyB5PSctNy4xODc0MzMnPs+APC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0uOTEyNjI0JyB5PSctNi4xOTExNjknPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg=="></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \usetikzlibrary {arrows}
        \begin {tikzcd}
            &amp; {X\times _ZY} \\
            \\
            &amp; A \\
            X &amp;&amp; Y \\
            &amp; Z
            \arrow [&quot;f&quot;&apos;, from=3-2, to=4-1]
            \arrow [&quot;g&quot;, from=3-2, to=4-3]
            \arrow [&quot;t&quot;&apos;, from=4-1, to=5-2]
            \arrow [&quot;u&quot;, from=4-3, to=5-2]
            \arrow [&quot;{\exists !}&quot;, dashed, from=3-2, to=1-2]
            \arrow [&quot;{\pi _1}&quot;&apos;, bend right, from=1-2, to=4-1]
	        \arrow [&quot;{\pi _2}&quot;, bend left, from=1-2, to=4-3]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure>
 

    there exists a <fr:em>unique</fr:em> arrow <fr:tex display="inline">\langle  f,g \rangle _Z: A\to  X\times _Z Y</fr:tex> such that
    <fr:tex display="block">         \pi _1\circ \langle  f,g \rangle _Z = f \text { and } \pi _2\circ \langle  f,g \rangle _Z = g     </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>565</fr:anchor>
                <fr:addr type="user">math-0004</fr:addr>
                <fr:route>math-0004.xml</fr:route>
                <fr:title text="The Construction of {R}">The Construction of <fr:tex display="inline">\mathbb {R}</fr:tex></fr:title>
                <fr:taxon>Math Analysis</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>27</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>We start constructing <fr:tex display="inline">\mathbb {R}</fr:tex> from <fr:tex display="inline">\mathbb {Q}</fr:tex> by a way that it satisfies the existence theorem,
    the core of construction.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>566</fr:anchor>
                    <fr:addr type="user">thm-0003</fr:addr>
                    <fr:route>thm-0003.xml</fr:route>
                    <fr:title text="Existence theorem">Existence theorem</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>There exists an ordered field <fr:tex display="inline">\mathbb {R}</fr:tex> that satisfies the <fr:link type="local" href="def-0012.xml" addr="def-0012" title="Least upper bound property">least upper bound property</fr:link>.
    Moreover <fr:tex display="inline">\mathbb {R}</fr:tex> contains <fr:tex display="inline">\mathbb {Q}</fr:tex> as a subfield.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>The least-upper-bound property mentioned above is defined:</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>567</fr:anchor>
                    <fr:addr type="user">def-0012</fr:addr>
                    <fr:route>def-0012.xml</fr:route>
                    <fr:title text="Least upper bound property">Least upper bound property</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A set <fr:tex display="inline">S</fr:tex> has the least upper bound property if every non-empty subset <fr:tex display="inline">T</fr:tex> of <fr:tex display="inline">S</fr:tex> that is bounded above has a least upper bound <fr:tex display="inline">\sup  T</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Why do we need the least-upper-bound property?
    Consider the set <fr:tex display="inline">S = \{x \in  \mathbb {Q} | x^2 &lt; 2\}</fr:tex>.
    <fr:tex display="inline">S</fr:tex> is bounded above by <fr:tex display="inline">2</fr:tex>, but it does not have a least upper bound in <fr:tex display="inline">\mathbb {Q}</fr:tex>.
    Therefore we can&apos;t express <fr:tex display="inline">\sqrt {2}</fr:tex> in field <fr:tex display="inline">\mathbb {Q}</fr:tex> since some &quot;gaps&quot; exist.
    This fact motivates us to construct a more complete field <fr:tex display="inline">\mathbb {R}</fr:tex>.
    We have constructed <fr:tex display="inline">\mathbb {Q}</fr:tex> from <fr:tex display="inline">\mathbb {Z}</fr:tex>, and now we construct <fr:tex display="inline">\mathbb {R}</fr:tex> from <fr:tex display="inline">\mathbb {Q}</fr:tex>.</fr:p>
                <fr:p>Then we should find a way to express &quot;<fr:tex display="inline">\sqrt {2}</fr:tex>&quot; using <fr:tex display="inline">\mathbb {Q}</fr:tex>.
    A crucial idea is <fr:strong>approximating</fr:strong> <fr:tex display="inline">\sqrt {2}</fr:tex> by a sequence of rational numbers.
    <fr:tex display="block">         \sqrt {2} := \{ p^2&lt;2 \lor  p&lt;0, p\in \mathbb {Q} \}     </fr:tex>
    We can cut the number axis into two pieces by <fr:tex display="inline">\sqrt {2}</fr:tex>, such cut is called a <fr:strong>Dedekind cut</fr:strong>. 
    A cut should be well-defined rather than just an intuitive concept.</fr:p>
                <fr:p>As we use set theory to construct <fr:tex display="inline">\mathbb {R}</fr:tex>, it motivates us to define Dedekind cut as a set.
    It should satisfies some properties:
    <fr:ul><fr:li>Can&apos;t be empty or the whole <fr:tex display="inline">\mathbb {Q}</fr:tex></fr:li>
        <fr:li>Closed downward</fr:li>
        <fr:li>Contains not the largest number</fr:li></fr:ul>
    A formal definition is given below:</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>568</fr:anchor>
                    <fr:addr type="user">def-0013</fr:addr>
                    <fr:route>def-0013.xml</fr:route>
                    <fr:title text="Dedekind cuts">Dedekind cuts</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A Dedekind cut is a partition of the rationals <fr:tex display="inline">\mathbb {Q}</fr:tex> into two non-empty sets <fr:tex display="inline">L</fr:tex> and <fr:tex display="inline">R</fr:tex> such that:
    <fr:ul><fr:li><fr:tex display="inline">L\neq \emptyset </fr:tex></fr:li>
        <fr:li><fr:tex display="inline">R\neq \emptyset </fr:tex></fr:li>
        <fr:li>if <fr:tex display="inline">x,y\in \mathbb {Q}, x&lt;y</fr:tex> and <fr:tex display="inline">y\in  L</fr:tex> then <fr:tex display="inline">x\in  L</fr:tex></fr:li>
        <fr:li>if <fr:tex display="inline">p\in  L</fr:tex> then exists <fr:tex display="inline">q\in  L</fr:tex> such that <fr:tex display="inline">p&lt;q</fr:tex></fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Now we can defined the real number as a set of Dedekind cuts.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>569</fr:anchor>
                    <fr:addr type="user">def-0014</fr:addr>
                    <fr:route>def-0014.xml</fr:route>
                    <fr:title text="Real Number System">Real Number System</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The element of <fr:tex display="inline">\mathbb {R}</fr:tex> is a <fr:link type="local" href="def-0013.xml" addr="def-0013" title="Dedekind cuts">Dedekind Cut</fr:link> in <fr:tex display="inline">\mathbb {Q}</fr:tex>.
    <fr:tex display="block">         \mathbb {R} := \{ L | (L,R) \text { is a Dedekind Cut} \}     </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Now define the order relation on <fr:tex display="inline">\mathbb {R}</fr:tex>.
    We have defined <fr:tex display="inline">\mathbb {R}</fr:tex> as the set of Dedekind cuts, so we can define the strict partial order relation <fr:tex display="inline">&lt;</fr:tex> on <fr:tex display="inline">\mathbb {R}</fr:tex> by the set operation <fr:tex display="inline">\subset </fr:tex>.
    The irreflexive, asymmetric and transitive properties are trivial.</fr:p>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>570</fr:anchor>
                <fr:addr type="user">math-0001</fr:addr>
                <fr:route>math-0001.xml</fr:route>
                <fr:title text="Introduction to Vector Space">Introduction to Vector Space</fr:title>
                <fr:taxon>Linear Algebra</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>26</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>This note introduces the concept of vector space.
    Refer to <fr:link type="local" href="linear-algebra-2015.xml" addr="linear-algebra-2015" title="Linear Algebra Done Right">Linear Algebra Done Right</fr:link>.</fr:p>
                <fr:p>The motivation for the definition of a vector space comes from the properties
    of vectors in Euclidean space <fr:tex display="inline">\mathbb {R}^n</fr:tex> and <fr:tex display="inline">\mathbb {C}^n</fr:tex>.
    The definition abstracts and generalizes these properties.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>571</fr:anchor>
                    <fr:addr type="user">def-000H</fr:addr>
                    <fr:route>def-000H.xml</fr:route>
                    <fr:title text="Vector Space">Vector Space</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A vector space over a <fr:link type="local" href="def-0006.xml" addr="def-0006" title="Field">field</fr:link> <fr:tex display="inline">F</fr:tex> is a non-empty set <fr:tex display="inline">V</fr:tex> together with a binary operation and a binary function that satisfy the axioms listed below. 
    In this context, the elements of <fr:tex display="inline">V</fr:tex> are commonly called <fr:strong>vectors</fr:strong>, and the elements of <fr:tex display="inline">F</fr:tex> are called <fr:strong>scalars</fr:strong>.
    <fr:ul><fr:li>Commutativity: <fr:tex display="inline">             \forall  x, y \in  V, x + y = y + x         </fr:tex></fr:li>
        <fr:li>Associativity: <fr:tex display="inline">             \forall  x, y, z \in  V, (x + y) + z = x + (y + z)         </fr:tex></fr:li>
        <fr:li>Additive Identity: <fr:tex display="inline">             \exists  0 \in  V \text { such that } \forall  x \in  V, x + 0 = x         </fr:tex></fr:li>
        <fr:li>Multiplicative Identity: <fr:tex display="inline">             \forall  x \in  V, 1x = x         </fr:tex></fr:li>
        <fr:li>Additive Inverse: <fr:tex display="inline">             \forall  x \in  V, \exists  y \in  V \text { such that } x + y = 0         </fr:tex></fr:li>
        <fr:li>Distributivity: <fr:tex display="inline">             \forall  x, y \in  V, \forall  c, d \in  F, c(x + y) = cx + cy, (c + d)x = cx + dx         </fr:tex></fr:li></fr:ul></fr:p>
                    <fr:p>Elements of a vector space are called <fr:strong>vectors</fr:strong> or <fr:strong>points</fr:strong>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>When dealing with vector spaces, we usually interested only in subspaces.
    And the union of subspaces is rarely a subspace, thus
    we are more interested with sums of subspaces.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>572</fr:anchor>
                    <fr:addr type="user">def-000I</fr:addr>
                    <fr:route>def-000I.xml</fr:route>
                    <fr:title text="Linear Subspace">Linear Subspace</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A subset <fr:tex display="inline">U</fr:tex> of a vector space <fr:tex display="inline">V</fr:tex> over a field <fr:tex display="inline">F</fr:tex> is called a <fr:strong>subspace</fr:strong> of <fr:tex display="inline">V</fr:tex> if <fr:tex display="inline">U</fr:tex> is itself a <fr:strong>vector space</fr:strong> over <fr:tex display="inline">F</fr:tex> with the operations of addition and scalar multiplication on <fr:tex display="inline">V</fr:tex>.
    The subset also satisfies the following axioms (vice versa):
    <fr:ul><fr:li>Additive identity: <fr:tex display="inline">0\in  U</fr:tex></fr:li>
        <fr:li>Closure: <fr:tex display="inline">\forall  u,v\in  U, u+v\in  U</fr:tex></fr:li>
        <fr:li>Closed Scalar multiplication: <fr:tex display="inline">\forall  u\in  U, \forall  c\in  F, cu\in  U</fr:tex></fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>After that we can define the sum of subsets.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>573</fr:anchor>
                    <fr:addr type="user">def-000J</fr:addr>
                    <fr:route>def-000J.xml</fr:route>
                    <fr:title text="Sum of subsets">Sum of subsets</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">U_1, \dots , U_n</fr:tex> be subsets of a vector space <fr:tex display="inline">V</fr:tex>.
    The <fr:strong>sum</fr:strong> of <fr:tex display="inline">U_1, \dots , U_n</fr:tex> is defined as
    <fr:tex display="block">U_1 + \dots  + U_n = \{u_1 + \dots  + u_n \mid  u_i \in  U_i\}</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>The sum of subspaces is the smallest subspace that contains all the subspaces.</fr:p>
                <fr:p>Every element in <fr:tex display="inline">U_1 + \dots  + U_n</fr:tex> can be written as a sum of elements <fr:tex display="inline">u_i</fr:tex> in <fr:tex display="inline">U_i</fr:tex>:
    <fr:tex display="block">         u_1+\cdots +u_n     </fr:tex>
    We will interested in cases where each vector in <fr:tex display="inline">U_1 + \dots  + U_n</fr:tex> can be represented in the form above
    in only one way. This leads to the definition of direct sum.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>574</fr:anchor>
                    <fr:addr type="user">def-000K</fr:addr>
                    <fr:route>def-000K.xml</fr:route>
                    <fr:title text="Direct Sum">Direct Sum</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">U_1, \dots , U_n</fr:tex> be subspaces of a vector space <fr:tex display="inline">V</fr:tex>.
    The <fr:strong>direct sum</fr:strong> of <fr:tex display="inline">U_1, \dots , U_n</fr:tex> is defined as
    <fr:tex display="block">         U_1 \oplus  \dots  \oplus  U_n = \{u_1 + \dots  + u_n \mid  u_i \in  U_i\}     </fr:tex>
    if every element in <fr:tex display="inline">U_1 \oplus  \dots  \oplus  U_n</fr:tex> can be written as <fr:tex display="inline">u_1 + \dots  + u_n </fr:tex> in only one way.
    This definition requires every vector in the sum have a unique representation.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>575</fr:anchor>
                <fr:addr type="user">math-0002</fr:addr>
                <fr:route>math-0002.xml</fr:route>
                <fr:title text="Finite Dimensional Vector Space">Finite Dimensional Vector Space</fr:title>
                <fr:taxon>Linear Algebra</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>26</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>This note introduces the concept of finite-dimensional vector space.
    Refer to <fr:link type="local" href="linear-algebra-2015.xml" addr="linear-algebra-2015" title="Linear Algebra Done Right">Linear Algebra Done Right</fr:link>.</fr:p>
                <fr:p>Adding up scalar mulitples of vectors in a list gives a linear combination.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>576</fr:anchor>
                    <fr:addr type="user">def-000L</fr:addr>
                    <fr:route>def-000L.xml</fr:route>
                    <fr:title text="Linear Combination">Linear Combination</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">V</fr:tex> be a <fr:link type="local" href="def-000H.xml" addr="def-000H" title="Vector Space">vector space</fr:link> over a field <fr:tex display="inline">F</fr:tex>.
    Let <fr:tex display="inline">v_1, \dots , v_n</fr:tex> be vectors in <fr:tex display="inline">V</fr:tex>.
    A <fr:strong>linear combination</fr:strong> of <fr:tex display="inline">v_1, \dots , v_n</fr:tex> is an expression of the form
    <fr:tex display="block">         a_1 v_1 + \dots  + a_n v_n     </fr:tex>
    where <fr:tex display="inline">a_1, \dots , a_n \in  F</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>To talk about a structure, we usually define a collection of this structure.
    Hence we have span for linear combinations.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>577</fr:anchor>
                    <fr:addr type="user">def-000M</fr:addr>
                    <fr:route>def-000M.xml</fr:route>
                    <fr:title text="Linear Span">Linear Span</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">V</fr:tex> be a vector space over a field <fr:tex display="inline">F</fr:tex>.
    Let <fr:tex display="inline">v_1, \dots , v_n</fr:tex> be vectors in <fr:tex display="inline">V</fr:tex>.
    The <fr:strong>span</fr:strong> of <fr:tex display="inline">v_1, \dots , v_n</fr:tex> is defined as
    <fr:tex display="block">         \text {span}(v_1, \dots , v_n) = \{a_1 v_1 + \dots  + a_n v_n \mid  a_i \in  F\}     </fr:tex>
    The span of empty set is defined to be <fr:tex display="inline">\{0\}</fr:tex>.</fr:p>
                    <fr:p>If <fr:tex display="inline">\text {span}(v_1, \dots , v_n) = V</fr:tex>, we say that <fr:tex display="inline">v_1, \dots , v_n</fr:tex> <fr:strong>spans</fr:strong> <fr:tex display="inline">V</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Suppose we have span <fr:tex display="inline">S=\text {span}(v_1, \dots , v_n)</fr:tex>. (Span is trivially a subspace.)
    Obviously for all <fr:tex display="inline">v_j (1 \leq  j \leq  n)</fr:tex>, <fr:tex display="inline">v_j \in  S</fr:tex>.
    Because subspaces are closed under scalar multiplication and addition, every
    subspace of <fr:tex display="inline">V</fr:tex> containing <fr:tex display="inline">v_1, \dots , v_n</fr:tex> must contain <fr:tex display="inline">S</fr:tex>.
    Thus we conclude that <fr:tex display="inline">S</fr:tex> is the smallest subspace containing <fr:tex display="inline">v_1, \dots , v_n</fr:tex>.</fr:p>
                <fr:p>The discussion about <fr:strong>spans</fr:strong> leads to a key definition in linear algebra.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>578</fr:anchor>
                    <fr:addr type="user">def-000N</fr:addr>
                    <fr:route>def-000N.xml</fr:route>
                    <fr:title text="Finite-Dimensional Vector Space">Finite-Dimensional Vector Space</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A <fr:link type="local" href="def-000H.xml" addr="def-000H" title="Vector Space">vector space</fr:link> <fr:tex display="inline">V</fr:tex> is called <fr:strong>finite-dimensional</fr:strong> if some <fr:link type="local" href="def-000G.xml" addr="def-000G" title="List">list</fr:link> of vectors <fr:tex display="inline">v_1, \dots , v_n</fr:tex> <fr:link type="local" href="def-000M.xml" addr="def-000M" title="Linear Span">spans</fr:link> <fr:tex display="inline">V</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>The opposite of finite-dimensional is infinite-dimensional.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>579</fr:anchor>
                    <fr:addr type="user">def-000O</fr:addr>
                    <fr:route>def-000O.xml</fr:route>
                    <fr:title text="Infinite-dimensional vector space">Infinite-dimensional vector space</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A vector space <fr:tex display="inline">V</fr:tex> is called <fr:strong>infinite-dimensional</fr:strong> if it is not <fr:link type="local" href="def-000N.xml" addr="def-000N" title="Finite-Dimensional Vector Space">finite-dimensional</fr:link>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Consider the situation that there is only one way to
    express a vector <fr:tex display="inline">v</fr:tex> as a linear combination of vectors in a list <fr:tex display="inline">v_1, \dots , v_n</fr:tex>.
    What property of the list <fr:tex display="inline">v_1, \dots , v_n</fr:tex> does this situation imply? The answer is
    linear independence.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>580</fr:anchor>
                    <fr:addr type="user">def-000P</fr:addr>
                    <fr:route>def-000P.xml</fr:route>
                    <fr:title text="Linearly independent">Linearly independent</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A set of vectors <fr:tex display="inline">\{v_1, \dots , v_n\}</fr:tex> is called <fr:strong>linearly independent</fr:strong> if
    <fr:tex display="block">a_1 v_1 + \dots  + a_n v_n = 0</fr:tex>
    implies that <fr:tex display="inline">a_1 = \dots  = a_n = 0</fr:tex>.
    The trivial case of <fr:tex display="inline">\{0\}</fr:tex> is also considered linearly independent.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>If some vectors are not linearly independent, then there are more than one way to
    express a vector as a linear combination of vectors in the list. This leads to 
    the following definition.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>581</fr:anchor>
                    <fr:addr type="user">def-000Q</fr:addr>
                    <fr:route>def-000Q.xml</fr:route>
                    <fr:title text="Linearly dependent">Linearly dependent</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A set of vectors <fr:tex display="inline">\{v_1, \dots , v_n\}</fr:tex> is called <fr:strong>linearly dependent</fr:strong> if
    <fr:tex display="block">a_1 v_1 + \dots  + a_n v_n = 0</fr:tex>
    for some <fr:tex display="inline">a_1, \dots , a_n \in  \mathbb {F}</fr:tex> with at least one <fr:tex display="inline">a_i \neq  0</fr:tex> (not all <fr:tex display="inline">0</fr:tex>).</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>The following lemma is a direct consequence of the definition of linear independence.
    It states that for a given linearly dependent list, we can always remove a vector
    without changing the span.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>582</fr:anchor>
                    <fr:addr type="user">thm-0001</fr:addr>
                    <fr:route>thm-0001.xml</fr:route>
                    <fr:title text="Linear Dependence Lemma">Linear Dependence Lemma</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">v_1, \dots , v_n</fr:tex> be vectors in a vector space <fr:tex display="inline">V</fr:tex> over a field <fr:tex display="inline">\mathbb {F}</fr:tex>.
    If <fr:tex display="inline">v_1, \dots , v_n</fr:tex> are linearly dependent, then there exists <fr:tex display="inline">1 \leq  i \leq  n</fr:tex> such that
    <fr:ul><fr:li><fr:tex display="inline">v_i \in  \text {span}(v_1, \dots , v_{i-1})</fr:tex></fr:li>
        <fr:li>Remove <fr:tex display="inline">v_i</fr:tex> from the list <fr:tex display="inline">v_1, \dots , v_n</fr:tex> and the span does not change</fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>583</fr:anchor>
                    <fr:addr type="user">thm-0002</fr:addr>
                    <fr:route>thm-0002.xml</fr:route>
                    <fr:title text="Length of linearly independent list  length of spanning list">Length of linearly independent list <fr:tex display="inline">\leq </fr:tex> length of spanning list</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>In a finite dimensional vector space, the length of a linearly independent list is less than or equal to the length of a spanning list.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>We have discussed linear independent lists and spanning lists.
    Now we are ready to define a basis.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>584</fr:anchor>
                    <fr:addr type="user">def-000R</fr:addr>
                    <fr:route>def-000R.xml</fr:route>
                    <fr:title text="Basis">Basis</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A basis of <fr:tex display="inline">V</fr:tex> is a list of vectors in <fr:tex display="inline">V</fr:tex>
    that is linearly independent and spans <fr:tex display="inline">V</fr:tex>.</fr:p>
                    <fr:p><fr:strong>Criterion for basis</fr:strong>
    A list of vectors <fr:tex display="inline">\{v_1, \dots , v_n\}</fr:tex> is a basis of <fr:tex display="inline">V</fr:tex> if and only if
    every <fr:tex display="inline">v \in  V</fr:tex> can be written <fr:strong>uniquely</fr:strong> as a linear combination of <fr:tex display="inline">v_1, \dots , v_n</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>For instance, we have standard basis <fr:tex display="inline">\{e_1, \dots , e_n\}</fr:tex> for <fr:tex display="inline">\mathbb {F}^n</fr:tex>,
    where <fr:tex display="inline">e_i</fr:tex> is the vector with <fr:tex display="inline">1</fr:tex> at <fr:tex display="inline">i</fr:tex>-th position and <fr:tex display="inline">0</fr:tex> elsewhere.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>585</fr:anchor>
                    <fr:addr type="user">thm-0005</fr:addr>
                    <fr:route>thm-0005.xml</fr:route>
                    <fr:title text="Spanning List contains a basis">Spanning List contains a basis</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Every spanning list in a vector space can be reduced to a basis.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>From the <fr:link type="local" href="thm-0005.xml" addr="thm-0005" title="Spanning List contains a basis">theorem</fr:link> we can infer a corollary.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>586</fr:anchor>
                    <fr:addr type="user">thm-0006</fr:addr>
                    <fr:route>thm-0006.xml</fr:route>
                    <fr:title text="Basis of finite-dimensional vector space">Basis of finite-dimensional vector space</fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Every finite-dimensional vector space has a basis.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>The next result states for a spanning list can be reduced to a basis.
    We can adjoin one or more vectors to a linearly independent list to form a basis.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>587</fr:anchor>
                    <fr:addr type="user">thm-0007</fr:addr>
                    <fr:route>thm-0007.xml</fr:route>
                    <fr:title text="Linearly dependent list extends to a basis">Linearly dependent list extends to a basis</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Every linearly independent list of vectors in  a finite-dimensional vector space can be extended to a basis.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Remind the definition of <fr:link type="external" href="der-000K">direct sum</fr:link>, we can now show that
    every subspace of a finite-dimensional vecrtor space can be paired
    with another subspace to form a direct sum of the whole space.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>588</fr:anchor>
                    <fr:addr type="user">thm-0008</fr:addr>
                    <fr:route>thm-0008.xml</fr:route>
                    <fr:title text="Direct Sum of Subspaces of V">Direct Sum of Subspaces of <fr:tex display="inline">V</fr:tex></fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Suppose <fr:tex display="inline">V</fr:tex> is a finite dimensional vector space,
    and <fr:tex display="inline">U</fr:tex> is a subspace of <fr:tex display="inline">V</fr:tex>.
    Then there exists a subspace <fr:tex display="inline">W</fr:tex> of <fr:tex display="inline">V</fr:tex> such that
    <fr:tex display="inline">V = U \oplus  W</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>This post discusses about <fr:em>finite-dimensional vector space</fr:em>.
    But we have not yet defined what is dimension.
    We tempted to define the dimension as the length of basis intuitively.
    With this definition we should prove its well-definedness.
    That is, every basis has the same length.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>589</fr:anchor>
                    <fr:addr type="user">thm-0009</fr:addr>
                    <fr:route>thm-0009.xml</fr:route>
                    <fr:title text="Basis length is invariant">Basis length is invariant</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">V</fr:tex> be a finite-dimensional vector space.
    Then every basis of <fr:tex display="inline">V</fr:tex> has the same length.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>This can be proved by <fr:link type="local" href="thm-0002.xml" addr="thm-0002" title="Length of linearly independent list  length of spanning list">Lemma 8</fr:link>.
    Now we can formally define the dimension of such spaces.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>590</fr:anchor>
                    <fr:addr type="user">def-001V</fr:addr>
                    <fr:route>def-001V.xml</fr:route>
                    <fr:title text="Dimension">Dimension</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The <fr:strong>dimension</fr:strong> of a finite-dimensional vector space <fr:tex display="inline">V</fr:tex> is the length of any basis of the vector space.
    Denoted by <fr:tex display="inline">\dim  V</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Every subspace of a finite-dimensional vector space is also finite-dimensional.
    Hence we can talk about the dimension of a subspace.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>591</fr:anchor>
                    <fr:addr type="user">thm-000A</fr:addr>
                    <fr:route>thm-000A.xml</fr:route>
                    <fr:title text="Dimension of a subspace">Dimension of a subspace</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">V</fr:tex> be a finite-dimensional vector space,
    and <fr:tex display="inline">U</fr:tex> be a subspace of <fr:tex display="inline">V</fr:tex>.
    Then <fr:tex display="inline">\dim  U \leq  \dim  V</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>According to the definition of <fr:link type="local" href="def-000P.xml" addr="def-000P" title="Linearly independent">linearly independent</fr:link>,
    to show a list of vectors is a basis, we only need to show it is linearly independent,
    and it spans the whole space.
    The next theorems simplifies the task:</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>592</fr:anchor>
                    <fr:addr type="user">thm-000B</fr:addr>
                    <fr:route>thm-000B.xml</fr:route>
                    <fr:title text="Linearly independent list of the right length is a basis">Linearly independent list of the right length is a basis</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">V</fr:tex> be a finite-dimensional vector space.
    Then every <fr:link type="local" href="def-000P.xml" addr="def-000P" title="Linearly independent">linearly independent</fr:link> list of vectors in <fr:tex display="inline">V</fr:tex> with length equal to <fr:tex display="inline">\dim  V</fr:tex> is a basis of <fr:tex display="inline">V</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>593</fr:anchor>
                    <fr:addr type="user">thm-000C</fr:addr>
                    <fr:route>thm-000C.xml</fr:route>
                    <fr:title text="Spanning list of the right length is a basis">Spanning list of the right length is a basis</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">V</fr:tex> be a finite-dimensional vector space.
    Then every <fr:link type="local" href="def-000M.xml" addr="def-000M" title="Linear Span">spanning</fr:link> list of vectors in <fr:tex display="inline">V</fr:tex> with length equal to <fr:tex display="inline">\dim  V</fr:tex> is a basis of <fr:tex display="inline">V</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Now we move to the discussion of the dimension of the sum of two subspaces.
    This is analogous to the <fr:link type="local" href="thm-000E.xml" addr="thm-000E" title="Inclusion-Exclusion Principle">inclusion-exclusion principle</fr:link>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>594</fr:anchor>
                    <fr:addr type="user">thm-000D</fr:addr>
                    <fr:route>thm-000D.xml</fr:route>
                    <fr:title text="Dimension of a sum">Dimension of a sum</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">V</fr:tex> be a finite-dimensional vector space,
    and <fr:tex display="inline">U</fr:tex> and <fr:tex display="inline">W</fr:tex> be subspaces of <fr:tex display="inline">V</fr:tex>.
    Then
    <fr:tex display="block">         \dim (U + W) = \dim  U + \dim  W - \dim (U \cap  W).     </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>595</fr:anchor>
                <fr:addr type="user">math-0005</fr:addr>
                <fr:route>math-0005.xml</fr:route>
                <fr:title text="Linear Maps">Linear Maps</fr:title>
                <fr:taxon>Linear Algebra</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>31</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>This note introduces the concept of linear maps.
    Refer to <fr:link type="local" href="linear-algebra-2015.xml" addr="linear-algebra-2015" title="Linear Algebra Done Right">Linear Algebra Done Right</fr:link>.</fr:p>
                <fr:p>Now we arrive at the main topic of this chapter: linear maps. 
    In classic mathematics, to understand the properties of the structure or space,
    we often study the maps between them.
    For vector spaces we study the <fr:strong>linear maps</fr:strong>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>596</fr:anchor>
                    <fr:addr type="user">def-0025</fr:addr>
                    <fr:route>def-0025.xml</fr:route>
                    <fr:title text="Linear Map">Linear Map</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A <fr:strong>linear map</fr:strong> is a function between two vector spaces that preserves the operations of addition and scalar multiplication.
    In other words, a function <fr:tex display="inline">T: V \to  W</fr:tex> where <fr:tex display="inline">V,W</fr:tex> are vector spaces if the following conditions are satisfied:
    <fr:ul><fr:li>Additivity: <fr:tex display="inline">T(u+v) = T(u) + T(v)</fr:tex> for all <fr:tex display="inline">u,v \in  V</fr:tex></fr:li>
        <fr:li>Homogeneity: <fr:tex display="inline">T(\alpha  v) = \alpha  T(v)</fr:tex> for all <fr:tex display="inline">\alpha  \in  \mathbb {F}</fr:tex> and <fr:tex display="inline">v \in  V</fr:tex></fr:li></fr:ul>
    Sometimes we ignore the brackets and write <fr:tex display="inline">T v</fr:tex> instead of <fr:tex display="inline">T(v)</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Now we can talk about the set of all linear maps between two vector spaces.
    <fr:tex display="block">         \mathcal {L}(V,W) = \{  T: V \to  W | T \text { is a linear map} \}     </fr:tex></fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>597</fr:anchor>
                    <fr:addr type="user">eg-0002</fr:addr>
                    <fr:route>eg-0002.xml</fr:route>
                    <fr:title text="Differentiation is linear map">Differentiation is linear map</fr:title>
                    <fr:taxon>Example</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Define <fr:tex display="inline">D\in \mathcal {L}(\mathcal {P}(\mathbb {R}),\mathcal {P}(\mathbb {R}))</fr:tex> (recall that <fr:tex display="inline">\mathcal {P}</fr:tex> means <fr:link type="local" href="def-0027.xml" addr="def-0027" title="Polynomial">set of polynomials</fr:link>) by
    <fr:tex display="block">         D(f) = f&apos;     </fr:tex>
    We can see that <fr:tex display="inline">D</fr:tex> a linear map.
    <fr:ul><fr:li>Additivity: <fr:tex display="inline">D(f+g) = (f+g)&apos; = f&apos; + g&apos; = D(f) + D(g)</fr:tex></fr:li>
        <fr:li>Homogeneity: <fr:tex display="inline">D(\alpha  f) = (\alpha  f)&apos; = \alpha  f&apos; = \alpha  D(f)</fr:tex></fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>598</fr:anchor>
                    <fr:addr type="user">eg-0003</fr:addr>
                    <fr:route>eg-0003.xml</fr:route>
                    <fr:title text="Integration is linear map">Integration is linear map</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">V</fr:tex> be the vector space of all continuous functions on the interval <fr:tex display="inline">[a,b]</fr:tex>.
    The map <fr:tex display="inline">I: V \to  V</fr:tex> defined by
    <fr:tex display="block">         I(f) = \int _a^x f(t) dt     </fr:tex>
    is a <fr:strong>linear map</fr:strong>.
    In other words, <fr:tex display="inline">I</fr:tex> preserves the operations of addition and scalar multiplication:
    For all <fr:tex display="inline">f,g \in  V</fr:tex> and all <fr:tex display="inline">\alpha  \in  \mathbb {R}</fr:tex>,
    <fr:tex display="block">         I(f+g) = I(f) + I(g) \quad  \text {and} \quad  I(\alpha  f) = \alpha  I(f)     </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>We can find a linear map that takes on <fr:em>whatever values we wish</fr:em> on the 
    vectors in a basis by the following theorem.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>599</fr:anchor>
                    <fr:addr type="user">thm-000F</fr:addr>
                    <fr:route>thm-000F.xml</fr:route>
                    <fr:title text="Linear maps and basis of domain">Linear maps and basis of domain</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">v_1, v_2, \ldots , v_n</fr:tex> be a basis of vector space <fr:tex display="inline">V</fr:tex>.
    Then for any vector space <fr:tex display="inline">W</fr:tex> and any vectors <fr:tex display="inline">w_1, w_2, \ldots , w_n</fr:tex> in <fr:tex display="inline">W</fr:tex>,
    there exists a unique linear map <fr:tex display="inline">T: V \to  W</fr:tex> such that
    <fr:tex display="block">         T(v_i) = w_i \quad  \text {for all} \quad  i = 1,2,\ldots ,n     </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Now let&apos;s turn to the algebraic operations over the set of linear maps <fr:tex display="inline">\mathcal {L}(V,W)</fr:tex>.
    We begin by defining the addition and scalar multiplication of linear maps.
    This leads to a surprising result: the set of linear maps is actually a vector space.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>600</fr:anchor>
                    <fr:addr type="user">def-0029</fr:addr>
                    <fr:route>def-0029.xml</fr:route>
                    <fr:title text="Addition and scalar multiplication over {L}(V,W)">Addition and scalar multiplication over <fr:tex display="inline">\mathcal {L}(V,W)</fr:tex></fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">T_1, T_2 \in  \mathcal {L}(V,W)</fr:tex>.
    We define the <fr:strong>addition</fr:strong> of <fr:tex display="inline">T_1</fr:tex> and <fr:tex display="inline">T_2</fr:tex> as the linear map <fr:tex display="inline">T_1 + T_2: V \to  W</fr:tex> such that
    <fr:tex display="block">         (T_1 + T_2)(v) = T_1(v) + T_2(v) \quad  \text {for all} \quad  v \in  V     </fr:tex>
    The scalar multiplication of a linear map <fr:tex display="inline">T \in  \mathcal {L}(V,W)</fr:tex> by a scalar <fr:tex display="inline">c \in  \mathbb {F}</fr:tex> is the linear map <fr:tex display="inline">cT: V \to  W</fr:tex> such that
    <fr:tex display="block">         (cT)(v) = cT(v) \quad  \text {for all} \quad  v \in  V     </fr:tex>
    With these operations, <fr:tex display="inline">\mathcal {L}(V,W)</fr:tex> is a <fr:link type="local" href="def-000H.xml" addr="def-000H" title="Vector Space"><fr:strong>vector space</fr:strong></fr:link> over the field <fr:tex display="inline">\mathbb {F}</fr:tex>.
    Note that the additive identity of <fr:tex display="inline">\mathcal {L}(V,W)</fr:tex> is the <fr:strong>zero map</fr:strong> <fr:tex display="inline">0: V \to  W</fr:tex> such that
    <fr:tex display="block">         0(v) = 0 \quad  \text {for all} \quad  v \in  V     </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Usually it makes no sense to multiply two linear maps. But we can define
    an operation called the <fr:strong>product</fr:strong> of linear maps, which is just the composition of the two functions.
    This can form a <fr:strong>monoid</fr:strong> or even a <fr:strong>group</fr:strong> under certain conditions.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>601</fr:anchor>
                    <fr:addr type="user">def-002A</fr:addr>
                    <fr:route>def-002A.xml</fr:route>
                    <fr:title text="Product of Linear Maps">Product of Linear Maps</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">T_1: V \to  W</fr:tex> and <fr:tex display="inline">T_2: W \to  U</fr:tex> be linear maps.
    We define the <fr:strong>product</fr:strong> of <fr:tex display="inline">T_1</fr:tex> and <fr:tex display="inline">T_2</fr:tex> as the linear map <fr:tex display="inline">T_2 \circ  T_1: V \to  U</fr:tex> such that
    <fr:tex display="block">         (T_2 \circ  T_1)(v) = T_2(T_1(v)) \quad  \text {for all} \quad  v \in  V     </fr:tex>
    Note that this is just the composition of the two functions <fr:tex display="inline">T_1</fr:tex> and <fr:tex display="inline">T_2</fr:tex>. 
    And we usually denote <fr:tex display="inline">T_2 \circ  T_1</fr:tex> by <fr:tex display="inline">T_2T_1</fr:tex>.
    The product of linear maps is associative, that is,
    <fr:tex display="block">         (T_3 \circ  T_2) \circ  T_1 = T_3 \circ  (T_2 \circ  T_1)     </fr:tex>
    for any linear maps <fr:tex display="inline">T_1: V \to  W</fr:tex>, <fr:tex display="inline">T_2: W \to  U</fr:tex>, and <fr:tex display="inline">T_3: U \to  X</fr:tex>.
    The identity map <fr:tex display="inline">I_V: V \to  V</fr:tex> is the identity element of the set of linear maps <fr:tex display="inline">\mathcal {L}(V,V)</fr:tex> under the product operation.
    That is, for any linear map <fr:tex display="inline">T: V \to  V</fr:tex>,
    <fr:tex display="block">         I_V \circ  T = T \circ  I_V = T     </fr:tex>
    where <fr:tex display="inline">I_V</fr:tex> is the identity map on <fr:tex display="inline">V</fr:tex>.
    The set of all linear maps from a vector space to itself, <fr:tex display="inline">\mathcal {L}(V,V)</fr:tex>, forms a <fr:link type="local" href="def-0007.xml" addr="def-0007" title="Monoid"><fr:strong>monoid</fr:strong></fr:link> under the product operation.
    The set of all invertible linear maps from a vector space to itself, <fr:tex display="inline">\mathcal {L}(V,V)^*</fr:tex>, forms a group under the product operation.
    The identity map is the identity element of the <fr:link type="local" href="def-0001.xml" addr="def-0001" title="Group"><fr:strong>group</fr:strong></fr:link> <fr:tex display="inline">\mathcal {L}(V,V)^*</fr:tex>.</fr:p>
                    <fr:p>With addition we also have the distributive law for the product of linear maps.
    That is, for any linear maps <fr:tex display="inline">S,S_1,S_2: V \to  W</fr:tex> and <fr:tex display="inline">T,T_1,T_2: U\to  V</fr:tex>:
    <fr:tex display="block">         (S_1 + S_2)T = S_1T + S_2T \quad  \text {and} \quad  T(S_1 + S_2) = TS_1 + TS_2     </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>In algebra, we have a structure named <fr:strong>kernel</fr:strong>, which is the set of all elements that are mapped to the zero element.
    For linear maps, the kernel is the <fr:strong>null space</fr:strong></fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>602</fr:anchor>
                    <fr:addr type="user">def-002C</fr:addr>
                    <fr:route>def-002C.xml</fr:route>
                    <fr:title text="Null Space">Null Space</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>For <fr:tex display="inline">T: V \to  W</fr:tex>, the <fr:strong>null space</fr:strong> of <fr:tex display="inline">T</fr:tex> is the set of all vectors in <fr:tex display="inline">V</fr:tex> that are mapped to <fr:tex display="inline">0</fr:tex> in <fr:tex display="inline">W</fr:tex>.
    <fr:tex display="block">         \text {null } T = \{ v \in  V | T(v) = 0 \}     </fr:tex>
    The null space of <fr:tex display="inline">T</fr:tex> is a subspace of <fr:tex display="inline">V</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>The injective linear map is defined like normal <fr:link type="local" href="def-002D.xml" addr="def-002D" title="Injective">injective</fr:link> functions.
    To check whether a linear map is injective, we can just check whether the null space is trivial.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>603</fr:anchor>
                    <fr:addr type="user">thm-000G</fr:addr>
                    <fr:route>thm-000G.xml</fr:route>
                    <fr:title text="Injectivity equivalent to Kernel Triviality">Injectivity equivalent to Kernel Triviality</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">T: V \to  W</fr:tex> be a linear map. Then <fr:tex display="inline">T</fr:tex> is injective if and only if <fr:tex display="inline">\text {null } T = \{ 0 \}</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>The image of a linear map is the set of all elements that are mapped to by some element in the domain.
    This is called the <fr:strong>range</fr:strong> of the linear map, just like <fr:link type="local" href="def-002E.xml" addr="def-002E" title="Range">range</fr:link> of normal function.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>604</fr:anchor>
                    <fr:addr type="user">thm-000H</fr:addr>
                    <fr:route>thm-000H.xml</fr:route>
                    <fr:title text="Range is a subspace">Range is a subspace</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>If <fr:tex display="inline">T: V \to  W</fr:tex> is a linear map, then the range of <fr:tex display="inline">T</fr:tex> is a subspace of <fr:tex display="inline">W</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>The next theorem plays a crucial role in the study of linear maps.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>605</fr:anchor>
                    <fr:addr type="user">thm-000I</fr:addr>
                    <fr:route>thm-000I.xml</fr:route>
                    <fr:title text="Fundamental Theorems of Linear Maps">Fundamental Theorems of Linear Maps</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">V</fr:tex> be finite-dimensional vector space and <fr:tex display="inline">T : V \to  W</fr:tex> be a linear map. 
    Then <fr:tex display="inline">\text {range } T</fr:tex> is finite-dimensional and 
    <fr:tex display="block">         \dim  V = \dim  \text {range } T + \dim  \text {null } T     </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Now we can show that no linear map from a finite-dimensional vector space
    to a <fr:em>smaller</fr:em> (In dimension) vector space can be <fr:link type="local" href="def-002D.xml" addr="def-002D" title="Injective">injective</fr:link>.
    This can be easily proved by the fundamental theorem of linear maps.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>606</fr:anchor>
                    <fr:addr type="user">thm-000M</fr:addr>
                    <fr:route>thm-000M.xml</fr:route>
                    <fr:title text="Map to smaller dimension is not injective">Map to smaller dimension is not injective</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">V</fr:tex> and <fr:tex display="inline">W</fr:tex> be finite-dimensional vector spaces, 
    and <fr:tex display="inline">\dim  V &gt; \dim  W</fr:tex>.
    Then no linear map <fr:tex display="inline">T:V\to  W</fr:tex> is injective.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Similarly, we can show that no linear map from a finite-dimensional vector space
    to a <fr:em>larger</fr:em> (In dimension) vector space can be <fr:link type="local" href="def-002F.xml" addr="def-002F" title="Surjective">surjective</fr:link>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>607</fr:anchor>
                    <fr:addr type="user">thm-000N</fr:addr>
                    <fr:route>thm-000N.xml</fr:route>
                    <fr:title text="Map to bigger dimension is not surjective">Map to bigger dimension is not surjective</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">V</fr:tex> and <fr:tex display="inline">W</fr:tex> be finite-dimensional vector spaces, 
    and <fr:tex display="inline">\dim  V &lt; \dim  W</fr:tex>.
    Then no linear map <fr:tex display="inline">T:V\to  W</fr:tex> is surjective.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>These two lemmas are very important in the study of linear equations.
    The idea here is to express linear equations system in terms of linear maps.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>608</fr:anchor>
                    <fr:addr type="user">eg-0004</fr:addr>
                    <fr:route>eg-0004.xml</fr:route>
                    <fr:title text="Homogeneous Linear Equations System">Homogeneous Linear Equations System</fr:title>
                    <fr:taxon>Example</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Reprase in terms of a linear map the question of whether a <fr:link type="local" href="def-002Q.xml" addr="def-002Q" title="Homogeneous Linear Equations">homogeneous system linear equations</fr:link> has a nonzero solution.</fr:p>
                    <fr:p>Let <fr:tex display="inline">A</fr:tex> be the coefficient matrix of a homogeneous linear system.
        <fr:tex display="block">             A = \begin {bmatrix}                 a_{11} &amp; a_{12} &amp; \cdots  &amp; a_{1n} \\                 a_{21} &amp; a_{22} &amp; \cdots  &amp; a_{2n} \\                 \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                 a_{m1} &amp; a_{m2} &amp; \cdots  &amp; a_{mn}             \end {bmatrix}         </fr:tex>
        The equation <fr:tex display="inline">A\vec {x} = \vec {0}</fr:tex> has a trivial solution <fr:tex display="inline">\vec {x} = \vec {0}</fr:tex>.
        The question here is whether there is a nontrivial solution.</fr:p>
                    <fr:p>Define <fr:tex display="inline">T: \mathbb {F}^n \to  \mathbb {F}^m</fr:tex> by
        <fr:tex display="block">             T(\vec {x}) = A\vec {x}         </fr:tex>
        Then the question of whether the homogeneous linear system has a nontrivial solution is equivalent to 
        asking <fr:tex display="inline">\text {null } T</fr:tex> is nontrivial.
        That is, <fr:tex display="inline">T</fr:tex> is <fr:link type="local" href="thm-000G.xml" addr="thm-000G" title="Injectivity equivalent to Kernel Triviality">not injective</fr:link>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>609</fr:anchor>
                    <fr:addr type="user">thm-000O</fr:addr>
                    <fr:route>thm-000O.xml</fr:route>
                    <fr:title text="Homogeneous system of linear equations">Homogeneous system of linear equations</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A homogeneous system of linear equations
    with more variables than equations has 
    a nontrivial solution.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>We have seen that <fr:link type="local" href="thm-000M.xml" addr="thm-000M" title="Map to smaller dimension is not injective">map to smaller dimension is not injective</fr:link>.
    <fr:tex display="inline">T</fr:tex> is not injective if <fr:tex display="inline">n &gt; m</fr:tex>. This results the theorem above.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>610</fr:anchor>
                    <fr:addr type="user">eg-0005</fr:addr>
                    <fr:route>eg-0005.xml</fr:route>
                    <fr:title text="Inhomogeneous Linear Equations System">Inhomogeneous Linear Equations System</fr:title>
                    <fr:taxon>Example</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Rephrase in terms of a linear map the question of whether a inhomogeneous system linear equations has no solutions
        for some choice of constant terms.</fr:p>
                    <fr:p>Let <fr:tex display="inline">A</fr:tex> be the coefficient matrix of a inhomogeneous linear system.
    <fr:tex display="block">         A = \begin {bmatrix}             a_{11} &amp; a_{12} &amp; \cdots  &amp; a_{1n} \\             a_{21} &amp; a_{22} &amp; \cdots  &amp; a_{2n} \\             \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\             a_{m1} &amp; a_{m2} &amp; \cdots  &amp; a_{mn}         \end {bmatrix}     </fr:tex>
    The equation <fr:tex display="inline">A\vec {x} = \vec {b}</fr:tex> has a solution <fr:tex display="inline">\vec {x} = A^{-1}\vec {b}</fr:tex>.</fr:p>
                    <fr:p>Define <fr:tex display="inline">T: \mathbb {F}^n \to  \mathbb {F}^m</fr:tex> by
        <fr:tex display="block">             T(\vec {x}) = A\vec {x}         </fr:tex>
        Then the statement that inhomogeneous linear system has no solutions is equivalent to 
        <fr:tex display="inline">\vec {b} \not \in  \text {range } T</fr:tex>.
        Thus the question is rephrased as not having a solution for some choice of <fr:tex display="inline">\vec {b}</fr:tex>.
        What condition ensures <fr:tex display="inline">T</fr:tex> is not surjective.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>611</fr:anchor>
                    <fr:addr type="user">thm-000P</fr:addr>
                    <fr:route>thm-000P.xml</fr:route>
                    <fr:title text="Inhomogeneous system of linear equations">Inhomogeneous system of linear equations</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>An inhomogeneous system of linear equations
    with more equations than variables has 
    no solution for some choice of the constant term.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Let <fr:tex display="inline">v_1, v_2, \cdots , v_n</fr:tex> be a basis of <fr:tex display="inline">V</fr:tex>.
    We know that for any value of a linear map <fr:tex display="inline">T:V\to  W</fr:tex>,
    can be determined by values <fr:tex display="inline">\{ T(v_1), T(v_2), \cdots , T(v_n) \}</fr:tex>.
    This leads to the definition of the matrix representation of a linear map.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>612</fr:anchor>
                    <fr:addr type="user">def-002R</fr:addr>
                    <fr:route>def-002R.xml</fr:route>
                    <fr:title text="Matrix">Matrix</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">m,n\in  \mathbb {Z}^+</fr:tex>.
    A <fr:tex display="inline">m\times  n</fr:tex> matrix is a rectangular array of elements of a field <fr:tex display="inline">\mathbb {F}</fr:tex>
    with <fr:tex display="inline">m</fr:tex> <fr:strong>rows</fr:strong> and <fr:tex display="inline">n</fr:tex> <fr:strong>columns</fr:strong>.
    <fr:tex display="block">         A = \begin {bmatrix}             a_{11} &amp; a_{12} &amp; \cdots  &amp; a_{1n} \\             a_{21} &amp; a_{22} &amp; \cdots  &amp; a_{2n} \\             \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\             a_{m1} &amp; a_{m2} &amp; \cdots  &amp; a_{mn}         \end {bmatrix}     </fr:tex>
    The notation <fr:tex display="inline">A_{jk}</fr:tex> refers to the element in the <fr:tex display="inline">j</fr:tex>-th row and <fr:tex display="inline">k</fr:tex>-th column.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Now we can define the matrix representation of a linear map.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>613</fr:anchor>
                    <fr:addr type="user">def-002S</fr:addr>
                    <fr:route>def-002S.xml</fr:route>
                    <fr:title text="Matrix of Linear Maps">Matrix of Linear Maps</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p>Let <fr:tex display="inline">T\in  \mathcal {L}(V,W)</fr:tex>,
    <fr:tex display="inline">\{ v_1,\ldots ,v_n \}\subset  V</fr:tex> be a basis of <fr:tex display="inline">V</fr:tex>,
    and <fr:tex display="inline">\{ w_1,\ldots ,w_m \}\subset  W</fr:tex> be a basis of <fr:tex display="inline">W</fr:tex>.
    The <fr:strong>matrix of <fr:tex display="inline">T</fr:tex></fr:strong> with respect to these bases is
    the <fr:tex display="inline">m\times  n</fr:tex> matrix <fr:tex display="inline">\mathcal {M}(T)</fr:tex> such that
    <fr:tex display="block">         T(v_j) = \sum _{i=1}^m \mathcal {M}(T)_{ij}w_i     </fr:tex>
    Or we denote <fr:tex display="inline">\mathcal {M}(T)</fr:tex> as <fr:tex display="inline">\mathcal {M}(T, (v_1,\ldots ,v_n), (w_1,\ldots ,w_m))</fr:tex>.</fr:p><fr:p>If <fr:tex display="inline">T</fr:tex> maps <fr:tex display="inline">n</fr:tex>-dimensional vector space to <fr:tex display="inline">m</fr:tex>-dimensional vector space,
    then <fr:tex display="inline">\mathcal {M}(T)</fr:tex> is a <fr:tex display="inline">m\times  n</fr:tex> matrix.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>614</fr:anchor><fr:addr type="machine">#326</fr:addr><fr:route>unstable-326.xml</fr:route><fr:title text="
    Addition
">
    <fr:strong>Addition</fr:strong>
</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    For two same-size matrix <fr:tex display="inline">A,B</fr:tex>,
    the sum of <fr:tex display="inline">A</fr:tex> and <fr:tex display="inline">B</fr:tex> is the matrix <fr:tex display="inline">C</fr:tex> such that
    <fr:tex display="block">         C_{ij} = A_{ij} + B_{ij}     </fr:tex>
    In the language of linear maps <fr:tex display="inline">S,T\in  \mathcal {L}(V,W)</fr:tex>,
    <fr:tex display="block">         \mathcal {M}(T+S) = \mathcal {M}(T) + \mathcal {M}(S)     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>615</fr:anchor><fr:addr type="machine">#327</fr:addr><fr:route>unstable-327.xml</fr:route><fr:title text="
    Scalar Multiplication
">
    <fr:strong>Scalar Multiplication</fr:strong>
</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    For a scalar <fr:tex display="inline">c</fr:tex> and a matrix <fr:tex display="inline">A</fr:tex>,
    the product of <fr:tex display="inline">c</fr:tex> and <fr:tex display="inline">A</fr:tex> is the matrix <fr:tex display="inline">B</fr:tex> such that
    <fr:tex display="block">         B_{ij} = cA_{ij}     </fr:tex>
    In the language of linear maps <fr:tex display="inline">T\in  \mathcal {L}(V,W)</fr:tex>,
    <fr:tex display="block">         \mathcal {M}(cT) = c\mathcal {M}(T)     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>616</fr:anchor><fr:addr type="machine">#328</fr:addr><fr:route>unstable-328.xml</fr:route><fr:title text="
    Set of Matrices
">
    <fr:strong>Set of Matrices</fr:strong>
</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    The set of all <fr:tex display="inline">m\times  n</fr:tex> matrices with elements in <fr:tex display="inline">\mathbb {F}</fr:tex> is denoted as <fr:tex display="inline">\mathcal {M}_{m\times  n}(\mathbb {F})</fr:tex>
    or <fr:tex display="inline">\mathbb {F}^{m\times  n}</fr:tex>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>We can see that <fr:tex display="inline">\mathbb {F}^{m\times  n}</fr:tex> is itself a vector space.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>617</fr:anchor>
                    <fr:addr type="user">thm-000Q</fr:addr>
                    <fr:route>thm-000Q.xml</fr:route>
                    <fr:title text="{F}^{m n} = mn">
                      <fr:tex display="inline">\dim \mathbb {F}^{m\times  n} = mn</fr:tex>
                    </fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p><fr:tex display="inline">\mathbb {F}^{m\times  n}</fr:tex> is a vector space with dimension <fr:tex display="inline">mn</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Consider linear maps <fr:tex display="inline">T:U\to  V</fr:tex> and <fr:tex display="inline">S:V\to  W</fr:tex>.
    The composition of linear maps is <fr:tex display="inline">ST</fr:tex>.
    Does the composition of linear maps have a matrix representation?
    <fr:tex display="block">         \mathcal {M}(ST) = \mathcal {M}(S)\mathcal {M}(T)     </fr:tex>
    This makes no sense now but indicates the definition of <fr:strong>matrix multiplication</fr:strong>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>618</fr:anchor>
                    <fr:addr type="user">def-002T</fr:addr>
                    <fr:route>def-002T.xml</fr:route>
                    <fr:title text="Matrix Multiplication">Matrix Multiplication</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p>Let <fr:tex display="inline">A</fr:tex> be a <fr:tex display="inline">m\times  n</fr:tex> matrix and <fr:tex display="inline">B</fr:tex> be a <fr:tex display="inline">n\times  p</fr:tex> matrix.
    Then <fr:tex display="inline">AC</fr:tex> is defined as the <fr:tex display="inline">m\times  p</fr:tex> matrix <fr:tex display="inline">C</fr:tex> such that
    <fr:tex display="block">         C_{ij} = \sum _{k=1}^n A_{ik}B_{kj}     </fr:tex></fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>619</fr:anchor><fr:addr type="machine">#325</fr:addr><fr:route>unstable-325.xml</fr:route><fr:title text="
    Derivation
">
    <fr:strong>Derivation</fr:strong>
</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    Let <fr:tex display="inline">T:U\to  V</fr:tex> and <fr:tex display="inline">S:V\to  W</fr:tex> be linear maps.
    Denote <fr:tex display="inline">A = \mathcal {M}(S)</fr:tex> and <fr:tex display="inline">C = \mathcal {M}(T)</fr:tex>.
    Then the composition of linear maps <fr:tex display="inline">ST</fr:tex> is computed
    <fr:tex display="block">         \begin {align*}             (ST)(u)_k &amp;= S(\sum _{r=1}^n C_{rk}v_r) \\             &amp;= \sum _{r=1}^n C_{rk}S(v_r) \\             &amp;= \sum _{r=1}^n C_{rk}\sum _{s=1}^m A _{sr}w_s \\             &amp;= \sum _{s=1}^m\left (\sum _{r=1}^n C_{rk}A_{sr}\right )w_s \\         \end {align*}     </fr:tex>
    Thus <fr:tex display="inline">\mathcal {M}(ST)</fr:tex> is the <fr:tex display="inline">m\times  p</fr:tex> whose entries are
    <fr:tex display="block">         \mathcal {M}(ST)_{sk} = \sum _{r=1}^n A_{sr}C_{rk}     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Now we see that the desired matrix multiplication holds.
    Matrix multiplication is not commutative in general.
    However, it satisfies the associative law and the distributive law.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>620</fr:anchor>
                    <fr:addr type="user">def-002Y</fr:addr>
                    <fr:route>def-002Y.xml</fr:route>
                    <fr:title text="A_{j} and A_{ j}"><fr:tex display="inline">A_{j\cdot }</fr:tex> and <fr:tex display="inline">A_{\cdot  j}</fr:tex></fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">A</fr:tex> be a <fr:tex display="inline">m\times  n</fr:tex> matrix.
    <fr:ul><fr:li>If <fr:tex display="inline">1\leq  j\leq  m</fr:tex> then <fr:tex display="inline">A_{j\cdot }</fr:tex> is the <fr:tex display="inline">j</fr:tex>-th row of <fr:tex display="inline">A</fr:tex>,
            defined as a <fr:tex display="inline">1\times  n</fr:tex> matrix. (A row vector)</fr:li>
        <fr:li>If <fr:tex display="inline">1\leq  j\leq  n</fr:tex> then <fr:tex display="inline">A_{\cdot  j}</fr:tex> is the <fr:tex display="inline">j</fr:tex>-th column of <fr:tex display="inline">A</fr:tex>,
            defined as a <fr:tex display="inline">m\times  1</fr:tex> matrix. (A column vector)</fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>With the notation we can think of matrix multiplication in another perspective.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>621</fr:anchor>
                    <fr:addr type="user">thm-000R</fr:addr>
                    <fr:route>thm-000R.xml</fr:route>
                    <fr:title text="Entry pf matrix product">Entry pf matrix product</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Suppose <fr:tex display="inline">A</fr:tex> is an <fr:tex display="inline">m\times  n</fr:tex> matrix and <fr:tex display="inline">B</fr:tex> is an <fr:tex display="inline">n\times  p</fr:tex> matrix.
    Then the entry of the product <fr:tex display="inline">AB</fr:tex> is:
    <fr:tex display="block">         (AB)_{ij} = A_{i\cdot }B_{\cdot  j}     </fr:tex>
    for <fr:tex display="inline">1\leq  i\leq  m</fr:tex> and <fr:tex display="inline">1\leq  j\leq  p</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>We have an interesting observation.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>622</fr:anchor>
                    <fr:addr type="user">thm-000S</fr:addr>
                    <fr:route>thm-000S.xml</fr:route>
                    <fr:title text="Linear Combination of columns">Linear Combination of columns</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">A</fr:tex> be an <fr:tex display="inline">m\times  n</fr:tex> matrix,
    and <fr:tex display="inline">c</fr:tex> is a <fr:tex display="inline">1\times  1</fr:tex> matrix.
    <fr:tex display="block">         c = \begin {pmatrix} c_1 \\ c_2 \\ \vdots  \\ c_n \end {pmatrix}     </fr:tex>
    Then <fr:tex display="inline">Ac = c_1A_{\cdot  1} + c_2A_{\cdot  2} + \cdots  + c_nA_{\cdot  n}</fr:tex>.
    In other words, <fr:tex display="inline">Ac</fr:tex> is a linear Combination of the columns of <fr:tex display="inline">A</fr:tex>,
    with the scalars that multiply the columns coming from <fr:tex display="inline">c</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Now we begin the study the invertibility of linear maps.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>623</fr:anchor>
                    <fr:addr type="user">def-002Z</fr:addr>
                    <fr:route>def-002Z.xml</fr:route>
                    <fr:title text="Inverse">Inverse</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A linear map <fr:tex display="inline">T\in \mathcal {L}(V,W)</fr:tex> is said to be <fr:tex display="inline">invertible</fr:tex> if 
    there exists a linear map <fr:tex display="inline">S\in \mathcal {L}(W,V)</fr:tex> such that:
    <fr:tex display="block">         \begin {align*}             T\cdot  S &amp;= \text {id}_V \\             S\cdot  T &amp;= \text {id}_W         \end {align*}     </fr:tex>
    where <fr:tex display="inline">\text {id}</fr:tex> is the identity map.
    If a linear map <fr:tex display="inline">T</fr:tex> is invertible, 
    then the map <fr:tex display="inline">S</fr:tex> is <fr:strong>unique</fr:strong> and is called the <fr:strong>inverse</fr:strong> of <fr:tex display="inline">T</fr:tex>, denoted <fr:tex display="inline">T^{-1}</fr:tex>.</fr:p>
                    <fr:p>An <fr:strong>isomorphism</fr:strong> is a linear map that is invertible.
    Two vector spaces are said to be <fr:strong>isomorphic</fr:strong> if there exists an isomorphism between them.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>A linear map is invertible if and only if
    it is <fr:strong>bijective</fr:strong>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>624</fr:anchor>
                    <fr:addr type="user">thm-000T</fr:addr>
                    <fr:route>thm-000T.xml</fr:route>
                    <fr:title text="Isomorphism of equal dimensions">Isomorphism of equal dimensions</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Two finite-dimensional vector spaces over <fr:tex display="inline">\mathbb {F}</fr:tex>
    are isomorphic iff they have the same <fr:link type="local" href="def-001V.xml" addr="def-001V" title="Dimension">dimension</fr:link>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>625</fr:anchor>
                    <fr:addr type="user">thm-000U</fr:addr>
                    <fr:route>thm-000U.xml</fr:route>
                    <fr:title text="{L}(V,W) is isomorphic to {F}^{m n}"><fr:tex display="inline">\mathcal {L}(V,W)</fr:tex> is isomorphic to <fr:tex display="inline">\mathbb {F}^{m\times  n}</fr:tex></fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">v_1, v_2, \ldots , v_n</fr:tex> be a basis for <fr:tex display="inline">V</fr:tex>,
    and <fr:tex display="inline">w_1, w_2, \ldots , w_m</fr:tex> be a basis for <fr:tex display="inline">W</fr:tex>.
    Then <fr:tex display="inline">\mathcal {M}</fr:tex> is an isomorphism between <fr:tex display="inline">\mathcal {L}(V,W)</fr:tex> and <fr:tex display="inline">\mathbb {F}^{m\times  n}</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>This has a trivial corollary.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>626</fr:anchor>
                    <fr:addr type="user">thm-000V</fr:addr>
                    <fr:route>thm-000V.xml</fr:route>
                    <fr:title text="Dimension product">Dimension product</fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">V</fr:tex> and <fr:tex display="inline">W</fr:tex> be finite-dimensional vector spaces.
    Then <fr:tex display="inline">\mathcal {L}(V,W)</fr:tex> is finite-dimensional and
    <fr:tex display="block">         \dim (\mathcal {L}(V,W)) = \dim (V)\dim (W).     </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>627</fr:anchor>
                <fr:addr type="user">math-0006</fr:addr>
                <fr:route>math-0006.xml</fr:route>
                <fr:title text="Category Theory of Utilitarianism">Category Theory of Utilitarianism</fr:title>
                <fr:taxon>Category Theory</fr:taxon>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter><fr:p>This note is about the category theory and its applications.
    Instead of reading a well-organized book, I prefer to write down the things I learned
    from <fr:link type="local" href="ncatlab.xml" addr="ncatlab" title="NLab">ncatlab</fr:link> and papers.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>628</fr:anchor><fr:addr type="machine">#316</fr:addr><fr:route>unstable-316.xml</fr:route><fr:title text="
    Ideas">
    <fr:strong>Ideas</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        Intuitively, a category is a collection of objects and arrows between them,
        such arrows can be composed and there is an identity arrow for each object.
    <fr:p>There are commonly two ways to define a category, which are equivalent in usual 
        foundations of mathematics. One of them generalizes the notion of <fr:strong>internal category</fr:strong>
        nicely while the other one is more convenient for <fr:strong>enriched category</fr:strong>.</fr:p>
    <fr:p>The major difference is whether they use a single collection of all morphisms or
        several collections of morphisms (<fr:strong>family of collections</fr:strong> indexed by pairs of objects)</fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>629</fr:anchor><fr:addr type="user">def-003E</fr:addr><fr:route>def-003E.xml</fr:route><fr:title text="Category">Category</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>630</fr:anchor><fr:addr type="machine">#319</fr:addr><fr:route>unstable-319.xml</fr:route><fr:title text="With one collection"><fr:strong>With one collection</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex display="inline">C</fr:tex> consists
    <fr:ul><fr:li>A collection of <fr:strong>objects</fr:strong> <fr:tex display="inline">C_0</fr:tex> (<fr:tex display="inline">\text {Ob}(C)</fr:tex>).</fr:li>
        <fr:li>A collection <fr:tex display="inline">C_1</fr:tex> (<fr:tex display="inline">\text {Mor}(C)</fr:tex>) of <fr:strong>morphisms</fr:strong> (arrows).</fr:li>
        <fr:li>For every morphism <fr:tex display="inline">f</fr:tex> there are an object <fr:tex display="inline">s(f)</fr:tex> (<fr:strong>source</fr:strong>, domain) and an object <fr:tex display="inline">t(f)</fr:tex> (<fr:strong>target</fr:strong>, codomain).</fr:li>
        <fr:li>For every pair of morphisms <fr:tex display="inline">f, g</fr:tex> such that <fr:tex display="inline">t(f) = s(g)</fr:tex>, there is a morphism <fr:tex display="inline">g \circ  f</fr:tex> (<fr:strong>composition</fr:strong>) (Also written <fr:tex display="inline">gf</fr:tex> or <fr:tex display="inline">f;g</fr:tex>).</fr:li>
        <fr:li>For every object <fr:tex display="inline">x</fr:tex>, there is a morphism <fr:tex display="inline">\text {id}_x</fr:tex> (or <fr:tex display="inline">1_x</fr:tex>) called <fr:strong>identity</fr:strong>.</fr:li>
        <fr:li>The following properties hold:
            <fr:ul><fr:li><fr:tex display="inline">s(g \circ  f) = s(f)</fr:tex> and <fr:tex display="inline">t(g \circ  f) = t(g)</fr:tex>.</fr:li>
                <fr:li><fr:tex display="inline">s(1_x) = x</fr:tex> and <fr:tex display="inline">t(1_x) = x</fr:tex>.</fr:li>
                <fr:li>Composition is <fr:strong>associative</fr:strong>: <fr:tex display="inline">h \circ  (g \circ  f) = (h \circ  g) \circ  f</fr:tex> when <fr:tex display="inline">t(f) = s(g)</fr:tex>, and <fr:tex display="inline">t(g) = s(h)</fr:tex>.</fr:li>
                <fr:li>Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex display="inline">f \circ  \text {id}_x = f</fr:tex> and <fr:tex display="inline">\text {id}_y \circ  f = f</fr:tex></fr:li></fr:ul></fr:li></fr:ul>
    If the identity map and its axioms are omitted then one speaks of a <fr:strong>semicategory</fr:strong>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>631</fr:anchor><fr:addr type="machine">#320</fr:addr><fr:route>unstable-320.xml</fr:route><fr:title text="With a family of collections of morphisms"><fr:strong>With a family of collections of morphisms</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex display="inline">C</fr:tex> consists
    <fr:ul><fr:li>A collection of <fr:strong>objects</fr:strong> <fr:tex display="inline">C_0</fr:tex> (<fr:tex display="inline">\text {Ob}(C)</fr:tex>).</fr:li>
        <fr:li>For every pair of objects <fr:tex display="inline">x, y</fr:tex>, a collection <fr:tex display="inline">C_1(x, y)</fr:tex> (<fr:tex display="inline">\hom _C(x,y)</fr:tex>) of <fr:strong>morphisms</fr:strong> from <fr:tex display="inline">x</fr:tex> to <fr:tex display="inline">y</fr:tex>.</fr:li>
        <fr:li>For each pair of morphisms <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex> and <fr:tex display="inline">g</fr:tex> in <fr:tex display="inline">C_1(y,z)</fr:tex>, a morphism <fr:tex display="inline">g \circ  f</fr:tex> in <fr:tex display="inline">C_1(x,z)</fr:tex>.
            called their <fr:strong>composition</fr:strong>.</fr:li>
        <fr:li>For each object <fr:tex display="inline">x</fr:tex>, a morphism <fr:tex display="inline">\text {id}_x</fr:tex> in <fr:tex display="inline">C_1(x,x)</fr:tex> called the <fr:strong>identity</fr:strong> on <fr:tex display="inline">x</fr:tex>.</fr:li>
        <fr:li>The following properties hold:
            <fr:ul><fr:li>Composition is <fr:strong>associative</fr:strong>: <fr:tex display="inline">h \circ  (g \circ  f) = (h \circ  g) \circ  f</fr:tex> for all <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex>, <fr:tex display="inline">g</fr:tex> in <fr:tex display="inline">C_1(y,z)</fr:tex>, and <fr:tex display="inline">h</fr:tex> in <fr:tex display="inline">C_1(z,w)</fr:tex>.</fr:li>
                <fr:li>Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex display="inline">f \circ  \text {id}_x = f</fr:tex> and <fr:tex display="inline">\text {id}_y \circ  f = f</fr:tex> for all <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex>.</fr:li></fr:ul></fr:li></fr:ul>
    Usually we write <fr:tex display="inline">\text {Mor}(C)</fr:tex> for the disjoint union <fr:tex display="inline">\bigsqcup _{x,y \in  C_0} C_1(x,y)</fr:tex>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Its common to talk about some objects and their morphisms.
    Informally, a <fr:strong>diagram</fr:strong> in a category <fr:tex display="inline">C</fr:tex> consists of some 
    objects of <fr:tex display="inline">C</fr:tex> connected by some morphisms of <fr:tex display="inline">C</fr:tex>.</fr:p><fr:p>This terminology is often used when speaking about <fr:strong>limits</fr:strong> or 
    <fr:strong>colimits</fr:strong> of a diagram.</fr:p><fr:p>One formal way to define a diagram is to use a <fr:strong>functor</fr:strong> from a (very) small category to <fr:tex display="inline">C</fr:tex>.
    That is, a functor whose domain is a small category.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>632</fr:anchor><fr:addr type="user">def-003F</fr:addr><fr:route>def-003F.xml</fr:route><fr:title text="Small Category">Small Category</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link type="local" href="def-003E.xml" addr="def-003E" title="Category">category</fr:link> is said to be <fr:strong>small</fr:strong> 
    if it has a <fr:strong>samll set</fr:strong> (i.e. a set but not a proper class) of objects and morphisms.
    In other words a small category is an <fr:strong>internal category</fr:strong> in category of sets.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We did not explain what a <fr:strong>functor</fr:strong> is, but it is very natural thought.
    Briefly, a functor is a <fr:strong>homomorphism</fr:strong> between two categories.
    It maps objects to objects and morphisms to morphisms, preserving the structure of the categories.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>633</fr:anchor><fr:addr type="user">def-003G</fr:addr><fr:route>def-003G.xml</fr:route><fr:title text="Functor">Functor</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>functor</fr:strong> <fr:tex display="inline">F</fr:tex> from a category <fr:tex display="inline">C</fr:tex> to a category <fr:tex display="inline">D</fr:tex> is a map
    sending each <fr:tex display="inline">x\in  C</fr:tex> to an object <fr:tex display="inline">F(x)\in  D</fr:tex> and each morphism
    <fr:tex display="inline">f:x\to  y</fr:tex> in <fr:tex display="inline">C</fr:tex> to morphism <fr:tex display="inline">F(f):F(x)\to  F(y)</fr:tex> in <fr:tex display="inline">D</fr:tex>, such that 
    <fr:ul><fr:li>Composition is preserved: <fr:tex display="inline">F(g\circ  f) = F(g)\circ  F(f)</fr:tex>.</fr:li>
        <fr:li>Identity is preserved: <fr:tex display="inline">F(\text {id}_x) = \text {id}_{F(x)}</fr:tex>.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>For the sake of completeness, we state the definition of the <fr:strong>functor category</fr:strong>
    and the <fr:strong>natural transformations</fr:strong> between functors.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>634</fr:anchor><fr:addr type="user">def-003I</fr:addr><fr:route>def-003I.xml</fr:route><fr:title text="Functor Category">Functor Category</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex> be categories, the functor category <fr:tex display="inline">D^C</fr:tex> 
    (or <fr:tex display="inline">[C,D]</fr:tex>) is the category whose
    <fr:ul><fr:li>objects are functors from <fr:tex display="inline">C</fr:tex> to <fr:tex display="inline">D</fr:tex>.</fr:li>
        <fr:li>morphisms are <fr:strong>natural transformations</fr:strong> between functors.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>635</fr:anchor><fr:addr type="user">def-003J</fr:addr><fr:route>def-003J.xml</fr:route><fr:title text="Natural Transformation">Natural Transformation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex> be categories and <fr:tex display="inline">F,G:C\to  D</fr:tex> be functors.
    A <fr:strong>natural transformation</fr:strong> <fr:tex display="inline">\alpha :F\Rightarrow   G</fr:tex> is 
    an assignment to every object <fr:tex display="inline">x\in  C</fr:tex> of a morphism <fr:tex display="inline">\alpha _x:F(x)\to  G(x)</fr:tex> in <fr:tex display="inline">D</fr:tex>,
    (called the <fr:strong>component</fr:strong> of <fr:tex display="inline">\alpha </fr:tex> at <fr:tex display="inline">x</fr:tex>)
    the following diagram commutes in <fr:tex display="inline">D</fr:tex>:
    
 
  
  <fr:figure><fr:resource hash="b5e91e181820d504fc4e45a8daad99b3"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE2MC42MTcwMTFwdCcgaGVpZ2h0PScxMDkuODE1MzkycHQnIHZpZXdCb3g9Jy03MiAtNzIgMTA3LjA3ODAwNyA3My4yMTAyNjInPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS1dvdU5HaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREpBQUFCTXUwS2tleHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHFPK0h2ZmorVzIrTWpDek1JREE0LzFmWnlQby80eE1sNWxCWEE0R0poQUZBRjJLRENnQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1RdkNNQkNGdjJJVnJZT0Q0T0Fnd1I5UXRBb3ViZzVPcmc1dTFnVHAwRlRTV25RUmY3clhFTHlRNDd2MzNoMlE4Q0dpcTRpSjcxM0Y4aWFCKzR5WkJoNkl2Z2ljTUdkSmp5Z2VpYkpnSHpobXlDVndueGw1NElIb3I4QUpXNzZIcW53OEcrUFVxZExHMlZ2cGRtZmo2cUt5YXAydXV2Rm9ySEhYeG1pVnY1VnVpN3E5bDJxVFptbkdnWXFTQjA4YURBN0ZTUlR0MlhJVHo3SGo3T2VhUWp3cm1UVXBxNzk3Rk5mNnhOVmYwWkxJZVV2WHRMSlRTNzlMVnJHUnZhejdQMWt5TGswQUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSOEFBb0FBQUFBQlRnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWk4xZ1dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFETVoyeDVaZ0FBQVdRQUFBRy9BQUFDRUgxRjE0eG9aV0ZrQUFBREpBQUFBQzhBQUFBMktlc3RKMmhvWldFQUFBTlVBQUFBSGdBQUFDUUdHUUtaYUcxMGVBQUFBM1FBQUFBTUFBQUFEQWxxQUx4c2IyTmhBQUFEZ0FBQUFBZ0FBQUFJQUlvQkNHMWhlSEFBQUFPSUFBQUFGd0FBQUNBQUJRQmFibUZ0WlFBQUE2QUFBQURPQUFBQk9QTmRLcDl3YjNOMEFBQUVjQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1WbWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwV01GUXlNL3dIOHBraDBraHEvZ09GQWI4ZURRVUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aVYvLzhEeVlyLy8vOTNndmtNQUZjckJ0VjQya1dRMzJyVFlCakc4N3hKazNacGtpWk52L1JQbG5WZGtpOWQyMlJ0bGtSUjJqSW1va3dtYklLaU1zRWpEN3dDUmZBU3ZBQlBSZkFPUE5jNzhFNDhkbjVSUk43bjVQM3p2UEQ4SkVoWDF6L3BLNzVManlVSktUUVRtbXBCS0VERnlxcXNQT2E1bWxwWHpFMksrUnI1aW5sTTFkZ2VWdVVHWlNGY3NWaG5pUGx4VlZ0SzVxMVJpU3RUZkN6aWt0NjZVU1BPZHpSclR3VW83VWZQQm1EdEpoSzlrMThPSHU0N0o0OGV5RFR0MlNQQUduZWQvdVMya1JoWWpNWlh3NmI1NTlCYVhRYm5vODQybjUwUmtxd0hFeCtNQm1qTzdPMmJ2dDQ5Rk5icTFBS1I3cThzNDBqQllPRW54Tk5vN0hxTnhOUmxXczQvM25TU0FGVGVONGxvWnpjMzIwc0YvcXlYRVY5TVFveE1lUzRKRE5MejY1Uys0SnQwTGhwWkVFbnhQM2FBWElRVHFrbnhtTWQxNHJqbVp1S0EvME1Rd0ZQcm1hQllNOXJRWHlDTVByM1kvZnowNUM2UWVNNFFjQ1pPWmgzZGNRNkNscnVaVjhXeEFpOHlnQ0JjTzNLemJUUVI2RFkvWGE1QnVoY0NXWGdyNmdUUUM0VUZGZ1B3N3RmN2w2K0JuSWVoeTFxSHV0V2lhVGU4TjdQSElOKy84QytlRFB3RTJCWjZTMFR1NVk0dDBPUjg2TjU0TlZzbVVDSXIwcVkvV0FMSEprbjZEU3FPUWZVQWVOcGpZR1JnWUFCaVYyRXp6bmgrbTY4TXpDd01JUEI0LzlmWkNQcS9Ibk1JNHpFZ2w0T0JDU1FLQUJuMkN2a0FlTnBqWUdSZ1lHYjR6d0FrUXhoaUdSeVpkakVBUlZBQU13QkN4UUs1QUFBRFZBQUFBeW9BWHdMc0FGMEFBQUFBQUlvQkNIamFZMkJrWUdCZ1pvaGtBTkVNVUJJSkFBQUphUUJnQUhqYVRZdzliOEl3RUlhZmlBU0pNTENnRGgyS2g4NFJCRmk3TURDeE1yRUFkbEVHMjhnSmtaQ3FqdjNkdmJnZWVwSlB6L3R4QmtxK3lSZ21ZeGIzTURtRnFEOHVtREpQUEJhMVNGenl5anNqc253aXpoc2ZpWE5KVG9rTFh2aE1QQmIvSzNISmhwK2R0L2RIWjRJNmVHMkN1MXJiYkk4bXRJMTNhbFV0bzk0Ylo4SzVNMXBkbmtyM1RkdmZyRnBYZFZXencyTzU4NkRERUZBY3hOR1JIVmZKTEExYmp0RnBoYjM0aWhVVnkzLzVYbklYTytmNGs1Yk9oYWRzVFMrTlZ2Wk51b3ExWE5iRCt3WElteS94QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVg4QUFvQUFBQUFCeUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXRjAybU50WVhBQUFBRTRBQUFBTlFBQUFEd0F2UUJ6WjJ4NVpnQUFBWEFBQUFNa0FBQUQzT2hicVBGb1pXRmtBQUFFbEFBQUFDOEFBQUEyS2FJdU5XaG9aV0VBQUFURUFBQUFIZ0FBQUNRR0xBRzhhRzEwZUFBQUJPUUFBQUFVQUFBQUZBeHNBSlpzYjJOaEFBQUUrQUFBQUF3QUFBQU1BZTRDNEcxaGVIQUFBQVVFQUFBQUZ3QUFBQ0FBQndCYWJtRnRaUUFBQlJ3QUFBRFVBQUFCUHBrUmRjZHdiM04wQUFBRjhBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXFtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHE2TVZReU0vd0g4cGtoMGtocS9nT0ZBZGtIRFNzQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS3VqTlUvdjhQNUxzeFZQei8vMy8zLzI2d0tpQUFBSmNiQ1NvQUFBQjQyaVdTUzQvYlZCaUcvWjVqK3lTT2I0bHZtZGl4azB6R1RpWTBrOG5GVHRJeXFVWXRVNGJlbUtLSyt3YllWT3hhSVNGVmJLZzZRdUlIQUJJL2dtVi9BSWdmd0o0MVc2U3lBVTM0UEdOWlBqNzZQbHZuZWI5SGdwUnR0eHpzbFhRcVNSQnFvUG9KbXdhdWVnQ1JwZGs4RC95OGNEWVlRNlgzYnU1YmNOTU5Gbms2UXFvS1BxTnlIa3dUVU1IRWJpOHI4aXhQZDVGdkZFRDM4b2pMbHZqeHZLckFNdGV4Y2k0RGV5dkx4bXRINTE0SWhWMy81RHh4bE9OUE43bkZkY0VaNUNWWFJJMXhqYkZPZ1h0Ym4xV3JqRUUzVlhBcVZ5MFZjR0lXMTRVaDVFZ0FWZWVYU05ZbXJYVUJlK2ZpUHd5dUIweFJtZm1uVWRIMWtmQ2JFbDJRWnR1L2VJMzlJZDJuRGFlakV0MEc4OVFrYUF0cUVLUHdDMkxaNEFqcEFkUWpKS3lZbXNoUzFXTFVORVpXdHBaclh2WVZmdUFIaE81ejdTWlhOUUprZVB6eitlaDJzMll6K2ZuOWNPazBpc0FVTUp3aWdTbnVuSHhwb0NidkIycFhVNWlvdGl0R21xN2YrdVlIeGgvTlQ1KytlRFFjcUhkTTZPejNpMy9wS3lhczlNTW51SnQvL05IK2V6dlBQZ2V6RmExNXNvb2FGY1o0VkFHNDNDTDRSdWZiekZQQmhwN2RzWnJnUHozLzd0bnAvSXpML1QzemdjbjRGWHU4ZmMwaS9DYTlUeHVDOWR3WWhEQUxmTThscEV1b2N1bWwyUkdLcWUrcXdrOG9oK0lJaXpFRXpabDBJQmt1dVhNL29BbzlUWkppTWMrTE1pMzZLUjd2R25KcmRSYkNFRXBjczRmSDQwSmpZVFR0cnhtU3ByNFRPYmJ0OUdaNk8yUjc5ZkRkTnFzSkJYR3RNVGh1SG52Vi9JMzJUWTUrNWtSKzNYS252dUpoOGYzQ3M4TUJYejNRd1NydW9Wcy9rSEVRYTBsWDd2WmFYZGo3Ylprc3dYcnk1S2svQ3NHV0QzVlFjdTdVcVU5a3hJZHV3UkZuU1FUUGNEc3lXU1FQdGRGVkhtUDhnMStsdDY5Y0lINlMreElwaTB2cThpYm8wbjhpdm9xZ1ZHYU15d2hpZUJTUjZxbGxGQnRPL2djZS92NHNlSGsydWJIblZ1a2tXV0JOamY3U2phUHE2TWJrSFJZbEprZGRoSVhQVlNGa05HcU56aks3VmpIbUNOUFptM3pzbVkxR3lQSHk0dXNQdm1JNHZKc0FadENPZU5zQyt1SHczdUFhVU56cWZmRXdHVFExWUhXaTA5RHRTYXRKa1V4MnJTaDVjYnM5Wi9JdDY5Vlo0U1BVYU96L0E0UEdmWUY0Mm1OZ1pHQmdBR0lwbVRmVzhmdzJYeG1ZV1JoQTRQSCtyN01SOUg4OVptNm1LMEF1QndNVFNCUUFPSEFMaFFCNDJtTmdaR0JnWnZqUEFDUlZHZVQrVDJUbVpnQ0tvQUJXQUVnWUF1NEFBQUoyQUFBQ2tnQW5BeVVBTXdKSkFCNEI5Z0FlQUFBQUFBQjBBUElCZWdIdWVOcGpZR1JnWUdCbGlHUUEwUXhRRWdrQUFBbWZBR0lBZU5wTmpyRnF3ekFVUlkrcFk2aGJ5SlFNSFlxbWpNWjIrZ0dGREpteVppd2trUWd1U0FxeVk4Z1MrZ0g5NkQ0ckd2cUVIa2ZuWFFrQkpYY3lwc3FZeHo1VlRpR25CODk0WVpHNGtLVVNsN3l4NG9rc2Z4Ynp6bWZpbkZlK0VzOVk4cDI0RVArVHVPU0QzNDIzbCt0Z2d0cDViWUk3V2RzMTlkNkV2dk5PTlZYOUVGdmpURGdNUnF2alRlbXg2OGV6VmV1cXJWbzJlQ3dYcmd3WWd2eHNKMFpIZHB4a1p1bG9xTmxIMTh2SnkwU0pxOFQrVDJ3bDRXTHFFRi9Ua2pweWs2NFpKZE5MUDB0YXNaYTc3YlQvQU9DQ01MMTQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVc0QUFvQUFBQUFCckFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hlRjRlR050WVhBQUFBRThBQUFBTlFBQUFFUUFld1JqWjJ4NVpnQUFBWFFBQUFMZEFBQURiSzJKM1dWb1pXRmtBQUFFVkFBQUFDOEFBQUEyS2ZjdU5HaG9aV0VBQUFTRUFBQUFIZ0FBQUNRR29nSXBhRzEwZUFBQUJLUUFBQUFVQUFBQUZBNXJBUmxzYjJOaEFBQUV1QUFBQUF3QUFBQU1BYndDbm0xaGVIQUFBQVRFQUFBQUdBQUFBQ0FBQ0FCUGJtRnRaUUFBQk53QUFBRFBBQUFCT1BOaEtxTndiM04wQUFBRnJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzUTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFIwWTk3SXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBZVZnNU1BSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGszQm5TbURmKy93OWt1VUZZLzNmL24vc25HS3dXREFEMlpBdmJBQUFBZU5wRmtrOXZHMFVZaC9mM3puakg2N1YzMXV2MXJ1dkUzc1pqNzZaS0V4ZHZ0QnRDNmsxYkdsSTNiUnFKcWswcTZEK3BFWENnQjFTaDNub3BOMVJWUFhCQkFuSGhEQnk0MHk4QVJ6NER4M0tObWEwRWFLU1Izdm5OYU9hWjV6VmdmRENmc3h2MHE3RmpHQkJtNktkaDVtQU1NWWl6TU1qeVZwWm44UmltcnBheVFDSlFjYmtpVkd3S2x1b05VNlNUVUpLcEJrbEJXYXp3Y2NFUlpRclMvTzRyaVdaamM5Rjh6Z0RMVFNKNERpbS93VnBvK1JWaUZ4OStHN21WQzhmRmxzT0U3WUxuZ2xzdW1Ba2FiV0EybDd4SlhBbHdIZ21nMWFOT3JTNTB5QWE2dElLZnU2eTdYdVJBSXppWlkvUmV3NWIrbjE1Rk5oWmFuY0RRT01idS9DOTJqLzR3cnVtQ09WQkpuQlJZUTZMZjdrQUVvUjc1SkN0WUZpZXhNS2VJS0orRVRwbHJJTDFQSDlHejV0VWppQkNFdWY0VGRyZGdvbTdyZHdEMzc2eStQSGozTXZoMnZiRXptejdwMkI1Z2QzcjltS1E0dVBuWUlaTG1Ta2NFZnFVZFdXZWVYWDcxSTlqdGpmMm5MKzZzbVdmTldWMDQ5TnZKWEZhSnJFYnY5dWRFNDcydG4yNStNYkdyeTdReUhzNnFsa1VNYktrS0J1NUt6ZDA4L2RIMVhpWHhWa2JzaDZmUEgrK21OeGhYWERYMkhXSWw4OVg1bUQ2bDM0M3RrbG5pTGVrZ1RyUW1UV3NLalRGRndWUXBOSjNpcmI1QU15djlCVm11VFRza2tXYUJtZUQ3VFplN1hldkNPOHVid0xBZE04aElTamxjWXIwMXVkZW5sanlRYlNlNHFNNXNBU3JRdWR1WDB2UDZ0V3IzYmhuajFjbnJXWE43M2IvRVl0VS9UVU16c1MwQ3Y5cis1dTlicGNSYmh3dEpQQnIrSCtGVXZQbzFIMVNoOVJsa0ZQTTM5QXRlRzJzbHphaVBYUGZiZXFxMSthWXdZNjFIL0tlbmoxQ2psZTBZb1krU1c4ditWM1hvYS9hTXp2SEFyZzNyWHMxRXVucHE2cC85Y3Zmb0h2R2Rwbjl3ZlAyVE9vRXVMVlpFVGNkZEszckp3U3Zuemk5Y0d5WDY0alI2OHVKb21jTmJ0RUUxTHlWU21VcEJ4MWNlN1B2dSt3eEhlL2JTNU1OSGJnMUU3WjNtbGM4T3gycHl5S0JXTjU0dHJKOEhEZjRCRURkNkh3QUFBSGphWTJCa1lHQUE0cXZGUEkzeC9EWmZHWmhaR0VEZzhmNnZzeEgwZjMzbUJLWkxRQzRIQXhOSUZBQlM0UXhSQUhqYVkyQmtZR0JtK004QUpQc1k3UDlQWlU1Z0FJcWdBRllBVy9NRDBRQUFBc1lBQUFMbEFFY0RqZ0JJQWpvQVN3TDRBRDhBQUFBQUFHNEE2QUZPQWJaNDJtTmdaR0JnWUdYd1kyQmlBQUZHQmpRQUFBaWpBRmg0MmsyTVBXL0NNQkNHbjRnRWlUQ3dvQTRkaW9mT0VRUWt0aTRNVEt4TUxJQmRsTUUyY2tJa3BLcGpmM2N2cm9lZTVOUHpmcHlCa204eWhzbVl4VDFNVGlIcWp3dW16Qk9QUlMwU2w3enl6b2dzbjRqenhrZmlYSkpUNG9JWFBoT1B4ZjlLWExMaForZnQvZEdab0E1ZW0rQ3UxamJib3dsdDQ1MWFWY3VvOThhWmNPNk1WcGVuMG4zVDlqZXIxbFZkMWV6d1dPNDg2REFFRkFkeGRHVEhWVEpMdzVaamRGcGhMNzVpUmNYeVg3NlgzTVhPT2Y2a3BYUGhLVnZUUzZPVmZaT3VZaTJYOWZCK0Fjd3JML2tBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMktSY3VNMmhvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGpLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaUQrOTJQWS9udC9uS3dNekNBQUtQOTMrZGphRC9NekExTUlPNEhBeE1JQW9Ba2pzTkdnQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZdzlpOEpBRUlhZllDSVlDeHV4c0xqYndqb2swZm9hQ3l0YnEydlVYU1ZGTnJLSkFVRXM3M2M3V1JkdVlJZm4vWmdGVWw1RURCTXg4M3VZbUVUVWh4T216QU9QUlgwSFRsbXlZa1FVVDhUNTRpZHdMTWx2NElRRmw4Qmo4WitCVXpiOGJadjZkdStNVS90R0cyZlB0U3Z5ZzNGdDFWaFZaTG5YTzJPTk8zWkdxOU5ENmI1cSsydXQxbG1abFd4cHFMbHhwOFBnVU96RjBaNHRaOGtjQlRrSDc3UlVrbHBwRldUaS91Yzd5YTN2SFAxUFdqb25IckkxdlZ5MXNxL1NWcXpsc2h6ZUcyUEhMeEVBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE4LjQ2MDk5OSwtMzMuOTc3MjkxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01My43Mzk3OCwtMjkuMTU5NzcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xOC40NjA5OTksLTMzLjk3NzI5MSlzY2FsZSgtMSwtMSknPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNTMzNjU0LC04Ny4wOTc2Mzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMC42NTYyNywwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zLjUzMzY1NCwtODcuMDk3NjM5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zLjUzMzY1NCcgeT0nLTg3LjA5NzYzOSc+RjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc0LjI1NjYwMicgeT0nLTg3LjA5NzYzOSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc4LjEzMDk3NScgeT0nLTg3LjA5NzYzOSc+eDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScxMy44MjQ5MDgnIHk9Jy04Ny4wOTc2MzknPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzUuMzAzOTk2LC04Ny4wOTc2Mzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzMuOTE1NjU3LC04Ny4wOTc2Mzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMC40Mjk0MywwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDczLjkxNTY1NywtODcuMDk3NjM5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9JzczLjkxNTY1NycgeT0nLTg3LjA5NzYzOSc+RjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc4MS43MDU5MTMnIHk9Jy04Ny4wOTc2MzknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nODUuNTgwMjg3JyB5PSctODcuMDk3NjM5Jz55PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzkwLjgyMjIzJyB5PSctODcuMDk3NjM5Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjUzMzY1NCwtNjMuMDI4MTI1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjUzMzY1NCwtMzMuOTc3MjkxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTAuNjc3NzgsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMy41MzM2NTQsLTMzLjk3NzI5MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMy41MzM2NTQnIHk9Jy0zMy45NzcyOTEnPkc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNC4yOTk0NjMnIHk9Jy0zMy45NzcyOTEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nOC4xNzM4MzcnIHk9Jy0zMy45NzcyOTEnPng8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTMuODY3NzY5JyB5PSctMzMuOTc3MjkxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM1LjMwMzk5NiwtMzMuOTc3MjkxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDczLjkxNTY1NywtMzMuOTc3MjkxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTAuNDUwOTQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg3My45MTU2NTcsLTMzLjk3NzI5MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSc3My45MTU2NTcnIHk9Jy0zMy45NzcyOTEnPkc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nODEuNzQ4Nzc0JyB5PSctMzMuOTc3MjkxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jzg1LjYyMzE0OCcgeT0nLTMzLjk3NzI5MSc+eTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc5MC44NjUwOTEnIHk9Jy0zMy45NzcyOTEnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS0yMy41OTQ2NSAyNi42NTk3N0gyMy42NDgzNicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMy44NDgzNCwyNi42NTk3NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOC4zMTQyLDMwLjc2MjUzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTguNDYwOTk5LC0zMy45NzcyOTEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE4LjQ2MDk5OScgeT0nLTMzLjk3NzI5MSc+RjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTIuMzM2MDE3JyB5PSctMzMuOTc3MjkxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy05LjIyMjY3NCcgeT0nLTMzLjk3NzI5MSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNC41NTYwOScgeT0nLTMzLjk3NzI5MSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00tMjMuNTczMTQtMjYuNjU5NzdIMjMuNjI2ODUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjMuODI2ODMsLTI2LjY1OTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04LjM1MzIxLC0yMi41NTcwMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE4LjQ2MDk5OSwtMzMuOTc3MjkxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xOC40NjA5OTknIHk9Jy0zMy45NzcyOTEnPkc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTEyLjI1ODI3NicgeT0nLTMzLjk3NzI5MSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctOS4xNDQ5MzInIHk9Jy0zMy45NzcyOTEnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQuNDc4MzQ4JyB5PSctMzMuOTc3MjkxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS0zOC43NTY0NSAxNy44MDAwNVYtMTcuNDAwMDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwtMzguNzU2NDUsLTE3LjYwMDA3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zNi40MDM3LC0xLjAwNjk0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTguNDYwOTk5LC0zMy45NzcyOTEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE4LjQ2MDk5OScgeT0nLTMzLjk3NzI5MSc+zrE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTEzLjI4MTY1OCcgeT0nLTMyLjk4MTAyNyc+eDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00zOC45ODMyOSAxNy44MDAwNVYtMTcuNDAwMDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwzOC45ODMyOSwtMTcuNjAwMDcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMzM2MDQsLTAuNTIwODQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xOC40NjA5OTksLTMzLjk3NzI5MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTguNDYwOTk5JyB5PSctMzMuOTc3MjkxJz7OsTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTMuMjgxNjU4JyB5PSctMzIuOTgxMDI3Jz55PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4="></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            {F(x)} &amp;&amp; {F(y)} \\
            \\
            {G(x)} &amp;&amp; {G(y)}
            \arrow [&quot;{F(f)}&quot;, from=1-1, to=1-3]
            \arrow [&quot;{G(f)}&quot;, from=3-1, to=3-3]
            \arrow [&quot;{\alpha _x}&quot;, from=1-1, to=3-1]
            \arrow [&quot;{\alpha _y}&quot;, from=1-3, to=3-3]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We state the concise functorial definition of diagrams of the shape of categories.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>636</fr:anchor><fr:addr type="user">def-003H</fr:addr><fr:route>def-003H.xml</fr:route><fr:title text="Diagram">Diagram</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">C</fr:tex> be a category and <fr:tex display="inline">J</fr:tex> be a small category.
    A <fr:strong>diagram</fr:strong> of shape <fr:tex display="inline">J</fr:tex> in <fr:tex display="inline">C</fr:tex> is a functor <fr:tex display="inline">X:J\to  C</fr:tex>.
    The category of <fr:tex display="inline">J</fr:tex>-shaped diagrams in <fr:tex display="inline">C</fr:tex> is the <fr:link type="local" href="def-003I.xml" addr="def-003I" title="Functor Category">functor category</fr:link> <fr:tex display="inline">C^J</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>A limit of a diagram <fr:tex display="inline">F:D\to  C</fr:tex> is an object <fr:tex display="inline">\lim  F</fr:tex> of <fr:tex display="inline">C</fr:tex>
    equipped with morphisms to the objects <fr:tex display="inline">F(d)</fr:tex> for all <fr:tex display="inline">d\in  D</fr:tex>,
    such that everything in sight commutes.</fr:p></fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>637</fr:anchor>
                <fr:addr type="user">cs-0001</fr:addr>
                <fr:route>cs-0001.xml</fr:route>
                <fr:title text="Is JavaScript an untyped language?">Is JavaScript an untyped language?</fr:title>
                <fr:taxon>Compute Science</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>29</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter><fr:p>This is a note about the the argument that JavaScript is an untyped language.
    Most opinions came from the References.</fr:p><fr:p>The first thing I want to classify is the word <fr:strong>strong typing</fr:strong> and <fr:strong>weak typing</fr:strong> are meaningless.
    In a limit case we can compare two languages that have similar type system, and talk about which one is <fr:em>stronger</fr:em>.
    But for the common case, it&apos;s totally nonsense.</fr:p><fr:p>Static and dynamic typing is a meaningful classsification. But the discussion about dynamic and static languages is mostly wrong on the Internet.
    Dynamic language is a popular concept, however, it is rather a <fr:strong>marketing</fr:strong> than a well-defined terminology.
    It&apos;s designed to confuse rather than inform.</fr:p><fr:p>In fact, dynamic typing is just a special case of static typing.
    It limits more than contributes.The root of the problem is the confusion 
    between type and class. It&apos;s very useful to have multiple classes of values
    of a same type.
    They are interchangeable because they represent values of the same type.
    Only the form of presentation differs.</fr:p><fr:p>The distinction between two classes of the same type is dynamic.
    But this does not conflict with the fact that only one static type.
    In type theory this is what we called <fr:strong>Sum Type</fr:strong>.
    Being a sum type we can dispatch on the class of the value of the type,
    and decide what to do at runtime.</fr:p><fr:p>This characteristics is same to dynamic language where values can be classified into
    various forms that can be distinguished at runtime.
    The answer is now clear: dynamic language classifies all values in this way.
    What they do just merge all values of the language into a single type.
    The so-called <fr:strong>untyped</fr:strong> language is just <fr:strong>unityped</fr:strong>.</fr:p><fr:p>Therefore, JavaScript is definitely untyped.</fr:p>
    <fr:p><fr:strong>References</fr:strong></fr:p>
    <fr:ul><fr:li><fr:link type="external" href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/">Dynamic and static language</fr:link></fr:li>
        <fr:li><fr:link type="external" href="https://stackoverflow.com/questions/964910/is-javascript-an-untyped-language">stackoverflow</fr:link></fr:li>
        <fr:li><fr:link type="external" href="https://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">What to know before debating type systems</fr:link></fr:li>
        <fr:li><fr:em>Practical Foundations for Programming Languages</fr:em>, Robert Harper</fr:li></fr:ul>
</fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>638</fr:anchor>
                <fr:addr type="user">cs-0002</fr:addr>
                <fr:route>cs-0002.xml</fr:route>
                <fr:title text="Primitive Recursion in Lambda Calculus">Primitive Recursion in Lambda Calculus</fr:title>
                <fr:taxon>Compute Science</fr:taxon>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter><fr:p>We begin with the <fr:strong>schema of iteration</fr:strong> and then proceed 
    the more complex schema of primitive recursion and general recursion.
    Refer to <fr:link type="local" href="tapl.xml" addr="tapl" title="Types and Programming Languages">TAPL</fr:link>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>639</fr:anchor><fr:addr type="machine">#374</fr:addr><fr:route>unstable-374.xml</fr:route><fr:title text="Function Composition"><fr:strong>Function Composition</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    Giving two functions <fr:tex display="inline">f, g</fr:tex> we can compose then to get a new function <fr:tex display="inline">f\circ  g = f(g(x))</fr:tex>.
    Using <fr:tex display="inline">\lambda </fr:tex>-notation, we can define the composition of two functions as follows:
    <fr:tex display="block">         f\circ  g = \lambda  x.f(g(x))     </fr:tex>
    And the composition operation is also a lambda abstraction.
    <fr:tex display="block">         \circ  = B = \lambda  f.\lambda  g.\lambda  x.f(g(x))     </fr:tex>
    Composing identity function with any function does not change the function.
    We expect the following equation to hold:
    <fr:tex display="block">         f\circ  I = f = I\circ  f     </fr:tex>
    where <fr:tex display="inline">I</fr:tex> is the identity function. This can be verified by the following calculation:
    <fr:tex display="block">         \begin {align*}             B\space  f\space  I &amp;= (\lambda  f.\lambda  g.\lambda  x.f(g(x)))\space  f\space  I \\             &amp;\to _\beta  \lambda  g.\lambda  x.f(g(x))\space  I \\             &amp;\to _\beta  \lambda  x.f(I(x)) \\             &amp;\to _\beta  \lambda  x.f(x) \\             &amp;=_\eta  f         \end {align*}     </fr:tex>
    The last step requires an extensional equality, which is the called <fr:strong>eta-conversion</fr:strong>.
    <fr:tex display="block">         \text {for}\space  x\not \in \text {FV}(f) ,\lambda  x.f(x) =_\eta  f     </fr:tex>
    It makes more sense to use the equation from right to left called <fr:strong>eta-expansion</fr:strong> 
    (And more discipline has to be imposed or expansion does not terminate).
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>640</fr:anchor><fr:addr type="machine">#375</fr:addr><fr:route>unstable-375.xml</fr:route><fr:title text="Non-termination"><fr:strong>Non-termination</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>The well-known <fr:link type="local" href="eg-0007.xml" addr="eg-0007" title="Divergent Combinator"><fr:strong>divergent combinator</fr:strong></fr:link> implies that 
        the lambda calculus is not strongly normalizing.</fr:p>
    <fr:p>However, we can always compute a normal form if one exists.
        Though there are many reduction strategies,
        there is a complete one for expressions that have normal form.
        This kind of reduction strategy is called <fr:strong>normal order reduction</fr:strong> or
        <fr:strong>leftmost-outermost reduction</fr:strong>. It scans through the expression from left to right
        and when it find a redex, it reduces it by applying beta reduction and returns to the beginning.</fr:p>
    <fr:p>The notation of leftmost-outermost reduction is closely related to the 
        notion of <fr:strong>call-by-name evaluation</fr:strong> in programming languages.
        (A little more distance to <fr:strong>call-by-need</fr:strong> evaluation in Haskell)</fr:p>
    <fr:p>In contrast, <fr:strong>call-by-value</fr:strong> evaluation is not complete, which would 
        reduce the argument of a function before applying beta reduction.</fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>641</fr:anchor><fr:addr type="machine">#376</fr:addr><fr:route>unstable-376.xml</fr:route><fr:title text="Church-Rosser Property"><fr:strong>Church-Rosser Property</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    The outcome of a computation <fr:tex display="inline">e</fr:tex> is its normal form.
    It is naturally to ask the question whether the normal form is unique.
    The key to this question is the <fr:strong>Church-Rosser property</fr:strong> or <fr:strong>confluence</fr:strong>:
    If <fr:tex display="inline">e\to ^* e_1</fr:tex> and <fr:tex display="inline">e\to ^* e_2</fr:tex>, then there exists a term <fr:tex display="inline">e_3</fr:tex> such that
    <fr:tex display="block">         e_1\to ^* e_3\space \text {and}\space  e_2\to ^* e_3     </fr:tex>
    This implies the uniqueness of the normal form.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>642</fr:anchor><fr:addr type="machine">#378</fr:addr><fr:route>unstable-378.xml</fr:route><fr:title text="Representing Natural Numbers"><fr:strong>Representing Natural Numbers</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>We can represent natural numbers in lambda calculus by using the 
        <fr:strong>Church numerals</fr:strong> or <fr:strong>Church encoding</fr:strong>.
        The two abstractions should be related in some ways: 
        one <fr:tex display="inline">x</fr:tex> stands for zero and the other <fr:tex display="inline">f</fr:tex> stands for the successor function.</fr:p>
    <fr:p>The Church numeral <fr:tex display="inline">n</fr:tex> is a function that takes two arguments <fr:tex display="inline">f</fr:tex> and <fr:tex display="inline">x</fr:tex> and applies <fr:tex display="inline">f</fr:tex> to <fr:tex display="inline">x</fr:tex> <fr:tex display="inline">n</fr:tex> times.
        The Church numeral <fr:tex display="inline">0</fr:tex> is defined as the identity function <fr:tex display="inline">\lambda  f.\lambda  x.x</fr:tex>.
        The Church numeral <fr:tex display="inline">1</fr:tex> is defined as the successor of <fr:tex display="inline">0</fr:tex>:
        <fr:tex display="block">             1 = \lambda  f.\lambda  x.f(x)         </fr:tex>
        The Church numeral <fr:tex display="inline">2</fr:tex> is defined as the successor of <fr:tex display="inline">1</fr:tex>:
        <fr:tex display="block">             2 = \lambda  f.\lambda  x.f(f(x))         </fr:tex>
        And so on.</fr:p>
    <fr:p>The Church numeral <fr:tex display="inline">n</fr:tex> is defined as the successor of <fr:tex display="inline">n-1</fr:tex>:
        <fr:tex display="block">             n = \lambda  f.\lambda  x.f^n(x)         </fr:tex>
        where <fr:tex display="inline">f^n(x)</fr:tex> means applying <fr:tex display="inline">f</fr:tex> to <fr:tex display="inline">x</fr:tex> <fr:tex display="inline">n</fr:tex> times.</fr:p>
    <fr:p>The successor function is defined as follows:
        <fr:tex display="block">             S = \lambda  n.\lambda  f.\lambda  x.f(n\space  f\space  x)         </fr:tex></fr:p>
    
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>643</fr:anchor><fr:addr type="machine">#377</fr:addr><fr:route>unstable-377.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            <fr:tex display="block">                 \begin {align*}                     S\space  n &amp;= (\lambda  n.\lambda  f.\lambda  x.f(n\space  f\space  x))\space  n \\                     &amp;\to _\beta  \lambda  f.\lambda  x.f(n\space  f\space  x) \\                     &amp;\to _\beta  \lambda  f.\lambda  x.f^n(x) \\                     &amp;\to _\beta  n+1                 \end {align*}             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 

    <fr:p>Using the iteration property we can define mathematical functions 
        over the natural numbers in lambda calculus.
        The addition of two Church numerals <fr:tex display="inline">m</fr:tex> and <fr:tex display="inline">n</fr:tex> is defined as follows:
        <fr:tex display="block">             m+n = \lambda  n.\lambda  k. n\space  S\space  k         </fr:tex></fr:p>
    <fr:p>The multiplication of two Church numerals <fr:tex display="inline">m</fr:tex> and <fr:tex display="inline">n</fr:tex> is defined by
        iterating the addition function <fr:tex display="inline">m</fr:tex> times:
        <fr:tex display="block">             m*n = \lambda  n.\lambda  k. n\space  (k + ) \space  0         </fr:tex></fr:p>
    <fr:p>The exponentiation of two Church numerals <fr:tex display="inline">m</fr:tex> and <fr:tex display="inline">n</fr:tex> is defined as follows:
        <fr:tex display="block">             m^n = \lambda  m.\lambda  n. n\space  (m *) \space  1         </fr:tex></fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>644</fr:anchor><fr:addr type="machine">#379</fr:addr><fr:route>unstable-379.xml</fr:route><fr:title text="The Schema of Iteration"><fr:strong>The Schema of Iteration</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>As we saw before, a natural number <fr:tex display="inline">n</fr:tex> is represented by a function 
        that iterates its first argument <fr:tex display="inline">n</fr:tex> times on its second argument.
        <fr:tex display="block">             n = \lambda  g.\lambda  c.g^n(c)         </fr:tex>
        Another way to specify such a function schematically is 
        <fr:tex display="block">             \begin {align*}                 f \space 0 &amp;= c \\                 f (n+1) &amp;= g\space  (f\space  n)             \end {align*}         </fr:tex>
        If such a function satisfies such a <fr:strong>schema of iteration</fr:strong>, then it can 
        be defined in the lambda calculus on Church numerals as
        <fr:tex display="block">             f = \lambda  n.n \space  g \space  c         </fr:tex>
        This definition is <fr:strong>total</fr:strong> which means it is defined for all natural numbers.
        Let&apos;s define the multiplication again
        <fr:tex display="block">             \begin {align*}                 m*0 &amp;= 0 \\                 m*(n+1) &amp;= m + (m*n)             \end {align*}         </fr:tex>
        To fit our schema of iteration, we can define the multiplication by abstracting over <fr:tex display="inline">k</fr:tex>:
        <fr:tex display="block">             \begin {align*}                 \text {times}\space  0 &amp;= \lambda  k.0 \\                 \text {times}\space  (n+1) &amp;= \lambda  k.k + (\text {times}\space  n\space  k)             \end {align*}         </fr:tex>
        where the <fr:tex display="inline">c</fr:tex> and <fr:tex display="inline">g</fr:tex> are
        <fr:tex display="block">             \begin {align*}                 c &amp;= \lambda  k.0 \\                 g &amp;= \lambda  r.\lambda  k.k+(r\space  k)             \end {align*}         </fr:tex>
        and we obtain
        <fr:tex display="block">             \text {times} = \lambda  n.n(\lambda  rk. k + (r\space  k))(\lambda  k.0)         </fr:tex></fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>645</fr:anchor><fr:addr type="machine">#384</fr:addr><fr:route>unstable-384.xml</fr:route><fr:title text="The Schema of Primitive Recursion"><fr:strong>The Schema of Primitive Recursion</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>Everything appears simply until we think of a very simple function,
        the <fr:strong>predecessor function</fr:strong> <fr:tex display="inline">\text {pred}</fr:tex> defined by
        <fr:tex display="block">             \begin {align*}                 \text {pred}\space  0 = 0 \\                 \text {pred}\space  (n+1) = n             \end {align*}         </fr:tex>
        What we would need is the <fr:strong>schema of primitive recursion</fr:strong>
        <fr:tex display="block">             \begin {align*}                 f\space  0 &amp;= c \\                 f\space  (n+1) &amp;= g\space  n\space  (f\space  n)             \end {align*}         </fr:tex>
        With which we can define the predecessor function by 
        <fr:tex display="block">             g = \lambda  x.\lambda  y.x         </fr:tex></fr:p>
    
    
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>646</fr:anchor><fr:addr type="machine">#380</fr:addr><fr:route>unstable-380.xml</fr:route><fr:title text="Define predecessor function"><fr:strong>Define predecessor function</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        The key idea is to gain access to <fr:tex display="inline">n</fr:tex> in the schema of 
        primitive recursion by rebuilding it during the iteration.
        <fr:tex display="block">             \text {pred}_2\space  n = \langle  n, \text {pred}\space  n \rangle          </fr:tex>
        The key step is to express the definition by a schema of iteration
        rather than primitive recursion.
        <fr:tex display="block">             \text {pred}_2\space  0 = \langle  0, 0 \rangle          </fr:tex>
        We need a helper function for the successor case
        <fr:tex display="block">             \text {letPair}\space \langle  e_1,e_2\rangle \space  k = k\space  e_1\space  e_2         </fr:tex>
        This function passes the elements of the pair to a <fr:strong>continuation</fr:strong> <fr:tex display="inline">k</fr:tex>.
        <fr:tex display="block">             \text {pred}_2 (n+1) = \text {letPair}\space  (\text {pred}_2\space  n)\space  (\lambda  xy. \langle  x+1, x \rangle )          </fr:tex>
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>647</fr:anchor><fr:addr type="machine">#381</fr:addr><fr:route>unstable-381.xml</fr:route><fr:title text="Define Pairs"><fr:strong>Define Pairs</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        Now we need to define pairs and <fr:tex display="inline">\text {letPair}</fr:tex>.
        The idea is to simply abstract over the continuation itself.
        <fr:tex display="block">             \begin {align*}                 \langle  x,y\rangle  &amp;= \lambda  k.k\space  x\space  y \\                 \text {pair} &amp;= \lambda  x.\lambda  y.\lambda  k.k\space  x\space  y \\                  \text {letPair} &amp;= \lambda  p.p             \end {align*}         </fr:tex>
        The letPair is not really needed here.
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>648</fr:anchor><fr:addr type="machine">#382</fr:addr><fr:route>unstable-382.xml</fr:route><fr:title text="Summary"><fr:strong>Summary</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        Summarizing the above and we obtain the full definition of the predecessor function.
        <fr:tex display="block">             \begin {align*}                 \text {pred}_2 &amp;= \lambda  n.n\space  (\lambda  p.p (\lambda  xy.\text {pair} \space  (x+1) \space  x))\space  \text {pair} (\space  0 \space  0)\\                  \text {pred} &amp;= \lambda  n. (\text {pred}_2\space  n) \space  (\lambda  xy.y)             \end {align*}            </fr:tex>
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>649</fr:anchor><fr:addr type="machine">#383</fr:addr><fr:route>unstable-383.xml</fr:route><fr:title text="General Primitive Recursion"><fr:strong>General Primitive Recursion</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        The general case of primitive recursion follows by a similar pattern.
        We begin by defining a function <fr:tex display="inline">f_2</fr:tex>:
        <fr:tex display="block">             f_2\space  n = \langle  n, f\space  n \rangle          </fr:tex>
        We can define <fr:tex display="inline">f_2</fr:tex> using the schema of iteration
        <fr:tex display="block">             \begin {align*}                 f_2\space  0 &amp;= \langle  0, c \rangle  \\                 f_2\space  (n+1) &amp;= \text {letPair}\space  (f_2\space  n)\space  (\lambda  xy.\langle  x+1, g\space  x\space  y \rangle ) \\                 f\space  n &amp;= \text {letPair}\space  (f_2\space  n)\space  (\lambda  xy.y)             \end {align*}         </fr:tex>
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:p>When computing over natural numbers we can restrict the functions that can be 
    formed in schematic ways to obtain a language in which all functions <fr:strong>terminate</fr:strong>.
    Because if <fr:tex display="inline">c</fr:tex> and <fr:tex display="inline">g</fr:tex> are terminating then so is <fr:tex display="inline">f</fr:tex> formed from them by primitive recursion.</fr:p></fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>650</fr:anchor>
                <fr:addr type="user">cs-0003</fr:addr>
                <fr:route>cs-0003.xml</fr:route>
                <fr:title text="Recursion">Recursion</fr:title>
                <fr:taxon>Computer Science</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>3</fr:month>
                  <fr:day>2</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter><fr:p>In this note we complete the development of <fr:strong>recursion</fr:strong>.
    Refer to <fr:link type="local" href="tapl.xml" addr="tapl" title="Types and Programming Languages">TAPL</fr:link></fr:p>
  
    
    <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>651</fr:anchor><fr:addr type="machine">#372</fr:addr><fr:route>unstable-372.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:strong>General Recursion</fr:strong>
    <fr:p>Let&apos;s first consider the <fr:strong>greatest common divisor</fr:strong> function <fr:tex display="inline">\gcd (a,b)</fr:tex></fr:p>
    <fr:tex display="block">         \begin {align*}             \gcd \space  a\space  a &amp;= a \\             \gcd \space  a\space  b &amp;= \gcd \space  (a-b)\space  b  \text { if } b &gt; a \\             \gcd \space  a\space  b &amp;= \gcd \space  a\space  (b-a)  \text { if } a &gt; b         \end {align*}     </fr:tex>
    This recursion is terminating because the arguments are decreasing.
    We can deal with this case currently and let&apos;s be hold.
    We consider the most general schema of recursion.
    <fr:tex display="block">         f = h\space  f     </fr:tex>
    which means that in the right-hand side we can make arbitrary recursive
    calls to the function <fr:tex display="inline">f</fr:tex>. For <fr:tex display="inline">\gcd </fr:tex> we have
    <fr:tex display="block">         h = \lambda  gab. \text {if } (a=b)\space  a\space ((             \text {if }\space (a&gt;b)\space (g\space  (a-b)\space  b)\space (g\space  a\space  (b-a))         ))     </fr:tex>
    How can we define <fr:tex display="inline">f</fr:tex> explicitly when given <fr:tex display="inline">h</fr:tex> so that <fr:tex display="inline">f = h\space  f</fr:tex>,
    which called a <fr:strong>fixed point</fr:strong> pf <fr:tex display="inline">h</fr:tex>. If we believe <fr:strong>Church-Turing thesis</fr:strong>,
    then any partial recursive function should be representable on Church numerals in lambda calculus.
    Hence we can find such <fr:tex display="inline">f</fr:tex> and the answer is called <fr:strong>Y-combinator</fr:strong>.
    We want that if <fr:tex display="inline">f = Y\space  h</fr:tex> and <fr:tex display="inline">f=h\space  f</fr:tex>, so we get <fr:tex display="inline">Y\space  h = h \space  (Y\space  h)</fr:tex>.
    <fr:tex display="block">         Y\space  h = h\space  (Y\space  h) = h\space  (h\space  (Y\space  h)) = h\space  (h\space  (h\space  (Y\space  h))) = \cdots      </fr:tex>
    This iterates infinitely. The definition of <fr:tex display="inline">Y</fr:tex> is:
    <fr:tex display="block">         Y = \lambda  h.(\lambda  x. h\space  (x\space  x))\space  (\lambda  x. h\space  (x\space  x))     </fr:tex>
    The application <fr:tex display="inline">x\space  x</fr:tex> will replicate <fr:tex display="inline">Y\space  h</fr:tex>:
    <fr:tex display="block">         \begin {align*}             Y\space  h &amp;= (\lambda  x. h\space  (x\space  x))\space  (\lambda  x. h\space  (x\space  x)) \\             &amp;= h\space  ((\lambda  x. h\space  (x\space  x))\space  (\lambda  x. h\space  (x\space  x))) \\             &amp;= h\space  (Y\space  h)         \end {align*}     </fr:tex>
    The partial recursive functions include functions that are <fr:strong>undefined</fr:strong> (have no normal form) 
    on some arguments, hence we can&apos;t always find an answer.
    Consider <fr:tex display="inline">f=f</fr:tex> as a recursion schema and <fr:tex display="inline">h=\text {id}</fr:tex>.
    <fr:tex display="block">         Y\space  h = Y\space  \text {id} = (\lambda  x. \text {id}\space  (x\space  x))\space  (\lambda  x. \text {id}\space  (x\space  x))         = (\lambda  x. x\space  x)\space  (\lambda  x. x\space  x) = \Omega      </fr:tex>
    The function <fr:tex display="inline">f=\Omega </fr:tex> solves the equation <fr:tex display="inline">f=f</fr:tex> by giving a divergent result.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
  

  
    
    <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>652</fr:anchor><fr:addr type="machine">#373</fr:addr><fr:route>unstable-373.xml</fr:route><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>2</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:strong>Define Functions By Recursion</fr:strong>
    <fr:p>Consider the factorial function:</fr:p>
    <fr:tex display="block">         \text {fact}\space  n = \text {if } (n=0)\space  1\space  (n\space  \text {fact}\space  (n-1))     </fr:tex>
    This requires a test <fr:tex display="inline">\text {if0}</fr:tex> satisfies:
    <fr:tex display="block">         \begin {align*}             \text {if0}(0,c,d) &amp;=c\\             \text {if0}(n+1,c,d) &amp;=d         \end {align*}     </fr:tex>
    We can define <fr:tex display="inline">\text {if0}</fr:tex> by (Recall that <fr:tex display="inline">K=\lambda  xy.x</fr:tex>):
    <fr:tex display="block">         \text {if0} = \lambda  ncd. n\space (K\space  d)\space  c     </fr:tex>
    The argument of Y combinator is defined:
    <fr:tex display="block">         h_\text {fact} = \lambda  g. \lambda  n. \text {if0}\space  n\space  1\space  (n\space  g\space  (n-1))     </fr:tex>
    and
    <fr:tex display="block">         \text {fact} = Y\space  h_\text {fact}     </fr:tex>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
  
</fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>653</fr:anchor>
                <fr:addr type="user">cs-0004</fr:addr>
                <fr:route>cs-0004.xml</fr:route>
                <fr:title text="Scanners">Scanners</fr:title>
                <fr:taxon>Computer Science</fr:taxon>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>The scanner&apos;s task is to transform a stream of characters into a stream 
    of words in the input language. Each word must be classified into a 
    <fr:strong>syntactic category</fr:strong>.
    This note refers to <fr:link type="local" href="eng-compiler-2022.xml" addr="eng-compiler-2022" title="Engineering a Compiler">Engineering a compiler</fr:link></fr:p>
                <fr:p>The first stage of a compiler is to perform <fr:strong>lexical analysis</fr:strong> by a scanner.
    The parser or <fr:strong>syntax analyzer</fr:strong> will fit the stream of words to a grammatical 
    model of the input language.</fr:p>
                <fr:p>Scanner construction has a strong foundation in formal language theory.
    Scanners are based on <fr:strong>recognizers</fr:strong> that simulate <fr:strong>deterministic finite automata</fr:strong>.
    We can specify the lexical structure using a set of <fr:strong>regular expression</fr:strong>.</fr:p>
                <fr:p>Each time a scanner recognizes a word, it will return a <fr:strong>token</fr:strong> that
    contains the word (<fr:strong>lexeme</fr:strong>) and its syntactic category.
    The scanner uses <fr:strong>microsyntax</fr:strong> (the lexical structure of a language) to 
    find and classify words. <fr:strong>Keywords</fr:strong> are <fr:strong>identifiers</fr:strong> but have special meanings.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>654</fr:anchor>
                    <fr:addr type="machine">#368</fr:addr>
                    <fr:route>unstable-368.xml</fr:route>
                    <fr:title text="A first look at recognizers">A first look at recognizers</fr:title>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p>A char-by-char algorithm to recognize words is trivial.
        Consider we want to recognize the word <fr:code>new</fr:code>.
        We can write down the following code.</fr:p><fr:pre>    c &lt;- nextChar();
    if (c == &apos;n&apos;) {
        c &lt;- nextChar();
        if (c == &apos;e&apos;) {
            c &lt;- nextChar();
            if (c == &apos;w&apos;) {
                return newToken();
            }
        }
    }
    reportError();</fr:pre><fr:p>We can also represent the code fragment using the simple <fr:strong>transition diagram</fr:strong>.</fr:p>
 
  
  <fr:figure><fr:resource hash="f4faee11facb506838a5d69a56ea34ed"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIyMi41NDAyNjlwdCcgaGVpZ2h0PScyMy4zOTEzOTJwdCcgdmlld0JveD0nLTcyIC03MiAxNDguMzYwMTc5IDE1LjU5NDI2Mic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVRQUFvQUFBQUFCZXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZQjFJR050WVhBQUFBRTRBQUFBTXdBQUFFUUFnZ0ZHWjJ4NVpnQUFBV3dBQUFKQkFBQUNySTFQcVl0b1pXRmtBQUFEc0FBQUFDOEFBQUEyS2JZdDdHaG9aV0VBQUFQZ0FBQUFIZ0FBQUNRR1VRS0NhRzEwZUFBQUJBQUFBQUFRQUFBQUVBc1NBS1ZzYjJOaEFBQUVFQUFBQUFvQUFBQUtBYXdBem0xaGVIQUFBQVFjQUFBQUdBQUFBQ0FBQndCWmJtRnRaUUFBQkRRQUFBRFBBQUFCT1BOaEtxTndiM04wQUFBRkJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbU9zSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWlNoblp2Z1A1RE5EcEpIVS9BY0tBd0QydGcyUWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VSU0dmSVl5di8vUjdEK3ovay81WDhQV0MwWUFBRHpoZ3ZDQUhqYUpaRTliOU5nRklYZmUvM1YyTTVyTzNsdHAyM2lPblpxeDAzbGZOcW1jdUs0TkZXQmdxZ0FVWW1CZ1kyRmdhK05nYi9CeUIvZ1R5RDRKUXpzcUF0RHNjTjRwSE9Qem5NdVFYSitld04vNFRzSlNFcEk1b3NhT0RDMzFwQm1xUU1tMDBDVVlrZ3FsYVh6bVdWYm9pUks0ZHlxZFJhREgxUlMvRlUyQUNFZDY2dFdtY3ROWmJaWHZIL3hrcjluZHA0K3l5NEEvRHZIazgrejN2TFFTM2dZKzlhY05wUGZROU1wQ2xRRnZWUkFGV21rRDNsOGMvVjJ3N1JrTXVxc1RNcnZnaWhRbGprdXh5VFpKVUFtdHpmNEZYNlF4NFNzdVRSWkJDRUZpY0lZNHFwdWdaWmRRSlphdGxpWHBtQ0s5cXh1YlR0UWw1UzhJRnhzdWJLME91UTBwRndRZmhxcGlxaTFIVThSSkZrUmdSbU44R3dqMmRmbDhYTU9HYmJWcHN4MTNieUZoaXlDclJoK01id0RuS3BaRmlJYm5WeU9xTlJqUXNQc01qajlOb2x0M2V3Q2xERlRBRkU3ZGRvRFBFcjZPV0o4UDE2SytYNi9iM2k0WHJVUTdZbHR4Znc0VWhWM2NQZHMycHB6dUN6NnZROVhUS09nRzJUTCs0YzdnSi9rdWhJYVVMQXR1K0tzR0pORkdJVC9ZVm1OV3JOUkNNVXhCR0dRMVI3SnE1RDl5clhZZnNvQm05VUprZ1BiZ0dvSnJnQWI5M3VVNTVyYVNYbkllanQ2b0hIZ21Uc1JCaDY5M0V3ZXRnYWxIczNOc1lDeUhDbmNycnRzZzFHTjFLbG1XQitsd0xkMEZ6QS8yT3ZMQTRsWEhkWmM4WER4cmpBSHZpOEl1WFB1cnBTWkszWE1QbUEzQzc5cy9DZTg1MDFOeExiU3ZXb0h3OWZXQXlqV09tS0RUaTB6Rm1CNnFOSTRlaFhsQVFKcmpyck1PUG40YUI4T0NDSC9BSjNGV05FQUFBQjQybU5nWkdCZ0FHSzV5ZDN0OGZ3Mlh4bVlXUmhBNFBIK3I3TVE5UDh2elBLTXg0RmNEZ1lta0NnQVZnQU10UUI0Mm1OZ1pHQmdadmpQQUNUOUdBd1k5Sm5sR1lBaUtJQUZBREUrQWRzQUFBTEdBQUFDS3dCRkF0TUFNQU5PQURBQUFBQUFBRllBemdGV0FBQjQybU5nWkdCZ1lHR0lZR0JpQUFGR0JqUUFBQW1DQUdGNDJrMk1QVy9DTUJDR240Z0VpVEN3b0E0ZGlvZk9FUVFrdGk0TVRLeE1MSUJkbE1FMmNrSWtwS3BqZjNjdnJvZWU1TlB6ZnB5QmttOHloc21ZeFQxTVRpSHFqd3VtekJPUFJTMFNsN3p5em9nc240anp4a2ZpWEpKVDRvSVhQaE9QeGY5S1hMTGhaK2Z0L2RHWm9BNWVtK0N1MWpiYm93bHQ0NTFhVmN1bzk4YVpjTzZNVnBlbjBuM1Q5amVyMWxWZDFlendXTzQ4NkRBRUZBZHhkR1RIVlRKTHc1WmpkRnBoTDc1aVJjWHlYNzZYM01YT09mNmtwWFBoS1Z2VFM2T1ZmWk91WWkyWDlmQitBY3dyTC9rQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9vQUFvQUFBQUFCQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXNTByV050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNtWjJ4NVpnQUFBV1FBQUFEb0FBQUE2S0tzVjhkb1pXRmtBQUFDVEFBQUFDOEFBQUEyS1MwdTYyaG9aV0VBQUFKOEFBQUFJQUFBQUNRRnpnRlhhRzEwZUFBQUFwd0FBQUFJQUFBQUNBVHFBRFZzYjJOaEFBQUNwQUFBQUFZQUFBQUdBSFFBQUcxaGVIQUFBQUtzQUFBQUZ3QUFBQ0FBQkFCS2JtRnRaUUFBQXNRQUFBRFVBQUFCUHBrUmRjZHdiM04wQUFBRG1BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9HTXdRek0vd0g4cGtoMGtocS9nT0ZBZFBCRFFzQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqQi8vOUR5UC9yd0h3R0FGUVJCcThBQUFBQUFRQTEvK2dDbGdMU0FFZ0FBQUVIQmljbUp6WTNMZ0VIRGdFSEhnRWZBUjRCRng0QkZ3WVBBUVlIQmlZbkR3SWlKejhCUGdFek5oY0hCaFVXSHdFV056NEJOeTRCTHdFdUFTYzJQd0UyTnhZWFB3SVdBcFEzQXd3SkFnRUNBVkpCUzJZQ0FTY1dSVUl4RHcwakFnSkFHRWhpTGwwaU1nd0dDd0VlRGc4SEJnb0NCUU1FTXhRNE1FNW9Bd005SDIwcFFBSURSQTVKWDJnck1Rd0dEUUxJNFJjREFRY0xNVlZLQVFObFFpa3RCeElSRWhFS09UUmFUQnBFQkFFZkxEb05Bd3Q0T2pnS0FnMGJFQk5WSHd3WUFnTnhTVDBxQlIwTFNENWJSUTVCQXdGSk93MENBd0FBZU5wallHUmdZQURpWGVscnRzZnoyM3hsWUdaaEFJSEgrNy9PUXREL1h6Qk5ZN29FNUhJd01JRkVBWDNXRGV3QWVOcGpZR1JnWUdiNHo4REF3RlRHWVByL0h0TTBCcUFJQ21BQ0FHS0RCQ2tDZGdBQUFuUUFOUUFBQUFBQWRBQUFlTnBqWUdSZ1lHQmk4R1FBMFF4UUVna0FBQWUrQUU4QWVOcE5qckZxd3pBVVJZK3BZNmhieUpRTUhZcW1qTVoyK2dHRkRKbXlaaXdra1FndVNBcXlZOGdTK2dIOTZENHJHdnFFSGtmblhRa0JKWGN5cHNxWXh6NVZUaUduQjg5NFlaRzRrS1VTbDd5eDRva3NmeGJ6em1maW5GZStFczlZOHAyNEVQK1R1T1NEMzQyM2wrdGdndHA1YllJN1dkczE5ZDZFdnZOT05WWDlFRnZqVERnTVJxdmpUZW14NjhlelZldXFyVm8yZUN3WHJnd1lndnhzSjBaSGRweGtadWxvcU5sSDE4dkp5MFNKcThUK1Qyd2w0V0xxRUYvVGtqcHlrNjRaSmROTFAwdGFzWmE3N2JUL0FPQ0NNTDE0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUTUFBb0FBQUFBQlhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVXQwZTJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDR1oyeDVaZ0FBQVdRQUFBSUZBQUFDUkVwYnltWm9aV0ZrQUFBRGJBQUFBQzhBQUFBMktXb3V4bWhvWldFQUFBT2NBQUFBSHdBQUFDUUZSd0lMYUcxMGVBQUFBN3dBQUFBT0FBQUFEZ1hCQUhSc2IyTmhBQUFEekFBQUFBd0FBQUFNQVJZQm9HMWhlSEFBQUFQWUFBQUFHQUFBQUNBQUNBQThibUZ0WlFBQUEvQUFBQURKQUFBQk11MEtrZXh3YjNOMEFBQUV2QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1TbWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvYU1CZ3pNL3dIOHBraDBraHEvZ09GQWNWYURMWUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2akcvLzhEU1lQLy8vOWZCUE1aQUZGbEJvOTQya1dSeTI3VFVCQ0d6OHh4Yk9KS1NYT3huVGdYeDNadGl5VGs0c2cyTkdwQ0VHbEphV2hFbTBhb2dJb1FSUlFLRVNEV0NGV3c0RUdBQlR4QTM0RDNZSWxZSUNSV0ZDWXJWa2Yvek5ITTk4L1BrSFgrZnNjMGZtUTZhekVHcXBRQVNaUmNyd0dlRzdsUkQ2SXdLb05XQnE2R3BJS1FPcllyMGpkTnBTb3VZMXd5eXAxbmM5OG9uNHNqcVFxcHRmMjhyZjh3SittNElDakpZYzBhcDVkaXlPWFVGbXg0NCtyTTdndEMzNTVWeDU2M1ZiKzFNaERBZDRMWFo4ZlFHcmFmWG5xN2U2RUY5Vzd0K1BOcW8rOHpZSE1pKzRhZldKN2VsS2gyUVdsQ0VvS09IM3FwQkhnQm9ZVXF6SGhsNUQyY3pOZTlVWVhYZDdQbXk0NnloTy8vZk5VVmh3T2lvK2dvWitPd2dtb0RaQnJGQm94aGpMeWZaOHlSekNqc1F3OWRqOXlWZ1F6YW91dVJmM0tmb0cyaUZDME9FR0hNT05zSGxINFhydkR0c2J1WDkxUUFLeU5YRVY3Y2UvQ080N1E3cmQ3NDZTekpDVHc5TFlyaXI4TGh5UUZDTFVBbldTeUE0bzRlYzNoMGQrT29QclNHQUlKOE9iTmdpU2lIQkg1Z3F5UnNNUWkxeFRJNmVBTWtBbEsxN0NLVkh2aXFwaTc0aUVtaWpQNFhJanBDQXlCM1VSZEUwKzNrbEN4ZmQ0eHB5ZWZGZkZ2QStaZFhDRmNuMDl1QWI1NGNuSEN3bWdhQWJsbEhWbk9IdzNYWTQ2bGw1SkFzNWdibW9FbURUTEdwbFFEQzN1YjJXdnUra1Ruc1RaNXptRjZyRkN2NWxNUHJKY0ROT3pkMzJEKy9jRnFTQUFBQWVOcGpZR1JnWUFEaUE5OGFoT1A1YmI0eU1MTXdnTURqL1Y5bkllai9iNWd1TTYwRWNqa1ltRUNpQUhhRERja0FlTnBqWUdSZ1lHYjR6OERBd0hTWndaakJsRW1JQVNpQ0FwZ0FQZGNDV0FBQzB3QUFBa2NBTXdCd0FFRUFOd0FBQUFBQUFBQlNBSDRBeEFFaWVOcGpZR1JnWUdCbHNHWmdZZ0FCUmdZMEFBQUd5QUJGZU5vOWpERUx3akFRaGI5aUZhMkRnK0RnSU1FZlVMUUtMbTRPVHE0T2J0WUU2ZEJVMGxwMEVYKzYxeEM4a09PNzk5NGRrUEFob3F1SWllOWR4ZkltZ2Z1TW1RWWVpTDRJbkRCblNZOG9Ib215WUI4NFpzZ2xjSjhaZWVDQjZLL0FDVnUraDZwOFBCdmoxS25TeHRsYjZYWm40K3Fpc21xZHJycnhhS3h4MThab2xiK1Zib3U2dlpkcWsyWnB4b0dLa2dkUEdnd094VWtVN2RseUU4K3g0K3pubWtJOEs1azFLYXUvZXhUWCtzVFZYOUdTeUhsTDE3U3lVMHUvUzFheGtiMnMrejlaTWk1TkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyLjE4MDA4OCwtNjQuMjAyODczKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03NC40NTgyNywtMi42NjY2NyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMi4xODAwODgsLTY0LjIwMjg3MylzY2FsZSgtMSwtMSknPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTEuNzU4NzQ2LC02NC4yMDI4NzMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjMwOTA0LDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTEuNzU4NzQ2LC02NC4yMDI4NzMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTEuNzU4NzQ2JyB5PSctNjQuMjAyODczJz5TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzE3Ljg2Nzc5MScgeT0nLTYyLjcwODQ5Mic+MDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1NC44MjYzNjgsLTY0LjIwMjg3MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMzA5MDQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg1NC44MjYzNjgsLTY0LjIwMjg3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSc1NC44MjYzNjgnIHk9Jy02NC4yMDI4NzMnPlM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNjAuOTM1NDE0JyB5PSctNjIuNzA4NDkyJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDk3Ljg5Mzk5MSwtNjQuMjAyODczKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4zMDkwNCwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDk3Ljg5Mzk5MSwtNjQuMjAyODczKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jzk3Ljg5Mzk5MScgeT0nLTY0LjIwMjg3Myc+UzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScxMDQuMDAzMDM2JyB5PSctNjIuNzA4NDkyJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE0MC45NjE2MTMsLTY0LjIwMjg3MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMzA5MDQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxNDAuOTYxNjEzLC02NC4yMDI4NzMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTQwLjk2MTYxMycgeT0nLTY0LjIwMjg3Myc+UzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScxNDcuMDcwNjU4JyB5PSctNjIuNzA4NDkyJz4zPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00tNTUuMDI5MTEtLjE2NjY3SC0zMS44MjkxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMS42MjkxMiwtMC4xNjY2NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDUuNzAwNzksMi4xODYwOCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMi4xODAwODgsLTY0LjIwMjg3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PScyLjE4MDA4OCcgeT0nLTY0LjIwMjg3Myc+bjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00tMTEuNzk5OTktLjE2NjY3SDExLjQwMDAyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDExLjYsLTAuMTY2NjcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEuODk3MDUsMi4xODYwOCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMi4xODAwODgsLTY0LjIwMjg3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PScyLjE4MDA4OCcgeT0nLTY0LjIwMjg3Myc+ZTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00zMS40MjkxNC0uMTY2NjdINTQuNjI5MTUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTQuODI5MTMsLTAuMTY2NjcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDAuMjQyNDMsMi4xODYwOCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMi4xODAwODgsLTY0LjIwMjg3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PScyLjE4MDA4OCcgeT0nLTY0LjIwMjg3Myc+dzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+"></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            {S_0} &amp; {S_1} &amp; {S_2} &amp; {S_3}
            \arrow [&quot;n&quot;, from=1-1, to=1-2]
            \arrow [&quot;e&quot;, from=1-2, to=1-3]
            \arrow [&quot;w&quot;, from=1-3, to=1-4]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure>
 
</fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>655</fr:anchor>
                    <fr:addr type="machine">#369</fr:addr>
                    <fr:route>unstable-369.xml</fr:route>
                    <fr:title text="A formalism for recognizers">A formalism for recognizers</fr:title>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Transition diagrams can be viewed as formal mathematics objects called <fr:strong>finite automata</fr:strong>.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>656</fr:anchor>
                        <fr:addr type="user">def-003M</fr:addr>
                        <fr:route>def-003M.xml</fr:route>
                        <fr:title text="Finite Automata">Finite Automata</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>A <fr:strong>finite automata (FA)</fr:strong> is a five-tuple <fr:tex display="inline">(S,\Sigma ,\delta ,s_0,S_A)</fr:tex> where
    <fr:ul><fr:li><fr:tex display="inline">S</fr:tex> is the finite set of states in the recognizer including <fr:tex display="inline">s_e</fr:tex>,
            the error state.</fr:li>
        <fr:li><fr:tex display="inline">\Sigma </fr:tex> is the finite alphabet used by the recognizer. 
            <fr:tex display="inline">\Sigma </fr:tex> is the union of the edge labels in the transition diagram.</fr:li>
        <fr:li><fr:tex display="inline">\delta (s, c)</fr:tex> is the recognizer&apos;s transition function, which 
            maps each state <fr:tex display="inline">s\in  S</fr:tex> and character <fr:tex display="inline">c\in \Sigma </fr:tex> into some next state.
            In state <fr:tex display="inline">s_i</fr:tex> with input character <fr:tex display="inline">c</fr:tex> the FA takes the transition
            <fr:tex display="inline">s_i \xrightarrow {c} \delta (s_i, c)</fr:tex>.</fr:li>
        <fr:li><fr:tex display="inline">s_0\in  S</fr:tex> is the initial state of the recognizer.</fr:li>
        <fr:li><fr:tex display="inline">S_A</fr:tex> is the set of accepting states, <fr:tex display="inline">S_A\subseteq  S</fr:tex>.</fr:li></fr:ul>
    <fr:tex display="inline">\delta </fr:tex> is only partially defined. For all other combinations of the 
    state <fr:tex display="inline">s_i</fr:tex> and input char <fr:tex display="inline">c</fr:tex> we can define <fr:tex display="inline">\delta (s_i,c)=s_e</fr:tex>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>An FA <fr:strong>accpets</fr:strong> a string <fr:tex display="inline">x</fr:tex> and iff starting in <fr:tex display="inline">s_0</fr:tex>,
        the sequence of chars in  <fr:tex display="inline">x</fr:tex> takes the FA to an accepting state
        when the entire string has been consumed.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>657</fr:anchor>
                        <fr:addr type="user">def-003N</fr:addr>
                        <fr:route>def-003N.xml</fr:route>
                        <fr:title text="Accepts">Accepts</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>If the string <fr:tex display="inline">x</fr:tex> consists characters <fr:tex display="inline">x_1, x_2, \ldots , x_n</fr:tex> then the
    FA <fr:tex display="inline">(S,\Sigma ,\delta ,s_0,S_A)</fr:tex> <fr:strong>accpets</fr:strong> <fr:tex display="inline">x</fr:tex> iff there is a sequence
    <fr:tex display="block">         \delta (             \delta (                 \dots \delta (\delta (                     \delta (s_0,x_1),x_2),x_3)\dots ,                 x_{n-1}             )             ,x_n         )\in  S_A     </fr:tex></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>658</fr:anchor>
                    <fr:addr type="machine">#370</fr:addr>
                    <fr:route>unstable-370.xml</fr:route>
                    <fr:title text="Recognize more complex words">Recognize more complex words</fr:title>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p>The char-by-char model is very simple and now we consider about numbers.
        For simplicity, we consider only unsigned integers: An unsigned integer is either
        zero or series of one or more digits where the first one is non-zero.</fr:p>
 
  
  <fr:figure><fr:resource hash="a55a074002c90d74861b032ab9b21f15"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzMS4xNzA1OHB0JyBoZWlnaHQ9JzE1NC4xNTU2OTFwdCcgdmlld0JveD0nLTcyIC03MiA4Ny40NDcwNTQgMTAyLjc3MDQ2MSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQUxvQUFvQUFBQUFBMUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVbDBJMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNCWjJ4NVpnQUFBV1FBQUFBc0FBQUFMTXNMM0lab1pXRmtBQUFCa0FBQUFDMEFBQUEyS1Z3c3FXaG9aV0VBQUFIQUFBQUFJQUFBQUNRRVhnSThhRzEwZUFBQUFlQUFBQUFJQUFBQUNBUWhBSFJzYjJOaEFBQUI2QUFBQUFZQUFBQUdBQllBQUcxaGVIQUFBQUh3QUFBQUZ3QUFBQ0FBQkFBTWJtRnRaUUFBQWdnQUFBRFBBQUFCT1BOaEtxTndiM04wQUFBQzJBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHJxTWVneE0vd0g4cGtoMGtocS9nT0ZBYVprREZ3QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoNi8vOUR5UCtYd1h3R0FGRUlCb29BQUFBQUFRQjBBQUFBNkFCMkFBb0FBRGNPQVFjaUpqUTJOeklXNkFFZ0doVWtJQm9XSXpvWElnRWdNeUlCSUhqYVkyQmtZR0FBNGwzS3pxM3gvRFpmR1poWkdFRGc4ZjZ2czVGcHBtTU1aVUNLZzRFSnhBTUFPSG9LK2dBQUFIamFZMkJrWUdCbStNL0F3TUIwaktHRW9aamhCUU5RQkFVd0FRQlhPUU9lQXNZQUFBRmJBSFFBQUFBQUFCWUFBSGphWTJCa1lHQmdZdUJtQU5FTVVCSUpBQUFCc0FBUkFIamFUWXc5YjhJd0VJYWZpQVNKTUxDZ0RoMktoODRSQkNTMkxneE1yRXdzZ0YyVXdUWnlRaVNrcW1OL2R5K3VoNTdrMC9OK25JR1NiektHeVpqRlBVeE9JZXFQQzZiTUU0OUZMUktYdlBMT2lDeWZpUFBHUitKY2tsUGlnaGMrRTQvRi8wcGNzdUZuNSszOTBabWdEbDZiNEs3V050dWpDVzNqblZwVnk2ajN4cGx3N294V2w2ZlNmZFAyTjZ2V1ZWM1Y3UEJZN2p6b01BUVVCM0YwWk1kVk1rdkRsbU4wV21FdnZtSkZ4ZkpmdnBmY3hjNDUvcVNsYytFcFc5TkxvNVY5azY1aUxaZjE4SDRCekNzditRQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT29BQW9BQUFBQUJCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFc1MHJXTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ21aMng1WmdBQUFXUUFBQURvQUFBQTZLS3NWOGRvWldGa0FBQUNUQUFBQUM4QUFBQTJLUzB1N1dob1pXRUFBQUo4QUFBQUlBQUFBQ1FGemdGWGFHMTBlQUFBQXB3QUFBQUlBQUFBQ0FUcUFEVnNiMk5oQUFBQ3BBQUFBQVlBQUFBR0FIUUFBRzFoZUhBQUFBS3NBQUFBRndBQUFDQUFCQUJLYm1GdFpRQUFBc1FBQUFEVUFBQUJQcGtSZGNkd2IzTjBBQUFEbUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb0dNd1F6TS93SDhwa2gwa2hxL2dPRkFkUEJEUXNBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpCLy85RHlQL3J3SHdHQUZRUkJxOEFBQUFBQVFBMS8rZ0NsZ0xTQUVnQUFBRUhCaWNtSnpZM0xnRUhEZ0VISGdFZkFSNEJGeDRCRndZUEFRWUhCaVluRHdJaUp6OEJQZ0V6TmhjSEJoVVdId0VXTno0Qk55NEJMd0V1QVNjMlB3RTJOeFlYUHdJV0FwUTNBd3dKQWdFQ0FWSkJTMllDQVNjV1JVSXhEdzBqQWdKQUdFaGlMbDBpTWd3R0N3RWVEZzhIQmdvQ0JRTUVNeFE0TUU1b0F3TTlIMjBwUUFJRFJBNUpYMmdyTVF3R0RRTEk0UmNEQVFjTE1WVktBUU5sUWlrdEJ4SVJFaEVLT1RSYVRCcEVCQUVmTERvTkF3dDRPamdLQWcwYkVCTlZId3dZQWdOeFNUMHFCUjBMU0Q1YlJRNUJBd0ZKT3cwQ0F3QUFlTnBqWUdSZ1lBRGlYZWxyTnNmejIzeGxZR1poQUlISCs3L09SdEQvWHpCTlk3b0U1SEl3TUlGRUFYMVlEZW9BZU5wallHUmdZR2I0ejhEQXdGVEdZUHIvSHRNMEJxQUlDbUFDQUdLREJDa0NkZ0FBQW5RQU5RQUFBQUFBZEFBQWVOcGpZR1JnWUdCaThHUUEwUXhRRWdrQUFBZStBRThBZU5wTmpyRnF3ekFVUlkrcFk2aGJ5SlFNSFlxbWpNWjIrZ0dGREpteVppd2trUWd1U0FxeVk4Z1MrZ0g5NkQ0ckd2cUVIa2ZuWFFrQkpYY3lwc3FZeHo1VlRpR25CODk0WVpHNGtLVVNsN3l4NG9rc2Z4Ynp6bWZpbkZlK0VzOVk4cDI0RVArVHVPU0QzNDIzbCt0Z2d0cDViWUk3V2RzMTlkNkV2dk5PTlZYOUVGdmpURGdNUnF2alRlbXg2OGV6VmV1cXJWbzJlQ3dYcmd3WWd2eHNKMFpIZHB4a1p1bG9xTmxIMTh2SnkwU0pxOFQrVDJ3bDRXTHFFRi9Ua2pweWs2NFpKZE5MUDB0YXNaYTc3YlQvQU9DQ01MMTQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVRnQUFvQUFBQUFCWUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVdDBnV050WVhBQUFBRTRBQUFBTWdBQUFEd0FWQUNJWjJ4NVpnQUFBV3dBQUFJVUFBQUNURUlUUmZKb1pXRmtBQUFEZ0FBQUFDOEFBQUEyS1dvdXlXaG9aV0VBQUFPd0FBQUFId0FBQUNRRlJ3SUxhRzEwZUFBQUE5QUFBQUFPQUFBQURnWEJBSFJzYjJOaEFBQUQ0QUFBQUF3QUFBQU1BUllCcEcxaGVIQUFBQVBzQUFBQUdBQUFBQ0FBQ0FBOWJtRnRaUUFBQkFRQUFBREpBQUFCTXUwS2tleHdiM04wQUFBRTBBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVNtYWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9hTUZneU0vd0g4cGtoMGtocS9nT0ZBY1lJREx3QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS0dqRlkvdjhQNUJ1QTZQOFgvNThHcXdJQ0FJMVpDTllBQUhqYUhaSExidE5BRklibm5QR2xjU0RCU1R4dUxzM0ZyajBsU1pNMHdiWWdKV21KUW9uYVFLbmFwaWkwQXBXTEFCVWl3UmFwQ3dSSWlFZGd4d0lRdkVERkMvQWVMQkVMVklrVmhUR3IwVDh6bXZQOTh4RWtyYjgvTUlFZlNJWTBDQUdteGtCVlZKZlhnTHVCRzNRZzhJTThtSG1nekJmSjg4V0o3U3JpbXNuRUxwN0JpRnJJdDU1TW1vWDhWQVJGS29wMGNaeTJNejlMNjRtSUpCbnhmc1VhSnFJeVVrMWZneFUrTEkvc3JpUjE3VkY1eVBsYTljYnNzZ1JOeHpzOE9ZQkdmK0h4K1plYjh3Mm90aXNIWHk3VXVrMENaQ0xJdnVOSGtoYXJyckEyR0hXSWc5ZHErbHlQQWZjRW1zOWdSSXNEZm45OWNwa1BpclM2bVNvOWF4bFJmUFBuVzhad0tDQTZSZ2ExVkFSbWtkVkFFMCtSWlVKUUZ0M1BFdUtvcGNEdlFnZGRMdHJsUVJTMEZaZUwvcUo5VEV4VDFDRDhnQURsd3NrWVVQMmR2VVN2RGQzdE5HY0FWbElySXp5OWZmY1Z4YTMyVnZucUx5ZXF4ZkRvS0tjb3g5bDdMMjRoVkR4MDRya3NHTzdnRVlVSGV5c1BxMzJyRHlCcFMwbUJRUUxoSVlhZnlCeHBDelJQYUJBS3hMd09tRDR6bFJEQWNua293MkFoWU1BRWo4L0Q2djl0aFVwU29STDRyRjlaM0Qya1VNL05qN083cjZsMFhkNllyRzRBMXFlbklWNHd1OGs1Yjlxb3ZXMk5LRVNOVXcwK3RJMklxck1BRmd5bmcvajhUbS9WTERQQWQxL2Y3OGszY2ZGY25VSTJOV1hMN0RSUVN5OHM3Y1BPL3N5T1pUaUFRYjYzM1p1eHNvVDhBMUxTWFVaNDJtTmdaR0JnQU9JTDN6dUM0L2x0dmpJd3N6Q0F3T1A5WDJjajZQOXZtQzR6clFKeU9SaVlRS0lBaGVrT0pRQjQybU5nWkdCZ1p2alB3TURBZEpuQm1NR1VTWWdCS0lJQ21BQTkxd0pZQUFMVEFBQUNSd0F6QUhBQVFRQTNBQUFBQUFBQUFGSUFmZ0RFQVNaNDJtTmdaR0JnWUdXd1lXQmlBQUZHQmpRQUFBYmhBRVo0MmoyTU1RdkNNQkNGdjJJVnJZT0Q0T0Fnd1I5UXRBb3ViZzVPcmc1dTFnVHAwRlRTV25RUmY3clhFTHlRNDd2MzNoMlE4Q0dpcTRpSjcxM0Y4aWFCKzR5WkJoNkl2Z2ljTUdkSmp5Z2VpYkpnSHpobXlDVndueGw1NElIb3I4QUpXNzZIcW53OEcrUFVxZExHMlZ2cGRtZmo2cUt5YXAydXV2Rm9ySEhYeG1pVnY1VnVpN3E5bDJxVFptbkdnWXFTQjA4YURBN0ZTUlR0MlhJVHo3SGo3T2VhUWp3cm1UVXBxNzk3Rk5mNnhOVmYwWkxJZVV2WHRMSlRTNzlMVnJHUnZhejdQMWt5TGswQUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00MC44ODc1MzUsLTEwLjU1MzczMSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzEuMjI5MTQsLTM2LjMxOTQ2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDAuODg3NTM1LC0xMC41NTM3MzEpc2NhbGUoLTEsLTEpJz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMS4zMDg4NzcsLTc3LjYwNzg1MSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMS43NTg3NDYsLTc3LjYwNzg1MSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMzA5MDQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxMS43NTg3NDYsLTc3LjYwNzg1MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PScxMS43NTg3NDYnIHk9Jy03Ny42MDc4NTEnPlM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTcuODY3NzkxJyB5PSctNzYuMTEzNDcnPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMxLjMwODg3NywtNDQuMDgwNzkxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4zMDkwNCwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zMS4zMDg4NzcsLTQ0LjA4MDc5MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzEuMzA4ODc3JyB5PSctNDQuMDgwNzkxJz5TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yNS4xOTk4MzEnIHk9Jy00Mi41ODY0MSc+MDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzEuMzA4ODc3LC0xMC41NTM3MzEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTEuNzU4NzQ2LC0xMC41NTM3MzEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjMwOTA0LDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTEuNzU4NzQ2LC0xMC41NTM3MzEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTEuNzU4NzQ2JyB5PSctMTAuNTUzNzMxJz5TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzE3Ljg2Nzc5MScgeT0nLTkuMDU5MzUnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTTI1LjQzNDQyIDQxLjY3OTE1QzM0LjY2Njk4IDYxLjQ3NjcyIDUxLjIyNjcgNDcuMjk0NyAzMS43OTE2MSAzOC4yMzE0NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC45MDYzLC0wLjQyMjYyLDAuNDIyNjIsLTAuOTA2MywzMS42MTAzOCwzOC4xNDY5NCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MS42NzA4LDUzLjEwOTcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MC44ODc1MzUsLTEwLjU1MzczMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDAuODg3NTM1JyB5PSctMTAuNTUzNzMxJz4wPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0zNi45MTYyOTQnIHk9Jy0xMC41NTM3MzEnPi4uPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zMi4xODQwMTInIHk9Jy0xMC41NTM3MzEnPjk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTExLjc5OTk5LTcuODA1ODVMMTEuNDg0NC0yNS45MzM1NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjc4OTA1LC0wLjYxNDI5LDAuNjE0MjksMC43ODkwNSwxMS42NDIxOCwtMjYuMDU2MzgpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMi4zNTI3NSwtMTQuNjM5NzkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MC44ODc1MzUsLTEwLjU1MzczMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDAuODg3NTM1JyB5PSctMTAuNTUzNzMxJz4wPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS0xMS43OTk5OSA3LjQ3MjVMMTEuNDg0NCAyNS42MDAyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzg5MDUsMC42MTQyOSwtMC42MTQyOSwwLjc4OTA1LDExLjY0MjE4LDI1LjcyMzA0KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNS4wNzUwMSwxOS4wMTE5NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQwLjg4NzUzNSwtMTAuNTUzNzMxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00MC44ODc1MzUnIHk9Jy0xMC41NTM3MzEnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTM2LjkxNjI5NCcgeT0nLTEwLjU1MzczMSc+Li48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTMyLjE4NDAxMicgeT0nLTEwLjU1MzczMSc+OTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+"></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            &amp; {S_2}
            \arrow [out=65, in=25 ,loop,&quot;0..9&quot;]
            \\
            {S_0} \\
            &amp; {S_1}
            \arrow [&quot;0&quot;, from=2-1, to=3-2]
            \arrow [&quot;{1..9}&quot;, from=2-1, to=1-2]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure>
 
<fr:p>And the code implementation can be:</fr:p><fr:pre>    state &lt;- s0;
    char &lt;-nextChar();
    while (state != se and char != eof) {
        state &lt;- delta(state, char);
        char &lt;- nextChar();
    }
    if (state in SA) {
        return Acceptance();
    } else {
        reportError();
    }</fr:pre><fr:p>Another example is to recognize <fr:strong>identifiers</fr:strong> which are sequences of letters and digits,
        starting with a letter. Many languages include other special characters for identifiers.
        The FA for unsigned integers and identifiers are different in syntactic categories.</fr:p></fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>659</fr:anchor>
                    <fr:addr type="machine">#371</fr:addr>
                    <fr:route>unstable-371.xml</fr:route>
                    <fr:title text="Regular Expressions">Regular Expressions</fr:title>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The set of words accpeted by a finite automata <fr:tex display="inline">F</fr:tex> forms a language <fr:tex display="inline">L(F)</fr:tex>.
        The transition diagram of <fr:tex display="inline">F</fr:tex> specifies the syntactic structure of <fr:tex display="inline">L(F)</fr:tex>.
        But such representation is complex and non-intuitive.
        Most systems use a notation called <fr:strong>regular expressions</fr:strong> to specify the language.
        Any language described by an RE is considered a <fr:strong>regular language</fr:strong>.
        RE is equivalent to FA.</fr:p>
                    <fr:p>To work with REs in a rigorous way, we need a foraml definition.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>660</fr:anchor>
                <fr:addr type="user">cs-0005</fr:addr>
                <fr:route>cs-0005.xml</fr:route>
                <fr:title text="Simply Typed Lambda Calculus and Representation Theorems">Simply Typed Lambda Calculus and Representation Theorems</fr:title>
                <fr:taxon>Computer Science</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>3</fr:month>
                  <fr:day>5</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>We have explored the power of lambda calculus.
    Church&apos;s original purpose of the pure calculus of functions 
    was a new foundations of mathematics distinct from set theory.
    Unfortunately the original lambda calculus is <fr:strong>inconsistent</fr:strong> (Every proposition has a proof).
    Church returned to the ideas by Russell and Whitehead and developed the <fr:strong>Church&apos;s Simple Theory of Types</fr:strong>.
    <fr:strong>SLTC</fr:strong> is a typed interpretation of the lambda calculus with only one type constructor <fr:tex display="inline">\to </fr:tex>
    that builds function types.</fr:p>
                <fr:p>We follow the converntion that function type constructor <fr:tex display="inline">\to </fr:tex> is right-associative.
    We write <fr:tex display="inline">e:\tau </fr:tex> if expression <fr:tex display="inline">e</fr:tex> has type <fr:tex display="inline">\tau </fr:tex>.
    <fr:tex display="block">         \lambda  x.x:\tau \to \tau      </fr:tex>
    But the type is not unique. The booleans can be typed:
    <fr:tex display="block">         \begin {align*}             \text {true} &amp;= \lambda  x.\lambda  y.x : \alpha \to (\beta \to \alpha )\\             \text {false} &amp;= \lambda  x.\lambda  y.y : \alpha \to (\beta \to \beta )         \end {align*}     </fr:tex></fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>661</fr:anchor>
                    <fr:addr type="machine">#246</fr:addr>
                    <fr:route>unstable-246.xml</fr:route>
                    <fr:title text="Typing Judgment">Typing Judgment</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>5</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Wem can formalize judgments about expressions and types using <fr:strong>inference rules</fr:strong>.
        For instance:
        <fr:tex display="block">             \frac {                 e_1:\tau _1\quad  e_2:\tau _2             }{                 e_1\space  e_2:\tau _2             }         </fr:tex>
        The application <fr:tex display="inline">e_1\space  e_2</fr:tex> has type <fr:tex display="inline">\tau _2</fr:tex> if <fr:tex display="inline">e_1</fr:tex> has type 
        <fr:tex display="inline">\tau _1\to \tau _2</fr:tex> and <fr:tex display="inline">e_2</fr:tex> has type <fr:tex display="inline">\tau _1</fr:tex>.</fr:p>
                    <fr:p>We can record the types of variable in a <fr:strong>typing context</fr:strong>.
        <fr:tex display="block">             \Gamma  :\equiv  x_1:\tau _1,\ldots ,x_n:\tau _n         </fr:tex>
        And we always assume that all variables declared in a context are distinct.
        This avoids any ambiguity when we try to determine the type of a variable.
        The typing judgment now becomes
        <fr:tex display="block">             \Gamma \vdash  e:\tau          </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>662</fr:anchor>
                    <fr:addr type="machine">#247</fr:addr>
                    <fr:route>unstable-247.xml</fr:route>
                    <fr:title text="The Limits of Simple Types">The Limits of Simple Types</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>5</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Are there expressions that cannot be typed in the simple type system?
        Yes, for example, <fr:tex display="inline">\Omega =\lambda  x.x\space  x</fr:tex> cannot be typed.
        But how do we prove that  <fr:tex display="inline">\Omega </fr:tex> cannot be typed?</fr:p>
                    <fr:p>We can apply the typing rules and get a contradiction.
        <fr:tex display="inline">\Omega </fr:tex> is a lambda abstraction hence we can assume that it has type <fr:tex display="inline">\tau \to \sigma </fr:tex>.
        Then <fr:tex display="inline">x</fr:tex> has type <fr:tex display="inline">\tau </fr:tex> and <fr:tex display="inline">x\space  x</fr:tex> has type <fr:tex display="inline">\sigma </fr:tex>.
        By the application of <fr:tex display="inline">x\space  x</fr:tex> we get that <fr:tex display="inline">\tau =\tau \to \sigma </fr:tex>, 
        which does not exist.</fr:p>
                    <fr:p>To recover from this in full generality we need <fr:strong>recursive types</fr:strong>.
        <fr:tex display="block">             \tau  =F\tau          </fr:tex>
        where <fr:tex display="inline">F=\lambda \alpha .\alpha \to \sigma </fr:tex> and we might have a solution with 
        <fr:tex display="inline">\tau =Y\space  F</fr:tex>. But such solution is not available to us. We do not have 
        function from types to types <fr:tex display="inline">F</fr:tex> and a type level Y combinator.
        However it is ok to construct recursive types (we would do later).</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>663</fr:anchor>
                    <fr:addr type="machine">#248</fr:addr>
                    <fr:route>unstable-248.xml</fr:route>
                    <fr:title text="Characterizing the Booleans">Characterizing the Booleans</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>5</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>We now show that the representation of the booleans is correct.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>664</fr:anchor>
                        <fr:addr type="machine">#249</fr:addr>
                        <fr:route>unstable-249.xml</fr:route>
                        <fr:title text="Representation of Booleans">Representation of Booleans</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>3</fr:month>
                          <fr:day>5</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>If <fr:tex display="inline">\emptyset \vdash  e:\alpha \to (\alpha \to \alpha )</fr:tex> and <fr:tex display="inline">e</fr:tex> is a normal form, 
            then <fr:tex display="inline">e = \text {true}</fr:tex> or <fr:tex display="inline">e = \text {false}</fr:tex>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>We will later combine this with the following theorems which yields 
    correctness of the representation of the booleans.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>665</fr:anchor>
                        <fr:addr type="user">def-003O</fr:addr>
                        <fr:route>def-003O.xml</fr:route>
                        <fr:title text="Weak Normalization">Weak Normalization</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>If <fr:tex display="inline">\Gamma \vdash  e:\tau </fr:tex> then <fr:tex display="inline">e\to _{\beta }^*e&apos;</fr:tex> for a <fr:strong>normal form</fr:strong> <fr:tex display="inline">e&apos;</fr:tex>.
    And we can define <fr:strong>subject reduction</fr:strong>, if <fr:tex display="inline">\Gamma \vdash  e:\tau </fr:tex> and <fr:tex display="inline">e\to _{\beta }e&apos;</fr:tex> then <fr:tex display="inline">\Gamma \vdash  e&apos;:\tau </fr:tex>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>666</fr:anchor>
                    <fr:addr type="machine">#250</fr:addr>
                    <fr:route>unstable-250.xml</fr:route>
                    <fr:title text="Reduction revised">Reduction revised</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>5</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Our characterization of normal forms is quite simple: terms that do not reduce.
        However, this is a <fr:strong>negative</fr:strong> condition, which is difficult to work with in proofs.
        We would like to have a <fr:strong>positive</fr:strong> condition, which is easier to work with.</fr:p>
                    <fr:p>We tend to give definitions in the form of inference rules.
        The property then holds if the judgment can be derived using the rules.
        (This closely related to the <fr:strong>inductive deefintion</fr:strong>).
        Before defining the normal forms we formally define <fr:strong>beta reduction</fr:strong>.
        The judgment here <fr:tex display="inline">e\to  e&apos;</fr:tex> expressing that <fr:tex display="inline">e</fr:tex> reduces to <fr:tex display="inline">e&apos;</fr:tex>.
        <fr:tex display="block">             \begin {align*}                 \frac {}{(\lambda  x.e_1)e_2\to  e_1[x:=e_2]} (\text {red/beta}) \\                 \frac {e\to  e&apos;}{\lambda  x.e \to  \lambda  x.e&apos;} (\text {red/lam}) \\                 \frac {e_1\to  e_1&apos;}{e_1\space  e_2\to  e_1&apos;\space  e_2} (\text {red/app}_1) \\                 \frac {e_2\to  e_2&apos;}{e_1\space  e_2\to  e_1\space  e_2&apos;} (\text {red/app}_2)                             \end {align*}         </fr:tex></fr:p>
                    <fr:p>A <fr:strong>normal form</fr:strong> is an expression that does not reduce.
        To give a proper formalization,, we need a separate judgment for <fr:strong>neutral terms</fr:strong>
        which do not create a redex when applied to an argument.
        <fr:tex display="block">                                       \begin {align*}                 \frac {e\text { normal}}{\lambda  x.e\text { normal}} (\text {normal/lam}) \\                 \frac {e\text { neutral}}{e\text { normal}} (\text {normal/var}) \\                 \frac {}{x\text { neutral}} (\text {neutral/var}) \\                 \frac {e_1\text { neutral}\quad  e_2\text { normal}}{e_1\space  e_2\text { neutral}} (\text {neutral/app}) \\             \end {align*}         </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>667</fr:anchor>
                    <fr:addr type="machine">#251</fr:addr>
                    <fr:route>unstable-251.xml</fr:route>
                    <fr:title text="Normal Forms and Reduction">Normal Forms and Reduction</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>5</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The characterization of normal forms via inference rules is compact,
        but is it really the same as saying that an expression does not reduce?
        We break this down into the following two properties.
        <fr:ul><fr:li>For all expressions <fr:tex display="inline">e</fr:tex>, either <fr:tex display="inline">e</fr:tex> reduces or <fr:tex display="inline">e</fr:tex> is normal</fr:li>
            <fr:li>For all expressions <fr:tex display="inline">e</fr:tex>, it is not that case <fr:tex display="inline">e</fr:tex> reduces and <fr:tex display="inline">e</fr:tex> is normal</fr:li></fr:ul></fr:p>
                    <fr:p>We have theorem that ensures that the first property holds. (Proof is omitted).</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>668</fr:anchor>
                        <fr:addr type="user">thm-0010</fr:addr>
                        <fr:route>thm-0010.xml</fr:route>
                        <fr:title text="Reduction and normal forms">Reduction and normal forms</fr:title>
                        <fr:taxon>Theorem</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>For every expression <fr:tex display="inline">e</fr:tex>, either <fr:tex display="inline">e\to  e&apos;</fr:tex> for some expression <fr:tex display="inline">e&apos;</fr:tex> or <fr:tex display="inline">e</fr:tex> is a normal form.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>669</fr:anchor>
                <fr:addr type="user">cs-0006</fr:addr>
                <fr:route>cs-0006.xml</fr:route>
                <fr:title text="Introduction to Programming Language Semantic">Introduction to Programming Language Semantic</fr:title>
                <fr:taxon>Programming Language Theory</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>3</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>I decided to read one paper or article every week.
    This week&apos;s topic is programming language semantics, refer to <fr:strong>Graham Huttons</fr:strong>&apos;s 
    paper <fr:link type="local" href="pl-123.xml" addr="pl-123" title="Programming language semantics: It&apos;s easy as 1,2,3">Programming language semantics: It&apos;s easy as 1,2,3</fr:link>.</fr:p>
                <fr:p><fr:strong>Semantics</fr:strong> is the general term for the study of meaning.
    <fr:strong>Programming language semantics</fr:strong> gives precise mathematical meaning to programs.
    We use a simple <fr:strong>arithmetic expression language</fr:strong> 
    (including integers and addition only) to illustrate the basic concepts.
    This is an example of <fr:strong>Occam&apos;s razor</fr:strong>, a philosophical principle that favours the 
    simplest explanation for a phenomenon.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>670</fr:anchor>
                    <fr:addr type="machine">#357</fr:addr>
                    <fr:route>unstable-357.xml</fr:route>
                    <fr:title text="Arithmetic Expressions">Arithmetic Expressions</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p>Now let&apos;s define our language of arithmetic expressions
        built up from the set of integers and the operation of addition.
        Use a <fr:strong>context-free</fr:strong> grammar.
        <fr:tex display="block">             E:\equiv \mathbb {Z} | E+E         </fr:tex></fr:p><fr:p>An expression is either an integer value or the addition of two sub-expressions.
        We assume that parentheses can be <fr:strong>freely</fr:strong> used as required to disambiguate expressions 
        written in normal textual form. This grammar can be easily translated into 
        a <fr:strong>Haskell</fr:strong> data type.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Expr = Val Integer | Add Expr Expr</html:code></fr:pre>
</fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>671</fr:anchor>
                    <fr:addr type="machine">#358</fr:addr>
                    <fr:route>unstable-358.xml</fr:route>
                    <fr:title text="Denotational Semantics">Denotational Semantics</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p>Now we consider <fr:strong>denotational semantics</fr:strong>, 
        where the terms in a language is defined using a 
        <fr:strong>valuation function</fr:strong> that maps terms into values in an appropriate <fr:strong>semantic domain</fr:strong>.</fr:p><fr:p>Formally, for a language <fr:tex display="inline">T</fr:tex> of syntactic terms comprises
        two components: a set <fr:tex display="inline">V</fr:tex> of <fr:strong>semantic values</fr:strong> and a 
        <fr:strong>valuation function</fr:strong> of type <fr:tex display="inline">T\to  V</fr:tex> that maps terms to 
        their meanings as values.
        This function is written by enclosing a term in a <fr:strong>semantic brackets</fr:strong> 
        (Also known as Oxford or Strachey brackets),
        writing <fr:tex display="inline">\llbracket  t\rrbracket </fr:tex> for the value of term <fr:tex display="inline">t</fr:tex>.
        In addition, the valuation function is required to be <fr:strong>compositional</fr:strong>,
        the meaning  of a <fr:strong>compound term</fr:strong> is defined purely in terms of the meaning
        of its sub-terms.</fr:p><fr:p>Compositionality aids understanding by ensuring that the semantics is modular
        and supports the use of simple <fr:strong>equational reasoning</fr:strong> techniques for proving properties of
        the semantics. When the set of semantic values is clear, a denotational semantics is often
        identified with the underlying valuation function.</fr:p><fr:p>Taking <fr:tex display="inline">V</fr:tex> the Haskell type <fr:code>Integer</fr:code> of integers and define a valuation function
        of type <fr:code>Expr -&gt; Integer</fr:code> (by following equations) we can define the denotational semantics of our expression language.
        <fr:tex display="block">             \begin {align*}                 \llbracket \text {Val} \space  n\rrbracket  &amp;= n \\                 \llbracket \text {Add} \space  e_1\space  e_2\rrbracket  &amp;= \llbracket  e_1\rrbracket  + \llbracket  e_2\rrbracket              \end {align*}         </fr:tex>
        This definition satisfies the compositionality requirement obviously.
        Note that the symbol <fr:tex display="inline">+</fr:tex> has two different purposes.
        On the left side, it is a <fr:strong>syntactic</fr:strong> constructor for building terms,
        while on the right side, it is a <fr:strong>semantic</fr:strong> operator for adding integers.</fr:p><fr:p>Compositionality simplifies reasoning because it allows us to 
        replace <fr:strong>equals by equals</fr:strong>. For example,
        <fr:tex display="block">             \frac {                 \llbracket  e_1\rrbracket  = n_1 \quad  \llbracket  e_2\rrbracket  = n_2             }{                 \llbracket \text {Add} \space  e_1\space  e_2\rrbracket  =                 \llbracket \text {Add} \space  n_1\space  n_2\rrbracket              }         </fr:tex>
        we can freely replace the two argument expressions of an addition by other expressions with the same meanings, 
        and the meaning of the whole addition will remain unchanged.
        Using the definition of the valuation function, we can prove this property.
        <fr:tex display="block">             \begin {align*}                 \llbracket \text {Add} \space  e_1\space  e_2\rrbracket  &amp;=                  \llbracket  e_1\rrbracket  + \llbracket  e_2\rrbracket  (\text {By definition of } \llbracket -\rrbracket ) \\                 &amp;= \llbracket  n_1\rrbracket  + \llbracket  n_2\rrbracket  (\text {Assumptions}) \\                  &amp;= \llbracket \text {Add} \space  n_1\space  n_2\rrbracket  (\text {By definition of } \llbracket -\rrbracket )             \end {align*}         </fr:tex></fr:p><fr:p>Given that terms and their semantics are built up <fr:strong>inductively</fr:strong>,
        proofs about denotational semantics typically  proceed using <fr:strong>structural induction</fr:strong>.
        Let us show that our expression semantics is <fr:strong>total</fr:strong>,
        that is, for every expression <fr:tex display="inline">e</fr:tex> there is an integer <fr:tex display="inline">n</fr:tex> such that <fr:tex display="inline">\llbracket  e\rrbracket  = n</fr:tex>.</fr:p>
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>672</fr:anchor><fr:addr type="machine">#359</fr:addr><fr:route>unstable-359.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>11</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        For the base case <fr:tex display="inline">e = \text {Val} \space  n</fr:tex>, we have <fr:tex display="inline">\llbracket  e\rrbracket  = n</fr:tex> trivially.
        For the inductive case <fr:tex display="inline">e = \text {Add} \space  e_1\space  e_2</fr:tex>,
        we can assume by induction that <fr:tex display="inline">\llbracket  e_1\rrbracket  = n_1</fr:tex> and <fr:tex display="inline">\llbracket  e_2\rrbracket  = n_2</fr:tex>
        for some integers <fr:tex display="inline">n_1</fr:tex> and <fr:tex display="inline">n_2</fr:tex>. Then <fr:tex display="inline">\llbracket  e\rrbracket  = n_1 + n_2</fr:tex> by definition of the valuation function,
        indicates this case is also true. Therefore, the semantics is total.
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 
<fr:p>The valuation function can be translated into a Haskell function</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval :: Expr -&gt; Integer
eval (Val n) = n
eval (Add x y) = eval x + eval y</html:code></fr:pre>
<fr:p>More generally, a denotational semantics can be viewed as an evaluator (or <fr:strong>interpreter</fr:strong>).
        Even <fr:strong>eval</fr:strong> is defined recursively, the semantics is compositional its behavior
        can be understood  as simply replacing the <fr:strong>constructors</fr:strong> for expressions by other functions.
        In this manner, a denotational semantics can also be viewed as an evaluation function that
        is defined by <fr:strong>folding</fr:strong> over the syntax of the source language.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval :: Expr -&gt; Integer
eval = fold id (+)</html:code></fr:pre>
<fr:p>The fold operator captures the ideas of replacing constructors
        of the language by other functions</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">fold :: (Integer -&gt; a) -&gt; (a -&gt; a -&gt; a) -&gt; Expr -&gt; a 
fold f g (Val n) = f n
fold f g (Add x y) = g (fold f g x) (fold f g y)</html:code></fr:pre>
<fr:p>Note that the above semantics for expressions does not specify the order
        of evaluation. If we do wish to make evaluation order explicit 
        this requires the introduction of additional structure into the semantics,
        named <fr:strong>abstract machines</fr:strong> (Discuss later).</fr:p></fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>673</fr:anchor>
                    <fr:addr type="machine">#360</fr:addr>
                    <fr:route>unstable-360.xml</fr:route>
                    <fr:title text="Small-Step Operational Semantics">Small-Step Operational Semantics</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p>Another popular approach to semantics is the <fr:strong>operational approach</fr:strong>,
        where the meaning of terms is defined using an <fr:strong>execution relation</fr:strong>
        that specifies how terms can be executed in an appropriate machine model.
        There are two basic forms of operational semantics:
        <fr:ul><fr:li><fr:strong>small-step</fr:strong>: describes the individual steps of execution</fr:li>
            <fr:li><fr:strong>big-step</fr:strong>: describes the overall results of execution</fr:li></fr:ul>
        In this section we consider the small-step approach, 
        which is also known as <fr:strong>structural operational semantics</fr:strong>.</fr:p><fr:p>Formally, a small-step operational semantics for a language <fr:tex display="inline">T</fr:tex> of syntactic terms
        comprises two components:
        a set <fr:tex display="inline">S</fr:tex> of <fr:strong>execution states</fr:strong> and 
        a <fr:strong>transition relation</fr:strong> of type <fr:tex display="inline">S\to  S</fr:tex> that specifies how terms can be executed.
        If there is a transition from state <fr:tex display="inline">s</fr:tex> to state <fr:tex display="inline">s&apos;</fr:tex> in a single execution step, we write <fr:tex display="inline">s\to  s&apos;</fr:tex>.</fr:p><fr:p>Arithmetic expressions have a simple small-step operational semantics,
        given by taking <fr:tex display="inline">S</fr:tex> as the Haskell type. And we define transition relation 
        on <fr:code>Expr</fr:code> by the following inference rules.
        <fr:tex display="block">             \begin {align*}                 \frac {}{                     \text {Add}\space (\text {Val}\space  n_1)\space (\text {Val}\space  n_2)\to \text {Val}\space (n_1+n_2)                 } \\                 \frac {x\to  x&apos;}{\text {Add} \space  x\space  y\to \text {Add} \space  x&apos;\space  y}                  \quad                   \frac {y\to  y&apos;}{\text {Add} \space  x\space  y\to \text {Add} \space  x\space  y&apos;}             \end {align*}         </fr:tex></fr:p><fr:p>The first rule states that two values can be added to give a single value and is called a
        <fr:strong>reduction</fr:strong> (or <fr:strong>contraction</fr:strong>) rule.
        An expression that matches such a rule is termed a reducible expression or <fr:strong>redex</fr:strong>.
        The last two rules are called <fr:strong>structural</fr:strong> (or <fr:strong>congruence</fr:strong>) rules as 
        they specify how larger terms can be reduced.</fr:p><fr:p>The semantics is <fr:strong>non-deterministic</fr:strong> because an expression
        may have more than one possible transition.
        This is obviously from the structural rules, which allow either sub-expression to be reduced first.</fr:p><fr:p>We can now capture a the relation between the denotational and operational semantics,
        namely that making a transition does not change the denotation of an expression.
        <fr:tex display="block">             \frac {                 e\to  e&apos;             }{                 \llbracket e\rrbracket  = \llbracket e&apos;\rrbracket              }         </fr:tex>
        This property can be proved by induction on the structure of the expression <fr:tex display="inline">e</fr:tex>.
        Note that by using the &quot;equals by equals&quot; and the assumption <fr:tex display="inline">x\to  x&apos;</fr:tex> we can easily 
        prove the inductive case. The details are omitted here as it involves quite a bit of 
        case analysis. We will later see the <fr:strong>principle of rule induction</fr:strong>, which gives 
        a simpler and more direct way to prove such properties.</fr:p><fr:p>Evaluation of an expression using the small-step semantics proceeds by a series of zero
        or more transition steps. Formally we can write <fr:tex display="inline">e\to ^* e&apos;</fr:tex> to indicate that <fr:tex display="inline">e</fr:tex> can be
        reduced to <fr:tex display="inline">e&apos;</fr:tex> in zero or more steps.
        We can generate a transition tree that captures all possible execution
        paths for an expression. Using the list comprehension we can define a 
        function that returns the list of all expressions that can be reduced 
        from a given expression <fr:tex display="inline">e</fr:tex> in a single transition.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">trans :: Expr -&gt; [Expr]
trans (Val n) = []
trans (Add (Val n) (Val m)) = [Val (n + m)]
trans (Add x y) = [Add x&apos; y | x&apos; &lt;- trans x] ++ [Add x y&apos; | y&apos; &lt;- trans y]</html:code></fr:pre>
<fr:p>We can define a Haskell datatype for transition trees 
        and an execution function that converts expressions into 
        transition trees.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Tree a = Node a [Tree a]
exec :: Expr -&gt; Tree Expr
exec e = Node e [exec e&apos; | e&apos; &lt;- trans e]</html:code></fr:pre>
<fr:p>Though <fr:code>exec</fr:code> is defined recursively, its behavior can be understood as simply applying
        the identity function to give the root of the tree and the transition function to generate a 
        list of residual expressions to be processed to give the subtrees.
        A small-step semantics can be viewed as giving rise to an execution
        function that is defined by <fr:strong>unfolding</fr:strong> to transition trees.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">exec :: Expr -&gt; Tree Expr
exec = unfold id trans</html:code></fr:pre>
<fr:p>The <fr:code>unfold</fr:code> function captures the idea of generating a tree 
        from a seed value <fr:tex display="inline">x</fr:tex> by applying a function <fr:tex display="inline">f</fr:tex> to give the root 
        and a function <fr:tex display="inline">g</fr:tex> to give a list of residual values to be processed
        for the subtrees.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">unfold :: (t -&gt; a) -&gt; (t -&gt; [t]) -&gt; t -&gt; Tree a
unfold f g x = Node (f x) [unfold f g x&apos; | x&apos; &lt;- g x]</html:code></fr:pre>
<fr:p>The operational semantics corresponds to <fr:strong>unfolding to transition trees</fr:strong>,
        while denotational semantics corresponds to <fr:strong>folding over syntax trees</fr:strong>.
        Thinking about semantics in terms of recursion operators reveals a duality</fr:p><fr:p>The above semantics for expressions does not specify the order of evaluation.
        But we can modify the inference rules to achieve this. Replace the second <fr:tex display="inline">\text {Add}</fr:tex> 
        rule by the following rule ensures the first argument of addition is 
        always reduced first.
        <fr:tex display="block">             \frac {                 y\to  y&apos;             }{                 \text {Add} (\text {Val}\space  n)\space  y \to  \text {Add} (\text {Val}\space  n)\space  y&apos;             }         </fr:tex></fr:p></fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>674</fr:anchor>
                    <fr:addr type="machine">#361</fr:addr>
                    <fr:route>unstable-361.xml</fr:route>
                    <fr:title text="Rule induction">Rule induction</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p>For denotational semantics we have structural induction,
        dual to this, for operational semantics we have <fr:strong>rule induction</fr:strong>.
        This allows us to perform proofs by considering the structure of the rules 
        that are used to define the semantics.</fr:p><fr:p>We introduce the idea of rule induction using a simple numeric example.
        We begin by inductively defining a set of natural numbers.
        <fr:tex display="block">                 \frac {}{0\in \mathbb {N}} \quad                   \frac {n\in \mathbb {N}}{n+1\in \mathbb {N}}         </fr:tex>
        This is the standard definition of the natural numbers using peano axioms,
        where the first rule states that zero is a natural number and the second rule states that
        if <fr:tex display="inline">n</fr:tex> is a natural number then so is <fr:tex display="inline">n+1</fr:tex>.</fr:p><fr:p>For the inductively defined set <fr:tex display="inline">\mathbb {N}</fr:tex>. The principle of rule induction
        states that in order to prove a property <fr:tex display="inline">P(n)</fr:tex> for all natural numbers <fr:tex display="inline">n</fr:tex>,
        it suffices to prove that <fr:tex display="inline">P(0)</fr:tex> holds and that if <fr:tex display="inline">P(n)</fr:tex> holds then <fr:tex display="inline">P(n+1)</fr:tex> holds.
        <fr:tex display="block">             \frac {                 P(0)\quad \forall  n\in \mathbb {N}. P(n)\to  P(n+1)             }{                 \forall  n\in \mathbb {N}. P(n)             }         </fr:tex>
        Notice that this is the well-known <fr:strong>principle of mathematical induction</fr:strong>.</fr:p><fr:p>The concept of rule induction can easily be generalised to multiple base and 
        inductive cases, to rule with multiple preconditions and so on.
        For the small-step semantics of expressions, we have one base case and two inductive cases.
        Hence if we want to show that some property <fr:tex display="inline">P(e,e&apos;)</fr:tex> on pairs of expression holds for 
        all transition <fr:tex display="inline">e\to  e&apos;</fr:tex>, we can use rule induction:
        <fr:tex display="block">             \frac {                 \begin {align*}                     P(\text {Add}\space (\text {Val}\space  n_1)\space (\text {Val}\space  n_2),\text {Val}\space (n_1+n_2)) \\                     \forall  x\to  x&apos;. P(x,x&apos;)\to  P(\text {Add}\space  x\space  y,\text {Add}\space  x&apos;\space  y) \\                     \forall  y\to  y&apos;. P(y,y&apos;)\to  P(\text {Add}\space  x\space  y,\text {Add}\space  x\space  y&apos;)                 \end {align*}             }{                 \forall  e\to  e&apos;. P(e,e&apos;)             }         </fr:tex>
        We write <fr:tex display="inline">\forall  x\to  y.P(x,y)</fr:tex> as shorthand for 
        <fr:tex display="block">\forall  x,y.x\to  y\Rightarrow  P(x,y)</fr:tex>. Now we give the proof 
        of the property <fr:tex display="inline">\llbracket e\rrbracket  = \llbracket e&apos;\rrbracket </fr:tex> for all transitions <fr:tex display="inline">e\to  e&apos;</fr:tex>.
        <fr:tex display="block">             \forall  e\to  e&apos;. \llbracket e\rrbracket  = \llbracket e&apos;\rrbracket          </fr:tex></fr:p>
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>675</fr:anchor><fr:addr type="machine">#362</fr:addr><fr:route>unstable-362.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>3</fr:month><fr:day>11</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        The proof consists of three parts: the base case, the reduction rule and the structural rule.
        <fr:tex display="block">             \begin {align*}                 \llbracket \text {Add}\space (\text {Val}\space  n)\space (\text {Val}\space  m)\rrbracket                  &amp;= \llbracket \text {Val}\space  n\rrbracket  + \llbracket \text {Val}\space  m\rrbracket  \\                 &amp;= n + m \\                 &amp;= \llbracket \text {Val}\space (n+m)\rrbracket              \end {align*}         </fr:tex>
        and
        <fr:tex display="block">             \begin {align*}                 \llbracket \text {Add}\space  x\space  y\rrbracket                  &amp;= \llbracket x\rrbracket  + \llbracket y\rrbracket   \\                 &amp;= \llbracket x&apos;\rrbracket  + \llbracket y\rrbracket  (\text {By assumption }\llbracket x\rrbracket =\llbracket x&apos;\rrbracket ) \\                 &amp;= \llbracket \text {Add}\space  x&apos;\space  y\rrbracket              \end {align*}         </fr:tex>
        and 
        <fr:tex display="block">             \begin {align*}                 \llbracket \text {Add}\space  x\space  y\rrbracket                  &amp;= \llbracket x\rrbracket  + \llbracket y\rrbracket   \\                 &amp;= \llbracket x\rrbracket  + \llbracket y&apos;\rrbracket  (\text {By assumption }\llbracket y\rrbracket =\llbracket y&apos;\rrbracket ) \\                  &amp;= \llbracket \text {Add}\space  x\space  y&apos;\rrbracket              \end {align*}         </fr:tex>
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 
</fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>676</fr:anchor>
                    <fr:addr type="machine">#363</fr:addr>
                    <fr:route>unstable-363.xml</fr:route>
                    <fr:title text="Contextual Semantics">Contextual Semantics</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p>The small-step semantics for expressions above has one basic reduction rule 
        for adding values and two structural rules that allow addition to be performed
        in larger expressions. Separating these two kinds of rules results 
        the notion of <fr:strong>contextual semantics</fr:strong> (or <fr:strong>reduction semantics</fr:strong>).</fr:p><fr:p>Informally, a context in this setting is a term with a &quot;<fr:strong>hole</fr:strong>&quot;, 
        usually written as <fr:tex display="inline">[-]</fr:tex>, which can be filled with another term later.
        In a contextual semantics, the hole represents the location where a <fr:strong>single</fr:strong>
        basic step of execution may take place within a term.</fr:p><fr:p>Consider the following transition in our small-step semantics.
        <fr:tex display="block">             (1+2)+(3+4)\to  3+(3+4)         </fr:tex>
        The addition is performed on the left side.
        We say that we can perform the basic step <fr:tex display="inline">1+2\to 3</fr:tex> in the 
        <fr:strong>context</fr:strong> <fr:tex display="inline">[-]+(3+4)</fr:tex> where <fr:tex display="inline">[-]</fr:tex> implies the location of the
        addition takes place.</fr:p><fr:p>The language <fr:tex display="inline">C</fr:tex> of contexts of arithmetic expressions can be formally defined by 
        <fr:tex display="block">             C:\equiv [-]|C+E|E+C         </fr:tex>
        As previously, we can define a Haskell datatype for contexts.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Cont = Hole | Add Cont Expr | Add Expr Cont</html:code></fr:pre>
<fr:p>The kind of context is known as &quot;outside-in&quot; as locating the hole involves
        navigating from the outside of the context inwards. To fill the hole in 
        a context <fr:tex display="inline">c</fr:tex> with an expression <fr:tex display="inline">e</fr:tex> we write <fr:tex display="inline">c\space [e]</fr:tex>:
        <fr:tex display="block">             \begin {align*}                 \text {Hole}\space [e] &amp;= e \\                 (\text {AddL}\space c\space r)\space [e] &amp;= \text {Add}\space  (c\space [e])\space  r \\                 (\text {AddR}\space l\space c)\space [e] &amp;= \text {Add}\space  l\space (c\space [e])             \end {align*}         </fr:tex></fr:p><fr:p>Use the idea of hole filling we can redefine the small-step semantics
        for expressions in contextual style.
        <fr:tex display="block">             \frac {}{                 \text {Add}\space (\text {Val}\space  n_1)\space (\text {Val}\space  n_2)\rightarrowtail  \text {Val}\space (n_1+n_2)             } \quad              \frac {                 e \rightarrowtail  e&apos;             }{                 c\space  [e] \to  c\space  [e&apos;]             }         </fr:tex>
        This first rule defines a reduction relation <fr:tex display="inline">\rightarrowtail </fr:tex> that captures the basic behavior of addition,
        while the second defines a transition relation <fr:tex display="inline">\to </fr:tex> that allows the first rule to be applied in 
        any context.</fr:p><fr:p>We have now refactored the small-step semantics into a single reduction rule and a single structural rule.
        If we subsequently want to extend the language with other features,
        it only requires adding new reduction rules and extending the notion of contexts
        but not need to adding new structural rules.</fr:p><fr:p>Now we define the hole filling function in Haskell.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">fill :: Cont -&gt; Expr -&gt; Expr
fill Hole e = e
fill (AddL c r) e = Add (fill c e) r
fill (AddR l c) e = Add l (fill c e)</html:code></fr:pre>
<fr:p>The dual operation which splits an expression into all possible pairs of 
    contexts and expressions can be defined:</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">split :: Expr -&gt; [(Cont,Expr)]
split e = (Hole, e) : case e of
Val n -&gt; []
Add l r -&gt; [(AddL c r, x) | (c, x) &lt;- split l] ++ 
            [(AddR l c, x) | (c, x) &lt;- split r]</html:code></fr:pre>
<fr:p>A pair <fr:tex display="inline">(c,x)</fr:tex> comprising a context #[c] and an expression <fr:tex display="inline">x</fr:tex> is
        an element of the list returned by <fr:code>split e</fr:code> precisely when <fr:code>fill c x = e</fr:code>.
        The contextual semantics can be translated into Haskell function that returns
        the lists of all expressions that can be reached by performing a single reduction step.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">reduce :: Expr -&gt; [Expr]
reduce (Add (Val n) (Val m)) = [Val (n + m)]
reduce _ = []</html:code></fr:pre>
<fr:p>or a single transition step.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">trans :: Expr -&gt; [Expr]
trans e = [fill c x&apos; | (c, x) &lt;- split e, x&apos; &lt;- reduce x]</html:code></fr:pre>
<fr:p>This function splits the given expression into all possible context 
        and expression pairs, then considering any reduction that can made by each component
        expression, and finally filling the hole in the context with the reduced expression.</fr:p><fr:p>Notice that the contextual semantics does not specify an evaluation
        order for addition and is non-deterministic. We can modify the language
        of contexts to achieve so.
        <fr:tex display="block">             C:\equiv [-]|C+E|\mathbb {Z}+C         </fr:tex>
        This version of the semantics also satisfies a <fr:strong>unique decomposition property</fr:strong>,
        that is, any expression <fr:tex display="inline">e</fr:tex> that is not a value can be uniquely decomposed into the 
        form <fr:tex display="inline">e=c\space [x]</fr:tex> for some context <fr:tex display="inline">c</fr:tex> and reducible expression <fr:tex display="inline">x</fr:tex>. This can be 
        proved by induction on the expression <fr:tex display="inline">e</fr:tex>.</fr:p><fr:p>Contexts are related to a number of other important concepts in
        programming and semantics, including the use of continuations to make control flow
        explicit (John C. Reynolds 1972).</fr:p></fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>677</fr:anchor>
                    <fr:addr type="machine">#364</fr:addr>
                    <fr:route>unstable-364.xml</fr:route>
                    <fr:title text="Big-step Semantics">Big-step Semantics</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p>Big-step semantics is also known as <fr:strong>natural semantics</fr:strong>,
        which focus on large execution step. For a language T of syntactic terms
        comprises two components: a set <fr:tex display="inline">V</fr:tex> of values and 
        an evaluation relation between <fr:tex display="inline">T</fr:tex> and <fr:tex display="inline">V</fr:tex> that relates each term 
        to all values that can be reached by fully executing the term.
        If a term <fr:tex display="inline">t</fr:tex> and a value <fr:tex display="inline">v</fr:tex> are related, we say that <fr:tex display="inline">t</fr:tex> can evaluate to <fr:tex display="inline">v</fr:tex> 
        and write this as <fr:tex display="inline">t\Downarrow  v</fr:tex></fr:p><fr:tex display="block">         \frac {}{             \text {Val}\space  n\Downarrow  n         }         \quad          \frac {             x\Downarrow  n\quad  y\Downarrow  m          }{             \text {Add}\space  x\space  y\Downarrow  n+m         }     </fr:tex><fr:p>The Haskell function definition is similar to the small-step semantics,
        by using the list comprehension.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval :: Expr -&gt; [Integer]
eval (Val n) = [n]
eval (Add x y) = [n + m | n &lt;- eval x, m &lt;- eval y]</html:code></fr:pre>
<fr:p>This is similar to denotational semantics but using inference rules
        rather than a functional manner.
        However, there is no need for a big-step semantics to be compositional.
        Formally, the denotational and big-step semantics for the expression language
        are equivalent, which can be captured by the following property:
        <fr:tex display="block">             \llbracket e\rrbracket  = n \iff  e\Downarrow  n         </fr:tex>
        This is easily verified by induction.</fr:p></fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>678</fr:anchor>
                    <fr:addr type="machine">#365</fr:addr>
                    <fr:route>unstable-365.xml</fr:route>
                    <fr:title text="Abstract Machine">Abstract Machine</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>All the exmaples we have meet focused on explaining semantic ideas,
        now we show how language of integers and addition can also be used to help 
        discover semantic ideas.
        We show how it can be used as the basis for discovering how to implement 
        an <fr:strong>abstract machine</fr:strong>.</fr:p>
                    <fr:p>Remember the evaluation order problem we meet before,
        if we want to make evaluation order explicit, we can introduce additional
        structure into the semantics by constructing an abstract machine.</fr:p>
                    <fr:p>Formally, an abstract machine is usually deifned by a set of syntactic rewrite ruless 
        that make explicit how each step of evaluation proceeds.
        This section we show how an abstract machine for our example language can 
        be systematically derived from the evaluation function using steps
        based on two important semantic concepts, <fr:strong>continuations</fr:strong> and <fr:strong>defunctionalisation</fr:strong>.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>679</fr:anchor>
                        <fr:addr type="machine">#366</fr:addr>
                        <fr:route>unstable-366.xml</fr:route>
                        <fr:title text="Add Continuations">Add Continuations</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>3</fr:month>
                          <fr:day>11</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter><fr:p>We want to make the order of evaluation explicit in the semantics itself.
            A standard technique for achieving this aim is to rewrite the semantics
            in <fr:strong>continuation-passing style</fr:strong>.</fr:p><fr:p>In our setting, a continuation is a function that will be applied to the result of an
            evaluation. Formally, for our semantics <fr:code>eval :: Expr -&gt; Integer</fr:code>, a continuation
            is a function of type <fr:code>Integer -&gt; Integer</fr:code> that will be applied to the resulting integer
            to give a new integer. (This type can be generalized to <fr:code>Integer -&gt; a</fr:code>, but we do not need now)
            We capture the notion of such a continuation using the following type declaration:</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">type Continuation = Integer -&gt; Integer</html:code></fr:pre>
<fr:p>We now define a new semantics <fr:tex display="inline">\text {eval}&apos;</fr:tex>, which takes an expression and returns
            an integer as previously but also takes a continuation as an additional argument,
            which is applied to the result of evaluating the expression.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval&apos; :: Expr -&gt; Continuation -&gt; Integer</html:code></fr:pre>
<fr:p>The behavior of <fr:tex display="inline">\text {eval}&apos;</fr:tex> should be:</fr:p><fr:tex display="block">             \text {eval}&apos;\space  e\space  c = \text {c (eval e)}         </fr:tex><fr:p>We want to calculate a definition that satisfies the specification.
            Using structural induction on the expression <fr:tex display="inline">e</fr:tex>, we construct 
            the term <fr:tex display="inline">\text {eval}&apos;\space  e\space  c</fr:tex> by gradually removing the reference to <fr:code>eval</fr:code>.
            For the base case, <fr:tex display="inline">e = \text {Val}\space  n</fr:tex> we have</fr:p><fr:tex display="block">             \begin {align*}                 \text {eval}&apos;\space (\text {Val}\space  n)\space  c                  &amp;= c\space  (\text {eval}\space  (\text {Val}\space  n)) \\                 &amp;= c\space  n             \end {align*}         </fr:tex><fr:p>For the inductive case, <fr:tex display="inline">e = \text {Add}\space  x\space  y</fr:tex> we begin in the same way:</fr:p><fr:tex display="block">             \begin {align*}                 \text {eval}&apos;\space (\text {Add}\space  x\space  y)\space  c                  &amp;= c\space  (\text {eval}\space  (\text {Add}\space  x\space  y)) \\                 &amp;= c\space  (\text {eval}\space  x + \text {eval}\space  y)             \end {align*}         </fr:tex><fr:p>However, no further definition can be applied now, so we consider the inductive hypothesis:
            Forall <fr:tex display="inline">c&apos;</fr:tex> and <fr:tex display="inline">c&apos;&apos;</fr:tex> we have <fr:tex display="inline">\text {eval}&apos;\space  x\space  c&apos; = c&apos;(\text {eval}\space  x)</fr:tex> and
            <fr:tex display="inline">\text {eval}&apos;\space  y\space  c&apos;&apos; = c&apos;&apos;(\text {eval}\space  y)</fr:tex>. This can readily be achieved by 
            abstracting over <fr:tex display="inline">\text {eval}\space  x</fr:tex> and <fr:tex display="inline">\text {eval}\space  y</fr:tex> using lambda abstraction.</fr:p><fr:tex display="block">             \begin {align*}                 &amp; c\space  (\text {eval}\space  x + \text {eval}\space  y) \\                 =&amp; (\lambda  n\to  c\space (n+\text {eval}\space  y)) \\                 =&amp; \text {eval}&apos;\space  x\space  (\lambda  n\to  c\space (n+\text {eval}\space  y)) \\                  =&amp; \text {eval}&apos;\space  x\space  (\lambda  n\to  (\lambda  m\to  c\space (n+m))(\text {eval}\space  y)) \\                  =&amp; \text {eval}&apos;\space  x\space  (\lambda  n\to  \text {eval}&apos;\space  y\space  (\lambda  m\to  c\space (n+m)))             \end {align*}         </fr:tex><fr:p>The final term does not refer to <fr:tex display="inline">\text {eval}</fr:tex> now.
            In summary we have calculated the following definition</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval&apos; :: Expr -&gt; Continuation -&gt; Integer
eval&apos; (Val n) c = c n 
eval&apos; (Add x y) c = eval&apos; x (\n -&gt; eval&apos; y (\m -&gt; c (n + m)))</html:code></fr:pre>
<fr:p>Our original semantics can be recovered from the new semantics by
            using the identity continuation <fr:tex display="inline">\lambda  n \to  n</fr:tex></fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval e = eval&apos; e (\n -&gt; n)</html:code></fr:pre>
</fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>680</fr:anchor>
                        <fr:addr type="machine">#367</fr:addr>
                        <fr:route>unstable-367.xml</fr:route>
                        <fr:title text="Defunctionalise">Defunctionalise</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>3</fr:month>
                          <fr:day>11</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter><fr:p>We use continuation to make the order of evaluation explicit in the semantics,
            but this also makes the semantics into a higher-order function.
            Hence our second step is to regain the first-order nature of the original semantics by 
            eliminating the use of continuations but <fr:strong>retaining</fr:strong> the explicit order of evaluation they introduced.</fr:p><fr:p>A standard technique for eliminating the use of functions as arguments is <fr:strong>defunctionalisation</fr:strong>.
            We do not usually need the entire function-space of possible argument functions, 
            there only a few forms of such functions are actually used.
            Hence we represent the argument functions that we actually need using 
            a datatype rather than functions.</fr:p><fr:p>We begin by defining three combinators <fr:strong>halt</fr:strong>, <fr:strong>next</fr:strong> and <fr:strong>add</fr:strong> 
            for constructing the continuations we used.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">halt :: Continuation
halt n = n

next :: Expr -&gt; Continuation -&gt; Continuation
next y c = \n -&gt; eval&apos; y (add n c)

add :: Integer -&gt; Continuation -&gt; Continuation
add n c = \m -&gt; c (n + m)</html:code></fr:pre>
<fr:p>Use the combinators, our continuation semantics can now be written as:</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval :: Expr -&gt; Integer
eavl e = eval&apos; e halt

eval&apos; :: Expr -&gt; Continuation -&gt; Integer
eval&apos; (Val n) c = c n 
eval&apos; (Add x y) c = eval&apos; x (next y c)</html:code></fr:pre>
<fr:p>Now we declare a new datatype for continuations, consists of three constructors.</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data CONT = HALT | NEXT Expr CONT | ADD Integer CONT</html:code></fr:pre>
<fr:p>The following translation function forms a denotational semantics for <fr:code>CONT</fr:code></fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">exec :: CONT -&gt; Continuation
exec HALT = halt
exec (NEXT y c) = next y (exec c)
exec (ADD n c) = add n (exec c)</html:code></fr:pre>
<fr:p>This function is usually called <fr:strong>apply</fr:strong>, which can be viewed as 
            applying a representation of a continuation to an integer to give another integer.
            We want to define a new semantics <fr:tex display="inline">\text {eval}&apos;</fr:tex> which behaves in the same way 
            as our previous <fr:tex display="inline">\text {eval}&apos;</fr:tex> except that it uses values of type <fr:code>CONT</fr:code> 
            rather than <fr:code>Continuation</fr:code>.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval&apos;&apos; :: Expr -&gt; CONT -&gt; Integer</html:code></fr:pre>

            The desired behavior of <fr:tex display="inline">\text {eval}&apos;&apos;</fr:tex> is:
            <fr:tex display="block">                 \text {eval}&apos;&apos;\space  e\space  c = \text {eval}&apos;\space  e\space  (\text {exec}\space  c)             </fr:tex></fr:p><fr:p>As before, we proceed by structural induction on expression <fr:tex display="inline">e</fr:tex>.
            The base case <fr:tex display="inline">e=\text {Val}\space  n</fr:tex> is trivial
            <fr:tex display="block">                 \begin {align*}                     \text {eval}&apos;&apos;\space (\text {Val}\space  n)\space  c                     &amp;= \text {eval}&apos;\space (\text {Val}\space  n)\space  (\text {exec}\space  c) \\                     &amp;= \text {exec}\space  c\space  n \\                 \end {align*}             </fr:tex></fr:p><fr:p>For the inductive case <fr:tex display="inline">e = \text {Add}\space  x\space  y</fr:tex>:
            <fr:tex display="block">                 \begin {align*}                     \text {eval}&apos;&apos;\space (\text {Add}\space  x\space  y)\space  c                      &amp;= \text {eval}&apos;\space (\text {Add}\space  x\space  y)\space  (\text {exec}\space  c) \\                     &amp;= \text {eval}&apos;\space  x\space (\text {next}\space  y\space (\text {exec}\space  c)) \\                      &amp;= \text {eval}&apos;\space  x\space (\text {exec}\space (\text {NEXT}\space  y\space  c)) \\                     &amp;= \text {eval}&apos;&apos;\space  x\space  (\text {NEXT}\space  y\space  c)                 \end {align*}             </fr:tex>
            The last step uses the inductive hypothesis for <fr:tex display="inline">x</fr:tex></fr:p><fr:p>In the basic case, <fr:tex display="inline">\text {exec}</fr:tex> still refers to the semantic <fr:tex display="inline">\text {eval}&apos;</fr:tex>,
            via the combinator <fr:tex display="inline">\text {next}</fr:tex>. Hence we need to compute a new definition 
            for <fr:tex display="inline">\text {exec}</fr:tex> that refers to our new <fr:tex display="inline">\text {eval}&apos;&apos;</fr:tex>.</fr:p><fr:tex display="block">             \begin {align*}                 \text {exec}\space \text {HALT}\space  n                  &amp;= \text {halt}\space  n                 \\                  &amp;= n                             \end {align*}         </fr:tex><fr:p>The other case is also easy to compute, no need to induction.</fr:p><fr:tex display="block">             \begin {align*}                 \text {exec}\space (\text {NEXT}\space  y\space  c)\space  n                  &amp;= \text {eval}&apos;&apos;\space  y\space (\text {ADD}\space  n\space  c)                 \\                  \text {exec}\space (\text {ADD}\space  n\space  c)\space  m                  &amp;= \text {exec}\space  c\space (n+m)             \end {align*}         </fr:tex><fr:p>Our original semantics <fr:tex display="inline">\text {eval}</fr:tex> can be recovered from the new 
            semantics <fr:tex display="inline">\text {eval}&apos;&apos;</fr:tex> too.</fr:p><fr:tex display="block">             \begin {align*}                 \text {eval}\space  e                  &amp;= \text {eval}&apos;\space  e\space (\lambda  n\to  n) \\                  &amp;= \text {eval}&apos;\space  e\space \text {halt} \\                  &amp;= \text {eval}&apos;\space  e\space (\text {exec}\space \text {HALT}) \\                  &amp;= \text {eval}&apos;&apos;\space  e\text {HALT}             \end {align*}         </fr:tex><fr:p>In summary, we have calculated the following definitions:</fr:p>
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">eval&apos;&apos; :: Expr -&gt; CONT -&gt; Integer
eval&apos;&apos; (Val n) c = exec c n 
eval&apos;&apos; (Add x y) c = eval&apos;&apos; x (NEXT y c)

exec :: CONT -&gt; Integer -&gt; Integer
exec HALT n = n 
exec (NEXT y c) n = eval&apos;&apos; y (ADD n c)
exec (ADD n c) m = exec c (n + m)

eval :: Expr -&gt; Integer
eval e = eval&apos;&apos; e HALT</html:code></fr:pre>
<fr:p>The four components (<fr:tex display="inline">\text {eval}&apos;&apos;</fr:tex>, <fr:tex display="inline">\text {eval}</fr:tex>, <fr:tex display="inline">\text {exec}</fr:tex> and <fr:code>CONT</fr:code>)
            forms an abstract machine.</fr:p><fr:p><fr:code>CONT</fr:code> is the type of <fr:strong>control stack</fr:strong> which comprises 
            instructions that determine how the machine should continue after evaluating
            the current expression. Sometimes it is called an &quot;eval/continue&quot; machine.
            The control stack can also be defined as a list of instructions.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">type CONT = [INST]
data INST = NEXT Expr | ADD Integer</html:code></fr:pre></fr:p><fr:p><fr:tex display="inline">\text {eval}</fr:tex> evaluates an expression and give an integer by simply 
            call the <fr:tex display="inline">\text {eval}&apos;&apos;</fr:tex> with empty control stack <fr:tex display="inline">\text {HALT}</fr:tex>.</fr:p><fr:p><fr:tex display="inline">\text {eval}&apos;&apos;</fr:tex> evaluates an expression in the context of a control stack.
            If the expression is an integer, we execute the control stack using this 
            integer as an argument. If the expression is an addition, 
            we evaluate the first argument <fr:tex display="inline">x</fr:tex> and place the instruction <fr:tex display="inline">\text {NEXT}\space  y</fr:tex>
            on the top of the control stack.</fr:p><fr:p><fr:tex display="inline">\text {exec}</fr:tex> executes the control stack. If the control stack is empty,
            then just return the integer argument as the result. If the top instruction
            is <fr:tex display="inline">\text {NEXT}\space  y</fr:tex>, we evaluate <fr:tex display="inline">y</fr:tex> and place the instruction <fr:tex display="inline">\text {ADD}\space  n</fr:tex>
            to the stack top. If the top instruction is <fr:tex display="inline">\text {ADD}\space  n</fr:tex>,evaluation of the 
            two arguments of an addition is complete, and we execute the remaining control stack 
            in the context of the sum of the resulting integers.</fr:p></fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>681</fr:anchor>
                <fr:addr type="user">cs-0007</fr:addr>
                <fr:route>cs-0007.xml</fr:route>
                <fr:title text="Categorical Semantics for Type Theories">Categorical Semantics for Type Theories</fr:title>
                <fr:taxon>Type Theory</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>3</fr:month>
                  <fr:day>21</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>This is a collection of notes on categorical semantics for type theories.
    The notes are based on the <fr:link type="local" href="cs-tt-2020.xml" addr="cs-tt-2020" title="Categorical Semantics for Type Theories">paper</fr:link> by Jason Z.S. Hu and <fr:link type="local" href="ncatlab.xml" addr="ncatlab" title="NLab">NLab</fr:link>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>682</fr:anchor>
                    <fr:addr type="machine">#350</fr:addr>
                    <fr:route>unstable-350.xml</fr:route>
                    <fr:title text="Introduction">Introduction</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Over the last few decades, many type systems are designed for different purposes:
        general program safety, security, and correctness. The <fr:strong>categorical semantics</fr:strong>
        is a collection of methods which define meanings of types and programs in category theory.</fr:p>
                    <fr:p>Category theory is a branch of mathematics studying an abstract kind of mappings, called morphisms,
        and their algebraic relations. Its generality serves as a common language for navigating connections
        between different concepts in different areas. We will first go over some basic concepts in category theory.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>683</fr:anchor>
                    <fr:addr type="machine">#351</fr:addr>
                    <fr:route>unstable-351.xml</fr:route>
                    <fr:title text="Basic Category Theory concepts">Basic Category Theory concepts</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Formally, a definition in category theory consists of two parts: data and axioms.
        The most basic definition is the <fr:strong>category</fr:strong></fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>684</fr:anchor>
                        <fr:addr type="user">def-003E</fr:addr>
                        <fr:route>def-003E.xml</fr:route>
                        <fr:title text="Category">Category</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>630</fr:anchor><fr:addr type="machine">#319</fr:addr><fr:route>unstable-319.xml</fr:route><fr:title text="With one collection"><fr:strong>With one collection</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex display="inline">C</fr:tex> consists
    <fr:ul><fr:li>A collection of <fr:strong>objects</fr:strong> <fr:tex display="inline">C_0</fr:tex> (<fr:tex display="inline">\text {Ob}(C)</fr:tex>).</fr:li>
        <fr:li>A collection <fr:tex display="inline">C_1</fr:tex> (<fr:tex display="inline">\text {Mor}(C)</fr:tex>) of <fr:strong>morphisms</fr:strong> (arrows).</fr:li>
        <fr:li>For every morphism <fr:tex display="inline">f</fr:tex> there are an object <fr:tex display="inline">s(f)</fr:tex> (<fr:strong>source</fr:strong>, domain) and an object <fr:tex display="inline">t(f)</fr:tex> (<fr:strong>target</fr:strong>, codomain).</fr:li>
        <fr:li>For every pair of morphisms <fr:tex display="inline">f, g</fr:tex> such that <fr:tex display="inline">t(f) = s(g)</fr:tex>, there is a morphism <fr:tex display="inline">g \circ  f</fr:tex> (<fr:strong>composition</fr:strong>) (Also written <fr:tex display="inline">gf</fr:tex> or <fr:tex display="inline">f;g</fr:tex>).</fr:li>
        <fr:li>For every object <fr:tex display="inline">x</fr:tex>, there is a morphism <fr:tex display="inline">\text {id}_x</fr:tex> (or <fr:tex display="inline">1_x</fr:tex>) called <fr:strong>identity</fr:strong>.</fr:li>
        <fr:li>The following properties hold:
            <fr:ul><fr:li><fr:tex display="inline">s(g \circ  f) = s(f)</fr:tex> and <fr:tex display="inline">t(g \circ  f) = t(g)</fr:tex>.</fr:li>
                <fr:li><fr:tex display="inline">s(1_x) = x</fr:tex> and <fr:tex display="inline">t(1_x) = x</fr:tex>.</fr:li>
                <fr:li>Composition is <fr:strong>associative</fr:strong>: <fr:tex display="inline">h \circ  (g \circ  f) = (h \circ  g) \circ  f</fr:tex> when <fr:tex display="inline">t(f) = s(g)</fr:tex>, and <fr:tex display="inline">t(g) = s(h)</fr:tex>.</fr:li>
                <fr:li>Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex display="inline">f \circ  \text {id}_x = f</fr:tex> and <fr:tex display="inline">\text {id}_y \circ  f = f</fr:tex></fr:li></fr:ul></fr:li></fr:ul>
    If the identity map and its axioms are omitted then one speaks of a <fr:strong>semicategory</fr:strong>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>631</fr:anchor><fr:addr type="machine">#320</fr:addr><fr:route>unstable-320.xml</fr:route><fr:title text="With a family of collections of morphisms"><fr:strong>With a family of collections of morphisms</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex display="inline">C</fr:tex> consists
    <fr:ul><fr:li>A collection of <fr:strong>objects</fr:strong> <fr:tex display="inline">C_0</fr:tex> (<fr:tex display="inline">\text {Ob}(C)</fr:tex>).</fr:li>
        <fr:li>For every pair of objects <fr:tex display="inline">x, y</fr:tex>, a collection <fr:tex display="inline">C_1(x, y)</fr:tex> (<fr:tex display="inline">\hom _C(x,y)</fr:tex>) of <fr:strong>morphisms</fr:strong> from <fr:tex display="inline">x</fr:tex> to <fr:tex display="inline">y</fr:tex>.</fr:li>
        <fr:li>For each pair of morphisms <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex> and <fr:tex display="inline">g</fr:tex> in <fr:tex display="inline">C_1(y,z)</fr:tex>, a morphism <fr:tex display="inline">g \circ  f</fr:tex> in <fr:tex display="inline">C_1(x,z)</fr:tex>.
            called their <fr:strong>composition</fr:strong>.</fr:li>
        <fr:li>For each object <fr:tex display="inline">x</fr:tex>, a morphism <fr:tex display="inline">\text {id}_x</fr:tex> in <fr:tex display="inline">C_1(x,x)</fr:tex> called the <fr:strong>identity</fr:strong> on <fr:tex display="inline">x</fr:tex>.</fr:li>
        <fr:li>The following properties hold:
            <fr:ul><fr:li>Composition is <fr:strong>associative</fr:strong>: <fr:tex display="inline">h \circ  (g \circ  f) = (h \circ  g) \circ  f</fr:tex> for all <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex>, <fr:tex display="inline">g</fr:tex> in <fr:tex display="inline">C_1(y,z)</fr:tex>, and <fr:tex display="inline">h</fr:tex> in <fr:tex display="inline">C_1(z,w)</fr:tex>.</fr:li>
                <fr:li>Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex display="inline">f \circ  \text {id}_x = f</fr:tex> and <fr:tex display="inline">\text {id}_y \circ  f = f</fr:tex> for all <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex>.</fr:li></fr:ul></fr:li></fr:ul>
    Usually we write <fr:tex display="inline">\text {Mor}(C)</fr:tex> for the disjoint union <fr:tex display="inline">\bigsqcup _{x,y \in  C_0} C_1(x,y)</fr:tex>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>We only talk about <fr:strong>collections</fr:strong> here, which is vague, because we do not specify 
        they are sets or classes. If both objects and morphisms fit in sets, we say the category
        is <fr:strong>small</fr:strong>. For a counterexample, the category of all sets is not small. However,
        all functions between sets can be contained in a set. In this case, the category is <fr:strong>locally small</fr:strong>.
        When morphisms between two objects fit in a set, we call the set <fr:strong>hom-set</fr:strong>.</fr:p>
                    <fr:p>Since category theory is constructed to study structures and a category is actually a structure,
        we can talk about the category of all small categories <fr:tex display="inline">\mathbf {Cat}</fr:tex>. Similar to morphisms, we can 
        define <fr:strong>functor</fr:strong> between categories.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>685</fr:anchor>
                        <fr:addr type="user">def-003G</fr:addr>
                        <fr:route>def-003G.xml</fr:route>
                        <fr:title text="Functor">Functor</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>A <fr:strong>functor</fr:strong> <fr:tex display="inline">F</fr:tex> from a category <fr:tex display="inline">C</fr:tex> to a category <fr:tex display="inline">D</fr:tex> is a map
    sending each <fr:tex display="inline">x\in  C</fr:tex> to an object <fr:tex display="inline">F(x)\in  D</fr:tex> and each morphism
    <fr:tex display="inline">f:x\to  y</fr:tex> in <fr:tex display="inline">C</fr:tex> to morphism <fr:tex display="inline">F(f):F(x)\to  F(y)</fr:tex> in <fr:tex display="inline">D</fr:tex>, such that 
    <fr:ul><fr:li>Composition is preserved: <fr:tex display="inline">F(g\circ  f) = F(g)\circ  F(f)</fr:tex>.</fr:li>
        <fr:li>Identity is preserved: <fr:tex display="inline">F(\text {id}_x) = \text {id}_{F(x)}</fr:tex>.</fr:li></fr:ul></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>We can push this idea further by considering functors as objects and <fr:strong>natural transformations</fr:strong> as morphisms.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>686</fr:anchor>
                        <fr:addr type="user">def-003I</fr:addr>
                        <fr:route>def-003I.xml</fr:route>
                        <fr:title text="Functor Category">Functor Category</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Let <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex> be categories, the functor category <fr:tex display="inline">D^C</fr:tex> 
    (or <fr:tex display="inline">[C,D]</fr:tex>) is the category whose
    <fr:ul><fr:li>objects are functors from <fr:tex display="inline">C</fr:tex> to <fr:tex display="inline">D</fr:tex>.</fr:li>
        <fr:li>morphisms are <fr:strong>natural transformations</fr:strong> between functors.</fr:li></fr:ul></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>Here we use a <fr:strong>commutative diagram</fr:strong> to represent a natural transformation.
        When a diagram commutes, morphisms composed by different paths with the same end points
        are equal. The following diagram represents the equality that <fr:tex display="inline">G(f)\circ \alpha _x = \alpha _y\circ  F(f)</fr:tex>.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>687</fr:anchor>
                        <fr:addr type="user">def-003J</fr:addr>
                        <fr:route>def-003J.xml</fr:route>
                        <fr:title text="Natural Transformation">Natural Transformation</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Let <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex> be categories and <fr:tex display="inline">F,G:C\to  D</fr:tex> be functors.
    A <fr:strong>natural transformation</fr:strong> <fr:tex display="inline">\alpha :F\Rightarrow   G</fr:tex> is 
    an assignment to every object <fr:tex display="inline">x\in  C</fr:tex> of a morphism <fr:tex display="inline">\alpha _x:F(x)\to  G(x)</fr:tex> in <fr:tex display="inline">D</fr:tex>,
    (called the <fr:strong>component</fr:strong> of <fr:tex display="inline">\alpha </fr:tex> at <fr:tex display="inline">x</fr:tex>)
    the following diagram commutes in <fr:tex display="inline">D</fr:tex>:
    
 
  
  <fr:figure><fr:resource hash="b5e91e181820d504fc4e45a8daad99b3"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE2MC42MTcwMTFwdCcgaGVpZ2h0PScxMDkuODE1MzkycHQnIHZpZXdCb3g9Jy03MiAtNzIgMTA3LjA3ODAwNyA3My4yMTAyNjInPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS1dvdU5HaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREpBQUFCTXUwS2tleHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHFPK0h2ZmorVzIrTWpDek1JREE0LzFmWnlQby80eE1sNWxCWEE0R0poQUZBRjJLRENnQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1RdkNNQkNGdjJJVnJZT0Q0T0Fnd1I5UXRBb3ViZzVPcmc1dTFnVHAwRlRTV25RUmY3clhFTHlRNDd2MzNoMlE4Q0dpcTRpSjcxM0Y4aWFCKzR5WkJoNkl2Z2ljTUdkSmp5Z2VpYkpnSHpobXlDVndueGw1NElIb3I4QUpXNzZIcW53OEcrUFVxZExHMlZ2cGRtZmo2cUt5YXAydXV2Rm9ySEhYeG1pVnY1VnVpN3E5bDJxVFptbkdnWXFTQjA4YURBN0ZTUlR0MlhJVHo3SGo3T2VhUWp3cm1UVXBxNzk3Rk5mNnhOVmYwWkxJZVV2WHRMSlRTNzlMVnJHUnZhejdQMWt5TGswQUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSOEFBb0FBQUFBQlRnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWk4xZ1dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFETVoyeDVaZ0FBQVdRQUFBRy9BQUFDRUgxRjE0eG9aV0ZrQUFBREpBQUFBQzhBQUFBMktlc3RKMmhvWldFQUFBTlVBQUFBSGdBQUFDUUdHUUtaYUcxMGVBQUFBM1FBQUFBTUFBQUFEQWxxQUx4c2IyTmhBQUFEZ0FBQUFBZ0FBQUFJQUlvQkNHMWhlSEFBQUFPSUFBQUFGd0FBQUNBQUJRQmFibUZ0WlFBQUE2QUFBQURPQUFBQk9QTmRLcDl3YjNOMEFBQUVjQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1WbWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwV01GUXlNL3dIOHBraDBraHEvZ09GQWI4ZURRVUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aVYvLzhEeVlyLy8vOTNndmtNQUZjckJ0VjQya1dRMzJyVFlCakc4N3hKazNacGtpWk52L1JQbG5WZGtpOWQyMlJ0bGtSUjJqSW1va3dtYklLaU1zRWpEN3dDUmZBU3ZBQlBSZkFPUE5jNzhFNDhkbjVSUk43bjVQM3p2UEQ4SkVoWDF6L3BLNzVManlVSktUUVRtbXBCS0VERnlxcXNQT2E1bWxwWHpFMksrUnI1aW5sTTFkZ2VWdVVHWlNGY3NWaG5pUGx4VlZ0SzVxMVJpU3RUZkN6aWt0NjZVU1BPZHpSclR3VW83VWZQQm1EdEpoSzlrMThPSHU0N0o0OGV5RFR0MlNQQUduZWQvdVMya1JoWWpNWlh3NmI1NTlCYVhRYm5vODQybjUwUmtxd0hFeCtNQm1qTzdPMmJ2dDQ5Rk5icTFBS1I3cThzNDBqQllPRW54Tk5vN0hxTnhOUmxXczQvM25TU0FGVGVONGxvWnpjMzIwc0YvcXlYRVY5TVFveE1lUzRKRE5MejY1Uys0SnQwTGhwWkVFbnhQM2FBWElRVHFrbnhtTWQxNHJqbVp1S0EvME1Rd0ZQcm1hQllNOXJRWHlDTVByM1kvZnowNUM2UWVNNFFjQ1pPWmgzZGNRNkNscnVaVjhXeEFpOHlnQ0JjTzNLemJUUVI2RFkvWGE1QnVoY0NXWGdyNmdUUUM0VUZGZ1B3N3RmN2w2K0JuSWVoeTFxSHV0V2lhVGU4TjdQSElOKy84QytlRFB3RTJCWjZTMFR1NVk0dDBPUjg2TjU0TlZzbVVDSXIwcVkvV0FMSEprbjZEU3FPUWZVQWVOcGpZR1JnWUFCaVYyRXp6bmgrbTY4TXpDd01JUEI0LzlmWkNQcS9Ibk1JNHpFZ2w0T0JDU1FLQUJuMkN2a0FlTnBqWUdSZ1lHYjR6d0FrUXhoaUdSeVpkakVBUlZBQU13QkN4UUs1QUFBRFZBQUFBeW9BWHdMc0FGMEFBQUFBQUlvQkNIamFZMkJrWUdCZ1pvaGtBTkVNVUJJSkFBQUphUUJnQUhqYVRZdzliOEl3RUlhZmlBU0pNTENnRGgyS2g4NFJCRmk3TURDeE1yRUFkbEVHMjhnSmtaQ3FqdjNkdmJnZWVwSlB6L3R4QmtxK3lSZ21ZeGIzTURtRnFEOHVtREpQUEJhMVNGenl5anNqc253aXpoc2ZpWE5KVG9rTFh2aE1QQmIvSzNISmhwK2R0L2RIWjRJNmVHMkN1MXJiYkk4bXRJMTNhbFV0bzk0Ylo4SzVNMXBkbmtyM1RkdmZyRnBYZFZXencyTzU4NkRERUZBY3hOR1JIVmZKTEExYmp0RnBoYjM0aWhVVnkzLzVYbklYTytmNGs1Yk9oYWRzVFMrTlZ2Wk51b3ExWE5iRCt3WElteS94QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVg4QUFvQUFBQUFCeUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXRjAybU50WVhBQUFBRTRBQUFBTlFBQUFEd0F2UUJ6WjJ4NVpnQUFBWEFBQUFNa0FBQUQzT2hicVBGb1pXRmtBQUFFbEFBQUFDOEFBQUEyS2FJdU5XaG9aV0VBQUFURUFBQUFIZ0FBQUNRR0xBRzhhRzEwZUFBQUJPUUFBQUFVQUFBQUZBeHNBSlpzYjJOaEFBQUUrQUFBQUF3QUFBQU1BZTRDNEcxaGVIQUFBQVVFQUFBQUZ3QUFBQ0FBQndCYWJtRnRaUUFBQlJ3QUFBRFVBQUFCUHBrUmRjZHdiM04wQUFBRjhBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXFtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHE2TVZReU0vd0g4cGtoMGtocS9nT0ZBZGtIRFNzQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS3VqTlUvdjhQNUxzeFZQei8vMy8zLzI2d0tpQUFBSmNiQ1NvQUFBQjQyaVdTUzQvYlZCaUcvWjVqK3lTT2I0bHZtZGl4azB6R1RpWTBrOG5GVHRJeXFVWXRVNGJlbUtLSyt3YllWT3hhSVNGVmJLZzZRdUlIQUJJL2dtVi9BSWdmd0o0MVc2U3lBVTM0UEdOWlBqNzZQbHZuZWI5SGdwUnR0eHpzbFhRcVNSQnFvUG9KbXdhdWVnQ1JwZGs4RC95OGNEWVlRNlgzYnU1YmNOTU5Gbms2UXFvS1BxTnlIa3dUVU1IRWJpOHI4aXhQZDVGdkZFRDM4b2pMbHZqeHZLckFNdGV4Y2k0RGV5dkx4bXRINTE0SWhWMy81RHh4bE9OUE43bkZkY0VaNUNWWFJJMXhqYkZPZ1h0Ym4xV3JqRUUzVlhBcVZ5MFZjR0lXMTRVaDVFZ0FWZWVYU05ZbXJYVUJlK2ZpUHd5dUIweFJtZm1uVWRIMWtmQ2JFbDJRWnR1L2VJMzlJZDJuRGFlakV0MEc4OVFrYUF0cUVLUHdDMkxaNEFqcEFkUWpKS3lZbXNoUzFXTFVORVpXdHBaclh2WVZmdUFIaE81ejdTWlhOUUprZVB6eitlaDJzMll6K2ZuOWNPazBpc0FVTUp3aWdTbnVuSHhwb0NidkIycFhVNWlvdGl0R21xN2YrdVlIeGgvTlQ1KytlRFFjcUhkTTZPejNpMy9wS3lhczlNTW51SnQvL05IK2V6dlBQZ2V6RmExNXNvb2FGY1o0VkFHNDNDTDRSdWZiekZQQmhwN2RzWnJnUHozLzd0bnAvSXpML1QzemdjbjRGWHU4ZmMwaS9DYTlUeHVDOWR3WWhEQUxmTThscEV1b2N1bWwyUkdLcWUrcXdrOG9oK0lJaXpFRXpabDBJQmt1dVhNL29BbzlUWkppTWMrTE1pMzZLUjd2R25KcmRSYkNFRXBjczRmSDQwSmpZVFR0cnhtU3ByNFRPYmJ0OUdaNk8yUjc5ZkRkTnFzSkJYR3RNVGh1SG52Vi9JMzJUWTUrNWtSKzNYS252dUpoOGYzQ3M4TUJYejNRd1NydW9Wcy9rSEVRYTBsWDd2WmFYZGo3Ylprc3dYcnk1S2svQ3NHV0QzVlFjdTdVcVU5a3hJZHV3UkZuU1FUUGNEc3lXU1FQdGRGVkhtUDhnMStsdDY5Y0lINlMreElwaTB2cThpYm8wbjhpdm9xZ1ZHYU15d2hpZUJTUjZxbGxGQnRPL2djZS92NHNlSGsydWJIblZ1a2tXV0JOamY3U2phUHE2TWJrSFJZbEprZGRoSVhQVlNGa05HcU56aks3VmpIbUNOUFptM3pzbVkxR3lQSHk0dXNQdm1JNHZKc0FadENPZU5zQyt1SHczdUFhVU56cWZmRXdHVFExWUhXaTA5RHRTYXRKa1V4MnJTaDVjYnM5Wi9JdDY5Vlo0U1BVYU96L0E0UEdmWUY0Mm1OZ1pHQmdBR0lwbVRmVzhmdzJYeG1ZV1JoQTRQSCtyN01SOUg4OVptNm1LMEF1QndNVFNCUUFPSEFMaFFCNDJtTmdaR0JnWnZqUEFDUlZHZVQrVDJUbVpnQ0tvQUJXQUVnWUF1NEFBQUoyQUFBQ2tnQW5BeVVBTXdKSkFCNEI5Z0FlQUFBQUFBQjBBUElCZWdIdWVOcGpZR1JnWUdCbGlHUUEwUXhRRWdrQUFBbWZBR0lBZU5wTmpyRnF3ekFVUlkrcFk2aGJ5SlFNSFlxbWpNWjIrZ0dGREpteVppd2trUWd1U0FxeVk4Z1MrZ0g5NkQ0ckd2cUVIa2ZuWFFrQkpYY3lwc3FZeHo1VlRpR25CODk0WVpHNGtLVVNsN3l4NG9rc2Z4Ynp6bWZpbkZlK0VzOVk4cDI0RVArVHVPU0QzNDIzbCt0Z2d0cDViWUk3V2RzMTlkNkV2dk5PTlZYOUVGdmpURGdNUnF2alRlbXg2OGV6VmV1cXJWbzJlQ3dYcmd3WWd2eHNKMFpIZHB4a1p1bG9xTmxIMTh2SnkwU0pxOFQrVDJ3bDRXTHFFRi9Ua2pweWs2NFpKZE5MUDB0YXNaYTc3YlQvQU9DQ01MMTQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVc0QUFvQUFBQUFCckFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hlRjRlR050WVhBQUFBRThBQUFBTlFBQUFFUUFld1JqWjJ4NVpnQUFBWFFBQUFMZEFBQURiSzJKM1dWb1pXRmtBQUFFVkFBQUFDOEFBQUEyS2ZjdU5HaG9aV0VBQUFTRUFBQUFIZ0FBQUNRR29nSXBhRzEwZUFBQUJLUUFBQUFVQUFBQUZBNXJBUmxzYjJOaEFBQUV1QUFBQUF3QUFBQU1BYndDbm0xaGVIQUFBQVRFQUFBQUdBQUFBQ0FBQ0FCUGJtRnRaUUFBQk53QUFBRFBBQUFCT1BOaEtxTndiM04wQUFBRnJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzUTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFIwWTk3SXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBZVZnNU1BSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGszQm5TbURmKy93OWt1VUZZLzNmL24vc25HS3dXREFEMlpBdmJBQUFBZU5wRmtrOXZHMFVZaC9mM3puakg2N1YzMXV2MXJ1dkUzc1pqNzZaS0V4ZHZ0QnRDNmsxYkdsSTNiUnFKcWswcTZEK3BFWENnQjFTaDNub3BOMVJWUFhCQkFuSGhEQnk0MHk4QVJ6NER4M0tObWEwRWFLU1Izdm5OYU9hWjV6VmdmRENmc3h2MHE3RmpHQkJtNktkaDVtQU1NWWl6TU1qeVZwWm44UmltcnBheVFDSlFjYmtpVkd3S2x1b05VNlNUVUpLcEJrbEJXYXp3Y2NFUlpRclMvTzRyaVdaamM5Rjh6Z0RMVFNKNERpbS93VnBvK1JWaUZ4OStHN21WQzhmRmxzT0U3WUxuZ2xzdW1Ba2FiV0EybDd4SlhBbHdIZ21nMWFOT3JTNTB5QWE2dElLZnU2eTdYdVJBSXppWlkvUmV3NWIrbjE1Rk5oWmFuY0RRT01idS9DOTJqLzR3cnVtQ09WQkpuQlJZUTZMZjdrQUVvUjc1SkN0WUZpZXhNS2VJS0orRVRwbHJJTDFQSDlHejV0VWppQkNFdWY0VGRyZGdvbTdyZHdEMzc2eStQSGozTXZoMnZiRXptejdwMkI1Z2QzcjltS1E0dVBuWUlaTG1Ta2NFZnFVZFdXZWVYWDcxSTlqdGpmMm5MKzZzbVdmTldWMDQ5TnZKWEZhSnJFYnY5dWRFNDcydG4yNStNYkdyeTdReUhzNnFsa1VNYktrS0J1NUt6ZDA4L2RIMVhpWHhWa2JzaDZmUEgrK21OeGhYWERYMkhXSWw4OVg1bUQ2bDM0M3RrbG5pTGVrZ1RyUW1UV3NLalRGRndWUXBOSjNpcmI1QU15djlCVm11VFRza2tXYUJtZUQ3VFplN1hldkNPOHVid0xBZE04aElTamxjWXIwMXVkZW5sanlRYlNlNHFNNXNBU3JRdWR1WDB2UDZ0V3IzYmhuajFjbnJXWE43M2IvRVl0VS9UVU16c1MwQ3Y5cis1dTlicGNSYmh3dEpQQnIrSCtGVXZQbzFIMVNoOVJsa0ZQTTM5QXRlRzJzbHphaVBYUGZiZXFxMSthWXdZNjFIL0tlbmoxQ2psZTBZb1krU1c4ditWM1hvYS9hTXp2SEFyZzNyWHMxRXVucHE2cC85Y3Zmb0h2R2Rwbjl3ZlAyVE9vRXVMVlpFVGNkZEszckp3U3Zuemk5Y0d5WDY0alI2OHVKb21jTmJ0RUUxTHlWU21VcEJ4MWNlN1B2dSt3eEhlL2JTNU1OSGJnMUU3WjNtbGM4T3gycHl5S0JXTjU0dHJKOEhEZjRCRURkNkh3QUFBSGphWTJCa1lHQUE0cXZGUEkzeC9EWmZHWmhaR0VEZzhmNnZzeEgwZjMzbUJLWkxRQzRIQXhOSUZBQlM0UXhSQUhqYVkyQmtZR0JtK004QUpQc1k3UDlQWlU1Z0FJcWdBRllBVy9NRDBRQUFBc1lBQUFMbEFFY0RqZ0JJQWpvQVN3TDRBRDhBQUFBQUFHNEE2QUZPQWJaNDJtTmdaR0JnWUdYd1kyQmlBQUZHQmpRQUFBaWpBRmg0MmsyTVBXL0NNQkNHbjRnRWlUQ3dvQTRkaW9mT0VRUWt0aTRNVEt4TUxJQmRsTUUyY2tJa3BLcGpmM2N2cm9lZTVOUHpmcHlCa204eWhzbVl4VDFNVGlIcWp3dW16Qk9QUlMwU2w3enl6b2dzbjRqenhrZmlYSkpUNG9JWFBoT1B4ZjlLWExMaForZnQvZEdab0E1ZW0rQ3UxamJib3dsdDQ1MWFWY3VvOThhWmNPNk1WcGVuMG4zVDlqZXIxbFZkMWV6d1dPNDg2REFFRkFkeGRHVEhWVEpMdzVaamRGcGhMNzVpUmNYeVg3NlgzTVhPT2Y2a3BYUGhLVnZUUzZPVmZaT3VZaTJYOWZCK0Fjd3JML2tBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMktSY3VNMmhvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGpLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaUQrOTJQWS9udC9uS3dNekNBQUtQOTMrZGphRC9NekExTUlPNEhBeE1JQW9Ba2pzTkdnQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZdzlpOEpBRUlhZllDSVlDeHV4c0xqYndqb2swZm9hQ3l0YnEydlVYU1ZGTnJLSkFVRXM3M2M3V1JkdVlJZm4vWmdGVWw1RURCTXg4M3VZbUVUVWh4T216QU9QUlgwSFRsbXlZa1FVVDhUNTRpZHdMTWx2NElRRmw4Qmo4WitCVXpiOGJadjZkdStNVS90R0cyZlB0U3Z5ZzNGdDFWaFZaTG5YTzJPTk8zWkdxOU5ENmI1cSsydXQxbG1abFd4cHFMbHhwOFBnVU96RjBaNHRaOGtjQlRrSDc3UlVrbHBwRldUaS91Yzd5YTN2SFAxUFdqb25IckkxdlZ5MXNxL1NWcXpsc2h6ZUcyUEhMeEVBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE4LjQ2MDk5OSwtMzMuOTc3MjkxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01My43Mzk3OCwtMjkuMTU5NzcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xOC40NjA5OTksLTMzLjk3NzI5MSlzY2FsZSgtMSwtMSknPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNTMzNjU0LC04Ny4wOTc2Mzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMC42NTYyNywwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zLjUzMzY1NCwtODcuMDk3NjM5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zLjUzMzY1NCcgeT0nLTg3LjA5NzYzOSc+RjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc0LjI1NjYwMicgeT0nLTg3LjA5NzYzOSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc4LjEzMDk3NScgeT0nLTg3LjA5NzYzOSc+eDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScxMy44MjQ5MDgnIHk9Jy04Ny4wOTc2MzknPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzUuMzAzOTk2LC04Ny4wOTc2Mzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzMuOTE1NjU3LC04Ny4wOTc2Mzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMC40Mjk0MywwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDczLjkxNTY1NywtODcuMDk3NjM5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9JzczLjkxNTY1NycgeT0nLTg3LjA5NzYzOSc+RjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc4MS43MDU5MTMnIHk9Jy04Ny4wOTc2MzknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nODUuNTgwMjg3JyB5PSctODcuMDk3NjM5Jz55PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzkwLjgyMjIzJyB5PSctODcuMDk3NjM5Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjUzMzY1NCwtNjMuMDI4MTI1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjUzMzY1NCwtMzMuOTc3MjkxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTAuNjc3NzgsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMy41MzM2NTQsLTMzLjk3NzI5MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMy41MzM2NTQnIHk9Jy0zMy45NzcyOTEnPkc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNC4yOTk0NjMnIHk9Jy0zMy45NzcyOTEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nOC4xNzM4MzcnIHk9Jy0zMy45NzcyOTEnPng8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTMuODY3NzY5JyB5PSctMzMuOTc3MjkxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM1LjMwMzk5NiwtMzMuOTc3MjkxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDczLjkxNTY1NywtMzMuOTc3MjkxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTAuNDUwOTQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg3My45MTU2NTcsLTMzLjk3NzI5MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSc3My45MTU2NTcnIHk9Jy0zMy45NzcyOTEnPkc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nODEuNzQ4Nzc0JyB5PSctMzMuOTc3MjkxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jzg1LjYyMzE0OCcgeT0nLTMzLjk3NzI5MSc+eTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc5MC44NjUwOTEnIHk9Jy0zMy45NzcyOTEnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS0yMy41OTQ2NSAyNi42NTk3N0gyMy42NDgzNicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMy44NDgzNCwyNi42NTk3NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOC4zMTQyLDMwLjc2MjUzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTguNDYwOTk5LC0zMy45NzcyOTEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE4LjQ2MDk5OScgeT0nLTMzLjk3NzI5MSc+RjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTIuMzM2MDE3JyB5PSctMzMuOTc3MjkxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy05LjIyMjY3NCcgeT0nLTMzLjk3NzI5MSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNC41NTYwOScgeT0nLTMzLjk3NzI5MSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00tMjMuNTczMTQtMjYuNjU5NzdIMjMuNjI2ODUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjMuODI2ODMsLTI2LjY1OTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04LjM1MzIxLC0yMi41NTcwMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE4LjQ2MDk5OSwtMzMuOTc3MjkxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xOC40NjA5OTknIHk9Jy0zMy45NzcyOTEnPkc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTEyLjI1ODI3NicgeT0nLTMzLjk3NzI5MSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctOS4xNDQ5MzInIHk9Jy0zMy45NzcyOTEnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQuNDc4MzQ4JyB5PSctMzMuOTc3MjkxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS0zOC43NTY0NSAxNy44MDAwNVYtMTcuNDAwMDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwtMzguNzU2NDUsLTE3LjYwMDA3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zNi40MDM3LC0xLjAwNjk0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTguNDYwOTk5LC0zMy45NzcyOTEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE4LjQ2MDk5OScgeT0nLTMzLjk3NzI5MSc+zrE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTEzLjI4MTY1OCcgeT0nLTMyLjk4MTAyNyc+eDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00zOC45ODMyOSAxNy44MDAwNVYtMTcuNDAwMDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwzOC45ODMyOSwtMTcuNjAwMDcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMzM2MDQsLTAuNTIwODQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xOC40NjA5OTksLTMzLjk3NzI5MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTguNDYwOTk5JyB5PSctMzMuOTc3MjkxJz7OsTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTMuMjgxNjU4JyB5PSctMzIuOTgxMDI3Jz55PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4="></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            {F(x)} &amp;&amp; {F(y)} \\
            \\
            {G(x)} &amp;&amp; {G(y)}
            \arrow [&quot;{F(f)}&quot;, from=1-1, to=1-3]
            \arrow [&quot;{G(f)}&quot;, from=3-1, to=3-3]
            \arrow [&quot;{\alpha _x}&quot;, from=1-1, to=3-1]
            \arrow [&quot;{\alpha _y}&quot;, from=1-3, to=3-3]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>688</fr:anchor>
                    <fr:addr type="machine">#352</fr:addr>
                    <fr:route>unstable-352.xml</fr:route>
                    <fr:title text="Basic Category Theory Structures">Basic Category Theory Structures</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Though the theory is already rich by only considering sets and categories, 
        it would not be interesting enough. We want to know a little more about the 
        category that we are working with. To achieve so, we can require some additional
        structures on the category. A common structure is the cartesian product.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>689</fr:anchor>
                        <fr:addr type="user">def-003P</fr:addr>
                        <fr:route>def-003P.xml</fr:route>
                        <fr:title text="Cartesian Product">Cartesian Product</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Given any category <fr:tex display="inline">\mathcal {C}</fr:tex>, and any set <fr:tex display="inline">\{X_i\}_{i\in  I}</fr:tex> of
    its objects, the product of all these objects is, if it exists, an object
    <fr:tex display="inline">         \prod _{i\in  I} X_i \in  \mathcal {C}     </fr:tex>
    equipped with morphisms (projections)
    <fr:tex display="block">         p_i : \left (\prod _{i\in  I} X_i\right ) \to  X_i     </fr:tex>
    for each <fr:tex display="inline">i\in  I</fr:tex>, such that it is <fr:strong>universal with this property</fr:strong>, i.e.
    such that given any other object <fr:tex display="inline">Q\in  C</fr:tex> with morphisms
    <fr:tex display="inline">         Q \xrightarrow {f_i} X_i      </fr:tex>
    there is a <fr:strong>unique</fr:strong> morphism
    <fr:tex display="block">         (f_i)_{i\in  I} : Q \to  \prod _{i\in  I} X_i     </fr:tex>
    where the following diagram commutes:
    
 
  
  <fr:figure><fr:resource hash="d048e45614c73265beb2fc1d1f8d51d6"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3OC42MjAwNDVwdCcgaGVpZ2h0PScxMDUuMjc1MDU5cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE5LjA4MDAzIDcwLjE4MzM3Mic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21leDEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNd0FBb0FBQUFBQTVnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdjRnBhUkdOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9Da1oyeDVaZ0FBQVd3QUFBQmhBQUFBYk55UGowMW9aV0ZrQUFBQjBBQUFBQzBBQUFBMktpTW9NV2hvWldFQUFBSUFBQUFBSGdBQUFDUUczZmd1YUcxMGVBQUFBaUFBQUFBSUFBQUFDQVdjQURsc2IyTmhBQUFDS0FBQUFBWUFBQUFHQURZQUFHMWhlSEFBQUFJd0FBQUFGd0FBQUNBQUJBQWhibUZ0WlFBQUFrZ0FBQURWQUFBQlBxQW5kY1p3YjNOMEFBQURJQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Pc2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFBQkpIWktjVms2QTl1RHdBZUJ6T0pmTkJrWW1NVzVyd09GR1JFcS92OW5ZQUFBUk1vUVhBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROEMvLytIa1BJYndQSU1BR2NuQjQwQUFIamFZMkJrc1B6RHdOekR3TUFnejhEQXFHaHF4Nmd1YUthbWJxb295c2NvTHNnbUppNEtFVk1Fc1JrTC9wMzBVV1JtVnZSaER2WUcwZDcvVHZrb3N2eHpCNHI4WWRCa01wVmk1cEV5WmRJRXNmNThnYkdZWS84c0JySVpBT1d3RlRrQUFBQjQybU5nWkdCZ0FPTFk1ZGVLNC9sdHZqSXdzekNBd09QOVgyY2g2RDhNekQxZ1lRNEdKaEFGQUZ6U0MrMEFBQUI0Mm1OZ1pHQmdGditpQ1NTUE0xZ3lXRFAzTUFCRlVBQVRBRTBUQXdrQUFBSFZBQUFEeHdBNUFBQUFBQUEyQUFCNDJtTmdaR0JnWUdKUVlBRFJERkFTQ1FBQUE3MEFKZ0I0MmsyT3NXckRNQkNHUDFQSFVMZlFxUjB5RkUwWmplMzBBUW9aTW1YTkdFaWlJN2hnT2NpT1NaYlNCK2hEOTZ4bzZBbjlmUHJ2djBOQXpqY0pVeVc4QkowcUpkUFhuV2M4OFJvNTAyTWk1OHhaOEVDU1Bxcnp6bWZrbEdkMmtXZTg4UlU1VS84bmNzNEh2NnV1UFY4RzhXYlRXZkh1Mk1xMUtyZmkrNlp6cGlyS3U3RVdKMzQvaURXSG03RmowNCtuMWl5THVxaFowZEZ5NXNLQTRQVm5HM1ZzWU1kUmU4S1ZpcEp0OEhvYTdUdk5WUlRxL2src2xWeEk3Y00ycTZrRE4xWExxSE85NmtuemhxWE8xdFA5QSsxck1Oa0FBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTThBQW9BQUFBQUE2UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncWxPVlhtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSmJaMng1WmdBQUFXd0FBQUIzQUFBQWdGcnJ4MUZvWldGa0FBQUI1QUFBQUM4QUFBQTJLdXd1TVdob1pXRUFBQUlVQUFBQUlBQUFBQ1FHOGdFMmFHMTBlQUFBQWpRQUFBQUlBQUFBQ0FnY0FLUnNiMk5oQUFBQ1BBQUFBQVlBQUFBR0FFQUFBRzFoZUhBQUFBSkVBQUFBRndBQUFDQUFCQUFvYm1GdFpRQUFBbHdBQUFET0FBQUJPQk45S3Jkd2IzTjBBQUFETEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNFdPY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeG9BQUhHQ09sdUN5ZGdVMkpRNG1EV2V1UEpRTURzeGJ6Y2FBd0kwTHAvLzhNREFETlZ3M21BQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVW9jLy85RHlMcy93ZklNQUZEV0JvWUFBSGphWTJCa1dQSi9Cck1TVXdhREdnT0RxcUljbzdpeG1aZ0ltN3F5bWpvSW1wbURJRlNJajVGZEVjUmkrdjczQmZmMm5sTzhjbks4NS9xeXhVVmpXRmhpUk1Xeis4NkJSRTcxYk9kbWtnQ3lIaGZPWldiazFPUmtaQW9VRWszbzdVMFFGUXBrQWdzd3p5MWs1TkxnWW1CZ0FBRGRLaHRNQUhqYVkyQmtZR0FBNHY4dGp4UGorVzIrTWpDek1JREE0LzFmWnlIby96TllRcGt5Z0Z3T0JpYVFLQUI5NkEwMkFIamFZMkJrWUdEVyttUEp3TUFTeXJDRVlTbXpFZ05RQkFVd0FRQlJpUU11QkZVQUFBUEhBS1FBQUFBQUFFQUFBSGphWTJCa1lHQmdZbEJuQU5FTVVCSUpBQUFFYkFBdEFIamFUWXc5YjhJd0VJYWZpQVNKTUxCVUhUcUFCK1lJUWxtN01EQ3hNckVBTmloREhHU0hTSkdxanYzZHZiZ2VPTW1uNS8wNEF6ay9KQXlUTUF0N21KUk0xRDluVEhtTFBCYTFpSnp6d1pJUlNUb1JaODVYNUZTU1UrU01kMjZSeCtKL1I4NzU1SGZYMUk5bmE1dzZOTm80ZTYxOXZ6MGE1NnZHcW5XeENucHZySEhuMW1oMTZaWHVLdC9kYTdVcHlxSmtSMFBOZ3ljdEJvZmlJSTRPYkxsSzV1blpjZ3lPcDVMVVNtdE53ZW9sMzB0dVErY2NmdExTdVVpaWhEcTU4ckx2MGxaczVMSWMzaC93Y3pCSkFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS1dvdU1taG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREpBQUFCTXUwS2tleHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHFPK0hvL2orVzIrTWpDek1JREE0LzFmWnlIby80eE1sNWxCWEE0R0poQUZBRjRJRENvQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1RdkNNQkNGdjJJVnJZT0Q0T0Fnd1I5UXRBb3ViZzVPcmc1dTFnVHAwRlRTV25RUmY3clhFTHlRNDd2MzNoMlE4Q0dpcTRpSjcxM0Y4aWFCKzR5WkJoNkl2Z2ljTUdkSmp5Z2VpYkpnSHpobXlDVndueGw1NElIb3I4QUpXNzZIcW53OEcrUFVxZExHMlZ2cGRtZmo2cUt5YXAydXV2Rm9ySEhYeG1pVnY1VnVpN3E5bDJxVFptbkdnWXFTQjA4YURBN0ZTUlR0MlhJVHo3SGo3T2VhUWp3cm1UVXBxNzk3Rk5mNnhOVmYwWkxJZVV2WHRMSlRTNzlMVnJHUnZhejdQMWt5TGswQUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU2dBQW9BQUFBQUJWd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFd4MU4yTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWNRQ25aMng1WmdBQUFXd0FBQUhWQUFBQ0pFbmVseUJvWldGa0FBQURSQUFBQUM4QUFBQTJLZjR1UEdob1pXRUFBQU4wQUFBQUhnQUFBQ1FHaGdJOWFHMTBlQUFBQTVRQUFBQU1BQUFBREFqdkFFNXNiMk5oQUFBRG9BQUFBQWdBQUFBSUFJQUJFbTFoZUhBQUFBT29BQUFBRmdBQUFDQUFCd0JoYm1GdFpRQUFBOEFBQUFEVUFBQUJQcGtSZGNkd2IzTjBBQUFFbEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtK3NVNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUU1aSWhnWnZnUDVETkRwSkhVL0FjS0F3QUVkQTJUZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLQmpKRS9QOFA1SVBwL3h2K3J3S3JBZ0lBbEpjSkVnQUFBSGphTlZCTmF4TlJGSDNudnBuMzhqRWZTWnpKSUNRemFSTm5RdEdKTWMxTUkwMWlWNlZTVTBIcFFnUUZMUTBpV3FzdUZBU3JLM1doSVA0RS9RSHVGRGYrQVJldS9BbHVYZWpTK0NaQjd1YWVjKzY1Y0E3ajdNeHNRSC9vTzR2WUJwc3dkc0pIV2szU0VhcFNxQWs3Q01jUVVZd29TYlB4NFdXODBNTm9oQXpONlV4ZkZ0S0M1MVM5ek4xUEZKQSs4Rlg2emZxbVF3NjVkaEJ0ckp1OFNOcXdmZkNXODR1clczZWZQbmhOZkdLV2QvOSs0eHpEbFhTSmJ2YjhVaDI0TVJrOEg1dzlqYlhIY1R1bjRkeHlCN1FrQmwzZ1ZGS0EwMjlIZlkySElxenRsSUUzUnk4ZVhrZ3VjWHIzNU9VOXQzS3JSY0hLQ05wMnNMNjNsdTZQcHdmWW11eCtXdHU4M1VLRlpQRUtSN2ZSTUJsallMWFpqTy9URjNaTkFSVWxKcFVyVUIwRWNFUlRaUkEyMU82ajUxVmRDeDNJS0l4V2s1NksySUdOZVVnbGVYTkp0VFdYeHNSak5NWGlrK2NqZStUaTE0Y1NwK0FZWU9xSDEvTkVSaUVldThmVForWFdUcUhlTlNRWjR2QW9yOFBJK2I0K3ZUb3Rsa0JCVG1xQW9kOWZHS0x6b2ZuamtWNDc2VkpHTHE0Yk5iei9hSG1PZ1lJbG9XclVoQ1c0NzFTSHIrTExuMzBiVkxDRTRnbDVVMm9WYWYvZXUxUDBUS2RJbFB0dnNBVTFJdU1uL0ZLWld3dVNYS201T21QL0FIVnpUYVlBQUFCNDJtTmdaR0JnQU9JRVp2bUQ4ZncyWHhtWVdSaEE0UEgrcjdNUTlIOUw1blNtUzBBdUJ3TVRTQlFBT1BJTHpnQjQybU5nWkdCZ1p2alBBQ1FER0dUK3YyUk9ad0NLb0FCbUFGb25BOGtBQUFKMkFBQURLUUF5QTFBQUhBQUFBQUFBZ0FFU2VOcGpZR1JnWUdCbVNBQmlFR0JrUUFNQUNrWUFhUUFBZU5wTmpyRnF3ekFVUlkrcFk2aGJ5SlFNSFlxbWpNWjIrZ0dGREpteVppd2trUWd1U0FxeVk4Z1MrZ0g5NkQ0ckd2cUVIa2ZuWFFrQkpYY3lwc3FZeHo1VlRpR25CODk0WVpHNGtLVVNsN3l4NG9rc2Z4Ynp6bWZpbkZlK0VzOVk4cDI0RVArVHVPU0QzNDIzbCt0Z2d0cDViWUk3V2RzMTlkNkV2dk5PTlZYOUVGdmpURGdNUnF2alRlbXg2OGV6VmV1cXJWbzJlQ3dYcmd3WWd2eHNKMFpIZHB4a1p1bG9xTmxIMTh2SnkwU0pxOFQrVDJ3bDRXTHFFRi9Ua2pweWs2NFpKZE5MUDB0YXNaYTc3YlQvQU9DQ01MMTQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVZvQUFvQUFBQUFCbHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXUjBoMk50WVhBQUFBRTRBQUFBT3dBQUFFd0JGQUVFWjJ4NVpnQUFBWFFBQUFLS0FBQURFRHR6MHlGb1pXRmtBQUFFQUFBQUFESUFBQUEyS1Z3dU1XaG9aV0VBQUFRMEFBQUFJQUFBQUNRRmJBR2NhRzEwZUFBQUJGUUFBQUFVQUFBQUZBci9BTHhzYjJOaEFBQUVhQUFBQUF3QUFBQU1BVllDTm0xaGVIQUFBQVIwQUFBQUdBQUFBQ0FBQ0FCUGJtRnRaUUFBQkl3QUFBRFBBQUFCT1BOaEtxTndiM04wQUFBRlhBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbU1tS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TWhRd00vd0g4cGtoMGtocS9nT0ZBYjE5RE5zQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdDeUFOQmNEQjFDT2ljR1RJWTBoazZIZy8zK2dHSno5ZjhmL09mOW4vWjhDMWdFRkFGZTdEZzhBZU5wRmtyMXYwMEFZeHUrNWMrNmF1UGpzMkRuSEpYSFNPTFZiQWttYUQ2ZHFTNXEwdEVqOUVFSUlTaGZZa0ZxeE1pRWtSbUJnWW1CbEFQNEpSdm9IVkl5SWlaRVp0aEl1UlFqZHF4dmU1ejNwK2IzUEVaRE55WVF1MEUra1FRaVk0S3FDMU9NdEt1SVdlcW5mU1FkdTJrK2pKT0pEVk9nR1F2QWs1dmo0d29Cd3JsWWwzN241eW1UVThWWkt4a3VEaG9GVmc1MDVydS9jc09HNmd6STlPZi91Q3dGcVJBSU1Ccmh3Qk55QVZtZXpGak5xMDZhdXNnQThvaTJRdlVtTG50QXpNcHI2a1hyY2dxakZ5UkJkNVNzdXRMOGhObGpFNDlUdkRqSFEvWTd5TFVSeEVxY0RiZHFpRXQxVThRVHZWbTNEbnN1T2x4ZFhnWG9oWnBBVktXVjlucFdiY2ora3Jyd3RDNWJhakpiV2dVaHAzUTZsek9mRDNNemN3Nm1NTjc4Lzd6cWpucmZGNGlpczBqcFB6Q3lGc1ZkNCsvT1FhZXVIUjVlVGVLSCtYMElRWDN0dDFHYWdVUWdsN2NrdlBLSWZTSTZzYXhvTjBrUi9pSTVpRzBqN1BWSGpna2RKblBRR3FUNGhmQzdwbEhlNjliVHJoeEI2UUw5SlV1eGp2dWdWRURXOHM5RWNEOEoxRDQ3SlVUU2RhTmpvQTVrZ3lFdWJsU3ByTG5XeUhNck1SOWUxUU9sek5RLzRVczBINXovZWIzcDJ3dFkyYlVxejFySXFORFBvMUIxN1BGNjhVdDNHeHZVOHBYN2JWMDBEeXd0RlFpZVR5UXBkeGFsMmYwQ0k3dzU2Y2FJaExMVFFSS3BYUDBpVi8vZm0vNnh5SFZsQmg5UlJCVS9EQ1o1Yy9DSlhjUDlpZG9oK1U0ZkZENTR3NllZMU15Tnlta1BKMlNRTXhsTHR0MWNlTURhMjgzdjNtcDJzNndvRHNwYXpMNG5IOTAzbW1HWG5OSVdydW92YmJyR01SaGpzUHNPWFNxRUVqSnFlcVdudHJaS3FBbUhEYjFIY09UcSs1VGxiakM0NVczZExGcDltbDdPeWhnRkhDdGo0K20xMm9aN0JldEorR3ZWYWlBbjVBNEVzWlZnQUFIamFZMkJrWUdBQTRpTnJUVjdIODl0OFpXQm1ZUUNCeC91L3pvTFIvLy8vMTJjNnhuUVJ5T1ZnWUFLSkFnQ2FkdzlzQUFCNDJtTmdaR0JnWnZqUHdNREFkT3ovLy84WG1MSVlnQ0lvZ0JVQWovb0dDd0xHQUFBQ0JnQkNBam9BU3dHZUFEQUNXdi8vQUFBQUFBQklBSzRCRGdHSWVOcGpZR1JnWUdCbDhHTmdZZ0FCUmdZMEFBQUlvd0JZZU5wTmpEMXZ3akFRaHArSUJJa3dzS0FPSFlxSHpoRUVKTFl1REV5c1RDeUFYWlRCTm5KQ0pLU3FZMzkzTDY2SG51VFQ4MzZjZ1pKdk1vYkptTVU5VEU0aDZvOExwc3dUajBVdEVwZTg4czZJTEorSTg4Wkg0bHlTVStLQ0Z6NFRqOFgvU2x5eTRXZm43ZjNSbWFBT1hwdmdydFkyMjZNSmJlT2RXbFhMcVBmR21YRHVqRmFYcDlKOTAvWTNxOVpWWGRYczhGanVQT2d3QkJRSGNYUmt4MVV5UzhPV1kzUmFZUysrWWtYRjhsKytsOXpGempuK3BLVno0U2xiMDB1amxYMlRybUl0bC9Yd2ZnSE1LeS81QUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTThBQW9BQUFBQUE2QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncWxHVWttTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSmJaMng1WmdBQUFXd0FBQUIxQUFBQWZCZVpiMUpvWldGa0FBQUI1QUFBQUM4QUFBQTJLaWd1TW1ob1pXRUFBQUlVQUFBQUhnQUFBQ1FHTmdBMWFHMTBlQUFBQWpRQUFBQUlBQUFBQ0Fha0FHOXNiMk5oQUFBQ1BBQUFBQVlBQUFBR0FENEFBRzFoZUhBQUFBSkVBQUFBRndBQUFDQUFCQUFuYm1GdFpRQUFBbHdBQUFEUEFBQUJPQk9CS3J0d2IzTjBBQUFETEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRG1LY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeG9BQUhHQ09sdUN5ZGdVMkpRNG1EV2ZHUEVRTURzeUx6T2FBd0kwTHAvLzhNREFEajB3NFhBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVW9jLy85RHlMcy93ZklNQUZEV0JvWUFBSGphWTJCa3lQKy9rV2tKVXdDREtnT0RxcUljbzdpeG1aZ0ltN3F5bWo2am1ycVpPUWhDUmZnWTJSVkJMS2FhZjJxOFM2clc4MGxKODI3dVNCU0xZR1lPNStaSjdOZ01FbGhmdFlTWDhSYVE5Ynh3QWhNamh3b0hJM093V0V4N1N3d3ZkekF6bU04MG9aQ1JVNW1UZ1FFQUpBOFpZUUFBQUhqYVkyQmtZR0FBNGg3SjZkWHgvRFpmR1poWkdFRGc4ZjZ2c3hEMC80M01FNWtDZ0Z3T0JpYVFLQUJSS2d4aUFIamFZMkJrWUdCVy9HTUVKQ2N5NURQa015MWhBSXFnQUNZQVZjb0Rid0FBQTVFQUFBTVRBRzhBQUFBQUFENEFBSGphWTJCa1lHQmdZbEJqQU5FTVVCSUpBQUFFVXdBc0FIamFUWXc5YjhJd0VJYWZpQVNKTUxCVUhUcUFCK1lJUWlXMkxneE1yRXdzZ0EzS0VBZlpJVktrcW1OL2R5K3VCMDd5NlhrL3prRE9Ed25ESk16Q0hpWWxFL1hQR1ZQZUlvOUZMU0xuZkxCa1JKSk94Sm56RlRtVjVCUTU0NTFiNUxINDM1RnpQdm5kTmZYajJScW5EbzAyemw1cjMyK1B4dm1xc1dwZHJJTGVHMnZjdVRWYVhYcWx1OHAzOTFwdGlySW8yZEZROCtCSmk4R2hPSWlqQTF1dWtubDZ0aHlENDZra3RkSmFVN0I2eWZlUzI5QTVoNSswZEM2U0tLRk9ycnpzdTdRVkc3a3NoL2NIOUFNd1VRQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRSUFBb0FBQUFBQkpnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoV1IwOVdOdFlYQUFBQUU0QUFBQU1RQUFBRHdBbXdDR1oyeDVaZ0FBQVd3QUFBRkJBQUFCYUt2K2pBcG9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktlc3U0bWhvWldFQUFBTGdBQUFBSGdBQUFDUUYwQUpvYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWYzQU5Cc2IyTmhBQUFEREFBQUFBZ0FBQUFJQUU0QXRHMWhlSEFBQUFNVUFBQUFHQUFBQUNBQUJnQkNibUZ0WlFBQUF5d0FBQURPQUFBQk9QTmRLcDl3YjNOMEFBQUQvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1XczQ0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUMFpNaGtadmdQNURORHBKSFUvQWNLQXdEbk13MUplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtlakprL3Y4UDVJUHAvenYrendTckFnSUFsWXdKR3dBQUFIamFKWTVMVGdKQkdJUzcvaGthNXNFTUE5MDk4bkFJWUtZaEVoNEJoNDBPUklrbUxtVGwwc1RFQXhqakFkeVplQUV2NFJWY2V3ZHY0QVZjS2pheGFsSEo5MjJLZ1QxdXQvUkE3MnpNR0N5dTJzaVVERENtRUYwOXoyS1ZMV3JaUE5WcGthZEhPZHEwaEpLQzY1VGo2d1d1SElZU05YNTV0Ym1va0pUSGlmMXN1YUxqVmNTT2JqYm5OU1ZPOXVudTU1TVhRT0MrZEdBQlZtUVdVWU5penl2c0FDK0xmMEdoY0kxaEpzUnV0dC80b0RmbXNwVjVGNkRZVFhWT3FpYUszSFFFblMydHpGd3pKa0JQcDNxK3lFd1R4RHkwdU9SeGprV09XYXp3U3IxbXBRbm93L3BrMzQ4R3ArTVZ5SW43clJJaDZhNnFWc2t2bDVCNGtWNVBjeURvamh5Yk9qb1A3Skx2Ty9TMGR3Q2w2ajAwZmtsTVJYVnNZektveSt6MkxDbjJnWHpoT1VTdW5GV2ppWTE1R3JldTd4dGVwV2ZSZWhnYXcvNEFiVVVySUFBQUFIamFZMkJrWUdBQTRsZm5MN3JHODl0OFpXQm1ZUUNCeC91L3prTFEvNzh5aHpEdEFYSTVHSmhBb2dDSWVRM3RBSGphWTJCa1lHQm0rTThBSkVNWVloa0VtQW9aZ0NJb2dCa0FPVlVDUHdBQUExUUFBQUtCQUhNQ0lnQmRBQUFBQUFCT0FMUjQybU5nWkdCZ1lHWndaR0JpQUFGR0JqUUFBQWNvQUVsNDJrMk1QVy9DTUJDR240Z0VpVEN3b0E0ZGlvZk9FUVJZdXpBd3NUS3hBSFpSQnR2SUNaR1Fxbzc5M2IyNEhucVNUOC83Y1FaS3Zza1lKbU1XOXpBNWhhZy9McGd5VHp3V3RVaGM4c283STdKOElzNGJINGx6U1U2SkMxNzRURHdXL3l0eHlZYWZuYmYzUjJlQ09uaHRncnRhMjJ5UEpyU05kMnBWTGFQZUcyZkN1VE5hWFo1SzkwM2IzNnhhVjNWVnM4Tmp1Zk9nd3hCUUhNVFJrUjFYeVN3Tlc0N1JhWVc5K0lvVkZjdC8rVjV5Rnp2bitKT1d6b1duYkUwdmpWYjJUYnFLdFZ6V3cvc0Z5SnN2OFFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21leDEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04Ljg5Mzg3OSwtMzYuOTA4MzE2KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01Ni4xODM4LC0yOC4wMzM4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOC44OTM4NzksLTM2LjkwODMxNilzY2FsZSgtMSwtMSknPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTMuMDk0OTUyLC04OS40NzUyMjgpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjk1Mjc3LDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTMuMDk0OTUyLC04OS40NzUyMjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTMuMDk0OTUyJyB5PSctODkuNDc1MjI4Jz5RPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEzLjA5NDk1MiwtNjUuOTU5MjExKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEzLjA5NDk1MiwtMzYuOTA4MzE2KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTcuNzY1NzUsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxMy4wOTQ5NTIsLTM2LjkwODMxNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y2JyB4PScxMy4wOTQ5NTInIHk9Jy00NC4zODAzNTcnPu6BkTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScyMi41MDQxNDEnIHk9Jy0zMy45MTk0NzknPmk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjUuMzIyODY4JyB5PSctMzMuOTE5NDc5Jz7iiIg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMzAuNjkxNjUnIHk9Jy0zMy45MTk0NzknPkk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMzYuOTIzMDkyJyB5PSctMzYuOTA4MzE2Jz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzQ1LjE3Njg4MScgeT0nLTM1LjQxMzkzNSc+aTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1OC45OTQwODksLTM2LjkwODMxNilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5Mi45NzkxNjMsLTM2LjkwODMxNilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuODA3LDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoOTIuOTc5MTYzLC0zNi45MDgzMTYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nOTIuOTc5MTYzJyB5PSctMzYuOTA4MzE2Jz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzEwMS4yMzI5NTInIHk9Jy0zNS40MTM5MzUnPmk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS0xMS44NDEyMy0yNS41MzM4SDM1LjM1ODc1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM1LjU1ODczLC0yNS41MzM4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDguMzEzNjQsLTIxLjgxOTk2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOC44OTM4NzksLTM2LjkwODMxNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOC44OTM4NzknIHk9Jy0zNi45MDgzMTYnPnA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQuNzg2OTIzJyB5PSctMzUuOTEyMDUyJz5pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS0yNS42NTQyIDIxLjY2OThMMzUuNDI0NjUtMTguNTMwNicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjgzNTI3LC0wLjU0OTc0LDAuNTQ5NzQsMC44MzUyNywzNS41OTE2NywtMTguNjQwNTIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNy40MDUsNS4xNzM1MiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTguODkzODc5LC0zNi45MDgzMTYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTguODkzODc5JyB5PSctMzYuOTA4MzE2Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01LjAwOTA5MicgeT0nLTM1LjkxMjA1Mic+aTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00tMzQuMTEyNTIgMTguOTI2MDlWLTE2LjI3NDA1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsLTM0LjExMjUyLC0xNi40NzQwMyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjEuMTksLTAuNjIzOTYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC04Ljg5Mzg3OSwtMzYuOTA4MzE2KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy04Ljg5Mzg3OScgeT0nLTM2LjkwODMxNic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNS43ODA1MzYnIHk9Jy0zNi45MDgzMTYnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTEuODk1NzQ5JyB5PSctMzUuOTEyMDUyJz5pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzEuMjYwMjYzJyB5PSctMzYuOTA4MzE2Jz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzQuMzczNjA2JyB5PSctMzUuOTA2NTA0Jz5pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzcuMDMxNScgeT0nLTM1LjkwNjUwNCc+4oiIPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzExLjczNjE0NycgeT0nLTM1LjkwNjUwNCc+STwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+"></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            Q \\
            \\
            {\prod _{i\in  I} X_i} &amp;&amp; {X_i}
            \arrow [&quot;{p_i}&quot;, from=3-1, to=3-3]
            \arrow [&quot;{f_i}&quot;, from=1-1, to=3-3]
            \arrow [&quot;{(f_i)_{i\in  I}}&quot;&apos;, from=1-1, to=3-1]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>With this definition, it is natural to ask what can serve as a <fr:strong>nullary product</fr:strong>.
        The concept is characterized by terminal objects.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>690</fr:anchor>
                        <fr:addr type="user">def-003Q</fr:addr>
                        <fr:route>def-003Q.xml</fr:route>
                        <fr:title text="Terminal Object">Terminal Object</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>A <fr:strong>terminal object</fr:strong> in a category <fr:tex display="inline">\mathcal {C}</fr:tex> is an object <fr:tex display="inline">\top </fr:tex> of <fr:tex display="inline">\mathcal {C}</fr:tex> 
    satisfying the following universal property: for any object <fr:tex display="inline">X</fr:tex> in <fr:tex display="inline">\mathcal {C}</fr:tex>,
    there exists a unique morphism <fr:tex display="inline">!:X\to  \top </fr:tex>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>When making math statements, we often encounter concepts that are dual to each other.
        In category theory, this phenomenon is captured by the concept of <fr:strong>duality</fr:strong>.
        Intuitively, duality offers us free dual theorem from the original one.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>691</fr:anchor>
                        <fr:addr type="user">def-003R</fr:addr>
                        <fr:route>def-003R.xml</fr:route>
                        <fr:title text="Opposite Category">Opposite Category</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>For a category <fr:tex display="inline">\mathcal {C}</fr:tex>, the <fr:strong>opposite category</fr:strong> <fr:tex display="inline">\mathcal {C}^{op}</fr:tex> 
    has the same objects as <fr:tex display="inline">\mathcal {C}</fr:tex>, but the morphisms are reversed.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>For example, the product in the opposite category, all <fr:strong>universal properties</fr:strong> corresponds
        to a dual concept.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>692</fr:anchor>
                        <fr:addr type="user">def-003S</fr:addr>
                        <fr:route>def-003S.xml</fr:route>
                        <fr:title text="Coproduct">Coproduct</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>For <fr:tex display="inline">\mathcal {C}</fr:tex> a category and <fr:tex display="inline">X, Y \in \text {Ob}{\mathcal {C}}</fr:tex>,
    the <fr:strong>coproduct</fr:strong> is an object <fr:tex display="inline">X\sqcup   Y</fr:tex> equipped with 
    two morphisms <fr:tex display="inline">i_X:X\to  X\sqcup   Y</fr:tex> and <fr:tex display="inline">i_Y:Y\to  X\sqcup   Y</fr:tex> such that
    it is universal with this property. That is, for any object <fr:tex display="inline">Z</fr:tex> and morphisms
    <fr:tex display="inline">f:X\to  Z</fr:tex> and <fr:tex display="inline">g:Y\to  Z</fr:tex>, there exists a unique morphism <fr:tex display="inline">\langle  f, g\rangle :X\sqcup   Y\to  Z</fr:tex>
    such that the following diagram commutes:
    
 
  
  <fr:figure><fr:resource hash="201c2fae0554c137f88cc7a14c567ddc"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI0OS43NzExODNwdCcgaGVpZ2h0PSc5OS4zMTA5ODRwdCcgdmlld0JveD0nLTcyIC03MiAxNjYuNTE0MTIyIDY2LjIwNzMyMyc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTU1BQW9BQUFBQUEzUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFhaMEQyTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWNRQzJaMng1WmdBQUFXd0FBQUJJQUFBQVNFRUxLRDVvWldGa0FBQUJ0QUFBQUM0QUFBQTJLV291TTJob1pXRUFBQUhrQUFBQUh3QUFBQ1FFVEFINGFHMTBlQUFBQWdRQUFBQUtBQUFBQ2dRL0FJdHNiMk5oQUFBQ0VBQUFBQWdBQUFBSUFCSUFKRzFoZUhBQUFBSVlBQUFBRndBQUFDQUFCUUFKYm1GdFpRQUFBakFBQUFESkFBQUJNdTBLa2V4d2IzTjBBQUFDL0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtUE1zNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwU01ab2hsWnZnUDVETkRwSkhVL0FjS0F3RDFkUTEwZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLUmpQRS92OFA1SVBwLzh2K0x3V3JBZ0lBbGw0SklRQUFBQUFCQUl2L0FBRXBBd0FBQndBQUFTTVJNeFVqRVRNQktaNmViR3ovQUFRQU12eGtBQUFCQUNIL0FBQytBd0FBQndBQUV4RWpOVE1SSXpXK25XdHJBd0Q4QURJRG5ESUFBSGphWTJCa1lHQUE0cHYxTjRYaitXMitNakN6TUlEQTQvMWZaeVBvL3d4TWw1bEJYQTRHSmhBRkFHQ0ZERElBQUhqYVkyQmtZR0JtK00vQXdNQjBtVUdSUVlsUmt3RW9nZ0tZQUR4TEFra0FBdE1BQUFGTEFJc0FJUUFBQUFBQUFBQVNBQ1I0Mm1OZ1pHQmdZR2JnWUFEUkRGQVNDUUFBQVlBQUR3QjQyajJNTVF2Q01CQ0Z2MklWcllPRDRPQWd3UjlRdEFvdWJnNU9yZzV1MWdUcDBGVFNXblFSZjdyWEVMeVE0N3YzM2gyUThDR2lxNGlKNzEzRjhpYUIrNHlaQmg2SXZnaWNNR2RKanlnZWliSmdIemhteUNWd254bDU0SUhvcjhBSlc3Nkhxbnc4RytQVXFkTEcyVnZwZG1majZxS3lhcDJ1dXZGb3JISFh4bWlWdjVWdWk3cTlsMnFUWm1uR2dZcVNCMDhhREE3RlNSVHQyWElUejdIajdPZWFRandybVRVcHE3OTdGTmY2eE5WZjBaTEllVXZYdExKVFM3OUxWckdSdmF6N1Axa3lMazBBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJzQUFvQUFBQUFCU0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hYTjE3Mk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNzWjJ4NVpnQUFBV1FBQUFHdkFBQUIrTDFxallKb1pXRmtBQUFERkFBQUFDOEFBQUEyS3RJdTdtaG9aV0VBQUFORUFBQUFId0FBQUNRSG9RTE9hRzEwZUFBQUEyUUFBQUFNQUFBQURBc1RBTTlzYjJOaEFBQURjQUFBQUFnQUFBQUlBSWdBL0cxaGVIQUFBQU40QUFBQUZ3QUFBQ0FBQlFCYWJtRnRaUUFBQTVBQUFBRE9BQUFCT1BOZEtwOXdiM04wQUFBRVlBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbTNzZzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFNNWUloa1p2Z1A1RE5EcEpIVS9BY0tBd0RyTkExVGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpUi8vOER5WWovLy8rdkJQTVpBRlNMQnJWNDJpMlF3VzdUUUJDRzk1OTFkbXZIWGlmcnpab21KbEVUWkJjSjJWR2hObEpSUWlOVUlZVFVFNEl6UGJiY3VYQkJnaXNDY2VzNUoxNGhjT0FGS2g0QWlSZmdpTVFwWVZOeG0vbG4vdEY4UHdNNzI2eTlJMXF4RjR3aEdlSnViWHRXVnBEallvWjBocnhDVEVJS080Sk5SVVZPYitwbWhqbnhFaE9SSCtaTjJ0U3BRakdXcWROTENHY2NVV05USStSWVNMcjgxcm81VlFiOWg0dVBYWUp1WlgyMFByeDc1UXNnTXFFRWJzd1g1NHB6cms1T2g1Mi95MVoyb0JMc3Z2MFVjM1JGTm5qelpiY0xNL0JjTXorK2lDa0l5bWNsM3ErL2h3b2lIQkNIMXpVQktBcms3OWN2UTk4WEVSRVBSOWVET0NTK1Ayai9nbW5IRUZHZlBBODZhVVAvdU96MWVqNFo0OFB0VWJ4amtPMHpzSXZOaHYraHIrd3hZejZrY0NhSDdrSlJxQ2hHWHR5clUxdlA4WisrZHFUWDlGTElCSTYvR09lRkUrYzQyQVl3VVpCOHVyNjY3WVBnNnpzZERTMU9uajU1cEdGMU05b3BWektybENhN09QN3NhSFdVV1ZwQ21kQ2JpQkJrN3orWWxsNEkzVDVjR0RwYS8xenUrVXA0N3BZSWU5dS80VUp6QmVLOUZaNTNJZ2M0M0ZKRGIvTWdmMzBGYmxSS3NyMlZ3V1dRQk40dHpkZy9jYkZCQ1FCNDJtTmdaR0JnQU9JOWQ0OVp4L1BiZkdWZ1ptRUFnY2Y3djg1RzBQLy9zVmd6N1FWeU9SaVlRS0lBZnFJTnJBQjQybU5nWkdCZ1p2alB3TURBVXN5US9EK2N4Wm9CS0lJQ21BRlU0d04zQUFOVUFBQUVjd0JqQTB3QWJBQUFBQUFBaUFEOGVOcGpZR1JnWUdCbWlHUUEwUXhRRWdrQUFBbHBBR0FBZU5wTmpEMXZ3akFRaHArSUJJa3dzS0FPSFlxSHpoRUVXTHN3TUxFeXNRQjJVUWJieUFtUmtLcU8vZDI5dUI1NmtrL1ArM0VHU3I3SkdDWmpGdmN3T1lXb1B5NllNazg4RnJWSVhQTEtPeU95ZkNMT0d4K0pjMGxPaVF0ZStFdzhGdjhyY2NtR241MjM5MGRuZ2pwNGJZSzdXdHRzanlhMGpYZHFWUzJqM2h0bndya3pXbDJlU3ZkTjI5K3NXbGQxVmJQRFk3bnpvTU1RVUJ6RTBaRWRWOGtzRFZ1TzBXbUZ2ZmlLRlJYTGYvbGVjaGM3NS9pVGxzNkZwMnhOTDQxVzlrMjZpclZjMXNQN0JjaWJML0VBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVRFQUFvQUFBQUFCYmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hYTjA4Mk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUN0WjJ4NVpnQUFBV1FBQUFINkFBQUNnT3BGVWxab1pXRmtBQUFEWUFBQUFDOEFBQUEyS2Y0dTdtaG9aV0VBQUFPUUFBQUFIZ0FBQUNRR2hnR2JhRzEwZUFBQUE3QUFBQUFRQUFBQUVBclNBSHBzYjJOaEFBQUR3QUFBQUFvQUFBQUtBZElCQUcxaGVIQUFBQVBNQUFBQUZ3QUFBQ0FBQmdCaGJtRnRaUUFBQStRQUFBRFVBQUFCUHBrUmRjZHdiM04wQUFBRXVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbTJzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFNNWUloaVp2Z1A1RE5EcEpIVS9BY0tBd0RzQ2cxV2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoUi8vOER5WWovLy8rdkJQTVpBRlNjQnJaNDJrMlJUWXZUVUJTRzg1NmIzSnVrK1dpbSthQzJUYVoyVEJqUVZxZE9xZ050RmdxQ0lDTE1Ua0ZSMUJFR2tSRVJOenFPUzMrR3FFdkZoWWdvYnZ3Ukx0eTQwcFdnNEhJNjNpVDRzYnZuUGVkZXp2TmNCVXAzYjQ5ZHAzZktSVVhCSko4TUtac2h3U1JNNFBPQkE4RmR5SE9NY1JRR0RrWVFXWm9kemNjenJJN2dRZzVVcmFocXBTTlVyWUxZRUFOZXZ4VEZLQjhLOE9OWmsxSFNBbXh0NjVKQlpKbkRJbWhQZHJ5bHMyYnZpQ1hJNGxzUERRMldIc2ZheG9XTlJoT1U2RUlGTE8xMmZTRTduZHFmN21uZGd3R1ZZVDI5Mk1YVFYwN2tXekFkQWNhZ2NvZXoyQStuajRmcmIyTVhaRHBjNWdUREZ1cUNjSDlkdmRtSWJMOUJwUCs1NEhKYXpLeHZpSnNlYytxUUFxRUdtaUsxS0V2U2tTVWRuWlFGY3lRMkQzaUMvSitPS013THl2NkhEaU9mcDF4MHBOTWhzblMxU2xkcXBYUmx6alYyU0tNNDdjSGlqMG9NeDFsTFJOOVc3MnY3U2ppN2hyT0R3K3p1ZDdlQmpzZGg4MnZydHFXUHB5R2Rtbi9tbHZQYUZ4S085ZXAxZFZjQS92TE9jUS9uV3MyL0ZCS1JERy8rQVo3djlzeXlMbDIwdWJiY3J0alc5dWIwbGQ0ckJ4VEZ3SGdsTDVDUHcwQTR5UHE4QUFiN3VlRFZ4eGFZSWVybmdyN3Nmbnp4NEZaUFY3bDlSalVYNWljNlVHbjYvTTVtQjVZQnBoNlRJVjUyR1QzWjNkNjg0V3RrL0pTN1VLTkYyNWZQaTlLMlpyNnBFdVUzZUI5Vm1RQUFlTnBqWUdSZ1lBQml5YzVsaCtQNWJiNHlNTE13Z01Eai9WOW5JK2ovLzVqVG1mWUN1UndNVENCUkFHWWFEVWdBZU5wallHUmdZR2I0endBa0F4aGsvcnN4cHpNQVJWQUFDd0JNeVFNbkFBQUNkZ0FBQTFBQUhBSlNBQ1FDdWdBNkFBQUFBQUNTQVFBQlFBQUFlTnBqWUdSZ1lHQmhTR0FBMFF4UUVna0FBQW96QUdnQWVOcE5qckZxd3pBVVJZK3BZNmhieUpRTUhZcW1qTVoyK2dHRkRKbXlaaXdra1FndVNBcXlZOGdTK2dIOTZENHJHdnFFSGtmblhRa0JKWGN5cHNxWXh6NVZUaUduQjg5NFlaRzRrS1VTbDd5eDRva3NmeGJ6em1maW5GZStFczlZOHAyNEVQK1R1T1NEMzQyM2wrdGdndHA1YllJN1dkczE5ZDZFdnZOT05WWDlFRnZqVERnTVJxdmpUZW14NjhlelZldXFyVm8yZUN3WHJnd1lndnhzSjBaSGRweGtadWxvcU5sSDE4dkp5MFNKcThUK1Qyd2w0V0xxRUYvVGtqcHlrNjRaSmROTFAwdGFzWmE3N2JUL0FPQ0NNTDE0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVY0FBb0FBQUFBQmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVWQwV0dOdFlYQUFBQUU0QUFBQU5RQUFBRVFBZkFEL1oyeDVaZ0FBQVhBQUFBSkdBQUFDdkRQS0pVTm9aV0ZrQUFBRHVBQUFBQzhBQUFBMktWMHVNV2hvWldFQUFBUG9BQUFBSUFBQUFDUUZtUUdjYUcxMGVBQUFCQWdBQUFBVUFBQUFGQW96QVJwc2IyTmhBQUFFSEFBQUFBd0FBQUFNQVNnQjdtMWhlSEFBQUFRb0FBQUFHQUFBQUNBQUNBQkZibUZ0WlFBQUJFQUFBQURQQUFBQk9QTmhLcU53YjNOMEFBQUZFQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm00bUtjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBycU1HUXlNL3dIOHBraDBraHEvZ09GQWFxbkRJOEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UjBHTklaTXYvL0I3UFNRS3ovVi8vUCtUOGJyQllNQU9kUkMzVUFBQUI0MmtXU1BXL1RRQnpHNzdsenprM2Q1T3pFUGpjaGRlTFlzUU50a3liT2k5U21lWVdodE9KbGlvb1FuV0JnUXFxRUVCT2ZnQUV4c0RMQWQyRHZGK2pHZDJBdUVnTU41eUxFM1hSNi9ycDdmajhkQVRsZjdaTXI4cHBJUW9ZNjExdm9EWVllSEM3QTlTZ2VETWY0dm1FVUs5VmFPUXkxUnJZaERBYWVWTTAxSGZDN1BqRHVMUHU1TG1oT3ozVE9pRm9neDZzMmZVa3Z5VlFkV0hwUkhubzlpc2RJcEN1NUxxc1lZOElDSGczY1pBejFSTktWYmg1QkZFZURZZFJHbmdva0E4bGpmTjQzTmJPY25YV2ErMERvUkF5aUtvUUlmYmJWRWljZUxZckh3c25MZVhCN0JBUlM1YVluUktIZ3JhK1Z6OUlZSDY4djdsdlRucjFnVWVEVmFNaGpJMHVoSFR1ZnJwYXNybU41ZWl1T0d1SC9DS1ZvOTcxV1gwUEtRc25PYXBjMmNFRmFaSkhTS0JKK1E2SWEyMXgzWlNKVFJ4T2s2cFN1ZEh0d0ZaVWFZQk1NWWdYRjlWU0JkTHZwS1BWZlpjL2Z0SjlwcXE4bGtTOVVMTjhlQlJXcHU4T2oyU2xsTTJFZG5UYjdPVll1NUJ4OGFEUFlUcSs4cURtbWhTajI1cFVOSFcrdlorMG5qRG83VzM2eGFIanJHUXFqVXRxclBVMDBMQjg5ZjFBVWR4bENhVXFZMXZXdmI4Sm9CQnFhL1dnMmZUaEVveVp5TjJ4N3E1OTRRYitTZFRKU2JBcXRoZjRZWFpuMjd2ZjB1dW9kcVA2OWYxUmMwQlFrNVJna3JxZFU2SCt4Y1FKLzAzWVFiTnVYMHpJdmVTTWJsc0d4YVZqQmVMc1BaRXFsZ2pCWnBYcFFwRmFXUXhxRjRGQUZsTDZUNmcrNVF2cWwzeisrekcwelpnZHprOUpzdmlPZFZnYmQwREpucythZDJqMU1EZ3VVdW51dWJHbm9ORGIvQUh3UlhTQUFBSGphWTJCa1lHQUE0dXRNaysvSDg5dDhaV0JtWVFDQngvdS96a2JRLzNXWmpqRmRCSEk1R0poQW9nQnJWUTBwQUhqYVkyQmtZR0JtK00vQXdNQjBqRUhuL3dXbUxBYWdDQXBnQlFCbEhRUTVBc1lBQUFGYkFITUNPZ0JMQWpvQUxBR2VBREFBQUFBQUFDb0FrQUQrQVY1NDJtTmdaR0JnWUdWd1lXQmlBQUZHQmpRQUFBZXBBRTU0MmsyTVBXL0NNQkNHbjRnRWlUQ3dvQTRkaW9mT0VRUWt0aTRNVEt4TUxJQmRsTUUyY2tJa3BLcGpmM2N2cm9lZTVOUHpmcHlCa204eWhzbVl4VDFNVGlIcWp3dW16Qk9QUlMwU2w3enl6b2dzbjRqenhrZmlYSkpUNG9JWFBoT1B4ZjlLWExMaForZnQvZEdab0E1ZW0rQ3UxamJib3dsdDQ1MWFWY3VvOThhWmNPNk1WcGVuMG4zVDlqZXIxbFZkMWV6d1dPNDg2REFFRkFkeGRHVEhWVEpMdzVaamRGcGhMNzVpUmNYeVg3NlgzTVhPT2Y2a3BYUGhLVnZUUzZPVmZaT3VZaTJYOWZCK0Fjd3JML2tBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTWNBQW9BQUFBQUEzd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYUlCaWYyTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPREhaMng1WmdBQUFXd0FBQUJRQUFBQVVNUEZoclZvWldGa0FBQUJ2QUFBQUM4QUFBQTJLYk11bFdob1pXRUFBQUhzQUFBQUhnQUFBQ1FGeGYrRmFHMTBlQUFBQWd3QUFBQUlBQUFBQ0FYR0FEMXNiMk5oQUFBQ0ZBQUFBQVlBQUFBR0FDZ0FBRzFoZUhBQUFBSWNBQUFBRndBQUFDQUFCQUFYYm1GdFpRQUFBalFBQUFEVkFBQUJQcTgzZGVOd2IzTjBBQUFEREFBQUFCQUFBQUFnQUFNQUFYamFZMkJtZXN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBQUJKSFpLY1ZrNkE5dURrZ2NsekZKL05Ca1ltS1dZcndPRkdSRXEvdjluWUFBQVZWOFF2UUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUTlLL3YrSGtQSzlZSGtHQUdvR0I3QUFBQUFCQUQzLy93SnRBbU1BRlFBQUFSRVdCaWNoQmlZM0VTWTJNaFlIRVNFUkpqWXlGZ0pzQVE0WS9od1hEd0VCQ0J3SEFRSGNBUWNjQ0FJLy9lWVpEUUVCRGhnQ0dnOFZGUS85NmdJV0R4VVZlTnBqWUdSZ1lBRGk1dVY3bE9QNWJiNHlNTE13Z01Eai9WOW5JK2ovLzVsbG1KS0JYQTRHSnBBb0FGKzJES0lBZU5wallHUmdZSmI2b3dra1pSaHNHV3laY2htQUlpaUFDUUE3MGdKUEFBQURIQUFBQXFvQVBRQUFBQUFBS0FBQWVOcGpZR1JnWUdCaUVHTUEwUXhRRWdrQUFBTERBQndBZU5wTmpyRnF3ekFVUlkrcFk2Z2I2SlFNSFlxbWpNWjI4Z0dGREpteVppd2trUWd1V0E2U1kvQlMrZ0g1NkR3ckd2cUVIa2YzM3ZjUWtQTkx3bFFKNzZGUGxaTEo2OGt6M2xoRXp1U295RGtmckhnaFNWOUYrZVFyY3NxYzc4Z3psdnhFemtUL2k1eXo0Yjd0MnV1dE4wN3RPMjJjUGJkK3JNcURjYjdwcktxSzhpbnNqRFh1MkJ1dFRxUFNRK09IUzZ2V1JWM1ViT2xvdVhLangrRGtaM3RSZEdETFdUelBTRVhKSVdpZVJud3J1WXBDMVArSm5TUnNTQjNETmkycGszaEthSkE1TC8waWVjVmFadXZwUGdBSjN6RVZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDExLjI1NzA1NywtMzcuODI1Mzc5KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04My41NjkyNywtMjguNDkzMDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDExLjI1NzA1NywtMzcuODI1Mzc5KXNjYWxlKC0xLC0xKSc+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMC4wNjQyODUsLTg3Ljc5MDg3MSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuNTM0NzEsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgyMC4wNjQyODUsLTg3Ljc5MDg3MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PScyMC4wNjQyODUnIHk9Jy04Ny43OTA4NzEnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuNzgxODIsLTg3Ljc5MDg3MSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NS4wMzMsLTg3Ljc5MDg3MSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE0LjEwNDExLDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoOTUuMDMzLC04Ny43OTA4NzEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nOTUuMDMzJyB5PSctODcuNzkwODcxJz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzEwNi4yODI0MjInIHk9Jy04Ny43OTA4NzEnPu6BtDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScxMTUuMTM4MDcnIHk9Jy04Ny43OTA4NzEnPlk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTM3LjI4NDE4LC04Ny43OTA4NzEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTY5LjQ4MjgzMiwtODcuNzkwODcxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNC4wMTM4OSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDE2OS40ODI4MzIsLTg3Ljc5MDg3MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PScxNjkuNDgyODMyJyB5PSctODcuNzkwODcxJz5ZPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIwLjA2NDI4NSwtNjYuMjEyMDE3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIwLjA2NDI4NSwtMzcuODI1Mzc5KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjc4MTgyLC0zNy44MjUzNzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTUuMDMzLC0zNy44MjUzNzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc3MDgzLDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoOTUuMDMzLC0zNy44MjUzNzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nOTUuMDMzJyB5PSctMzcuODI1Mzc5Jz5aPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzIuNzk5ODUsMS41OTk5MScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00uNTIwODMgMTcuODAwMDVWLTE3LjQwMDA5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC41MjA4MywtMTcuNjAwMDcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE3LjE0MDcsLTEuNzUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDExLjI1NzA1NywtMzcuODI1Mzc5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9JzExLjI1NzA1NycgeT0nLTM3LjgyNTM3OSc+WzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScxMy41MTI1MDInIHk9Jy0zNy44MjUzNzknPmY8dHNwYW4geD0nMTcuNzUwMTM4Jz4sZzwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzI0LjI1MzIzJyB5PSctMzcuODI1Mzc5Jz5dPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTY1LjY4ODc3IDE4LjEzNzE4TC04LjA4ODMtMjAuMjYxMScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjgzMjAyLC0wLjU1NDY2LDAuNTU0NjYsMC44MzIwMiwtNy45MjE5MiwtMjAuMzcyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00My43NTg5OSwtOC4zODY3MiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTEuMjU3MDU3LC0zNy44MjUzNzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTEuMjU3MDU3JyB5PSctMzcuODI1Mzc5Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTTY2LjczMDQyIDI0LjE1OTc3SDE5LjUzMDQ0JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDE5LjMzMDQ2LDI0LjE1OTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM4LjUxMDU3LDI3LjUxODA4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxMS4yNTcwNTcsLTM3LjgyNTM3OSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScxMS4yNTcwNTcnIHk9Jy0zNy44MjUzNzknPmk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTQuMDc1Nzg0JyB5PSctMzYuODIzNTY2Jz5ZPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS02NS42ODg3NyAyNC4xNTk3N0gtMTguNDg4NzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE4LjI4ODgsMjQuMTU5NzcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ2LjUyNzQ0LDI3LjUxODA4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxMS4yNTcwNTcsLTM3LjgyNTM3OSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScxMS4yNTcwNTcnIHk9Jy0zNy44MjUzNzknPmk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTQuMDc1Nzg0JyB5PSctMzYuODIzNTY2Jz5YPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTTY2LjczMDQyIDE4LjQ0MjU1TDkuMTI5MjYtMjAuMjIyMDMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuODMwMjYsLTAuNTU3MywwLjU1NzMsLTAuODMwMjYsOC45NjMyNCwtMjAuMzMzNDcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDAuMTE2NTYsLTYuMzY3ODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDExLjI1NzA1NywtMzcuODI1Mzc5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzExLjI1NzA1NycgeT0nLTM3LjgyNTM3OSc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+"></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            X &amp;&amp; {X\sqcup  Y} &amp;&amp; Y \\
            \\
            &amp;&amp; Z
            \arrow [&quot;{[f,g]}&quot;&apos;, dashed, from=1-3, to=3-3]
            \arrow [&quot;f&quot;&apos;, from=1-1, to=3-3]
            \arrow [&quot;{i_Y}&quot;&apos;, from=1-5, to=1-3]
            \arrow [&quot;{i_X}&quot;, from=1-1, to=1-3]
            \arrow [&quot;g&quot;, from=1-5, to=3-3]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>693</fr:anchor>
                    <fr:addr type="machine">#353</fr:addr>
                    <fr:route>unstable-353.xml</fr:route>
                    <fr:title text="Logic, Types and Categories">Logic, Types and Categories</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>One important principle in type theory is the <fr:strong>Curry-Howard Isomorphism</fr:strong> (Propositions as types).
        It depicts the connection between logic and types. A program can represent a logical argument, and 
        operations in logic find meaningful correspondences in program execution.
        The principle was later extended with category theory due to <fr:strong>Lambek</fr:strong>. In his work, he showed
        a correspondence between STLC and <fr:strong>Cartesian Closed Categories (CCC)</fr:strong> and revealed the connection
        between types and categories. The correspondence is called the <fr:strong>Curry-Howard-Lambek Isomorphism</fr:strong>.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>694</fr:anchor>
                        <fr:addr type="machine">#354</fr:addr>
                        <fr:route>unstable-354.xml</fr:route>
                        <fr:title text="Syntax and Semantics">Syntax and Semantics</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>3</fr:month>
                          <fr:day>21</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>In general, there are two approaches to understand or design a type system: the <fr:strong>syntactic</fr:strong> view 
            and <fr:strong>semantic</fr:strong> view.

            The syntactic view focuses on the syntactic structure of types and programs. We study about <fr:strong>subject reduction</fr:strong>,
            <fr:strong>cut elimination</fr:strong> and etc, simply by manipulating the syntax. It is usually more direct and easier to understand
            as it is often conducted via induction on some syntactic structures. And it also suggest algorithms which can be implemented.
            The disadvantage is that it is limited and hard to proof some properties like normalization.

            The semantic appoaches are more powerful in general. It is based on mathematics models of type systems.
            In exchange of the strength and generality, it is usually harder to understand and heavyweight, requries
            more intuition of the concepts.</fr:p>
                        <fr:p>One clasical semantic approach to logic is algebraic logic. A logical system is modeled by some algebraic theory.
            (often related to <fr:strong>lattices</fr:strong> and <fr:strong>semi-lattices</fr:strong>). Famous examples include <fr:strong>Boolean algebras</fr:strong>
            for classic propositional logic and <fr:strong>Heyting algebras</fr:strong> for intuitionistic counterpart. 
            The algebraic logic is a powerful tool to study the properties of logical systems, but has a limitation that 
            all operations are limited in one structured set.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>695</fr:anchor>
                        <fr:addr type="machine">#355</fr:addr>
                        <fr:route>unstable-355.xml</fr:route>
                        <fr:title text="Computations as Monads">Computations as Monads</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>3</fr:month>
                          <fr:day>21</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>An important result from ategorical semantics could be <fr:strong>monads</fr:strong>.
            In <fr:strong>Moggi</fr:strong>&apos;s paper, he showed that monads can be used to model computational effects.</fr:p>
                        <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                          <fr:frontmatter>
                            <fr:anchor>696</fr:anchor>
                            <fr:addr type="user">def-003T</fr:addr>
                            <fr:route>def-003T.xml</fr:route>
                            <fr:title text="Monad">Monad</fr:title>
                            <fr:taxon>Definition</fr:taxon>
                            <fr:authors></fr:authors>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <fr:p>A <fr:strong>monad</fr:strong> of a category <fr:tex display="inline">\mathcal {C}</fr:tex> is an endofunctor <fr:tex display="inline">M:\mathcal {C}\to \mathcal {C}</fr:tex> with two natural
    transformations <fr:tex display="inline">\eta :\text {id}_{\mathcal {C}}\Rightarrow  M</fr:tex> and <fr:tex display="inline">\mu :M^2\Rightarrow  M</fr:tex> satisfying the following conditions:
    
 
  
  <fr:figure><fr:resource hash="65b705e596b5ade3ad3981d38dbae97a"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzQ0MS4xMzcwMDZwdCcgaGVpZ2h0PScyMTcuMjkwOTE5cHQnIHZpZXdCb3g9Jy03MiAtNzIgMjk0LjA5MTMzNyAxNDQuODYwNjEzJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQS9RQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wbW1OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzhBQUFBMEU4T3pIMW9aV0ZrQUFBQ0lBQUFBQzRBQUFBMktla3VNMmhvWldFQUFBSlFBQUFBSGdBQUFDUUZMQUs0YUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1hmQUpwc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURZQWFHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWdibUZ0WlFBQUFwd0FBQURKQUFBQk11c0lrZWh3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm02bUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWRJbERNMEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkpqMW40SHhPRE1EZ3h3REF5TWZJenVidUJnWWlyQXBxZXN4cXF1cG01bmJNWnFiR1ltSnNqRWVDV3BsWlZiaTROS3Q0R0JrazNKVTlGS3daV0d4VmZCU2RKUmlZMlI2YnZaMVQyeWxoSGhWS2dzWEM1ZUpiSlJ0d1lvVmhiYVJzaVpjTEp3TVFNRElrQXkwYXdMUUxta2doNDBkWkp1YVBxTUoyQUloTlhVMUlFTmNqbEZjakhFQzFGUm1KbGIxY0RWVHhyUmlkbVptaUlXTURCQXpHVms1T0Zoa2s4T2FHS1YreDNKenN6S0NMUVFBRWFNamozamFZMkJrWUdBQTRqMXBuZXZqK1cyK01qQ3pNSURBNC8xZlp5UG8vd3pNUWN3Z0xnY0RFNGdDQUZ6ZkM4Z0FBSGphWTJCa1lHQm0rTThBSklNWWtobVNHWTh6QUVWUUFCTUFSc2tDNmdBQUExSUFBQUlxQUpvQVl3QUFBQUFBQUFBMkFHaDQybU5nWkdCZ1lHYVFad0RSREZBU0NRQUFBNzhBSmdCNDJqMk1NUXZDTUJDRnYySVZyWU9ENE9BZ3dSOVF0T3JtNXVEazZ1Qm1UWkFPVFNXdFJSZnhwM3NOd1FzNXZudnYzUUVKSHlLNmlwajQzbFVzYnhLNHo1aHA0SUhvaThBSmM1YjBpT0tSS0F2MmdXT0dYQUwzbVpFSEhvaitDcHl3NVh1b3lzZXpNVTZkS20yY3ZaVnVkemF1TGlxcjF1bXFHNC9HR25kdGpGYjVXK20ycU50N3FUWnBsbVljcUNoNThLVEI0RkNjUk5HZUxUZnhIRHZPZnE0cHhMT1NXWk95K3J0SGNhMVBYUDBWTFltY3QzUk5LenUxOUx0a0ZSdlp5N3IvQTFXNExrVUFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUb0FBb0FBQUFBQlp3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wVEdOdFlYQUFBQUU0QUFBQU5RQUFBRHdBVGdCK1oyeDVaZ0FBQVhBQUFBSVRBQUFDWU5ZdzlUbG9aV0ZrQUFBRGhBQUFBQzRBQUFBMktXb3VOR2hvWldFQUFBTzBBQUFBSHdBQUFDUUZSd0lSYUcxMGVBQUFBOVFBQUFBVUFBQUFGQWp0QVdOc2IyTmhBQUFENkFBQUFBNEFBQUFPQWV3Qk1tMWhlSEFBQUFQNEFBQUFGd0FBQUNBQUNBQThibUZ0WlFBQUJCQUFBQURKQUFBQk11MEtrZXh3YjNOMEFBQUUzQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1NbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1CZ3pNL3dIOHBraDBraHEvZ09GQWJOUERIOEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEthaklZLy84UDVHc3dHUDcvLy8vbS8wdGdWVUFBQUl1RkNNWUFBQUI0MmtXUVRXc1RRUnlINS9lZmRJWnM2U1loeWVhOVNiYnVMcTB4b1MrN3F5bW1qZGphMUpjVzIwVFFWRnFMRld1UnRCWnZCYWtSRCtLSDZFbTkrQUY2RnNIdm9UZEJFRUY2MERwTER6SXdNLzg1UFBQd01MRDlVK0FGWnl6TEdGSkdRb29JaEJTR3VrWmdPMnI1OWd3ODdBeEoyYXpMU3h5ZExVME92WEwxUVl2b2d1NXhCb3FLcVozbzd1ZTNKMnZoS09IQlFibDBzTG4zMGpwVVNMYWcrS3RuL0xpaXBneVpFRktIN1UvTm9BRy9Dc2QyUGIvYjl3TGdxT2s5ellGSFZydmd1L05oQ003T2FIZVBaamMyU2VPaDJJMGZSNSsrMVRVUkpzWUNmazl0WCtrRHk2Z3pKb3hwSkd1SXdKMmM4SnlZRHNjMVBOOHpjSWVYV3M2ajVkNjgweXJ4eW1xaXZEK1pIS1EzZjc1a2t4WUhrWlhNa3BZSTR4d1pWV2dCdDhrWURkQjdOc3FZSmN1K3AyeEoxUkJ5R0VwL1JOaU9zaDlHU2tjUXpQZDhOZEpBOGU4OWtQeWR1OEtYYnRxZGpHTUFabHdiSXp6YmVQaWFVM3U2UFhicnB6V282WFI4bkJmaVYyNnJ2MDQ0NzVJVnllZVF0RnRQT0I3ZnY3WmRtVFBuZ0pBMkd3OWMvTlB2cE5NN1ZsZkRpSEM5VlBCWkEyNFZVZ2taS1ZVMDBKbFFkUU0vNVNSVjEvOFB2b3BRQmRJWHN5RlJ0aWZUeVFTZnQ0cnR3Z1RQWjhaRDFQdjRuSEIxdWQwRkhlNnM5em5NV2hISW11YTJXVnZodUk0T2owV0pJNUpQTjh2Tm1nS1ZSUzFWQUx6RzR0TGw4YzFpZkt1eHZNZlJYaWpsUzVtWXhTc0YwT0xhN1JYMkQ4eU5YKzhBZU5wallHUmdZQURpQlZjMGw4ZnoyM3hsWUdaaEFJSEgrNy9PUnREL0daa3VNNE80SEF4TUlBb0FYK01NTXdBQWVOcGpZR1JnWUdiNHo4REF3SFNad1p6QmtvbVBBU2lDQWxnQVBqMENYZ0FDMHdBQUFja0FkQUhKQUVnQ1J3QndBRUVBTndBQUFBQUFNQUJnQUl3QTBnRXdBQUI0Mm1OZ1pHQmdZR093WmdEUkRGQVNDUUFBQnN3QVJRQjQyajJNTVF2Q01CQ0Z2MklWcllPRDRPQWd3UjlRdEFvdWJnNU9yZzV1MWdUcDBGVFNXblFSZjdyWEVMeVE0N3YzM2gyUThDR2lxNGlKNzEzRjhpYUIrNHlaQmg2SXZnaWNNR2RKanlnZWliSmdIemhteUNWd254bDU0SUhvcjhBSlc3Nkhxbnc4RytQVXFkTEcyVnZwZG1majZxS3lhcDJ1dXZGb3JISFh4bWlWdjVWdWk3cTlsMnFUWm1uR2dZcVNCMDhhREE3RlNSVHQyWElUejdIajdPZWFRandybVRVcHE3OTdGTmY2eE5WZjBaTEllVXZYdExKVFM3OUxWckdSdmF6N1Axa3lMazBBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVI4QUFvQUFBQUFCVWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXaDFkR050WVhBQUFBRTRBQUFBTVFBQUFEd0FkUUNmWjJ4NVpnQUFBV3dBQUFHekFBQUNFT3dvM3c5b1pXRmtBQUFESUFBQUFDOEFBQUEyS3NRdThHaG9aV0VBQUFOUUFBQUFIZ0FBQUNRSFRBS1phRzEwZUFBQUEzQUFBQUFNQUFBQURBbW5BRWhzYjJOaEFBQURmQUFBQUFnQUFBQUlBSFlCQ0cxaGVIQUFBQU9FQUFBQUZ3QUFBQ0FBQlFCaGJtRnRaUUFBQTV3QUFBRFVBQUFCUHBrUmRjZHdiM04wQUFBRWNBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbU5tZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHI2TWtRd00vd0g4cGtoMGtocS9nT0ZBYjF3RE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUSytqSkUvUDhQNUlQcC8xdityd0tyQWdJQWxCc0pEZ0FBQUhqYU5aQzlqdE5BRklYbjNCblB4STQ5ZHVMWTFpck9KTktDTFVGSWhNTGFBbW16QlFVSUNpaG9rSkJBU0dpWEFvcEZDRUhEVHdGSVM4VTd3QU1nS3JUaUlhaW9xR2twS0VNWU85Q016dHh6N3BXK3c4Q202N1U0UTEvWkpjYkFReGhVR25Pb3NpalBWVmxhMVRHa0tuYTZrSWxNeDBpVDFwWFdXNktPcTdKUml5ck5ZaXpSQ0ZrV2tuOStLNENUNXhFNEw1NTdEcUxnZ25IZS83a3JlK0hOSTRIaDZVQkNpL3Y3UVNCMnAvSTFMcG9vZkJmN3VJN0hIZDEvTTBUWXIwZjBZUFdqcndJcFJncWNFOXhRQXJHaHE2c25XdkNFbnEyK2FUZmVBc2pWVFFKRCs1NmFVQjV4UHJKUjFWc2QwMlV0d1hNRkpNemlzWHk5NXZ0MHpHN2JUMTNWTXlxWEdLTzJYQU81clMxV0NLc05GdGsvenJhRnhSSTdjNFN3Z2RiS1dxdVlvN1gyaU0rd0xUZVhNb1BtVUlKZkh5Tk80eGkyZ3NNN0xwSHZ6ZmFTcmZwVjc4UTFiM1RXVitUTHc1ZXVBNzlqakhOdzY2QWJnY1lkWld2em5VZWJoZkpLRVh4LzZ1VFRoSnJoSmozSjhlR1R6Z1krdkEyMWtGcHlNMGgzajJZM3ZwZ1E1RFhJVFYrQkVuMFYvcjczc0pzRmd5NVI1LzlDS0dsUytqOWhvaDdYbXlFbFNpUU9ZMzhCNHJ4RDFBQjQybU5nWkdCZ0FHS3hmMzJTOGZ3Mlh4bVlXUmhBNFBIK3I3TVI5UC8vTExwTSs0QmNEZ1lta0NnQVZxa013UUI0Mm1OZ1pHQmdadmpQQUNRZk1zajgzOEtpeXdBVVFRSE1BRis5QSt3QUFBSjJBQUFENFFBc0ExQUFIQUFBQUFBQWRnRUllTnBqWUdSZ1lHQm1TR0FBMFF4UUVna0FBQW9ZQUdjQWVOcE5qckZxd3pBVVJZK3BZNmhieUpRTUhZcW1qTVoyK2dHRkRKbXlaaXdra1FndVNBcXlZOGdTK2dIOTZENHJHdnFFSGtmblhRa0JKWGN5cHNxWXh6NVZUaUduQjg5NFlaRzRrS1VTbDd5eDRva3NmeGJ6em1maW5GZStFczlZOHAyNEVQK1R1T1NEMzQyM2wrdGdndHA1YllJN1dkczE5ZDZFdnZOT05WWDlFRnZqVERnTVJxdmpUZW14NjhlelZldXFyVm8yZUN3WHJnd1lndnhzSjBaSGRweGtadWxvcU5sSDE4dkp5MFNKcThUK1Qyd2w0V0xxRUYvVGtqcHlrNjRaSmROTFAwdGFzWmE3N2JUL0FPQ0NNTDE0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMktSY3VNMmhvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGpLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaUQrOTJQWS9udC9uS3dNekNBQUtQOTMrZGphRC9NekExTUlPNEhBeE1JQW9Ba2pzTkdnQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZdzlpOEpBRUlhZllDSVlDeHV4c0xqYndqb2swZm9hQ3l0YnEydlVYU1ZGTnJLSkFVRXM3M2M3V1JkdVlJZm4vWmdGVWw1RURCTXg4M3VZbUVUVWh4T216QU9QUlgwSFRsbXlZa1FVVDhUNTRpZHdMTWx2NElRRmw4Qmo4WitCVXpiOGJadjZkdStNVS90R0cyZlB0U3Z5ZzNGdDFWaFZaTG5YTzJPTk8zWkdxOU5ENmI1cSsydXQxbG1abFd4cHFMbHhwOFBnVU96RjBaNHRaOGtjQlRrSDc3UlVrbHBwRldUaS91Yzd5YTN2SFAxUFdqb25IckkxdlZ5MXNxL1NWcXpsc2h6ZUcyUEhMeEVBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVFQUFvQUFBQUFCZUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hlcDRyR050WVhBQUFBRThBQUFBTXdBQUFFUUF5UVJ1WjJ4NVpnQUFBWEFBQUFJeEFBQUNvQzNpRTZGb1pXRmtBQUFEcEFBQUFDOEFBQUEyS3lZdUYyaG9aV0VBQUFQVUFBQUFJQUFBQUNRSHdnTXNhRzEwZUFBQUEvUUFBQUFRQUFBQUVBeENBSzlzYjJOaEFBQUVCQUFBQUFvQUFBQUtBZFFBN20xaGVIQUFBQVFRQUFBQUZ3QUFBQ0FBQmdCU2JtRnRaUUFBQkNnQUFBRFBBQUFCT1BOaEtxTndiM04wQUFBRStBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUZtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUV6QXhKSUtTNUxCMHI2TW05blp2Z1A1RE16TUlLRUdSRXEvZ09GQWRSSURZb0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtmQm0yTW0vLy94L0Irci9sdis4Zkg3QmFNQUFBQkVBTU5BQjQyaTJSelc3VFFCU0ZmZTZNWjJMSEdUdngyQk9hTkVtVE51NFBTZ29KRG0xS1N0VVdpc1NpYkZFWGJKQ1FRR1VERXR2Q3BnaWtDaUVoWG9BMWo5QU5Zc1U3c09JeDBqS3BxbG5NblhQdWxjNDMxNEh6K1BLU245RzVjK2c0WUZLa1RlUmE5QkdpMjhjd04yaytpaUZrT3l0Q21KbWJHb1UrcEhVbk1CT000bEZ1NjQ3bzVtYVFweWFleVlQY2FKRjFCVTlQT1dRbGE0YnUrNTN0SXFOSWJjNnpMeGRQZksxeGZPcUNkRjhWZ05COTlkSm5oSkxjV25WUE9BcVJqaGRRQ2I4bUFYdU9UNzdTbitkUmlVWjFlakg5WjZRRThZNEVCN1BKeWhLb3pOSGU5SU5tZFRxZS9rMTRVR2ZFUEd0d2JodWlBdGhhalNpVkFveTNiYnNYVDgvcFFGay9EdTFUT3hiZEdWd3UwVGY4Y3ZZZHg4U1dLelU2WkFvbXRaRGJmSUxCVENDRlJGOHB5R2Rmb1lXMHA1dGRYVmtJQmRudVpxTXowclVGa3NZb1JrRzBlWFBQZUZsVGVsV3Z3VVhIQ0UvcFZ0c3JjTjhURkpkcmVYZ1FVN2F5TXg0MEl6dFlTdkNEN2dZZG9xYWJQRHNhVnpxTEhZN2I3ZkwzZHplVWo2WTBINCtTbmtycm9QMnNKa0RrdXp1dEFhUHFRRFJiSEkyVFRkV2hxR3laMWkzVEEveDI3czEyZTUwdG5sQTNzN1dDcFdIZGJKdmxkNGJYU2g4OTVLTUp6UWhOZzBMUTFtdEs1cFFHZjhNWnBTdmp3MnJveTNudGVrbGR3MThMaWlLTUcrMmlLLzJpUUJvRzJjYWp3dUJwNitFd0FHQXV0b05aa2dSL1N0WGxXMFM3eThsYzQrMmhEaFdpOHVyUDlaNkpranB3djZlTEZpUGFyYWN0V3RvWUw1TGJINVpxZGkzL0FiVVNVSWNBQUFCNDJtTmdaR0JnQU9MTGMxWWt4L1BiZkdWZ1ptRUFnY2Y3djg1RzBQOVZXZnFaOWdPNUhBeE1JRkVBY0lvTkNRQjQybU5nWkdCZ1p2alB3TURBRXMxZzhQOE1TejhEVUFRRnNBQUFYY3dEOWdMR0FBQUVXd0JNQXNjQU13SmFBREFBQUFBQUFJUUE3Z0ZRQUFCNDJtTmdaR0JnWUdFSVpBRFJERkFTQ1FBQUNMd0FXUUI0MmsyTVBXL0NNQkNHbjRnRWlUQ3dvQTRkaW9mT0VRUWt0aTRNVEt4TUxJQmRsTUUyY2tJa3BLcGpmM2N2cm9lZTVOUHpmcHlCa204eWhzbVl4VDFNVGlIcWp3dW16Qk9QUlMwU2w3enl6b2dzbjRqenhrZmlYSkpUNG9JWFBoT1B4ZjlLWExMaForZnQvZEdab0E1ZW0rQ3UxamJib3dsdDQ1MWFWY3VvOThhWmNPNk1WcGVuMG4zVDlqZXIxbFZkMWV6d1dPNDg2REFFRkFkeGRHVEhWVEpMdzVaamRGcGhMNzVpUmNYeVg3NlgzTVhPT2Y2a3BYUGhLVnZUUzZPVmZaT3VZaTJYOWZCK0Fjd3JML2tBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTTUFBb0FBQUFBQlVRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoV2gyaTJOdFlYQUFBQUU0QUFBQU1RQUFBRHdBZFFDZloyeDVaZ0FBQVd3QUFBSEdBQUFDRk9UU1dFNW9aV0ZrQUFBRE5BQUFBQzhBQUFBMks4RXU3R2hvWldFQUFBTmtBQUFBSUFBQUFDUUlrQVFnYUcxMGVBQUFBNFFBQUFBTUFBQUFEQXpxQU9Gc2IyTmhBQUFEa0FBQUFBZ0FBQUFJQUlJQkNtMWhlSEFBQUFPWUFBQUFGd0FBQUNBQUJRQmFibUZ0WlFBQUE3QUFBQURPQUFBQk9QTmRLcDl3YjNOMEFBQUVnQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm04V09jd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjByNk1rUXdNL3dIOHBraDBraHEvZ09GQWNZcERPVUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEsrakpFL1A4UDVJUHAvMXYrcndLckFnSUFsQnNKRGdBQUFIamFKWkE5aXhOUkZJYm5QZmZtM3AxazVzN1huWm5OMXdheU9Ba3FpYXhtUmxaTWRCR0xiY1JDc0ZZYlVVdkJSZ1hGZ0JZUkxkMVNCTVcvb0JiK0EvK0IxWGIyZ2lUcjJVMTFQdDVUbk9keDREdzdXdFpPMHpmbnB1TkFhSlgxVUdhcHdSaTZHRndvODUyeVNxQUcvV0xRZ0ZaNW1lVnFUQnhOa1U5UkpkV2tHRU1WRTc0OHoxa0Mzbk5qdGRMYmhaS2Y1d0p1ZkRhTUVhdkZtd2ladmRnVmk5VWtEVTJkRm5NcDl0MFFsTzFlZmh3UW9vMXJRL0ZjUkxaall4dCtUQVA1RWwrOE5QcGdFcGRVcytyU3ZlVmhvQ1FJeWt0ZFNDa01sekNuM2VYcnRnZ04zVjhlYnA0NlRuc2tJQ213ZFlnek9mNTV2Z1NnZk9zQ2JyTDhUdnRHODl6MENZZ2NPSGVQVnZJU083ak5EcEl0TUVDYWFUYlFYMk15WWtEcXhNMGF2eitveW1xS0dZa1J0cG0rcVBLcXpBMEdmWjN6ZnNUQ3B1aFJsZVZXNmI3U2RQQ2oxajFuTEZwWDl0NUZoTGpXYWFIMjl0VWpWd0crOWZpWnpkbmVBeU9FTU5kdmJJVi9QOVU2T3laQjg4WDdRQ0JTbmZiVHI4MEl0aTE1bUYxOUdGQzlQcm8xd256MTB6T00yejdHalppVy9Mcis4K1NPNTdyS0p4SnJEMUhna1JpMkc3OWhHd0ZiYUpHVWlKTUc0bDhIYVpxNlpObkxpYThOaTg3d1B5RDdTU2tBQUhqYVkyQmtZR0FBNHRRdjJyWHgvRFpmR1poWkdFRGc4ZjZ2c3hIMC83K3NXa3g3Z0Z3T0JpYVFLQUJpbEEwQkFIamFZMkJrWUdCbStNL0F3TUNxekpEOC95ZXJGZ05RQkFVd0F3QlpTQU82QTFRQUFBVWpBSDRFY3dCakFBQUFBQUNDQVFwNDJtTmdaR0JnWUdhSVpBRFJERkFTQ1FBQUNXa0FZQUI0MmsyTVBXL0NNQkNHbjRnRWlUQ3dvQTRkaW9mT0VRUll1ekF3c1RLeEFIWlJCdHZJQ1pHUXFvNzkzYjI0SG5xU1Q4LzdjUVpLdnNrWUptTVc5ekE1aGFnL0xwZ3lUendXdFVoYzhzbzdJN0o4SXM0Ykg0bHpTVTZKQzE3NFREd1cveXR4eVlhZm5iZjNSMmVDT25odGdydGEyMnlQSnJTTmQycFZMYVBlRzJmQ3VUTmFYWjVLOTAzYjM2eGFWM1ZWczhOanVmT2d3eEJRSE1UUmtSMVh5U3dOVzQ3UmFZVzkrSW9WRmN0LytWNXlGenZuK0pPV3pvV25iRTB2alZiMlRicUt0VnpXdy9zRnlKc3Y4UUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNDcuNTk3MDksLTY1LjQzOTMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDc1LjA0NTY2NiwxLjUyOTA3MSlzY2FsZSgtMSwtMSknPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTUuMzM3NjEzLC0xMjMuMjQxNjI1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTYuMDYyNSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDk1LjMzNzYxMywtMTIzLjI0MTYyNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSc5NS4zMzc2MTMnIHk9Jy0xMjMuMjQxNjI1Jz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzEwNi4wODg5NTYnIHk9Jy0xMjYuODU2OTg5Jz4yPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzExMC41NTgzMjYnIHk9Jy0xMjMuMjQxNjI1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzExNC40MzI3JyB5PSctMTIzLjI0MTYyNSc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScxMjMuNDY4MjU1JyB5PSctMTIzLjI0MTYyNSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNTkuODMxODE0LC0xMjMuMjQxNjI1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIyMi4wOTEzMzcsLTEyMy4yNDE2MjUpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMy44MTk0NCwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDIyMi4wOTEzMzcsLTEyMy4yNDE2MjUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjIyLjA5MTMzNycgeT0nLTEyMy4yNDE2MjUnPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjMyLjg0MjY3OScgeT0nLTEyMy4yNDE2MjUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjM2LjcxNzA1MycgeT0nLTEyMy4yNDE2MjUnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjQ1Ljc1MjYwOScgeT0nLTEyMy4yNDE2MjUnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjg0LjM1MDg2LC0xMjMuMjQxNjI1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM0OC44NDUwNiwtMTIzLjI0MTYyNSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE2LjA2MjUsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgzNDguODQ1MDYsLTEyMy4yNDE2MjUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMzQ4Ljg0NTA2JyB5PSctMTIzLjI0MTYyNSc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSczNTkuNTk2NDAzJyB5PSctMTI2Ljg1Njk4OSc+MjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczNjQuMDY1NzcyJyB5PSctMTIzLjI0MTYyNSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSczNjcuOTQwMTQ2JyB5PSctMTIzLjI0MTYyNSc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczNzYuOTc1NzAyJyB5PSctMTIzLjI0MTYyNSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NS4zMzc2MTMsLTg4LjA1NDA3NSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNTkuODMxODE0LC04OC4wNTQwNzUpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjIyLjA5MTMzNywtODguMDU0MDc1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTMuODE5NDQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgyMjIuMDkxMzM3LC04OC4wNTQwNzUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjIyLjA5MTMzNycgeT0nLTg4LjA1NDA3NSc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScyMzIuODQyNjc5JyB5PSctODguMDU0MDc1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzIzNi43MTcwNTMnIHk9Jy04OC4wNTQwNzUnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjQ1Ljc1MjYwOScgeT0nLTg4LjA1NDA3NSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NS4zMzc2MTMsLTYzLjk4NDU2KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDk1LjMzNzYxMywtMzQuMjk2MTAzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE1OS44MzE4MTQsLTM0LjI5NjEwMylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE2LjA2MjUsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxNTkuODMxODE0LC0zNC4yOTYxMDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTU5LjgzMTgxNCcgeT0nLTM0LjI5NjEwMyc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxNzAuNTgzMTU2JyB5PSctMzcuOTExNDY3Jz4zPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzE3NS4wNTI1MjYnIHk9Jy0zNC4yOTYxMDMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTc4LjkyNjknIHk9Jy0zNC4yOTYxMDMnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTg3Ljk2MjQ1NScgeT0nLTM0LjI5NjEwMyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMjIuMDkxMzM3LC0zNC4yOTYxMDMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjg0LjM1MDg2LC0zNC4yOTYxMDMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNi4wNjI1LDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMjg0LjM1MDg2LC0zNC4yOTYxMDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjg0LjM1MDg2JyB5PSctMzQuMjk2MTAzJz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzI5NS4xMDIyMDInIHk9Jy0zNy45MTE0NjcnPjI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjk5LjU3MTU3MicgeT0nLTM0LjI5NjEwMyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSczMDMuNDQ1OTQ2JyB5PSctMzQuMjk2MTAzJz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzMxMi40ODE1MDEnIHk9Jy0zNC4yOTYxMDMnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTUuMzM3NjEzLDEuNTI5MDcxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE1OS44MzE4MTQsMS41MjkwNzEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNi4wNjI1LDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTU5LjgzMTgxNCwxLjUyOTA3MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PScxNTkuODMxODE0JyB5PScxLjUyOTA3MSc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxNzAuNTgzMTU2JyB5PSctMi4wODYyOTMnPjI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTc1LjA1MjUyNicgeT0nMS41MjkwNzEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTc4LjkyNjknIHk9JzEuNTI5MDcxJz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzE4Ny45NjI0NTUnIHk9JzEuNTI5MDcxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIyMi4wOTEzMzcsMS41MjkwNzEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjg0LjM1MDg2LDEuNTI5MDcxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTMuODE5NDQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgyODQuMzUwODYsMS41MjkwNzEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjg0LjM1MDg2JyB5PScxLjUyOTA3MSc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScyOTUuMTAyMjAyJyB5PScxLjUyOTA3MSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PScyOTguOTc2NTc2JyB5PScxLjUyOTA3MSc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczMDguMDEyMTMyJyB5PScxLjUyOTA3MSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTYyLjQ5My0zNS44Mzk1MVYtNTMuMDM5NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLC02Mi40OTMsLTUzLjIzOTU4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04OC41MzgxLC00NC44NTIwMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPsK1PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc5Ljg4OTgyMScgeT0nMi44NjI5NjcnPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nODYuODI5MTQ1JyB5PScyLjg2Mjk2Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc4OS41Mjc0JyB5PScyLjg2Mjk2Nyc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc5NS40NTMxNzgnIHk9JzIuODYyOTY3Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS00MS45MjQ5Ni02Mi45MzkzSDQzLjc2ODA1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQzLjk2ODAzLC02Mi45MzkzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00LjUzMzYzLC01OS4yMjU0NiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPsK1PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc5Ljg4OTgyMScgeT0nMi41MzA4ODQnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNMCA1My40Mzk1NlYzNi4yMzk0NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwzNi4wMzk0OSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyLjM1Mjc1LDQzLjY3ODQ0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg3NS4wNDU2NjYsMS41MjkwNzEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNzUuMDQ1NjY2JyB5PScxLjUyOTA3MSc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc3OS4wMTY5MDcnIHk9JzIuODYyOTY3Jz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jzg1Ljk1NjIzJyB5PScyLjg2Mjk2Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc4OC42NTQ0ODUnIHk9JzIuODYyOTY3Jz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jzk0LjU4MDI2MycgeT0nMi44NjI5NjcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTEwNi42NjEwMSA1Ni41OTY3NkwtMTguNzEwMzMgMzIuMTcyNzMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC45NjM0OSwtMC4yNjc1NSwwLjI2NzU1LDAuOTYzNDksLTE4LjUxNzY1LDMyLjExOTIzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03Ni4xNTYwNSwzOC45NjQ2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPsK1PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc5Ljg4OTgyMScgeT0nMi41MzA4ODQnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTE4LjMyNDk4IDYyLjI5OTI5SC0xMDYuMjYxMDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsLTEwNi40NjEwMyw2Mi4yOTkyOSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNzUuMDkwMyw2Ni40MDIwNCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nODMuMzkwNzc5JyB5PScxLjUyOTA3MSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc4Ni41MDQxMjInIHk9JzEuNTI5MDcxJz7OtzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc5MC42MDg5MScgeT0nMi41MzA4ODQnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nOTcuMDMyODE4JyB5PScxLjUyOTA3MSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00xOC4zMjQ5OCA2Mi4yOTkyOUgxMDYuMjYxMDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA2LjQ2MTAzLDYyLjI5OTI5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjAxNzg4LDY3LjI0MDk0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg3NS4wNDU2NjYsMS41MjkwNzEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNzUuMDQ1NjY2JyB5PScxLjUyOTA3MSc+zrc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNzkuMTUwNDU0JyB5PScyLjg2Mjk2Nyc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc4Ni4wODk3NzgnIHk9JzIuODYyOTY3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzg4Ljc4ODAzMycgeT0nMi44NjI5NjcnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nOTQuNzEzODExJyB5PScyLjg2Mjk2Nyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00xMDYuNjYxMDEgNTYuNTk2NzZMMTguNzEwMzMgMzIuMTcyNzMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuOTYzNDksLTAuMjY3NTUsMC4yNjc1NSwtMC45NjM0OSwxOC41MTc2NSwzMi4xMTkyMyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2NC44NDU3NSwzOC45NjQ2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPsK1PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc5Ljg4OTgyMScgeT0nMi41MzA4ODQnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNNjIuNDkzLTM1LjgzOTUxVi01My42Nzk2MScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDYyLjQ5MywtNTMuODc5NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2NC44NDU3NSwtNDUuNzg1OTMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDc1LjA0NTY2NiwxLjUyOTA3MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSc3NS4wNDU2NjYnIHk9JzEuNTI5MDcxJz7CtTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc3OS44ODk4MjEnIHk9JzIuNTMwODg0Jz5YPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS00MS45MjQ5Ni0yNi45Nzk3OEg0MS41MjUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuNzI0OTgsLTI2Ljk3OTc4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMi45NjgzNywtMjIuODc3MDMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDc1LjA0NTY2NiwxLjUyOTA3MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSc3NS4wNDU2NjYnIHk9JzEuNTI5MDcxJz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzgzLjM5MDc3OScgeT0nMS41MjkwNzEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nODYuNTA0MTIyJyB5PScxLjUyOTA3MSc+wrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nOTEuMzQ4Mjc3JyB5PScyLjUzMDg4NCc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSc5Ny43NzIxODUnIHk9JzEuNTI5MDcxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4="></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            {M^2(X)} &amp;&amp; {M(X)} &amp;&amp; {M^2(X)} \\
            &amp;&amp; {M(X)} \\
            \\
            &amp; {M^3(X)} &amp;&amp; {M^2(X)} \\
            &amp; {M^2(X)} &amp;&amp; {M(X)}
            \arrow [&quot;{\mu _{M(X)}}&quot;&apos;, from=4-2, to=5-2]
            \arrow [&quot;{\mu _X}&quot;, from=5-2, to=5-4]
            \arrow [&quot;{1_{M(X)}}&quot;, from=1-3, to=2-3]
            \arrow [&quot;{\mu _X}&quot;&apos;, from=1-1, to=2-3]
            \arrow [&quot;{M(\eta _X)}&quot;&apos;, from=1-3, to=1-1]
            \arrow [&quot;{\eta _{ M(X)}}&quot;, from=1-3, to=1-5]
            \arrow [&quot;{\mu _X}&quot;, from=1-5, to=2-3]
            \arrow [&quot;{\mu _X}&quot;, from=4-4, to=5-4]
            \arrow [&quot;{M(\mu _X)}&quot;, from=4-2, to=4-4]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure></fr:p>
                          </fr:mainmatter>
                          <fr:backmatter></fr:backmatter>
                        </fr:tree>
                        <fr:p>It requires an operation over functors named <fr:strong>whiskering</fr:strong></fr:p>
                        <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                          <fr:frontmatter>
                            <fr:anchor>697</fr:anchor>
                            <fr:addr type="user">def-003U</fr:addr>
                            <fr:route>def-003U.xml</fr:route>
                            <fr:title text="Whiskering">Whiskering</fr:title>
                            <fr:taxon>Definition</fr:taxon>
                            <fr:authors></fr:authors>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <fr:p>Let <fr:tex display="inline">F,G:C\to  D</fr:tex> and <fr:tex display="inline">H,D\to  E</fr:tex> be functors and <fr:tex display="inline">\eta :F\to  G</fr:tex> be a natural 
    transformation whose coordinate at any object <fr:tex display="inline">A</fr:tex> of <fr:tex display="inline">C</fr:tex> is <fr:tex display="inline">\eta _A</fr:tex>, then 
    <fr:strong>whiskering</fr:strong> <fr:tex display="inline">H</fr:tex> and <fr:tex display="inline">\eta </fr:tex> yields the natural transformation 
    <fr:tex display="inline">H\circ \eta :H\circ  F\to  H\circ  G</fr:tex> whose coordinate at <fr:tex display="inline">A</fr:tex> is <fr:tex display="inline">H(\eta _A)</fr:tex>.</fr:p>
                          </fr:mainmatter>
                          <fr:backmatter></fr:backmatter>
                        </fr:tree>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>698</fr:anchor>
                        <fr:addr type="machine">#356</fr:addr>
                        <fr:route>unstable-356.xml</fr:route>
                        <fr:title text="Logic as Adjoint Functors">Logic as Adjoint Functors</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>3</fr:month>
                          <fr:day>21</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Categorical logic is a new approach to logic, due to <fr:strong>Lawvere</fr:strong>. 
            He showed that logical constructs are fundamentally just <fr:strong>adjoint functors</fr:strong>.
            This allows us to capture many logical constructs by using only one categorical concept.
            Adjoint also provides a strong guarantee about the derived syntactic formulation.</fr:p>
                        <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                          <fr:frontmatter>
                            <fr:anchor>699</fr:anchor>
                            <fr:addr type="user">def-003V</fr:addr>
                            <fr:route>def-003V.xml</fr:route>
                            <fr:title text="Adjoint Functor">Adjoint Functor</fr:title>
                            <fr:taxon>Definition</fr:taxon>
                            <fr:authors></fr:authors>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <fr:p>Let <fr:tex display="inline">\mathcal {C}</fr:tex> and <fr:tex display="inline">\mathcal {D}</fr:tex> be categories and a pair of functors 
    <fr:tex display="inline">F:\mathcal {C}\to \mathcal {D}</fr:tex> and <fr:tex display="inline">G:\mathcal {D}\to \mathcal {C}</fr:tex>. This is called 
    pair of <fr:strong>adjoint functors</fr:strong> (or <fr:strong>adjunction</fr:strong>) with <fr:tex display="inline">F</fr:tex> the left adjoint
    and <fr:tex display="inline">G</fr:tex> the right adjoint denoted 
    <fr:tex display="block">         F\dashv  G     </fr:tex>
    if there is a natural isomorphism between the hom-functors:
    <fr:tex display="block">         \hom _{\mathcal {D}}(F(-),-)\cong \hom _{\mathcal {C}}(-,G(-))     </fr:tex>
    which means forall objects <fr:tex display="inline">C\in \mathcal {C}</fr:tex> and <fr:tex display="inline">D\in \mathcal {D}</fr:tex>, there is a bijection
    <fr:tex display="block">         \hom _{\mathcal {D}}(F(C),D)\cong \hom _{\mathcal {C}}(C,G(D)) \\          (F(C)\xrightarrow {f}D) \mapsto  (C\xrightarrow {G(f)}G(D))     </fr:tex>
    which is natural in both <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex>.</fr:p>
                          </fr:mainmatter>
                          <fr:backmatter></fr:backmatter>
                        </fr:tree>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>700</fr:anchor>
                <fr:addr type="user">cs-0008</fr:addr>
                <fr:route>cs-0008.xml</fr:route>
                <fr:title text="Algebraic Graphs">Algebraic Graphs</fr:title>
                <fr:taxon>Graph Theory</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>10</fr:month>
                  <fr:day>3</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>This post focus on the the algebra of graphs introduced in paper <fr:strong>Algebraic graphs with class (functional pearl)</fr:strong>,
    which built on rigorous mathematical foundation that allows us to apply equational reasoning for proving the correctness of graph transformation algorithms.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>405</fr:anchor>
                    <fr:addr type="machine">#341</fr:addr>
                    <fr:route>unstable-341.xml</fr:route>
                    <fr:title text="Introduction to Graphs">Introduction to Graphs</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>3</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Graphs are ubiquitous in computing. Roughly speaking, a graph is a collection of vertices and edges, where each edge connects two vertices.
        For the most trivial case, a graph is an ordered pair <fr:tex display="inline"> G=(V,E)</fr:tex> comprising:
        <fr:ul><fr:li><fr:tex display="inline"> V </fr:tex> is a set of vertices.</fr:li>
            <fr:li><fr:tex display="inline"> E \subseteq  \{ (x,y) \mid  x, y \in  V\} </fr:tex> is a set of edges.</fr:li></fr:ul>
        We can define a graph type in some programming languages (e.g. Haskell) as:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Graph a = Graph [a] [(a, a)]</html:code></fr:pre>

        Work with such low-level fiddling with sets of vertices and edges is very painful. And we can easily construct a graph that breaks the invariant of the graph structure like <fr:code>Graph [1] [(1,2)]</fr:code> which has an edge connecting a non-existent vertex.</fr:p>
                    <fr:p>How the state-of-art libraries deal with this problem? 
        The <fr:strong>container</fr:strong> library in Haskell provides a type <fr:code>Data.Graph</fr:code> which represents graph using adjacency array:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">type Graph a = Array a [a]</html:code></fr:pre>

        which ensures performance and generality. But the consistency invariant is not <fr:strong>statically</fr:strong> checked, which may lead
        to runtime errors like <fr:code>index out of ranges</fr:code>. Another approach is the <fr:strong>fgl</fr:strong> (Martin Erwig&apos;s Functional Graph Library)
        where the graph is introduced as an <fr:strong>inductive type</fr:strong>. The approach is very complex and its API contains partial functions.
        So is there a <fr:strong>safe</fr:strong> graph construction interface we can build on top?</fr:p>
                    <fr:p><fr:strong>Andrey Mokhov</fr:strong>&apos;s paper presents a new interface for constructing and transforming graphs in a safe and convenient manner.
        And abstract away from the actual representation details and characterize graphs by a set of axioms, just like numbers are algebraically characterized
        by rings. The core calculus is based on the algebra of parameterized graphs. Algebraic graphs have a safe and minimalistic core of four graph construction primitives, as captured by the following data type:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Graph a
    = Empty
    | Vertex a
    | Overlay (Graph a) (Graph a)
    | Connect (Graph a) (Graph a)</html:code></fr:pre></fr:p>
                    <fr:p>The <fr:code>Empty</fr:code> and <fr:code>Vertex</fr:code> construct the empty and single-vertex graphs respectively. <fr:code>Overlay</fr:code> composes two graphs by taking the union of their vertices and edges, and <fr:code>Connect</fr:code> is similar to <fr:code>Overlay</fr:code> but also creates edges between vertices of the two graphs. 
        
        The overlay and connect operations have three properties:
        <fr:ul><fr:li>(Closure)  They are closed on the set of graphs (all total functions)</fr:li>
            <fr:li>(Complete) They can be used to construct any graph starting from the empty and single-vertex graphs</fr:li>
            <fr:li>(Sound) Malformed graphs are impossible to construct</fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>406</fr:anchor>
                    <fr:addr type="machine">#342</fr:addr>
                    <fr:route>unstable-342.xml</fr:route>
                    <fr:title text="Core of Algebraic Graphs">Core of Algebraic Graphs</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>3</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>407</fr:anchor>
                        <fr:addr type="machine">#343</fr:addr>
                        <fr:route>unstable-343.xml</fr:route>
                        <fr:title text="Graph Construction">Graph Construction</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>10</fr:month>
                          <fr:day>3</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>The simplest possible graph is the empty graph. We denote it by <fr:tex display="inline"> \epsilon  = (\varnothing , \varnothing ) </fr:tex>.
            A graph with a single vertex is <fr:tex display="inline"> \text {Vertex} x = (\{x\}, \varnothing ) </fr:tex>.
            To construct larger graphs from the above primitives we define binary operations overlay and connect, denoted by <fr:tex display="inline"> + </fr:tex> and <fr:tex display="inline"> \to  </fr:tex> respectively.
            The overlay operation <fr:tex display="inline"> + </fr:tex> is defined as:
            <fr:tex display="block">                 (V_1, E_1) + (V_2, E_2) = (V_1 \cup  V_2, E_1 \cup  E_2)             </fr:tex>
            The connect operation <fr:tex display="inline"> \to  </fr:tex> is defined similarly (We give it a higher precedence than <fr:tex display="inline"> + </fr:tex>):
            <fr:tex display="block">                 (V_1, E_1) \to  (V_2, E_2) = (V_1 \cup  V_2, E_1 \cup  E_2 \cup  V_1 \times  V_2)             </fr:tex></fr:p>
                        <fr:p>As shown above, the core can be represented by a simple data type <fr:code>Graph</fr:code>, parameterized by the type of vertices <fr:code>a</fr:code>.
            We can push this further by defining a type class <fr:code>GraphLike</fr:code> that captures the core operations of the algebraic graph.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>408</fr:anchor>
                        <fr:addr type="machine">#344</fr:addr>
                        <fr:route>unstable-344.xml</fr:route>
                        <fr:title text="Type Class">Type Class</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>10</fr:month>
                          <fr:day>3</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>We abstract the graph construction primitives defined above as the type class Graph (Note that associated types requires <fr:code>TypeFamilies</fr:code> GHC extension):
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">class Graph g where
    type Vertex g
    empty :: g
    vertex :: Vertex g -&gt; g
    overlay :: g -&gt; g -&gt; g
    connect :: g -&gt; g -&gt; g</html:code></fr:pre></fr:p>
                        <fr:p>This interface is very simple and easy to use, which allows fewer opportunities for usage errors and greater opportunities for reuse.
            Now let&apos;s create some functions to construct graphs. For instance, a single edge is obtained by connecting two vertices:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">edge :: (Graph g) =&gt; Vertex g -&gt; Vertex g -&gt; g
edge x y = connect (vertex x) (vertex y)</html:code></fr:pre></fr:p>
                        <fr:p>A graph that contains a given list of isolated vertices can be constructed as follows:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">vertices :: Graph g =&gt; [Vertex g] -&gt; g
vertices = foldr (overlay . vertex) empty</html:code></fr:pre>

            which turns each vertex into a singleton graph and overlay the results. By replacing the 
            <fr:code>overlay</fr:code> with <fr:code>connect</fr:code> we can construct a full connected graph.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">clique :: (Graph g) =&gt; [Vertex g] -&gt; g
clique = foldr (connect . vertex) empty</html:code></fr:pre></fr:p>
                        <fr:p>The graph construction functions defined above are total, fully polymorphic, and elegant. 
            Thanks to the minimalistic core type class, it is easy to wrap our favourite graph library into the described interface, 
            and reuse the functions defined with graph class.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>409</fr:anchor>
                    <fr:addr type="machine">#345</fr:addr>
                    <fr:route>unstable-345.xml</fr:route>
                    <fr:title text="Algebraic Structure">Algebraic Structure</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>3</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>In this section we characterise the <fr:code>Graph</fr:code> type class with a set of axioms that reveal an algebraic structure very similar to a semiring. This provides a convenient framework for proving graph properties, using equational reasoning. The presented characterization is generally useful for formal verification, as well as automated testing of graph library APIs.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>410</fr:anchor>
                        <fr:addr type="machine">#346</fr:addr>
                        <fr:route>unstable-346.xml</fr:route>
                        <fr:title text="Axioms">Axioms</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>10</fr:month>
                          <fr:day>3</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Notice that the <fr:code>clique</fr:code> and <fr:code>vertices</fr:code> functions use <fr:tex display="inline">\epsilon </fr:tex> as the identity element for the overlay and connect operation respectively.
            Further more we can verify:
            <fr:ul><fr:li><fr:tex display="inline">(G,+,\epsilon )</fr:tex> is an idempotent commutative monoid.</fr:li>
                <fr:li><fr:tex display="inline">(G,\to ,\epsilon )</fr:tex> is a monoid.</fr:li>
                <fr:li><fr:tex display="inline">\to </fr:tex> distributes over <fr:tex display="inline">+</fr:tex>.</fr:li></fr:ul>
            This looks like a semiring, but the identity element are shared between the two operations. 
            What makes the algebra of graphs different is the <fr:strong>decomposition law</fr:strong>:
            <fr:tex display="block">                 x \to  y \to  z = x \to  y + x \to  z + y \to  z             </fr:tex>
            Interestingly, the fact that overlay and connect share the same identity follows from the decomposition law.
            Furthermore, the identity (<fr:tex display="inline">x + \epsilon  = x</fr:tex>) and idempotence (<fr:tex display="inline">x + x = x</fr:tex>) can also be proved from the decomposition law.
            Hence we get a minimal set (8) of axioms that characterize the algebraic graphs.
            <fr:ul><fr:li><fr:tex display="inline">+</fr:tex> is commutative and associative: <fr:tex display="inline">x + y = y + x</fr:tex> and <fr:tex display="inline">(x + y) + z = x + (y + z)</fr:tex></fr:li>
                <fr:li><fr:tex display="inline">(G,\to ,\epsilon )</fr:tex> is a monoid, i.e. <fr:tex display="inline">x \to  y \to  z = x \to  (y \to  z)</fr:tex> and <fr:tex display="inline">\epsilon  \to  x = x, x \to  \epsilon  = x</fr:tex></fr:li>
                <fr:li><fr:tex display="inline">\to </fr:tex> distributes over <fr:tex display="inline">+</fr:tex>: <fr:tex display="inline">(x + y) \to  z = x \to  z + y \to  z</fr:tex></fr:li>
                <fr:li>Decomposition law: <fr:tex display="inline">x \to  y \to  z = x \to  y + x \to  z + y \to  z</fr:tex></fr:li></fr:ul>
            By adding more axioms we can obtain more complex graphs such as directed graphs, hypergraphs, etc.</fr:p>
                        <fr:p>Algebraic graphs are <fr:strong>complete</fr:strong> in the sense that it is possible to describe any graph using the core interface. Indeed, given a graph <fr:tex display="inline">G=(V , E)</fr:tex> we can construct it as <fr:code>graph V E</fr:code>, where the function <fr:code>graph</fr:code> is defined as follows.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">graph :: (Graph g) =&gt; [Vertex g] -&gt; [(Vertex g, Vertex g)] -&gt; g
graph vs es = overlay (vertices vs) (edges es)</html:code></fr:pre>

            where <fr:code>edges</fr:code> is defined as:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">edges :: (Graph g) =&gt; [(Vertex g, Vertex g)] -&gt; g
edges = foldr (overlay . uncurry edge) empty</html:code></fr:pre>

            The absorption theorem <fr:tex display="inline">x \to  y + x + y = x \to  y</fr:tex>, derived from decomposition of <fr:tex display="inline">x \to  y \to  \epsilon </fr:tex>, states that an edge <fr:tex display="inline">(u, v)</fr:tex> 
            contains its two vertices <fr:tex display="inline">u, v</fr:tex> and is inseparable from them. Therefore, if the pair <fr:tex display="inline">(V , E)</fr:tex> is inconsistent, the set of vertices <fr:tex display="inline">V</fr:tex> 
            will be expanded to <fr:tex display="inline">\hat {V}</fr:tex> so that <fr:tex display="inline">E\subseteq  \hat {V} \times  \hat {V}</fr:tex> holds. More generally, the absorption theorem states that in 
            addition to being complete, the algebraic graph API is also sound in the sense that it is impossible to construct an inconsistent pair
            <fr:tex display="inline">(V , E)</fr:tex> using the four Graph methods.</fr:p>
                        <fr:p>There are many other interesting properties of algebraic graphs can be proved using the axioms:
            <fr:ul><fr:li>(Overlay Identity) <fr:tex display="inline">x + \epsilon  = x</fr:tex></fr:li>
                <fr:li>(Overlay Idempotence) <fr:tex display="inline">x + x = x</fr:tex></fr:li>
                <fr:li>(Absorption) <fr:tex display="inline">x \to  y + x + y = x \to  y</fr:tex></fr:li>
                <fr:li>(Saturation) <fr:tex display="inline">x \to  x \to  x = x \to  x</fr:tex></fr:li></fr:ul></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>411</fr:anchor>
                        <fr:addr type="machine">#347</fr:addr>
                        <fr:route>unstable-347.xml</fr:route>
                        <fr:title text="Partial Order">Partial Order</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>10</fr:month>
                          <fr:day>3</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>It is fairly standard to define <fr:tex display="inline">x \leq  y</fr:tex> as <fr:tex display="inline">x + y = y</fr:tex> for an idempotent operation <fr:tex display="inline">+</fr:tex>, since it gives a <fr:link type="local" href="def-000Y.xml" addr="def-000Y" title="Partial Order">partial order</fr:link> on the elements of the algebra. Formally we call this definition the <fr:strong>subgraph</fr:strong> relation. Therefore, we can check if a graph is a subgraph of another one if we know how to compare graphs for equality.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">isSubgraphOf :: (Graph g, Eq g) =&gt; g -&gt; g -&gt; Bool
isSubgraphOf x y = overlay x y == y</html:code></fr:pre></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>412</fr:anchor>
                    <fr:addr type="machine">#348</fr:addr>
                    <fr:route>unstable-348.xml</fr:route>
                    <fr:title text="Graphs  la Carte">Graphs  la Carte</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>3</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Now we define some instances of the Grpah, and extend the axioms to construct more complex graphs.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>413</fr:anchor>
                        <fr:addr type="machine">#349</fr:addr>
                        <fr:route>unstable-349.xml</fr:route>
                        <fr:title text="Binary Relation">Binary Relation</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>10</fr:month>
                          <fr:day>3</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>We start by a direct encoding of the graph construction primitives defined into the abstract data type <fr:code>Relation</fr:code> isomorphic to a pair of sets <fr:tex display="inline">(V , E)</fr:tex>: 
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Relation a = R {domain :: Set a, relation :: Set (a, a)} deriving (Eq)

instance (Ord a) =&gt; Graph (Relation a) where
    type Vertex (Relation a) = a
    empty = R Set.empty Set.empty
    vertex x = R (singleton x) Set.empty
    overlay x y = R (domain x `union` domain y) (relation x `union` relation y)
    connect x y =
        R (domain x `union` domain y)
        ( relation x
            `union` relation y
            `union` fromAscList [(a, b) | a &lt;- elems (domain x), b &lt;- elems (domain y)]
        )</html:code></fr:pre>

            As we have seen, this implementation satisfies the axioms of the graph algebra. Furthermore, it is a free graph in the sense that it does not satisfy any other laws. This follows from the fact that any algebraic graph expression <fr:tex display="inline">g</fr:tex> can be rewritten in the following canonical form:
            <fr:tex display="block">                 g = \left ( \sum _{v\in  V_g} v \right ) + \left ( \sum _{(u,v)\in  E_g} u \to  v \right )             </fr:tex>
            The existence of the canonical form was proved by <fr:strong>Mokhov</fr:strong> in <fr:em>Algebra of Parameterised Graphs</fr:em> for an extended version of the algebra.
            The core idea is to repeatedly apply the decomposition law to rewrite the graph expression in the form of the above equation,
            until no further decomposition is possible.</fr:p>
                        <fr:p>It will be convenient to make <fr:code>Relation</fr:code> an instance of <fr:code>Num</fr:code> type class.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">instance (Ord a, Num a) =&gt; Num (Relation a) where
    fromInteger = vertex . fromInteger
    (+) = overlay
    (*) = connect
    signum = const empty
    abs = id
    negate = id</html:code></fr:pre>

            With these setups we can use the standard <fr:tex display="inline">+</fr:tex> and <fr:tex display="inline">\times </fr:tex> operators as shortcuts for overlay and connect respectively.
            Note that the Num law <fr:code>abs x * signum x == x</fr:code> is satisfied by the above definition since <fr:tex display="inline">x \to  \epsilon  = x</fr:tex>.
            Any Graph instance can be made an instance of <fr:code>Num</fr:code> if needed.</fr:p>
                        <fr:p>Now let&apos;s try to construct some graphs using the <fr:code>Relation</fr:code> type and the <fr:code>Num</fr:code> instance:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">ghci&gt; 1 * (2 + 3) :: Relation Int
R {domain = fromList [1,2,3], relation = fromList [(1,2),(1,3)]}
ghci&gt; 1 * 2 * 3 :: Relation Int
R {domain = fromList [1,2,3], relation = fromList [(1,2),(1,3),(2,3)]}</html:code></fr:pre></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>701</fr:anchor>
                <fr:addr type="user">cs-0009</fr:addr>
                <fr:route>cs-0009.xml</fr:route>
                <fr:title text="Algebraic Effects">Algebraic Effects</fr:title>
                <fr:taxon>Algebra</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>28</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Notes about algebraic effects and handlers.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>702</fr:anchor>
                    <fr:addr type="machine">#340</fr:addr>
                    <fr:route>unstable-340.xml</fr:route>
                    <fr:title text="Algebraic Theories">Algebraic Theories</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>In algebra we study mathematical structures that are equipped with operations
        satisfying equational laws.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>703</fr:anchor>
                        <fr:addr type="user">def-004M</fr:addr>
                        <fr:route>def-004M.xml</fr:route>
                        <fr:title text="Signatures, terms and equations">Signatures, terms and equations</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>A signature <fr:tex display="inline">\Sigma </fr:tex> is a collection of operation symbols with arities <fr:tex display="inline">\{(\text {op}_i, \text {ar}_i)\}_i</fr:tex>. The operation 
    symbols opi may be any anything, but are usually thought of as syntactic entities, while arities <fr:tex display="inline">\text {ar}_i</fr:tex> are 
    non-negative integers. An operation symbol whose arity is 0 is called a constant or a nullary symbol. 
    Operation symbols with arities <fr:tex display="inline">1</fr:tex>, <fr:tex display="inline">2</fr:tex> and <fr:tex display="inline">3</fr:tex> are referred to as unary, binary, and ternary, respectively.</fr:p>
                        <fr:p>A list of distinct variables <fr:tex display="inline">x_1, \cdots , c_k</fr:tex> is called a <fr:strong>context</fr:strong>. 
    The <fr:tex display="inline">\Sigma \text {-terms}</fr:tex> in this context are built inductively using the following rules:
    <fr:ul><fr:li>Each variable <fr:tex display="inline">x_i</fr:tex> is a <fr:tex display="inline">\Sigma \text {-term}</fr:tex> in this context</fr:li>
        <fr:li>If <fr:tex display="inline">t_1, \cdots , t_{\text {ar}_i}</fr:tex> are <fr:tex display="inline">\Sigma \text {-terms}</fr:tex> in this context, then <fr:tex display="inline">\text {op}_i(t_1, \cdots , t_{\text {ar}_i})</fr:tex> is a <fr:tex display="inline">\Sigma \text {-term}</fr:tex> in this context</fr:li></fr:ul>
    We write 
    <fr:tex display="block">         x_1, \cdots , x_k \mid  t     </fr:tex>
    to indicate that <fr:tex display="inline">t</fr:tex> is a <fr:tex display="inline">\Sigma \text {-term}</fr:tex> in the context <fr:tex display="inline">x_1, \cdots , x_k</fr:tex>.
    A <fr:strong>closed</fr:strong> <fr:tex display="inline">\Sigma \text {-term}</fr:tex> is a term in the empty context.</fr:p>
                        <fr:p>A <fr:tex display="inline">\Sigma \text {-equation}</fr:tex> is a pair of <fr:tex display="inline">\Sigma \text {-terms}</fr:tex> <fr:tex display="inline">l</fr:tex> and <fr:tex display="inline">r</fr:tex> in the context <fr:tex display="inline">x_1, \cdots , x_k</fr:tex>:
    <fr:tex display="block">         x_1, \cdots , x_k \mid  l = r     </fr:tex>
    We shall often elide the context and write simply <fr:tex display="inline">l = r</fr:tex>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>704</fr:anchor>
                        <fr:addr type="user">def-004N</fr:addr>
                        <fr:route>def-004N.xml</fr:route>
                        <fr:title text="Algebraic Theories">Algebraic Theories</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>An <fr:strong>algebraic (equational) theory</fr:strong> <fr:tex display="inline">T = (\Sigma _T, E_T)</fr:tex> is given by 
    a signature <fr:tex display="inline">\Sigma _T</fr:tex> and a collection <fr:tex display="inline">\Epsilon _T</fr:tex> of equations over the terms of this signature.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>705</fr:anchor>
                        <fr:addr type="user">def-004O</fr:addr>
                        <fr:route>def-004O.xml</fr:route>
                        <fr:title text="Interpretation of Signatures">Interpretation of Signatures</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Let <fr:tex display="inline">\Sigma </fr:tex> be a signature, 
    an <fr:strong>interpretation</fr:strong> <fr:tex display="inline">I</fr:tex> of <fr:tex display="inline">\Sigma </fr:tex> is given by the following data:
    <fr:ul><fr:li>A set <fr:tex display="inline">|I|</fr:tex> called the <fr:strong>carrier</fr:strong> of the interpretation</fr:li>
        <fr:li>For each operation symbol <fr:tex display="inline">\text {op}_i</fr:tex>, a map
            <fr:tex display="block">                 [\text {op}_i]_I : |I|^i \to  |I|             </fr:tex></fr:li></fr:ul>
    The bracket <fr:tex display="inline">[]_I</fr:tex> here is called the <fr:strong>semantic bracket</fr:strong> and is typically used when 
    syntactic entities (operation symbols, terms, equations) are mapped to their mathematical counterparts.</fr:p>
                        <fr:p>The interpretation can be extended to terms and equations.
    A <fr:tex display="inline">\Sigma \text {-term}</fr:tex> <fr:tex display="inline">t</fr:tex> in the context <fr:tex display="inline">x_1, \cdots , x_k</fr:tex> is interpreted as a function
    <fr:tex display="block">         [x_1, \cdots , x_k \mid  t]_I : |I|^k \to  |I|     </fr:tex>
    as follows:
    <fr:ul><fr:li>The variable <fr:tex display="inline">x_i</fr:tex> is interpreted as the i-th projection
            <fr:tex display="block">                 [x_1, \cdots , x_k \mid  x_i]_I : |I|^k \to  |I|, \quad  (a_1, \cdots , a_k) \mapsto  a_i             </fr:tex></fr:li>
        <fr:li>A compound term in context <fr:tex display="inline">x_1, \cdots , x_k</fr:tex> is interpreted as the composition of the 
            semantic brackets of the operation symbols and the terms:
            <fr:tex display="block">                 |I|^k \xrightarrow {[t_1]_I, \cdots , [t_{\text {ar}_i}]_I} |I|^{\text {ar}_i} \xrightarrow {[\text {op}_i]_I} |I|             </fr:tex></fr:li></fr:ul></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>706</fr:anchor>
                        <fr:addr type="user">def-004P</fr:addr>
                        <fr:route>def-004P.xml</fr:route>
                        <fr:title text="Models of algebraic theories">Models of algebraic theories</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>A <fr:strong>model</fr:strong> <fr:tex display="inline">M</fr:tex> of an algebraic theory <fr:tex display="inline">T</fr:tex> is an interpretation of the signature <fr:tex display="inline">\Sigma _T</fr:tex> 
    which validates all the equations <fr:tex display="inline">E_T</fr:tex>.
    That is, for each equations <fr:tex display="inline">x_1, \cdots , x_k \mid  l = r</fr:tex> in <fr:tex display="inline">E_T</fr:tex>, we have:
    <fr:tex display="block">         [x_1, \cdots , x_k \mid  l]_M = [x_1, \cdots , x_k \mid  r]_M     </fr:tex>
    We refer to a model of <fr:tex display="inline">T</fr:tex> as a <fr:tex display="inline">T\text {-algebra}</fr:tex> or <fr:tex display="inline">T\text {-model}</fr:tex>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>707</fr:anchor>
                        <fr:addr type="user">def-004Q</fr:addr>
                        <fr:route>def-004Q.xml</fr:route>
                        <fr:title text="Model Homomorphism">Model Homomorphism</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Let <fr:tex display="inline">M</fr:tex> and <fr:tex display="inline">N</fr:tex> be models of an algebraic theory <fr:tex display="inline">T</fr:tex>.
    A <fr:strong>T-homomorphism</fr:strong> from <fr:tex display="inline">M</fr:tex> to <fr:tex display="inline">N</fr:tex> is a function <fr:tex display="inline">f:|M|\to |N|</fr:tex> that preserves the interpretation of the operations of <fr:tex display="inline">T</fr:tex>.
    That is, for each operation symbol <fr:tex display="inline">f\in \Sigma _T</fr:tex>, we have:
    <fr:tex display="block">         f_N \circ  (f, \cdots , f) = f \circ  f_M     </fr:tex>
    where <fr:tex display="inline">f_M</fr:tex> and <fr:tex display="inline">f_N</fr:tex> are the interpretations of <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">M</fr:tex> and <fr:tex display="inline">N</fr:tex> respectively.
    We say that <fr:tex display="inline">f</fr:tex> is a <fr:strong>model isomorphism</fr:strong> if it is bijective.
    We say that <fr:tex display="inline">M</fr:tex> and <fr:tex display="inline">N</fr:tex> are <fr:strong>isomorphic</fr:strong> if there exists a model isomorphism between them.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>We may organize the models of an algebraic theory <fr:tex display="inline">T</fr:tex> into a category <fr:tex display="inline">\mathbf {Mod}(T)</fr:tex>
        whose objects are the models of the theory and the morphisms are the model homomorphisms.</fr:p>
                    <fr:p>So far we have considered the models of an algebraic theory as sets with operations.
        More generally we can consider models in any category <fr:tex display="inline">C</fr:tex> with finite products.
        Hence the definition of an interpretation and a model may be directly transcribed.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>708</fr:anchor>
                        <fr:addr type="user">def-004R</fr:addr>
                        <fr:route>def-004R.xml</fr:route>
                        <fr:title text="Interpretation over Category">Interpretation over Category</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>An interpretation <fr:tex display="inline">I</fr:tex> in <fr:tex display="inline">C</fr:tex> is given by
    <fr:ul><fr:li>An object <fr:tex display="inline">|I|</fr:tex> in <fr:tex display="inline">C</fr:tex>, called the <fr:strong>carrier</fr:strong></fr:li>
        <fr:li>For each operation symbol <fr:tex display="inline">\text {op}_i</fr:tex>, a morphism in <fr:tex display="inline">C</fr:tex>
            <fr:tex display="block">                 [\text {op}_i]_I : |I|^i \to  |I|             </fr:tex></fr:li></fr:ul>
    Notice that a nullary symbol is interpreted as a morphism <fr:tex display="inline">|I|^0 \to  |I|</fr:tex>,
    which is a morphism form the terminal object <fr:tex display="inline">1\to |I|</fr:tex> in <fr:tex display="inline">C</fr:tex>.</fr:p>
                        <fr:p>Similarly, the interpretation can be extended to terms and equations in the same way.
    A model of an algebraic theory <fr:tex display="inline">T</fr:tex> in <fr:tex display="inline">C</fr:tex> is an interpretation <fr:tex display="inline">M</fr:tex> of its signature <fr:tex display="inline">\Sigma _T</fr:tex> 
    which validates all the equations <fr:tex display="inline">E_T</fr:tex>.
    The definition of a homomorphism is now the morphism in the category <fr:tex display="inline">C</fr:tex>.
    The <fr:tex display="inline">T\text {-models}</fr:tex> and <fr:tex display="inline">T\text {-homomorphisms}</fr:tex> in <fr:tex display="inline">C</fr:tex> form another category, denoted by <fr:tex display="inline">\mathbf {Mod}_C(T)</fr:tex>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>Of special interest are the free models of an algebraic theory.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>709</fr:anchor>
                        <fr:addr type="user">def-004S</fr:addr>
                        <fr:route>def-004S.xml</fr:route>
                        <fr:title text="Free Models">Free Models</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter><fr:p>Let <fr:tex display="inline">T</fr:tex> be an algebraic theory and <fr:tex display="inline">X</fr:tex> be a set,
    the <fr:strong>free T-model</fr:strong>, also called the <fr:strong>free T-algebra</fr:strong>,
    generated by <fr:tex display="inline">X</fr:tex> is a model <fr:tex display="inline">M</fr:tex> together with a map 
    <fr:tex display="inline">\eta :X\to  |M|</fr:tex> such that for any T-model <fr:tex display="inline">L</fr:tex> and every map <fr:tex display="inline">f:X\to  |L|</fr:tex>,
    there is a unique T-homomorphism <fr:tex display="inline">\bar {f}:|M|\to  |L|</fr:tex> such that the following diagram commutes:</fr:p>
 
  
  <fr:figure><fr:resource hash="d427212bc19168e8ea1de56926b81991"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzNS40NTAyMDJwdCcgaGVpZ2h0PScxMDUuODkyNTU4cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTAuMzAwMTM0IDcwLjU5NTAzOSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTFlBQW9BQUFBQUF6d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaGN0MUlXTnRZWEFBQUFFOEFBQUFLUUFBQURRQURBRUNaMng1WmdBQUFXZ0FBQUFjQUFBQUhEcGNMZkZvWldGa0FBQUJoQUFBQUMwQUFBQTJLV2t1azJob1pXRUFBQUcwQUFBQUlBQUFBQ1FGU0FJdWFHMTBlQUFBQWRRQUFBQUlBQUFBQ0FVYUFGZHNiMk5oQUFBQjNBQUFBQVlBQUFBR0FBNEFBRzFoZUhBQUFBSGtBQUFBRndBQUFDQUFCQUFGYm1GdFpRQUFBZndBQUFESkFBQUJNdTBLa2V4d2IzTjBBQUFDeUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRVRBeEpJS1M1TEIwcXVaMWpQelBBZnlHZG1ZQVFKTXlKVS9BY0tBd0R5UEEzY0FIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ1VnRFFMRUlMNDYvLy9oNUQvZzhCOEJnQmJuUWNMQUFBQUFBRUFWd0k1QWU4Q1lBQURBQUFCSVRVaEFlLythQUdZQWprbkFIamFZMkJrWUdBQTRzZlJaeXpqK1cyK01qQ3pNSURBNC8xZlp5UFRUSmVaRW9BVUJ3TVRpQWNBVkVjTGtRQUFBSGphWTJCa1lHQm0rTS9Bd01CMG1TR2NJWUx4UFFOUUJBVXdBUUJVUlFON0F0TUFBQUpIQUZjQUFBQUFBQTRBQUhqYVkyQmtZR0JnWW1CaEFORU1VQklKQUFBQkFRQUtBSGphUFl3eEM4SXdFSVcvWWhXdGc0UGc0Q0RCSDFDMENpNXVEazZ1RG03V0JPblFWTkphZEJGL3V0Y1F2SkRqdS9mZUhaRHdJYUtyaUludlhjWHlKb0g3akprR0hvaStDSnd3WjBtUEtCNkpzbUFmT0diSUpYQ2ZHWG5nZ2VpdndBbGJ2b2VxZkR3YjQ5U3Awc2JaVytsMlorUHFvckpxbmE2NjhXaXNjZGZHYUpXL2xXNkx1cjJYYXBObWFjYUJpcElIVHhvTURzVkpGTzNaY2hQUHNlUHM1NXBDUEN1Wk5TbXJ2M3NVMS9yRTFWL1Jrc2g1UzllMHNsTkx2MHRXc1pHOXJQcy9XVEl1VFFBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVHdBQW9BQUFBQUJld0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFdkMVZHTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWRnQ2ZaMng1WmdBQUFXd0FBQUllQUFBQ3JLeitmZkJvWldGa0FBQURqQUFBQUM4QUFBQTJLc1F1N21ob1pXRUFBQU84QUFBQUhnQUFBQ1FIVEFLYWFHMTBlQUFBQTl3QUFBQVFBQUFBRUF4ZkFIQnNiMk5oQUFBRDdBQUFBQW9BQUFBS0FhUUF4RzFoZUhBQUFBUDRBQUFBRndBQUFDQUFCZ0JoYm1GdFpRQUFCQkFBQUFEVUFBQUJQcGtSZGNkd2IzTjBBQUFFNUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtRm1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcjZNRVF3TS93SDhwa2gwa2hxL2dPRkFiR3hES3dBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLK2pKRS9QOFA1UHVBNlA5Yi82OEdxd0lDQUpRZUNROEFBSGphTlpFeGI5TkFGTWY5ZjJlL1N4ejduTVN4cmFxT0UyaXhFWVJFS0cyc0lqVWRLZ1NDQVFZWWtKQkFTS2hGQW9ZQ3FtQXBNRUJGWVlHRkx3QWZBREdoaWcvQkFoTXpBd3NEWXhyT1RybVRUdS9lZTNmNi8vN1BnSEY4T3FGM3RHLzBEUVBDQXcralVWN3VLUFNna0IzaEpSMk9jbjlwSWVNeE9zaWpNR3B4ZHBTeDg4b0UxUGJEa1dQM0FtbTd1R3JhallNMFZ1cE1ZcjJKMHpZYzNuMXZXNmlIWnhmcDd1UjdrMjJJdk9hTzF5T2k2bStISWRvUzhCTmFhWkNJSllRQVZSVWpNUFNDMFp0T3pWUDAxVGczMDVaZ3BEQ0F6TkxzVUJOWXBzczFjTUJoQjJGUVZndTlZK1QrS0N1aTRTaU1mSXhSQkp5bExEN3ZhdEhIVnVCYVQzY0thYTdXK3ZiZ0ZqZThhM3NtNWsrNkRHWGUyWEJkYzdYSEw3Q2UxTDNYdm9QTGVGUlJ6WmZ6OEpwNW0rNU5mamFseTJhN2tFeW9lbHhTWEp4c0sxTUU5R1R5VFZYOU9SUXdKZFM4UGs5MEthNEwwZGF0c2pIWnAvT2FzMkF1WVdIRTA2blkwSE80b1MvYS9qNWxwZG1hcThVTFNtTjUwSEdDWVhUSVdib3dIR041Z0dKUXNpeEZaU2tkb0N5dGtlaGpnV2MvUlFtS2p3TDgrVmdYMVBHaExkaTZXU1Z5N1A1YU1KYy9ieXhlc3R1bkhVa09iejJyV25BcVNXSnRYdCtzMVVHZGl0UzJPZGFEMllQc1F1citlR3pGdllDSzVLeTdHK1BESnhXMUhOZ3phcE1WaTZRVnJ1NzFyM3hKUEpCZElCZCt1ZEpzU3UvdjdmdTF5RzNWaUNyL0gzaE0zY3o1aGFUZUVHcVdwRUNhZ1dVWS93RGtjVm5aQUFCNDJtTmdaR0JnQU9MZVZ1L3o4ZncyWHhtWVdSaEE0UEgrcjdNUjlQKy9MTHBNKzRCY0RnWW1rQ2dBYWJZTk1BQjQybU5nWkdCZ1p2alBBQ1FmTXNqODM4S2l5d0FVUVFFc0FGKytBKzBBQUFKMkFBQUN1QUFvQStFQUxBTlFBQndBQUFBQUFFNEF4QUZXQUFCNDJtTmdaR0JnWUdGSVlBRFJERkFTQ1FBQUNqTUFhQUI0MmsyT3NXckRNQlJGajZsanFGdklsQXdkaXFhTXhuYjZBWVVNbWJKbUxDU1JDQzVJQ3JKanlCTDZBZjNvUGlzYStvUWVSK2RkQ1FFbGR6S215cGpIUGxWT0lhY0h6M2hoa2JpUXBSS1h2TEhpaVN4L0Z2UE9aK0tjVjc0U3oxanluYmdRLzVPNDVJUGZqYmVYNjJDQzJubHRnanRaMnpYMTNvUys4MDQxVmYwUVcrTk1PQXhHcStOTjZiSHJ4N05WNjZxdFdqWjRMQmV1REJpQy9Hd25Sa2QybkdSbTZXaW8yVWZYeThuTFJJbXJ4UDVQYkNYaFl1b1FYOU9TT25LVHJoa2wwMHMvUzFxeGxydnR0UDhBNElJd3ZYamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFvQUFvQUFBQUFCTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjREMk50WVhBQUFBRThBQUFBTVFBQUFEd0hHZjF5WjJ4NVpnQUFBWEFBQUFGZEFBQUJrSHhHOTVGb1pXRmtBQUFDMEFBQUFDOEFBQUEyS1YwdUtXaG9aV0VBQUFNQUFBQUFJQUFBQUNRRm5RR2FhRzEwZUFBQUF5QUFBQUFNQUFBQURBZGFBSHRzYjJOaEFBQURMQUFBQUFnQUFBQUlBR1lBeUcxaGVIQUFBQU0wQUFBQUZ3QUFBQ0FBQlFCQ2JtRnRaUUFBQTB3QUFBRFBBQUFCT1BOaEtxTndiM04wQUFBRUhBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUttYWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVc5blp2Z1A1RE16TUlLRUdSRXEvZ09GQWZxQ0RnTUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5cVl4Yi8vL0g4Z0gwLzluLy9FR3F3SUNBS0kvQ1lrQUFBQjQya1dQdjA3Q1VCeEcrLzF1YVlGaWI0SDJWaEVyMG5JTEdnRUZTMEF0S0luR1B3Tk9SQmQzRnhkOURTY0hWNS9BbHpCT0xqNk1LMWlpaWQvMDVaenBLRkF1NWkyNm95OWxwQ2hnSEpwdVFxL0tNRVpIdUVMVHhUcGlESm12eWNqdHhPZ2xmRmU0Sm53WnlxZ25XekNKb3hNSkxjVHJ3Rkt0VXVab3B6NEFBa2N5OEhYT2ViREIxcHI4MHFNaXYrS09LWTc5eGdIZ2k4UmJIdWVGZ3BkTmwyNFhHcyt6OS9QOHFHdVBtZlM5Q2dWYWFHUUk2b1h6OGoxbFZSM1Q2OVZRMW9KL2hSVzUvYVJXMDFDU1FXblBhM1NDRCtWdzBmTGIwU3ZHSk1Qa20rQmtNaGtPV2JUWC9TTXROQkgxWWhKdUROZExRdWpnbnB5U2FVTjlVQm1KeHY1a21XZjFOVHVWY2NvMnNsczVRK05GcjJxazlLeWhRZkJjMkQ5TGQyNHFwOTBjQUhjMnpQbGs1UjE4TGkzWGQ0akdkYWZrUFU1c2JzTEtiNzYxbTY3bGxJRlIwelpBWkkzTG9rSzEvbjVBcVZaM2FUVkorQUZ3aXpFcEFBQUFlTnBqWUdSZ1lBQml1NTQveGZIOE5sOFptRmtZUU9EeC9xK3pFZlIvVmFaalRCZUJYQTRHSnBBb0FHZUpEUThBZU5wallHUmdZR2I0ejhEQXdIU013ZUQvQmFZc0JxQUlDbUFHQUdWM0JEc0N4Z0FBQWpvQVN3SmFBREFBQUFBQUFHWUF5SGphWTJCa1lHQmdabkJrQU5FTVVCSUpBQUFIRVFCSUFIamFUWXc5YjhJd0VJYWZpQVNKTUxDZ0RoMktoODRSQkNTMkxneE1yRXdzZ0YyVXdUWnlRaVNrcW1OL2R5K3VoNTdrMC9OK25JR1NiektHeVpqRlBVeE9JZXFQQzZiTUU0OUZMUktYdlBMT2lDeWZpUFBHUitKY2tsUGlnaGMrRTQvRi8wcGNzdUZuNSszOTBabWdEbDZiNEs3V050dWpDVzNqblZwVnk2ajN4cGx3N294V2w2ZlNmZFAyTjZ2V1ZWM1Y3UEJZN2p6b01BUVVCM0YwWk1kVk1rdkRsbU4wV21FdnZtSkZ4ZkpmdnBmY3hjNDUvcVNsYytFcFc5TkxvNVY5azY1aUxaZjE4SDRCekNzditRQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFMOEFBb0FBQUFBQTJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVjQUFBQmdpSWh4d0dOdFlYQUFBQUU4QUFBQUtRQUFBRFFBREFEUFoyeDVaZ0FBQVdnQUFBQTBBQUFBTkxQN1JBeG9aV0ZrQUFBQm5BQUFBQzhBQUFBMktiTXVNMmhvWldFQUFBSE1BQUFBSGdBQUFDUUVPUC9BYUcxMGVBQUFBZXdBQUFBSUFBQUFDQVE0QUhsc2IyTmhBQUFCOUFBQUFBWUFBQUFHQUJvQUFHMWhlSEFBQUFIOEFBQUFGd0FBQUNBQUJBQU5ibUZ0WlFBQUFoUUFBQURWQUFBQlBxODNkZU53YjNOMEFBQUM3QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1rbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjByV01OUXdTLzNSWkdCZ2xtSytqcXJtLzM4R0JnRFZ1QTQzQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnVWdEUUxFSUw0TmYvL1E4ai9yV0ErQXdCWGJnYllBQUFBQUFFQWVmOEJBS1FDL3dBTEFBQVRFUllHSWlZM0VTWTJNaGFqQVFjZEJ3RUJCeDBIQXR2OFNnNFdGZzREdGc0V0ZnQUFBSGphWTJCa1lHQUE0c3o2eDJ2aitXMitNakN6TUlEQTQvMWZaeVBvLzR6TU1rei9nVndPQmlhUUtBQnB0Z3l2QUhqYVkyQmtZR0NXK3FNSkpHVVlLaGtxR0pZd0FFVlFBQk1BU2ZvQyt3QUFBeHdBQUFFY0FIa0FBQUFBQUJvQUFIamFZMkJrWUdCZ1l1QmhBTkVNVUJJSkFBQUJ5UUFTQUhqYVRZNnhhc013RkVXUHFXT29HK2lVREIyS3BvekdkdklCaFF5WnNtWXNKSkVJTGxnT2ttUHdVdm9CK2VnOEt4cjZoQjVIOTk3M0VKRHpTOEpVQ2UraFQ1V1N5ZXZKTTk1WVJNN2txTWc1SDZ4NElVbGZSZm5rSzNMS25PL0lNNWI4Uk01RS80dWNzK0crN2RycnJUZE83VHR0bkQyM2ZxektnM0crNmF5cWl2SXA3SXcxN3RnYnJVNmowa1BqaDB1cjFrVmQxR3pwYUxseW84Zmc1R2Q3VVhSZ3kxazh6MGhGeVNGb25rWjhLN21LUXRUL2laMGtiRWdkd3pZdHFaTjRTbWlRT1MvOUlubkZXbWJyNlQ0QUNkOHhGUUFBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yNi44NDk5MzUsLTM2LjU5MjUxNClzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDUuMzE5MzgsLTI5LjE1OTc3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjYuODQ5OTM1LC0zNi41OTI1MTQpc2NhbGUoLTEsLTEpJz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xOC4wNDI3MDcsLTg5LjcxMjg2MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuNTM0NzEsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTguMDQyNzA3LC04OS43MTI4NjMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE4LjA0MjcwNycgeT0nLTg5LjcxMjg2Myc+WDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNC42NzQ4MjgsLTg5LjcxMjg2MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS4wMTc2NjgsLTg5LjcxMjg2MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTguMTczNjEsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg1MS4wMTc2NjgsLTg5LjcxMjg2MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSc1MS4wMTc2NjgnIHk9Jy04OS43MTI4NjMnPnw8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNTMuNzg1MDc3JyB5PSctODkuNzEyODYzJz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzY0LjUzNjQxOScgeT0nLTg5LjcxMjg2Myc+fDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTguMDQyNzA3LC02NS42NDMzNDkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE4LjA0MjcwNywtMzYuNTkyNTE0KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE0LjY3NDgyOCwtMzYuNTkyNTE0KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjAxNzY2OCwtMzYuNTkyNTE0KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNi4xODA1NywwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDUxLjAxNzY2OCwtMzYuNTkyNTE0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9JzUxLjAxNzY2OCcgeT0nLTM2LjU5MjUxNCc+fDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc1My43ODUwNzcnIHk9Jy0zNi41OTI1MTQnPkw8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nNjAuNTY1MjI0JyB5PSctMzYuNTkyNTE0Jz58PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00tMjcuNDM4ODcgMjYuNjU5NzdIMTkuNzYxMTEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTkuOTYxMDksMjYuNjU5NzcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuODI0NTcsMzAuMzczNjEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yNi44NDk5MzUsLTM2LjU5MjUxNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjYuODQ5OTM1JyB5PSctMzYuNTkyNTE0Jz7OtzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00tMjguMjExNzYgMjAuMzAwMDVMMjEuODM3MTMtMTguMjAwMTUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43OTI1NiwtMC42MDk2OCwwLjYwOTY4LDAuNzkyNTYsMjEuOTk1NjIsLTE4LjMyMjA3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMC4wNjU2NiwtNi4yODU4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTI2Ljg0OTkzNSwtMzYuNTkyNTE0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yNi44NDk5MzUnIHk9Jy0zNi41OTI1MTQnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNMzIuODQwMjMgMTcuODAwMDVWLTE3LjQwMDA5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMzIuODQwMjMsLTE3LjYwMDA3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1LjgwMzM5LC0yLjI1Mjc4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjYuODQ5OTM1LC0zNi41OTI1MTQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTI1LjIxNTM2NCcgeT0nLTM4LjQzMjgyNyc+wq88L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTI2Ljg0OTkzNScgeT0nLTM2LjU5MjUxNCc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+"></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
    \begin {tikzcd}
        X &amp;&amp; {|M|} \\
        \\
        &amp;&amp; {|L|}
        \arrow [&quot;\eta &quot;, from=1-1, to=1-3]
        \arrow [&quot;f&quot;&apos;, from=1-1, to=3-3]
        \arrow [&quot;{\bar {f}}&quot;&apos;, from=1-3, to=3-3]
    \end {tikzcd}
</fr:resource-source></fr:resource></fr:figure>
 
</fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>This can be understood as follows: the free T-model 
        generated by <fr:tex display="inline">X</fr:tex> is the most economical way of making a 
        T-model out of the set <fr:tex display="inline">X</fr:tex>. 
        (&quot;Free&quot; essentially means with as few assumptions as possible.)</fr:p>
                    <fr:p>For instance, the free group generated by the singleton set <fr:tex display="inline">\{a\}</fr:tex> is the 
        infinite cyclic group, which is isomorphic to <fr:tex display="inline">\mathbb {Z}</fr:tex>. If you have an element <fr:tex display="inline">a</fr:tex>,
        then you automatically have all its powers of <fr:tex display="inline">a</fr:tex> in the group.
        We can not make any further assumptions because we need to send this free group 
        to any other group that satisfies the group axioms, the powers of <fr:tex display="inline">a</fr:tex> are going 
        to be &quot;interpreted&quot;.</fr:p>
                    <fr:p>Every algebraic theory <fr:tex display="inline">T</fr:tex> has a free model.
        Given a signature <fr:tex display="inline">\Sigma </fr:tex> and a set <fr:tex display="inline">X</fr:tex>,
        define <fr:tex display="inline">\text {Tree}_\Sigma (X)</fr:tex> to be the set of well-founded 
        trees built inductively as follows:
        <fr:ul><fr:li><fr:tex display="inline">\forall  x \in  X</fr:tex>, there is a tree <fr:tex display="inline">\text {return}(x) \in  \text {Tree}_\Sigma (X)</fr:tex>
                (the choice of the label is immaterial in fact)</fr:li>
            <fr:li>For each operation symbol <fr:tex display="inline">\text {op}_i</fr:tex> and trees 
                <fr:tex display="inline">t_1, \cdots , t_{\text {ar}_i} \in  \text {Tree}_\Sigma (X)</fr:tex>,
                there is a tree, denoted by <fr:tex display="inline">\text {op}_i(t_1, \cdots , t_{\text {ar}_i}) \in  \text {Tree}_\Sigma (X)</fr:tex>,
                whose root is labeled by <fr:tex display="inline">\text {op}_i</fr:tex> and 
                whose children are subtrees <fr:tex display="inline">t_1, \cdots , t_{\text {ar}_i}</fr:tex>.</fr:li></fr:ul>
        In this setting, the <fr:tex display="inline">\Sigma \text {-terms}</fr:tex> in the context <fr:tex display="inline">x_1, \cdots , x_k</fr:tex> are
        the trees in <fr:tex display="inline">\text {Tree}_\Sigma (\{x_1, \cdots , x_k\})</fr:tex>.
        A variable <fr:tex display="inline">x_i</fr:tex> is labeled as <fr:tex display="inline">\text {return}(x_i)</fr:tex> when construed as a tree.
        Suppose <fr:tex display="inline">x_1, \cdots , x_n \mid  t</fr:tex> is a term in context and we are given 
        an assignment <fr:tex display="inline">\sigma  : \{x_1, \cdots , x_n\} \to  \text {Tree}_\Sigma (X)</fr:tex>.
        We can build the tree <fr:tex display="inline">\sigma (t)</fr:tex> inductively as follows:
        <fr:ul><fr:li><fr:tex display="inline">\sigma (t) = \sigma (x_i)</fr:tex> if <fr:tex display="inline">t = x_i</fr:tex></fr:li>
            <fr:li><fr:tex display="inline">\sigma (t) = \text {op}_i(\sigma (t_1), \cdots , \sigma (t_{\text {ar}_i}))</fr:tex> if <fr:tex display="inline">t = \text {op}_i(t_1, \cdots , t_{\text {ar}_i})</fr:tex></fr:li></fr:ul>
        Briefly, the tree <fr:tex display="inline">\sigma (t)</fr:tex> is obtained by replacing each 
        variable <fr:tex display="inline">x_i</fr:tex> in <fr:tex display="inline">t</fr:tex> with the corresponding tree <fr:tex display="inline">\sigma (x_i)</fr:tex>.</fr:p>
                    <fr:p>Let <fr:tex display="inline">\sim _T</fr:tex> be the least equivalence relation on <fr:tex display="inline">\text {Tree}_{\Sigma _T}(X)</fr:tex>
        such that:
        <fr:ul><fr:li>For every equation <fr:tex display="inline">x_1, \cdots , x_n \mid  l = r</fr:tex> in <fr:tex display="inline">E_T</fr:tex> and 
                for every assignment <fr:tex display="inline">\sigma </fr:tex> we have: <fr:tex display="inline">                     \sigma (l) \sim _T \sigma (r)                 </fr:tex></fr:li>
            <fr:li><fr:tex display="inline">\sim _T</fr:tex> is a congruence: for every operation symbol <fr:tex display="inline">\text {op}_i</fr:tex> 
                in <fr:tex display="inline">\sigma _T</fr:tex> and forall trees <fr:tex display="inline">s_1,\cdot ,s_{\text {ar}_i}</fr:tex>
                and <fr:tex display="inline">t_1, \cdots , t_{\text {ar}_i}</fr:tex> in <fr:tex display="inline">\text {Tree}_\Sigma (X)</fr:tex>, if
                <fr:tex display="block">                     s_1 \sim _T t_1 \quad  \cdots  \quad  s_{\text {ar}_i} \sim _T t_{\text {ar}_i}                 </fr:tex>
                then the following holds:
                <fr:tex display="block">                     \text {op}_i(s_1, \cdots , s_{\text {ar}_i}) \sim _T \text {op}_i(t_1, \cdots , t_{\text {ar}_i})                 </fr:tex></fr:li></fr:ul></fr:p>
                    <fr:p>Now we define the carrier the free model <fr:tex display="inline">F_T(X)</fr:tex> to be the quotient set 
        <fr:tex display="block">             |F_T(X)| = \text {Tree}_{\Sigma _T}(X)/\sim _T         </fr:tex>
        Let <fr:tex display="inline">\langle  t \rangle </fr:tex> be the <fr:tex display="inline">\sim _T</fr:tex> equivalence class of <fr:tex display="inline">t \in  \text {Tree}_{\Sigma _T}(X)</fr:tex>,
        the interpretation of the operation symbol <fr:tex display="inline">\text {op}_i</fr:tex> in the free model is defined by:
        <fr:tex display="block">             [\text {op}_i]_{F_T(X)}(\langle  t_1 \rangle , \cdots , \langle  t_{\text {ar}_i} \rangle ) = \langle  \text {op}_i(t_1, \cdots , t_{\text {ar}_i}) \rangle          </fr:tex>
        and the map <fr:tex display="inline">\eta _X : X \to  F_T(X)</fr:tex> is defined by
        <fr:tex display="block">             \eta _X(x) = \langle  \text {return}(x) \rangle          </fr:tex>
        Note that if theory <fr:tex display="inline">T</fr:tex> has no equations,
        the free models generated by <fr:tex display="inline">T</fr:tex> is the set of all trees in <fr:tex display="inline">\text {Tree}_{\Sigma _T}(X)</fr:tex>
        because the equivalence relation <fr:tex display="inline">\sim _T</fr:tex> is the identity relation <fr:tex display="inline">=</fr:tex>.</fr:p>
                    <fr:p>So far we have developed the algebraic theories,
        to get a better fit with computational effects,
        we need to generalize operations in two ways:
        arities and parameters.</fr:p>
                    <fr:p><fr:strong>Generalizing arities</fr:strong>:
        One might expect that the generalization of 
        arities is to allow them to be ordinal or cardinal
        numbers, hence they can fit the infinity.
        However, that would be a <fr:strong>non-computational</fr:strong> idea.
        Instead, we can generalize the arities to be functions.
        Notice that the n-ary cartesian product of <fr:tex display="inline">X</fr:tex> is isomorphic
        to the exponential <fr:tex display="inline">X^{[n]}</fr:tex>, where <fr:tex display="inline">[n] = \{1, \cdots , n\}</fr:tex>.
        Now we replace <fr:tex display="inline">[n]</fr:tex> with arbitrary set <fr:tex display="inline">A</fr:tex>,
        then we can think of a map <fr:tex display="inline">X^A \to  X</fr:tex> as arguments of arity <fr:tex display="inline">A</fr:tex>.
        We need a reasonable notation for writing down
        an operation symbol to <fr:tex display="inline">A\text {-many}</fr:tex> arguments,
        where <fr:tex display="inline">A</fr:tex> is an arbitrary set. 
        To achieve this, we introduce the map <fr:tex display="inline">\kappa :A\to  X</fr:tex>,
        and thus we simply write <fr:tex display="inline">\text {op}_i(\kappa )</fr:tex> for the operation symbol.</fr:p>
                    <fr:p><fr:strong>Generalizing parameters</fr:strong>:
        We can generalize operations to take parameters from a set <fr:tex display="inline">P</fr:tex>,
        this naturally models algebraic operations that 
        arise as computational effects.</fr:p>
                    <fr:p><fr:strong>Compose them together</fr:strong>:
        Now we can restate the definitions of signatures and  
        algebraic operations with the generalizations incorporated.
        <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>710</fr:anchor><fr:addr type="user">def-004T</fr:addr><fr:route>def-004T.xml</fr:route><fr:title text="Parameterized Operations and General Arities">Parameterized Operations and General Arities</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A signature <fr:tex display="inline">\Sigma </fr:tex> is given by a collection of operation 
    symbols <fr:tex display="inline">\text {op}_i</fr:tex> with associated parameters sets <fr:tex display="inline">P_i</fr:tex> and 
    arity <fr:tex display="inline">A_i</fr:tex>, denoted <fr:tex display="inline">\text {op}_i: P_i \rightsquigarrow  A_i</fr:tex>.</fr:p><fr:p>The terms in context are generalized to well-founded trees
    over <fr:tex display="inline">\Sigma </fr:tex> generated by a set <fr:tex display="inline">X</fr:tex>.
    These form a set <fr:tex display="inline">\text {Tree}_\Sigma (X)</fr:tex> whose elements
    are inductively generated:
    <fr:ul><fr:li>for every <fr:tex display="inline">x \in  X</fr:tex>, there is a tree <fr:tex display="inline">\text {return}(x) \in  \text {Tree}_\Sigma (X)</fr:tex></fr:li>
        <fr:li>If <fr:tex display="inline">p \in  P_i</fr:tex> and <fr:tex display="inline">\kappa  : A_i \to  \text {Tree}_\Sigma (X)</fr:tex>,
            then there is a tree <fr:tex display="inline">\text {op}_i(p, \kappa ) \in  \text {Tree}_\Sigma (X)</fr:tex>,
            whose root is labeled by <fr:tex display="inline">\text {op}_i</fr:tex> and subtrees are
            given by the trees in the image of <fr:tex display="inline">\kappa </fr:tex>.</fr:li></fr:ul>
    The elements of <fr:tex display="inline">\text {Tree}_\Sigma (X)</fr:tex> may be thought of 
    as <fr:tex display="inline">\Sigma \text {-terms}</fr:tex> with variables <fr:tex display="inline">X</fr:tex>.</fr:p><fr:p>An interpretation <fr:tex display="inline">I</fr:tex> of a signature <fr:tex display="inline">\Sigma </fr:tex> is given by
    (here we assume that the category is a category of sets,
    the more general cases are omitted for brevity):
    <fr:ul><fr:li>A set <fr:tex display="inline">|I|</fr:tex> called the <fr:strong>carrier</fr:strong> of the interpretation</fr:li>
        <fr:li>For each operation symbol <fr:tex display="inline">\text {op}_i: P_i \rightsquigarrow  A_i</fr:tex>, a map
            <fr:tex display="block">                 [\text {op}_i]_I : P_i \times  |I|^{A_i} \to  |I|             </fr:tex></fr:li></fr:ul>
    The interpretation can be extended to terms (trees).
    A tree <fr:tex display="inline">t \in  \text {Tree}_\Sigma (X)</fr:tex> is interpreted as a map 
    <fr:tex display="inline">         [t]_I : |I| ^ X \to  |I|      </fr:tex>
    as follows:
    <fr:ul><fr:li>The tree <fr:tex display="inline">\text {return}(x)</fr:tex> is interpreted as the projection map:
            <fr:tex display="block">                 [\text {return}(x)]_I : \eta  \mapsto  \eta (x)             </fr:tex></fr:li>
        <fr:li>A compound tree is interpreted as the composition of the 
            semantic brackets of the operation symbols and the subtrees:
            <fr:tex display="block">                 [\text {op}_i(p, \kappa )]_I : \eta  \to  [\text {op}_i]_I(p, \lambda  a. [\kappa (a)]_I(\eta ))             </fr:tex></fr:li></fr:ul></fr:p><fr:p>A <fr:tex display="inline">\Sigma \text {-equation}</fr:tex> is a set <fr:tex display="inline">X</fr:tex> and 
    a pair of trees <fr:tex display="inline">l, r \in  \text {Tree}_\Sigma (X)</fr:tex>:
    <fr:tex display="block">         X\mid  l = r      </fr:tex>
    Given an interpretation <fr:tex display="inline">I</fr:tex> of signature <fr:tex display="inline">\Sigma </fr:tex>,
    we say that such an equation is <fr:strong>valid</fr:strong> 
    for <fr:tex display="inline">I</fr:tex> if <fr:tex display="inline">l</fr:tex> and <fr:tex display="inline">r</fr:tex> are interpreted as the same map.
    The algebraic theory, models and categories are generalized
    similarly, we do not repeat here.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>711</fr:anchor>
                <fr:addr type="user">math-0007</fr:addr>
                <fr:route>math-0007.xml</fr:route>
                <fr:title text="Vector Calculus and Geometry of Space">Vector Calculus and Geometry of Space</fr:title>
                <fr:taxon>Differential Geometry</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>5</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Notes about multi-variable calculus, geometry of space and linear algebra.
    Refer to <fr:link type="external" href="A%20Visual%20Introduction%20to%20Differential%20Forms%20and%20Calculus%20on%20Manifolds">df-cm-2018</fr:link>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>712</fr:anchor>
                    <fr:addr type="machine">#310</fr:addr>
                    <fr:route>unstable-310.xml</fr:route>
                    <fr:title text="Review of Vector Spaces">Review of Vector Spaces</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>4</fr:month>
                      <fr:day>5</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>We now start with introducing the vector space over the field of real numbers <fr:tex display="inline">\mathbb {R}</fr:tex>.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>713</fr:anchor>
                        <fr:addr type="user">def-000H</fr:addr>
                        <fr:route>def-000H.xml</fr:route>
                        <fr:title text="Vector Space">Vector Space</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>A vector space over a <fr:link type="local" href="def-0006.xml" addr="def-0006" title="Field">field</fr:link> <fr:tex display="inline">F</fr:tex> is a non-empty set <fr:tex display="inline">V</fr:tex> together with a binary operation and a binary function that satisfy the axioms listed below. 
    In this context, the elements of <fr:tex display="inline">V</fr:tex> are commonly called <fr:strong>vectors</fr:strong>, and the elements of <fr:tex display="inline">F</fr:tex> are called <fr:strong>scalars</fr:strong>.
    <fr:ul><fr:li>Commutativity: <fr:tex display="inline">             \forall  x, y \in  V, x + y = y + x         </fr:tex></fr:li>
        <fr:li>Associativity: <fr:tex display="inline">             \forall  x, y, z \in  V, (x + y) + z = x + (y + z)         </fr:tex></fr:li>
        <fr:li>Additive Identity: <fr:tex display="inline">             \exists  0 \in  V \text { such that } \forall  x \in  V, x + 0 = x         </fr:tex></fr:li>
        <fr:li>Multiplicative Identity: <fr:tex display="inline">             \forall  x \in  V, 1x = x         </fr:tex></fr:li>
        <fr:li>Additive Inverse: <fr:tex display="inline">             \forall  x \in  V, \exists  y \in  V \text { such that } x + y = 0         </fr:tex></fr:li>
        <fr:li>Distributivity: <fr:tex display="inline">             \forall  x, y \in  V, \forall  c, d \in  F, c(x + y) = cx + cy, (c + d)x = cx + dx         </fr:tex></fr:li></fr:ul></fr:p>
                        <fr:p>Elements of a vector space are called <fr:strong>vectors</fr:strong> or <fr:strong>points</fr:strong>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>Use <fr:tex display="inline">\mathbb {R}^2</fr:tex> as an example we can see (Note that we always treat elements of vector spaces as 
        column vectors and never as row vectors):
        <fr:tex display="block">             c \cdot  \begin {bmatrix}                 a \\ b             \end {bmatrix} = \begin {bmatrix}                 c \cdot  a \\ c \cdot  b             \end {bmatrix}         </fr:tex></fr:p>
                    <fr:p>Now we will consider a certain type of transformation between vector spaces called a <fr:link type="local" href="def-0025.xml" addr="def-0025" title="Linear Map"><fr:strong>linear transformation</fr:strong></fr:link>.
        Suppose <fr:tex display="inline">T</fr:tex> is a mapping between <fr:tex display="inline">\mathbb {R}^n</fr:tex> and <fr:tex display="inline">\mathbb {R}^m</fr:tex>, that is <fr:tex display="inline">T:\mathbb {R}^n\to \mathbb {R}^m</fr:tex>, then <fr:tex display="inline">T</fr:tex> is a linear transformation if:
        <fr:tex display="block">             T(c \cdot  \vec {v}) = c \cdot  T(\vec {v})             \\              T(\vec {v} + \vec {w}) = T(\vec {v}) + T(\vec {w})         </fr:tex>
        If <fr:tex display="inline">T</fr:tex> is a linear transformation from <fr:tex display="inline">\mathbb {R}^m</fr:tex> to <fr:tex display="inline">\mathbb {R}</fr:tex> we simply call it a <fr:strong>linear function</fr:strong> or a <fr:strong>linear functional</fr:strong>.</fr:p>
                    <fr:p>We now turn our attention to the relationship between linear transformation and matrices. 
        We just stick to vector spaces <fr:tex display="inline">\mathbb {R}^n</fr:tex> and the standard basis made up of the <fr:strong>Euclidian unit vectors</fr:strong>.
        In order to write linear transformation <fr:tex display="inline">T:\mathbb {R}^n\to \mathbb {R}^m</fr:tex> as a matrix we need ordered bases for both <fr:tex display="inline">\mathbb {R}^n</fr:tex> and <fr:tex display="inline">\mathbb {R}^m</fr:tex>.
        We can use the intuitively obvious order <fr:tex display="inline">e_1 &lt; e_2 &lt; \cdots  &lt; e_n</fr:tex>.
        Now we can give formal definition of the matrix representation of a linear transformation.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>714</fr:anchor>
                        <fr:addr type="user">def-003W</fr:addr>
                        <fr:route>def-003W.xml</fr:route>
                        <fr:title text="Matrix Representation of Linear Transformation over {R}^n">Matrix Representation of Linear Transformation over <fr:tex display="inline">\mathbb {R}^n</fr:tex></fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Suppose that <fr:tex display="inline">T:\mathbb {R}^n\to \mathbb {R}^m</fr:tex> is a linear transformation between vector spaces <fr:tex display="inline">\mathbb {R}^n</fr:tex> and <fr:tex display="inline">\mathbb {R}^m</fr:tex>.
    Let <fr:tex display="inline">e_1, e_2, \ldots , e_n</fr:tex> be the standard basis of <fr:tex display="inline">\mathbb {R}^n</fr:tex> and <fr:tex display="inline">f_1, f_2, \ldots , f_m</fr:tex> be the standard basis of <fr:tex display="inline">\mathbb {R}^m</fr:tex>.
    Then the matrix representation of <fr:tex display="inline">T</fr:tex> is the <fr:tex display="inline">m \times  n</fr:tex> matrix <fr:tex display="inline">A</fr:tex> such that for <fr:tex display="inline">1\leq  j\leq  n</fr:tex>:
    <fr:tex display="block">         T(e_j) = \sum _{i=1}^m A_{ij} f_i     </fr:tex>
    where the matrix representation of <fr:tex display="inline">T</fr:tex> is given by the <fr:tex display="inline">m\times  n</fr:tex> matrix with entries <fr:tex display="inline">A_{ij}</fr:tex>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>The last major topic in this section is the definition of the <fr:link type="local" href="def-003X.xml" addr="def-003X" title="Dual Space">dual space</fr:link>.
        In our discussion, we only concern the dual space of <fr:tex display="inline">\mathbb {R}^n</fr:tex> which is denoted as <fr:tex display="inline">(\mathbb {R}^n)^*</fr:tex>.
        Now let&apos;s consider the <fr:strong>dual basis</fr:strong> of <fr:tex display="inline">(\mathbb {R}^n)^*</fr:tex> which is denoted as <fr:tex display="inline">\{T_1, \cdots , T_n\}</fr:tex>, 
        which is defined by:
        <fr:tex display="block">             T_i(e_j) = e^i(e_j) = \langle  e^i, e_j \rangle  = \delta _{j}^i         </fr:tex>
        where <fr:tex display="inline">\delta _{ij}</fr:tex> is the <fr:link type="local" href="def-001P.xml" addr="def-001P" title="Kronecker Delta">Kronecker delta</fr:link>. We say that <fr:tex display="inline">T_i</fr:tex> is dual to the vector <fr:tex display="inline">e_i</fr:tex>.
        Note that we also denote <fr:tex display="inline">T_i</fr:tex> as <fr:tex display="inline">e^i</fr:tex> using superscript notation. And the notation <fr:tex display="inline">\langle  e^i, e_j \rangle </fr:tex> d
        indicates the products of row vector <fr:tex display="inline">e^i</fr:tex> and column vector <fr:tex display="inline">e_j</fr:tex> (Usually used in quantum computing).
        <fr:tex display="block">             \alpha (v) = \langle  \alpha , v \rangle  = [a,b] \times  \begin {bmatrix}                 x \\ y             \end {bmatrix} = ax + by         </fr:tex>
        This explains wht we always denote elements of the vector space as column vectors, because elements of the dual space 
        are written as row vectors and its very important to distinguish between them.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>715</fr:anchor>
                    <fr:addr type="machine">#311</fr:addr>
                    <fr:route>unstable-311.xml</fr:route>
                    <fr:title text="Dot Products">Dot Products</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>4</fr:month>
                      <fr:day>5</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>In linear algebra, <fr:strong>dot product</fr:strong> or <fr:strong>scalar product</fr:strong> is an operation that takes two vectors and returns a scalar.
        Geometrically, it is the product of the Euclidean magnitudes of the two vectors and the cosine of the angle between them.
        Dot product is also used to define lengths and angles.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>716</fr:anchor>
                        <fr:addr type="user">def-0041</fr:addr>
                        <fr:route>def-0041.xml</fr:route>
                        <fr:title text="Dot Product (Coordinate Form)">Dot Product (Coordinate Form)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>The <fr:strong>dot product</fr:strong> of two vectors <fr:tex display="inline">\vec {a} = (a_1, a_2, \cdots , a_n)</fr:tex> and <fr:tex display="inline">\vec {b} = (b_1, b_2, \cdots , b_n)</fr:tex> is defined as
    <fr:tex display="block">         \vec {a}\cdot \vec {b} = a_1b_1 + a_2b_2 + \cdots  + a_nb_n = \sum _{i=1}^n a_ib_i.     </fr:tex>
    The dot product is also called the <fr:strong>inner product</fr:strong> or <fr:strong>scalar product</fr:strong>.
    The dot product satisfies the following properties:
    <fr:ul><fr:li><fr:strong>Commutative</fr:strong>: <fr:tex display="inline">\vec {a}\cdot \vec {b} = \vec {b}\cdot \vec {a}</fr:tex></fr:li>
        <fr:li><fr:strong>Distributive</fr:strong>: <fr:tex display="inline">\vec {a}\cdot (\vec {b} + \vec {c}) = \vec {a}\cdot \vec {b} + \vec {a}\cdot \vec {c}</fr:tex></fr:li>
        <fr:li><fr:strong>Bilinear</fr:strong>: <fr:tex display="inline">\vec {a}\cdot (k\vec {b}) = k(\vec {a}\cdot \vec {b}) = (\vec {a}\cdot  k\vec {b})</fr:tex></fr:li>
        <fr:li><fr:strong>Scalar Multiplication</fr:strong>: <fr:tex display="inline">(c_1\vec {a}) \cdot  (c_2\vec {b}) = c_1c_2(\vec {a}\cdot \vec {b})</fr:tex></fr:li>
        <fr:li><fr:strong>Orthogonality</fr:strong>: If <fr:tex display="inline">\vec {a}\cdot \vec {b} = 0</fr:tex>, then <fr:tex display="inline">\vec {a}</fr:tex> and <fr:tex display="inline">\vec {b}</fr:tex> are <fr:strong>orthogonal</fr:strong></fr:li>
        <fr:li><fr:strong>Product Rule</fr:strong>: If <fr:tex display="inline">\vec {a}</fr:tex> and <fr:tex display="inline">\vec {b}</fr:tex> are vector valued differentiable functions then the derivative 
            of <fr:tex display="inline">\vec {a}\cdot \vec {b}</fr:tex> is given by the rule <fr:tex display="inline">(\vec {a}\cdot \vec {b})&apos; = \vec {a}&apos;\cdot \vec {b} + \vec {a}\cdot \vec {b}&apos;</fr:tex></fr:li></fr:ul></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>717</fr:anchor>
                        <fr:addr type="user">def-0042</fr:addr>
                        <fr:route>def-0042.xml</fr:route>
                        <fr:title text="Dot Product (Geometric Form)">Dot Product (Geometric Form)</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>In <fr:strong>Euclidean space</fr:strong>, a <fr:strong>Euclidean vector</fr:strong> is a geometric object that possesses both 
    a norm and a direction. The <fr:strong>dot product</fr:strong> of two vectors <fr:tex display="inline">\vec {a}</fr:tex> and <fr:tex display="inline">\vec {b}</fr:tex> is defined as
    <fr:tex display="block">         \vec {a}\cdot \vec {b} = \lVert \vec {a}\rVert \lVert \vec {b}\rVert \cos \theta      </fr:tex>
    where <fr:tex display="inline">\theta </fr:tex> is the angle between the two vectors.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>The geometric definition of dot product helps us express the projection of one vector onto another as well as the component of 
        one vector in the direction of another. By simple geometry we can derive the formula for the <fr:strong>projection</fr:strong>
        <fr:tex display="block">             \text {proj}_{\vec {a}}\vec {b} = \frac {\vec {a}\cdot \vec {b}}{\lVert \vec {a}\rVert }\frac {\vec {a}}{\lVert \vec {a}\rVert }         </fr:tex>
        and the <fr:strong>component</fr:strong> of <fr:tex display="inline">\vec {b}</fr:tex> in the direction <fr:tex display="inline">\vec {a}</fr:tex> is given by
        <fr:tex display="block">             \text {comp}_{\vec {a}}\vec {b} = \lVert \text {proj}_{\vec {a}}\vec {b}\rVert  = \frac {\vec {a}\cdot \vec {b}}{\lVert \vec {a}\rVert }         </fr:tex></fr:p>
                    <fr:p>Two points determine a line, and so does a point and a vector. Define the base point vector <fr:tex display="inline">\vec {b}=(x,y,z)</fr:tex> and
        the direction vector <fr:tex display="inline">\vec {v}=(a,b,c)</fr:tex> then the line is given by <fr:tex display="inline">\vec {r}(t)</fr:tex>
        <fr:tex display="block">             \vec {r}(t) = t\vec {v} + \vec {b} = (at+x, bt+y, ct+z)         </fr:tex>
        Solving for <fr:tex display="inline">t</fr:tex> in the equation we get
        <fr:tex display="block">             t = \frac {x-at}{a} = \frac {y-bt}{b} = \frac {z-ct}{c}         </fr:tex>
        which is the <fr:strong>equation of line</fr:strong>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>718</fr:anchor>
                    <fr:addr type="machine">#312</fr:addr>
                    <fr:route>unstable-312.xml</fr:route>
                    <fr:title text="Volume and Determinants">Volume and Determinants</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>4</fr:month>
                      <fr:day>5</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The <fr:strong>determinant</fr:strong> has various properties and applications in linear algebra and geometry.
        For us the most useful thing about it will be how it relates to volume:
        the determinant of a matrix gives the <fr:strong>signed volume</fr:strong> of the parallelepiped that 
        is generated by the vectors given by the matrix columns.</fr:p>
                    <fr:p>Determinants can be introduced in a variety of different ways but many of them are not at all clear.
        It usually relates to volume hence we will actually use our intuitive understanding of volumes and 
        three properties that we expected volume to have to derive the determinant (It is <fr:strong>uniquely</fr:strong> determined!).</fr:p>
                    <fr:p>So how do we expect volume to behave?
        First we expect a unit cube to have a volume of one.
        Second we expect the <fr:strong>degenerate</fr:strong> parallelepiped to have a volume of zero. Basically in <fr:tex display="inline">n</fr:tex> dimensions any 
        <fr:tex display="inline">n-1</fr:tex> dimensions object has zero <fr:tex display="inline">n</fr:tex>-D volume.
        Third we expect that volumes to be <fr:strong>linear</fr:strong>.
        Now with these three properties we move to the actual mathematics.</fr:p>
                    <fr:p>Suppose we have a parallelepiped <fr:tex display="inline">\mathscr {P}\in \mathbb {R}^n</fr:tex> whose edges are given by <fr:tex display="inline">v_1, v_2, \cdots , v_n\in \mathbb {R}^n</fr:tex>.
        We sat that the parallelepiped <fr:tex display="inline">\mathscr {P}</fr:tex> is the <fr:strong>span</fr:strong> of the vectors <fr:tex display="inline">v_1, v_2, \cdots , v_n</fr:tex> and 
        write <fr:tex display="inline">\mathscr {P}=\text {span}\{v_1, v_2, \cdots , v_n\}</fr:tex> (Note that this span is different from linear span).
        We want to find function <fr:tex display="inline">D:\mathbb {R}^{n\times  n}\to \mathbb {R}</fr:tex> which takes <fr:tex display="inline">v_1, v_2, \cdots , v_n</fr:tex> or a matrix with <fr:tex display="inline">v_1, v_2, \cdots , v_n</fr:tex> as columns
        to a real number which is the volume of <fr:tex display="inline">\mathscr {P}</fr:tex>. Now we present the three properties in mathematical form.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>719</fr:anchor>
                        <fr:addr type="machine">#313</fr:addr>
                        <fr:route>unstable-313.xml</fr:route>
                        <fr:title text="Properties of Volume">Properties of Volume</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>4</fr:month>
                          <fr:day>5</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:ul><fr:li><fr:tex display="inline"> D(I) = I </fr:tex> where <fr:tex display="inline">I = [e_1, e_2, \cdots , e_n]</fr:tex> is the identity matrix.</fr:li>
            <fr:li><fr:tex display="inline"> D(v_1, v_2, \cdots , v_n) = 0 </fr:tex> if <fr:tex display="inline">v_i = v_j</fr:tex> for any <fr:tex display="inline">i\neq  j</fr:tex>.</fr:li>
            <fr:li><fr:tex display="inline"> D(v_1, \cdots , v_{j-1}, v+cw, v_{j+1}, \cdots , v_n) \\                  = D(v_1, \cdots , v_{j-1}, v, v_{j+1}, \cdots , v_n) + cD(v_1, \cdots , v_{j-1}, w, v_{j+1}, \cdots , v_n) </fr:tex>
                for any <fr:tex display="inline">1 \leq  j \leq  n</fr:tex>, that is, <fr:tex display="inline">D</fr:tex> is linear.</fr:li></fr:ul>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>Now we use these properties of volume to derive several other useful properties.
        The first property is that the volumes are signed.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>720</fr:anchor>
                        <fr:addr type="machine">#314</fr:addr>
                        <fr:route>unstable-314.xml</fr:route>
                        <fr:title text="Derived Properties of Volume Function">Derived Properties of Volume Function</fr:title>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>4</fr:month>
                          <fr:day>5</fr:day>
                        </fr:date>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:ul><fr:li><fr:tex display="inline">D</fr:tex> is alternating, if we switch any two vectors the sign changes.
                <fr:tex display="block">                     D(v_1, \cdots , v_i, \cdots , v_j, \cdots , v_n) = -D(v_1, \cdots , v_j, \cdots , v_i, \cdots , v_n)                 </fr:tex></fr:li> 
            <fr:li>If <fr:tex display="inline">v_1, v_2, \cdots , v_n</fr:tex> are <fr:link type="local" href="def-000Q.xml" addr="def-000Q" title="Linearly dependent">linear dependent</fr:link> then
                <fr:tex display="block">                     D(v_1, v_2, \cdots , v_n) = 0                 </fr:tex></fr:li>
            <fr:li>Adding a multiple of one vector to another does not change the determinant.</fr:li></fr:ul>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>We almost ready to derive the formula for determinant. The final ingredient we need to do is <fr:strong>permutations</fr:strong>.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>721</fr:anchor>
                        <fr:addr type="user">def-003Y</fr:addr>
                        <fr:route>def-003Y.xml</fr:route>
                        <fr:title text="Permutation">Permutation</fr:title>
                        <fr:taxon>Defintion</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>A <fr:strong>permutation</fr:strong> of a set <fr:tex display="inline">S</fr:tex> is a bijection from <fr:tex display="inline">S</fr:tex> to itself.
    The set of permutation of <fr:tex display="inline">\{1,\cdots , n\}</fr:tex> is usually denoted by <fr:tex display="inline">S_n</fr:tex>.
    We often denote a particular permutation <fr:tex display="inline">\sigma </fr:tex> by <fr:strong>Cauchy&apos;s two-line notation</fr:strong>:
    <fr:tex display="block">         \begin {bmatrix}             1 &amp; 2 &amp; \cdots  &amp; n \\             \sigma (1) &amp; \sigma (2) &amp; \cdots  &amp; \sigma (n)         \end {bmatrix}     </fr:tex>
    or <fr:strong>Cauchy&apos;s one-line notation</fr:strong>: <fr:tex display="inline">(\sigma (1),\sigma (2),\cdots ,\sigma (n))</fr:tex>.
    Another common notation is the <fr:strong>cycle notation</fr:strong>:
    <fr:tex display="block">         (i_1\ i_2\ \cdots \ i_k)     </fr:tex> which means <fr:tex display="inline">i_1 \to  i_2 \to  \cdots  \to  i_k \to  i_1</fr:tex>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>722</fr:anchor>
                        <fr:addr type="user">def-003Z</fr:addr>
                        <fr:route>def-003Z.xml</fr:route>
                        <fr:title text="Transposition">Transposition</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>A <fr:link type="local" href="def-003Y.xml" addr="def-003Y" title="Permutation">permutation</fr:link> in which only two elements are exchanged is called a <fr:strong>transposition</fr:strong>.
    The notation is <fr:tex display="inline">\tau _{i,j}</fr:tex> where <fr:tex display="inline">i</fr:tex> and <fr:tex display="inline">j</fr:tex> are the two elements exchanged while the others remain fixed.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>Notice that the composition of two permutations is also a permutation. 
        And for any permutation <fr:tex display="inline">\sigma </fr:tex> we can perform a series of transpositions to get the identity permutation.
        It turns out that the count of the number of transpositions needed to get the identity permutation is always the same,
        which is called the <fr:strong>parity</fr:strong> of the permutation.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>723</fr:anchor>
                        <fr:addr type="user">def-0040</fr:addr>
                        <fr:route>def-0040.xml</fr:route>
                        <fr:title text="Sign of Permutation">Sign of Permutation</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>The <fr:strong>sign</fr:strong> of a <fr:link type="local" href="def-003Y.xml" addr="def-003Y" title="Permutation">permutation</fr:link> <fr:tex display="inline">\sigma \in  S_n</fr:tex> is a function <fr:tex display="inline">\text {sgn}:S_n\to \{-1,1\}</fr:tex> defined as
    <fr:tex display="inline">\text {sgn}(\sigma ) = 1</fr:tex> if <fr:tex display="inline">\sigma </fr:tex> requires an even number of permutations and 
    <fr:tex display="inline">\text {sgn}(\sigma ) = -1</fr:tex> if <fr:tex display="inline">\sigma </fr:tex> requires an odd number of permutations to get the identity permutation.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>Now we define the permutation of unit vectors <fr:tex display="inline">E_\sigma  = [e_{\sigma (1)}, e_{\sigma (2)}, \cdots , e_{\sigma (n)}]</fr:tex>.
        We got the property that
        <fr:tex display="block">             D(E_\sigma ) = \text {sgn}(\sigma )D(I) = \text {sgn}(\sigma )         </fr:tex>
        Now we have all the pieces necessary to find a formula that will give the volume of the parallelepiped spanned
        by <fr:tex display="inline">n</fr:tex> vectors.
        <fr:tex display="block">             \begin {align*}                 D\left (\begin {bmatrix}                     a_{11} &amp; a_{12} &amp; \cdots  &amp; a_{1n} \\                     a_{21} &amp; a_{22} &amp; \cdots  &amp; a_{2n} \\                     \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                     a_{n1} &amp; a_{n2} &amp; \cdots  &amp; a_{nn}                 \end {bmatrix}\right ) &amp;= \sum _{i_1=1}^n a_{i_11}D\left (\begin {bmatrix}                     | &amp; a_{12} &amp; \cdots  &amp; a_{1n} \\                     e_{i_1} &amp; a_{22} &amp; \cdots  &amp; a_{2n} \\                     | &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                     | &amp; a_{n2} &amp; \cdots  &amp; a_{nn}                 \end {bmatrix}\right ) \\                  &amp;= \sum _{i_1=1}^n a_{i_11} \sum _{i_2=1}^n a_{i_22}D\left (\begin {bmatrix}                     | &amp; | &amp; \cdots  &amp; a_{1n} \\                     e_{i_1} &amp; e_{i_2} &amp; \cdots  &amp; a_{2n} \\                     | &amp; | &amp; \vdots  &amp; \vdots  \\                     | &amp; | &amp; \cdots  &amp; a_{nn}                 \end {bmatrix}\right ) \\                 &amp;= \vdots  \\                  &amp;= \sum _{i_1, i_2, \cdots , i_n = 1}^{n} a_{i_11}a_{i_22}\cdots  a_{i_nn}D\left (                     \begin {bmatrix}                         | &amp; | &amp;  &amp; | \\                         e_{i_1} &amp; e_{i_2} &amp; \cdots  &amp; e_{i_n} \\                         | &amp; | &amp;  &amp; | \\                     \end {bmatrix}                 \right ) \\                  &amp;= \sum _{\sigma \in  S_n} a_{\sigma (1)1}\cdots  a_{\sigma (n)n}                 D\left (                     \begin {bmatrix}                         | &amp; | &amp;  &amp; | \\                         e_{\sigma (1)} &amp; e_{\sigma (2)} &amp; \cdots  &amp; e_{\sigma (n)} \\                         | &amp; | &amp;  &amp; | \\                     \end {bmatrix}                 \right ) \\                  &amp;= \sum _{\sigma \in  S_n} a_{\sigma (1)1}a_{\sigma (2)2}\cdots  a_{\sigma (n)n} \text {sgn}(\sigma ) \\                  &amp;= \sum _{\sigma \in  S_n} \text {sgn}(\sigma ) \prod _{i=1}^n a_{\sigma (i)i}             \end {align*}         </fr:tex>
        In the forth step we transform the terms because the value of <fr:tex display="inline">D</fr:tex> is zero for any <fr:tex display="inline">{i_j} = {i_k}</fr:tex>,
        non-zero terms should be permutation of <fr:tex display="inline">S_n</fr:tex>.</fr:p>
                    <fr:p>It&apos;s easy to validate that the following properties of the determinant holds:
        <fr:ul><fr:li><fr:tex display="inline">D(AB) = D(A)D(B)</fr:tex></fr:li>
            <fr:li><fr:tex display="inline">D(A) = D(A^T)</fr:tex></fr:li></fr:ul>
        The second statement for transpose of <fr:tex display="inline">A</fr:tex> indicates that all the properties above also holds for row as well.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>724</fr:anchor>
                    <fr:addr type="machine">#315</fr:addr>
                    <fr:route>unstable-315.xml</fr:route>
                    <fr:title text="Derivatives of Multivariable Functions">Derivatives of Multivariable Functions</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>4</fr:month>
                      <fr:day>5</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>In this section we will introduce the idea of the derivative of a multivariable function. 
        Recall that a function <fr:tex display="inline">f:\mathbb {R}\to \mathbb {R}</fr:tex> the derivative of <fr:tex display="inline">f</fr:tex> at <fr:tex display="inline">x_0\in \mathbb {R}</fr:tex> is given by
        <fr:tex display="block">             f&apos;(x_0) = \lim _{h\to  0} \frac {f(x_0+h) - f(x_0)}{h}         </fr:tex>
        if the limit exists. Now let&apos;s do some transformations:
        <fr:tex display="block">             \begin {align*}                 &amp; f&apos;(x_0) = \lim _{h\to  0} \frac {f(x_0+h) - f(x_0)}{h} \\                 \implies  &amp; \lim _{h\to  0} \frac {f(x_0+h) - f(x_0) -f&apos;(x_0)h }{h} = 0 \\                 \implies  &amp; \lim _{x\to  x_0} \frac {f(x) - f(x_0) - f&apos;(x_0)(x-x_0)}{x-x_0} = 0 \\                  \implies  &amp; \lim _{x\to  x_0} \frac {|f(x) - f(x_0) - f&apos;(x_0)(x-x_0)|}{|x-x_0|} = 0             \end {align*}         </fr:tex></fr:p>
                    <fr:p>Since <fr:tex display="inline">f&apos;(x_0)</fr:tex> represents the slope of the line tangent to the graph of <fr:tex display="inline">f</fr:tex> at <fr:tex display="inline">(x_0, f(x_0))</fr:tex>,
        differentiability of <fr:tex display="inline">f</fr:tex> at <fr:tex display="inline">x_0</fr:tex> means that there exists a number <fr:tex display="inline">m</fr:tex> st
        <fr:tex display="block">             \lim _{x\to  x_0} \frac {|f(x) - f(x_0) - m(x-x_0)|}{|x-x_0|} = 0         </fr:tex>
        Now consider the function <fr:tex display="inline">T:\mathbb {R}\to \mathbb {R}</fr:tex> where <fr:tex display="inline">T(s) = ms</fr:tex>
        <fr:tex display="block">             T(s+t) = m(s+t) = ms + mt = T(s) + T(t)             \\              T(cs) = mcs = c(ms) = cT(s)         </fr:tex>
        then <fr:tex display="inline">T</fr:tex> is a linear transformation. In fact <fr:tex display="inline">T</fr:tex> is the linear function that most closely approximates the 
        function <fr:tex display="inline">f</fr:tex> at the point <fr:tex display="inline">(x_0, f(x_0))</fr:tex>. So for <fr:tex display="inline">x</fr:tex> values that are very close to <fr:tex display="inline">x_0</fr:tex> we have
        <fr:tex display="block">             f(x) \approx  m(x-x_0) + f(x_0)         </fr:tex></fr:p>
                    <fr:p>Now let&apos;s generalize the concept of derivatives to functions of the form <fr:tex display="inline">f:\mathbb {R}^n\to \mathbb {R}^m</fr:tex>.
        We assume the function <fr:tex display="inline">f</fr:tex> has the form
        <fr:tex display="block">             \begin {align*}                 &amp;f(x_1, x_2, \cdots , x_n) =                  \\                  &amp;(f_1(x_1, x_2, \cdots , x_n), f_2(x_1, x_2, \cdots , x_n), \cdots , f_m(x_1, x_2, \cdots , x_n))             \end {align*}         </fr:tex>
        We want to search for this linear transformation which we will denoted by <fr:tex display="inline">Df</fr:tex>,
        that most closely approximates this function <fr:tex display="inline">f:\mathbb {R}^n\to \mathbb {R}^m</fr:tex> at some specific point <fr:tex display="inline">x_0=(x_{1_0}, x_{2_0}, \cdots , x_{n_0}) \in  \mathbb {R}^n</fr:tex>.
        If <fr:tex display="inline">f</fr:tex> is differentiable at <fr:tex display="inline">x_0</fr:tex> then there exists a linear transformation <fr:tex display="inline">Df(x_0):\mathbb {R}^n\to \mathbb {R}^m</fr:tex> such that
        <fr:tex display="block">             \lim _{x\to  x_0} \frac {                 \lVert                      f(x) - f(x_0) - Df(x_0)(x-x_0)                 \rVert              }{\lVert x-x_0\rVert } = 0         </fr:tex>
        The <fr:tex display="inline">\lVert \cdot \rVert </fr:tex> represents the <fr:strong>Euclidean norm</fr:strong> of the vector (Multi-dimensional version of the absolute value)
        <fr:tex display="block">             \lVert \vec {x}\rVert  = \sqrt {x_1^2 + x_2^2 + \cdots  + x_n^2} = \sqrt {\sum _{i=1}^n x_i^2}         </fr:tex>
        which is just the length of the vector. This allows us to perform dividing.</fr:p>
                    <fr:p>As before we have
        <fr:tex display="block">             f(x) \approx  Df(x_0)(x-x_0) + f(x_0)         </fr:tex>
        Now we want to write <fr:tex display="inline">Df(x)</fr:tex> as a matrix. Denote the basis of <fr:tex display="inline">\mathbb {R}^n</fr:tex> as <fr:tex display="inline">e_j</fr:tex> and the basis of <fr:tex display="inline">\mathbb {R}^m</fr:tex> as <fr:tex display="inline">f_i</fr:tex>.
        Then we want to find <fr:tex display="inline">a_{ij}</fr:tex> st
        <fr:tex display="block">             Df(x)(e_j) = \sum _{i=1}^{m} a_{ij} f_j = \begin {bmatrix}                 a_{1j} \\ a_{2j} \\ \vdots  \\ a_{mj}             \end {bmatrix}         </fr:tex>
        In other words, the <fr:tex display="inline">i</fr:tex>-th component of the <fr:tex display="inline">j</fr:tex>-th column of <fr:tex display="inline">Df(x)</fr:tex> is just the <fr:tex display="inline">i</fr:tex>-th component of the <fr:tex display="inline">Df(x)(e_j)</fr:tex></fr:p>
                    <fr:p>Recall from vector calculus that given a function <fr:tex display="inline">f:\mathbb {R}^n\to \mathbb {R}</fr:tex> we defined the <fr:strong>partial derivative</fr:strong> of <fr:tex display="inline">f</fr:tex> with respect to the <fr:tex display="inline">x_j</fr:tex> as 
        <fr:tex display="block">             \frac {\partial  f}{\partial  x_j} = \lim _{h\to 0}             \frac {f(x_1,\cdots ,x_j+h,\cdots ,x_n) - f(x_1,\cdots ,x_n)}{h}         </fr:tex>
        Hence we can define the partial derivatives for each <fr:tex display="inline">f_i (1\leq  i\leq  m)</fr:tex> with respect to each <fr:tex display="inline">x_j (1\leq  j\leq  n)</fr:tex>.
        <fr:tex display="block">             \frac {\partial  f_i}{\partial  x_j} = \lim _{h\to 0}             \frac {f_i(x_1,\cdots ,x_j+h,\cdots ,x_n) - f_i(x_1,\cdots ,x_n)}{h}         </fr:tex>
        Thus we have
        <fr:tex display="block">             \frac {\partial  f_i}{\partial  x_j} = a_{ij}         </fr:tex>
        To find <fr:tex display="inline">a_{ij}</fr:tex> of <fr:tex display="inline">Df(x_0)</fr:tex> we need to find the <fr:tex display="inline">i</fr:tex>-th element of <fr:tex display="inline">Df(x_0)(e_j)</fr:tex>. Let
        <fr:tex display="block">             x = \begin {bmatrix}                 x_{1_0} \\ x_{2_0} \\ \vdots  \\ x_{n_0}             \end {bmatrix} + \begin {bmatrix}                 0 \\ \vdots  \\ 1 \\ \vdots  \\ 0             \end {bmatrix} = x_0 + he_j         </fr:tex>
        We have 
        <fr:tex display="block">             \lim _{x\to  x_0}\frac {\lVert f(x)-f(x_0)-Df(x_0)(he_j)\rVert }{\lVert he_j\rVert }             \\ \implies               \lim _{h\to 0}\frac {\lVert                  f(x_0+he_j) - f(x_0) -hDf(x_0)(e_j)             \rVert }{\lVert h\rVert } = 0         </fr:tex>
        The component is given by 
        <fr:tex display="block">             \lim _{h\to 0}\frac {\lVert f_i(x_0+he_j)-f_i(x_0)-ha_{ij}\rVert }{\lVert h\rVert } = 0             \\ \implies               a_{ij} = \lim _{h\to 0}\frac {f_i(x_0+he_j) - f_i(x_0)}{h}         </fr:tex>
        which is exactly <fr:tex display="inline">\frac {\partial  f_i}{\partial  x_j}</fr:tex>. Thus the matrix representation of <fr:tex display="inline">Df(x)</fr:tex> is given by 
        a matrix called the <fr:strong>Jacobin matrix</fr:strong> of <fr:tex display="inline">f</fr:tex>.
        <fr:tex display="block">             Df(x) = \begin {bmatrix}                 \frac {\partial  f_1}{\partial  x_1} &amp; \frac {\partial  f_1}{\partial  x_2} &amp; \cdots  &amp; \frac {\partial  f_1}{\partial  x_n} \\                 \frac {\partial  f_2}{\partial  x_1} &amp; \frac {\partial  f_2}{\partial  x_2} &amp; \cdots  &amp; \frac {\partial  f_2}{\partial  x_n} \\                 \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                 \frac {\partial  f_m}{\partial  x_1} &amp; \frac {\partial  f_m}{\partial  x_2} &amp; \cdots  &amp; \frac {\partial  f_m}{\partial  x_n}             \end {bmatrix} = \left [                 \frac {\partial  f_i}{\partial  x_j}             \right ]         </fr:tex>
        where <fr:tex display="inline">i</fr:tex> ranges row and <fr:tex display="inline">j</fr:tex> ranges column.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>725</fr:anchor>
                <fr:addr type="user">math-0008</fr:addr>
                <fr:route>math-0008.xml</fr:route>
                <fr:title text="Matrix Computation">Matrix Computation</fr:title>
                <fr:taxon>Linear Algebra</fr:taxon>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>6</fr:month>
                  <fr:day>10</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>This post shows operations and applications over matrix, refers to Wikipedia.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>726</fr:anchor>
                    <fr:addr type="user">def-0043</fr:addr>
                    <fr:route>def-0043.xml</fr:route>
                    <fr:title text="Transpose">Transpose</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The <fr:strong>transpose</fr:strong> of a matrix <fr:tex display="inline">A</fr:tex>, denoted by <fr:tex display="inline">A^T</fr:tex> is
    the matrix obtained by swapping the rows and columns of <fr:tex display="inline">A</fr:tex>.
    It satisfies the following properties:
    <fr:ul><fr:li><fr:tex display="inline">(A^T)^T = A</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">(A + B)^T = A^T + B^T</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">(cA)^T = cA^T</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">(AB)^T = B^TA^T</fr:tex></fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>If the following condition satisfies:
    <fr:tex display="block">         a_{ij} = a_{ji} \quad  \forall  i,j     </fr:tex>
    Then the matrix is called symmetric.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>727</fr:anchor>
                    <fr:addr type="user">def-001N</fr:addr>
                    <fr:route>def-001N.xml</fr:route>
                    <fr:title text="Symmetric Matrix">Symmetric Matrix</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A square matrix <fr:tex display="inline">A</fr:tex> is symmetric if it is equal to its transpose:
    <fr:tex display="block">         A = A^T     </fr:tex>
    This also implies <fr:tex display="inline">A^{-1} A^T = I</fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>728</fr:anchor>
                    <fr:addr type="user">def-0044</fr:addr>
                    <fr:route>def-0044.xml</fr:route>
                    <fr:title text="Determinant">Determinant</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The determinant of a <fr:tex display="inline">n\times  n</fr:tex> square matrix <fr:tex display="inline">A</fr:tex> is commonly denoted <fr:tex display="inline">\det  A</fr:tex> or <fr:tex display="inline">|A|</fr:tex>.
    It satisfies the following properties:
    <fr:ul><fr:li><fr:tex display="inline">\det  A^T = \det  A</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">\det  AB = \det  A \det  B</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">\det  \lambda  A = \lambda ^n \det  A</fr:tex></fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>To compute the inverse of a matrix, we need <fr:strong>Adjugate matrix</fr:strong>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>729</fr:anchor>
                    <fr:addr type="user">def-0045</fr:addr>
                    <fr:route>def-0045.xml</fr:route>
                    <fr:title text="First Minor and Cofactor">First Minor and Cofactor</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>If <fr:tex display="inline">A</fr:tex> is a square matrix, then the <fr:strong>minor</fr:strong> of the entry in the i-th row and j-th 
    column (also called the <fr:tex display="inline">(i, j)</fr:tex> minor, or a first minor) is the <fr:strong>determinant</fr:strong> of 
    the sub-matrix formed by deleting the i-th row and j-th column.
    The <fr:tex display="inline">(i, j)</fr:tex> minor is denoted as <fr:tex display="inline">M_{ij}</fr:tex>.
    The <fr:strong>Cofactor</fr:strong> is obtained by multiplying the minor by <fr:tex display="inline">(-1)^{i+j}</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>730</fr:anchor>
                    <fr:addr type="user">def-0046</fr:addr>
                    <fr:route>def-0046.xml</fr:route>
                    <fr:title text="Cofactor Matrix">Cofactor Matrix</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The matrix formed by all of the <fr:link type="local" href="def-0045.xml" addr="def-0045" title="First Minor and Cofactor">cofactors</fr:link> of a square matrix <fr:tex display="inline">A</fr:tex> is called the cofactor matrix,
    or <fr:strong>comatrix</fr:strong>:
    <fr:tex display="block">         C = \left [              \begin {array}{cccc}                 C_{11} &amp; C_{12} &amp; \cdots  &amp; C_{1n} \\                 C_{21} &amp; C_{22} &amp; \cdots  &amp; C_{2n} \\                 \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                 C_{n1} &amp; C_{n2} &amp; \cdots  &amp; C_{nn}             \end {array}         \right ]     </fr:tex>
    The <fr:strong>Adjugate matrix</fr:strong> of <fr:tex display="inline">A</fr:tex> is the transpose of the cofactor matrix.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Then the inverse of <fr:tex display="inline">A</fr:tex> is the transpose of the cofactor matrix times the reciprocal of the determinant of <fr:tex display="inline">A</fr:tex>:
    <fr:tex display="block">         A^{-1} = \frac {1}{\det  A} \cdot  \text {adj} A = \frac {1}{\det  A} \cdot  C^T     </fr:tex></fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>731</fr:anchor>
                    <fr:addr type="user">def-0047</fr:addr>
                    <fr:route>def-0047.xml</fr:route>
                    <fr:title text="Singular Matrix">Singular Matrix</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A square matrix that is not <fr:strong>invertible</fr:strong> is called <fr:strong>singular</fr:strong> or degenerate</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>732</fr:anchor>
                    <fr:addr type="machine">#303</fr:addr>
                    <fr:route>unstable-303.xml</fr:route>
                    <fr:title text="An important property of the inverse of a matrix">An important property of the inverse of a matrix</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>6</fr:month>
                      <fr:day>10</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter><fr:p><fr:tex display="block">             A \cdot  \text {adj} A = \text {adj} A \cdot  A = \det  A \cdot  I         </fr:tex></fr:p>
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>733</fr:anchor><fr:addr type="machine">#304</fr:addr><fr:route>unstable-304.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
        Let <fr:tex display="inline">A \cdot  \text {adj} A = (b_{ij})</fr:tex> and we have
        <fr:tex display="block">             b_{ij} = a_{i1}A_{j1} + a_{i2}A_{j2} + \cdots  + a_{in}A_{jn} = \delta _{ij} \cdot  \det  A         </fr:tex>
        Hence we have <fr:tex display="inline">A \cdot  \text {adj} A = \det  A \cdot  I</fr:tex> 
    </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 
</fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>734</fr:anchor>
                    <fr:addr type="machine">#305</fr:addr>
                    <fr:route>unstable-305.xml</fr:route>
                    <fr:title text="Matrix Polynomial and Computation">Matrix Polynomial and Computation</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>6</fr:month>
                      <fr:day>10</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>735</fr:anchor>
                        <fr:addr type="user">def-0048</fr:addr>
                        <fr:route>def-0048.xml</fr:route>
                        <fr:title text="Matrix Polynomial">Matrix Polynomial</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>A <fr:strong>matrix polynomial</fr:strong> is a polynomial with square matrices as variables.
    The general form of a matrix polynomial is:
    <fr:tex display="block">         P(A) = \sum _{i=0}^{n} a_i A^i     </fr:tex>
    where <fr:tex display="inline">A^0 = I</fr:tex> is the identity matrix.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>If <fr:tex display="inline">A</fr:tex> is a diagonal matrix, then the polynomial of <fr:tex display="inline">A</fr:tex> is the diagonal matrix of the polynomial of the diagonal elements of <fr:tex display="inline">A</fr:tex>.
        <fr:tex display="block">             p(A) = \begin {bmatrix}                 p(a_{11}) &amp; 0 &amp; \cdots  &amp; 0 \\                 0 &amp; p(a_{22}) &amp; \cdots  &amp; 0 \\                 \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                 0 &amp; 0 &amp; \cdots  &amp; p(a_{nn})             \end {bmatrix}         </fr:tex></fr:p>
                    <fr:p>If <fr:tex display="inline">A = P\Lambda  P^{-1}</fr:tex>, then <fr:tex display="inline">A^k = P \Lambda  ^k P^{-1}</fr:tex> and hence
        <fr:tex display="block">             p(A) = a_0 I + a_1 A + a_2 A^2 + \cdots  + a_n A^n = P \Lambda  P^{-1}         </fr:tex></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>736</fr:anchor>
                    <fr:addr type="machine">#306</fr:addr>
                    <fr:route>unstable-306.xml</fr:route>
                    <fr:title text="Solving a Linear System">Solving a Linear System</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>6</fr:month>
                      <fr:day>10</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>737</fr:anchor>
                        <fr:addr type="user">thm-0011</fr:addr>
                        <fr:route>thm-0011.xml</fr:route>
                        <fr:title text="Cramer&apos;s rule">Cramer&apos;s rule</fr:title>
                        <fr:taxon>Theorem</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Consider a system of <fr:tex display="inline">n</fr:tex> linear equations for <fr:tex display="inline">n</fr:tex> unknowns, represented in matrix multiplication form as follows:
    <fr:tex display="block">         A \cdot  X = B     </fr:tex>
    where <fr:tex display="inline">A</fr:tex> is a square matrix of order <fr:tex display="inline">n</fr:tex>, <fr:tex display="inline">X</fr:tex> is a column matrix of order <fr:tex display="inline">n</fr:tex> and <fr:tex display="inline">B</fr:tex> is a column matrix of order <fr:tex display="inline">n</fr:tex>.
    <fr:tex display="block">         X = \begin {bmatrix} x_1 \\ x_2 \\ \vdots  \\ x_n \end {bmatrix}     </fr:tex>
    The Cramer&apos;s rule states that the solution to the system of equations is given by:
    <fr:tex display="block">         x_i = \frac {\text {det}(A_i)}{\text {det}(A)}     </fr:tex>
    where <fr:tex display="inline">A_i</fr:tex> is the matrix obtained by replacing the <fr:tex display="inline">i</fr:tex>th column of <fr:tex display="inline">A</fr:tex> by <fr:tex display="inline">B</fr:tex>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>Matrix partitioning is the process of dividing a matrix into smaller submatrices. 
        This is often done to simplify the computation of matrix operations, such as matrix multiplication.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>738</fr:anchor>
                        <fr:addr type="user">def-0049</fr:addr>
                        <fr:route>def-0049.xml</fr:route>
                        <fr:title text="Matrix Partitioning">Matrix Partitioning</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Let <fr:tex display="inline">A \in  \mathbb {C}^{m\times  n} </fr:tex>. A <fr:strong>partitioning</fr:strong> of <fr:tex display="inline">A</fr:tex> is a representation of <fr:tex display="inline">A</fr:tex> in the form
    <fr:tex display="block">         A = \begin {bmatrix}             A_{11} &amp; A_{12} &amp; \cdots  &amp; A_{1q} \\             A_{21} &amp; A_{22} &amp; \cdots  &amp; A_{2q} \\             \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\             A_{p1} &amp; A_{p2} &amp; \cdots  &amp; A_{pq}         \end {bmatrix}     </fr:tex>
    where <fr:tex display="inline">A_{ij} \in  \mathbb {C}^{m_i \times  n_j} </fr:tex> for <fr:tex display="inline">1 \leq  i \leq  p</fr:tex> and <fr:tex display="inline">1 \leq  j \leq  q</fr:tex> such that
    <fr:tex display="block">         \sum _{i=1}^p m_i = m \quad  \text {and} \quad  \sum _{j=1}^q n_j = n.     </fr:tex>
    The partitioned matrix operations are similar to the operations on the normal matrix.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>If the partitioned matrix is formed as diagonal blocks, then we can compute the determinant of the matrix by the following formula:
        <fr:tex display="block">             \det  A = \det  A_1 \cdot  \det  A_2 \cdots  \det  A_n         </fr:tex>
        And the inverse of the matrix is
        <fr:tex display="block">             A^{-1} = \begin {bmatrix}                 A_1^{-1} &amp; O &amp; \cdots  &amp; O \\                 O &amp; A_2^{-1} &amp; \cdots  &amp; O \\                 \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                 O &amp; O &amp; \cdots  &amp; A_n^{-1}             \end {bmatrix}         </fr:tex></fr:p>
                    <fr:p>The column partitioning of matrix is useful. 
        If we have <fr:tex display="inline">m\times  s</fr:tex> matrix <fr:tex display="inline">A = (a_{ij})</fr:tex> and <fr:tex display="inline">s\times  n</fr:tex> matrix <fr:tex display="inline">B=(b_{ij})</fr:tex>,
        their product can be written:
        <fr:tex display="block">             AB = \begin {bmatrix} A_1 \\ A_2 \\ \vdots  A_m \end {bmatrix}             \begin {bmatrix}                 B_1 &amp; B_2 &amp; \cdots  &amp; B_n             \end {bmatrix} =              \begin {bmatrix}                 A_1B_1 &amp; A_1B_2 &amp; \cdots  &amp; A_1B_n \\                 A_2B_1 &amp; A_2B_2 &amp; \cdots  &amp; A_2B_n \\                 \vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots  \\                 A_mB_1 &amp; A_mB_2 &amp; \cdots  &amp; A_mB_n             \end {bmatrix}         </fr:tex>
        We can show that <fr:tex display="inline">A=O\iff  A^TA=O</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>739</fr:anchor>
                    <fr:addr type="machine">#307</fr:addr>
                    <fr:route>unstable-307.xml</fr:route>
                    <fr:title text="Matrix Transformation">Matrix Transformation</fr:title>
                    <fr:taxon>Section</fr:taxon>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>6</fr:month>
                      <fr:day>10</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>740</fr:anchor>
                        <fr:addr type="user">def-004A</fr:addr>
                        <fr:route>def-004A.xml</fr:route>
                        <fr:title text="Elementary Operations">Elementary Operations</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>There are three types of elementary matrices, which correspond to three types of row operations
    (respectively, column operations, row operations are equivalent to multiplying on the left by the
    corresponding elementary matrix, and column operations are equivalent to multiplying on the right
    by the corresponding elementary matrix):
    <fr:ul><fr:li><fr:strong>Row switching</fr:strong>: A row within the matrix can be switched with another row.
            <fr:tex display="block">                 P_{i,j} = \begin {bmatrix}                     1 \\                     &amp; \ddots  \\                     &amp; &amp; 0 &amp; &amp;  1 \\                      &amp; &amp; &amp; \ddots  \\                      &amp; &amp; 1 &amp; &amp; 0 \\                      &amp; &amp; &amp; &amp; &amp; \ddots  \\                     &amp; &amp; &amp; &amp; &amp; &amp; 1                 \end {bmatrix}             </fr:tex></fr:li>
        <fr:li><fr:strong>Row multiplication</fr:strong>: Each element in a row can be multiplied by a non-zero constant.
            <fr:tex display="block">                 D_i(k) = \text {diag} (1, \cdots , k, \cdots , 1)             </fr:tex></fr:li>
        <fr:li><fr:strong>Row additio</fr:strong>: A row can be replaced by the sum of that row and a multiple of another row.
            <fr:tex display="block">                 T_{i,j} = \begin {bmatrix}                     1 \\                     &amp; \ddots  \\                     &amp; &amp; 1 &amp; &amp; k \\                      &amp; &amp; &amp; \ddots  \\                      &amp; &amp; &amp; &amp; 1 \\                      &amp; &amp; &amp; &amp; &amp; \ddots  \\                     &amp; &amp; &amp; &amp; &amp; &amp; 1                 \end {bmatrix}             </fr:tex></fr:li></fr:ul></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>741</fr:anchor>
                        <fr:addr type="user">def-004B</fr:addr>
                        <fr:route>def-004B.xml</fr:route>
                        <fr:title text="Column / Row Equivalence">Column / Row Equivalence</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Two matrices <fr:tex display="inline">A,B</fr:tex> are column / row equivalent if one can 
    be obtained from the other by a finite sequence of <fr:link type="local" href="def-004A.xml" addr="def-004A" title="Elementary Operations">elementary operations</fr:link>,
    denoted <fr:tex display="inline">A \sim  B</fr:tex>.
    The column / row equivalence is an <fr:link type="local" href="def-000X.xml" addr="def-000X" title="Equivalence Relation">equivalence relation</fr:link>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>We can show that a matrix <fr:tex display="inline">A</fr:tex> is invertible iff there are finite elementary matrices
        <fr:tex display="inline">E_1, E_2, \cdots , E_n</fr:tex> such that
        <fr:tex display="block">             A = E_1E_2\cdots  E_n         </fr:tex></fr:p>
                    <fr:p>From above we can deduce that a square matrix <fr:tex display="inline">A</fr:tex> is invertible iff <fr:tex display="inline">A\sim  E</fr:tex>.
        This trick can be used for solving a linear system and computing the inverse of a matrix.
        For instance, given <fr:tex display="inline">AX=B</fr:tex> we can solve <fr:tex display="inline">X</fr:tex> by the following steps:
        Let <fr:tex display="inline">P</fr:tex> be a matrix such that <fr:tex display="inline">PA=I</fr:tex> where <fr:tex display="inline">I</fr:tex> is the identity matrix.
        Hence <fr:tex display="inline">P = A^{-1}</fr:tex> and we have <fr:tex display="inline">X = PB</fr:tex>, we can do elementary operations over matrix <fr:tex display="inline">(A, B)</fr:tex>
        to get the solution of <fr:tex display="inline">X</fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>742</fr:anchor>
                    <fr:addr type="machine">#308</fr:addr>
                    <fr:route>unstable-308.xml</fr:route>
                    <fr:title text="Rank">Rank</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>6</fr:month>
                      <fr:day>10</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Now let&apos;s talk about the concept of <fr:strong>rank</fr:strong>.
        In linear algebra, the (column)<fr:strong>rank</fr:strong> of a matrix <fr:tex display="inline">A</fr:tex> is the dimension of the vector space 
        generated (or spanned) by its columns.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>743</fr:anchor>
                        <fr:addr type="user">def-004J</fr:addr>
                        <fr:route>def-004J.xml</fr:route>
                        <fr:title text="Rank">Rank</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>The rank of a linear map or operator <fr:tex display="inline">\Phi </fr:tex> is defined as the dimension of its range:
    <fr:tex display="block">         \text {rank}(M)\equiv \dim (\text {range }(M))     </fr:tex>
    Note that the range (<fr:strong>column space</fr:strong>) of a matrix <fr:tex display="inline">M</fr:tex> is the <fr:link type="local" href="def-000M.xml" addr="def-000M" title="Linear Span">span</fr:link> of its column vectors.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>Similarly we can define the row rank of a matrix. A fundamental result in linear algebra is 
        that the column rank and the row rank are always equal. Hence we can simply call it the rank of a matrix.
        If the column rank equals to the column size, we say that the matrix is full column rank.</fr:p>
                    <fr:p>A common approach to finding the rank of a matrix is to reduce it to a simpler form, 
        generally <fr:strong>row echelon form</fr:strong>, by elementary row operations.
        Row operations do not change the row space (hence do not change the row rank), and, being 
        invertible, map the column space to an isomorphic space (hence do not change the column rank).
        <fr:tex display="block">             A \sim  B \implies  \text {rank}(A) = \text {rank}(B)             \\              \text {rank}(A) = \text {rank}(A^T)         </fr:tex>
        Once in row echelon form, the rank is clearly the same for both row rank and column rank, 
        and equals to the number of <fr:strong>pivots</fr:strong> (or basic columns) and also the number of non-zero rows.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>744</fr:anchor>
                        <fr:addr type="user">def-004I</fr:addr>
                        <fr:route>def-004I.xml</fr:route>
                        <fr:title text="Row Echelon Form">Row Echelon Form</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>A matrix is in <fr:strong>row echelon form</fr:strong> if
    <fr:ul><fr:li>All rows having only zero entries are at the bottom</fr:li>
        <fr:li>The leading entry (that is, the <fr:strong>left-most</fr:strong> nonzero entry) of every nonzero row, called
            the <fr:strong>pivot</fr:strong>, is on the right of the leading entry of every row above.</fr:li></fr:ul>
    Some texts add the condition that the leading coefficient must be <fr:tex display="inline">1</fr:tex>
    while others require this only in <fr:strong>reduced row echelon form</fr:strong>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>For instance, matrix <fr:tex display="inline">A = \begin {bmatrix}1&amp;2&amp;1\\-2&amp;-3&amp;1\\3&amp;5&amp;0\end {bmatrix}</fr:tex> can be transformed into reduced row-echelon form:
        <fr:tex display="block">\begin {aligned}{\begin {bmatrix}1&amp;2&amp;1\\-2&amp;-3&amp;1\\3&amp;5&amp;0\end {bmatrix}}&amp;\xrightarrow  {2R_{1}+R_{2}\to  R_{2}} {\begin {bmatrix}1&amp;2&amp;1\\0&amp;1&amp;3\\3&amp;5&amp;0\end {bmatrix}}\xrightarrow  {-3R_{1}+R_{3}\to  R_{3}} {\begin {bmatrix}1&amp;2&amp;1\\0&amp;1&amp;3\\0&amp;-1&amp;-3\end {bmatrix}}\\&amp;\xrightarrow  {R_{2}+R_{3}\to  R_{3}} \,\,{\begin {bmatrix}1&amp;2&amp;1\\0&amp;1&amp;3\\0&amp;0&amp;0\end {bmatrix}}\xrightarrow  {-2R_{2}+R_{1}\to  R_{1}} {\begin {bmatrix}1&amp;0&amp;-5\\0&amp;1&amp;3\\0&amp;0&amp;0\end {bmatrix}}~.\end {aligned}</fr:tex>
        The final matrix has two non-zero rows and thus the rank of matrix <fr:tex display="inline">A</fr:tex> is <fr:tex display="inline">2</fr:tex>.</fr:p>
                    <fr:p>The determinantal rank of a matrix is the order of the largest non-zero minor of the matrix.
        It is also the number of non-zero eigenvalues of the matrix. 
        This does not give an efficient way of computing the rank, but it is useful theoretically: 
        a single non-zero minor witnesses a lower bound for the rank of the matrix,
        which can be useful to prove that certain operations do not lower the rank of a matrix.</fr:p>
                    <fr:p>We can conclude the properties of rank:
        <fr:tex display="block">             \begin {align*}                 &amp;0 \leq  \text {rank}(A_{m\times  n}) \leq  \min (m,n) \\                 &amp;\text {rank}(A^T) = \text {rank}(A) \\                  &amp; A \sim  B \implies  \text {rank}(A)=\text {rank}(B) \\                  &amp; P, Q \text { is invertible} \implies  \text {rank}(PAQ) = \text {rank}(A) \\                  &amp; \max (\text {rank}(A), \text {rank}(B)) \leq  \text {rank}(A, B) \leq  \text {rank}(A) + \text {rank}(B) \\                  &amp; \text {rank}(A+B) \leq  \text {rank}(A) + \text {rank}(B) \\                 &amp; \text {rank}(AB) \leq  \min (\text {rank}(A), \text {rank}(B)) \\                  &amp; A_{m\times  n}B_{n\times  l} = O\implies  \text {rank}(A) + \text {rank}(B) \leq  n             \end {align*}         </fr:tex></fr:p>
                    <fr:p>With such properties we can prove an important theorem:
        <fr:tex display="block">             AB = O \land  A \text { is full rank} \implies  B = O         </fr:tex>
        which is known as the cancellation law of matrix multiplication.</fr:p>
                    <fr:p>The rank of a matrix is also related to the solution of a linear system.
        If the rank of the coefficient matrix is less than the rank of the augmented matrix, 
        then the system is inconsistent. Hence there does not exist a solution.
        Similarly we have the following discussion: For a <fr:tex display="inline">n</fr:tex>-variable linear system <fr:tex display="inline">Ax = b</fr:tex>
        <fr:ul><fr:li>If <fr:tex display="inline">\text {rank}(A) &lt; \text {rank}(A,b)</fr:tex>, the solution does not exist.</fr:li>
            <fr:li>If <fr:tex display="inline">\text {rank}(A)=\text {rank}(A,b)=n</fr:tex>, there is a unique solution.</fr:li>
            <fr:li>Ig <fr:tex display="inline">\text {rank}(A)=\text {rank}(A,b)&lt;n</fr:tex>, there are infinite solutions.</fr:li></fr:ul>
        This leads two fundamental theorems of linear systems:
        <fr:ul><fr:li><fr:tex display="inline">n</fr:tex>-variable regular linear system <fr:tex display="inline">Ax = 0</fr:tex> has a non-trivial solution iff <fr:tex display="inline">\text {rank}(A) &lt; n</fr:tex>.</fr:li>
            <fr:li>Matrix equation <fr:tex display="inline">AX = B</fr:tex> has solutions iff <fr:tex display="inline">\text {rank}(A) = \text {rank}(A,B)</fr:tex>.</fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>745</fr:anchor>
                    <fr:addr type="machine">#309</fr:addr>
                    <fr:route>unstable-309.xml</fr:route>
                    <fr:title text="Linear Combinations">Linear Combinations</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>6</fr:month>
                      <fr:day>10</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p></fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>746</fr:anchor>
                        <fr:addr type="user">def-000L</fr:addr>
                        <fr:route>def-000L.xml</fr:route>
                        <fr:title text="Linear Combination">Linear Combination</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Let <fr:tex display="inline">V</fr:tex> be a <fr:link type="local" href="def-000H.xml" addr="def-000H" title="Vector Space">vector space</fr:link> over a field <fr:tex display="inline">F</fr:tex>.
    Let <fr:tex display="inline">v_1, \dots , v_n</fr:tex> be vectors in <fr:tex display="inline">V</fr:tex>.
    A <fr:strong>linear combination</fr:strong> of <fr:tex display="inline">v_1, \dots , v_n</fr:tex> is an expression of the form
    <fr:tex display="block">         a_1 v_1 + \dots  + a_n v_n     </fr:tex>
    where <fr:tex display="inline">a_1, \dots , a_n \in  F</fr:tex>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>Given two sets of vectors, we say that they are eqaul iff their elements can write as linear combinations of each other.
        This condition can be written using rank:
        <fr:tex display="block">             \text {rank}(A) = \text {rank}(B) = \text {rank}(A, B)         </fr:tex></fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>747</fr:anchor>
                        <fr:addr type="user">def-000P</fr:addr>
                        <fr:route>def-000P.xml</fr:route>
                        <fr:title text="Linearly independent">Linearly independent</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>A set of vectors <fr:tex display="inline">\{v_1, \dots , v_n\}</fr:tex> is called <fr:strong>linearly independent</fr:strong> if
    <fr:tex display="block">a_1 v_1 + \dots  + a_n v_n = 0</fr:tex>
    implies that <fr:tex display="inline">a_1 = \dots  = a_n = 0</fr:tex>.
    The trivial case of <fr:tex display="inline">\{0\}</fr:tex> is also considered linearly independent.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>748</fr:anchor>
                <fr:addr type="user">phy-0004</fr:addr>
                <fr:route>phy-0004.xml</fr:route>
                <fr:title text="Classical Mechanics">Classical Mechanics</fr:title>
                <fr:taxon>Mechanics</fr:taxon>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Notes about the classic mechanics. 
    Most of the content is based on the Wikipedia page about the subject.</fr:p>
                <fr:p>The motion of a body can only be described relative to something elseother bodies, 
    observers, or a set of spacetime coordinates. These are called <fr:strong>frames of reference</fr:strong>. 
    All physical laws take their simplest form in an <fr:strong>inertial</fr:strong> frame.
    <fr:strong>Galilean invariance</fr:strong> or <fr:strong>Galilean relativity</fr:strong> states that the 
    laws of motion are the same in all <fr:strong>inertial frames of reference</fr:strong>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>749</fr:anchor>
                    <fr:addr type="machine">#287</fr:addr>
                    <fr:route>unstable-287.xml</fr:route>
                    <fr:title text="Center of mass">Center of mass</fr:title>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The center of mass of a distribution of mass in space is the unique point 
        at any given time where the weighted relative position of the distributed mass sums to zero.
        <fr:ul><fr:li><fr:strong>System of particles</fr:strong>
                <fr:tex display="block">                     \vec {R} = \frac {\sum  m_i \vec {r}_i}{\sum  m_i}                 </fr:tex></fr:li>
            <fr:li><fr:strong>Continuous volume</fr:strong>
                <fr:p>If the mass is distributed continuously, the center of mass is given by the
                    following formula:
                    <fr:tex display="block">                         \vec {R} = \frac {\int  \vec {r} dm}{\int  dm}                     </fr:tex></fr:p></fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>750</fr:anchor>
                    <fr:addr type="machine">#288</fr:addr>
                    <fr:route>unstable-288.xml</fr:route>
                    <fr:title text="Work and Energy">Work and Energy</fr:title>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p><fr:strong>Work</fr:strong> is the energy transferred to or from an object via the application of force along a displacement.
        <fr:ul><fr:li>Positive Work: The force has a component in the direction of the displacement.</fr:li>
            <fr:li>Negative Work: The force has a component opposite to the direction of the displacement.</fr:li></fr:ul>
        Both force and displacement are vectors. The work done is given by the dot product of the two vectors,
        where the result is a scalar. The work can be given by line integrals:
        <fr:tex display="block">             W = \int _C \vec {F} \cdot  d\vec {r}         </fr:tex>
        where <fr:tex display="inline">d\vec {r}</fr:tex> is the tiny displacement vector along the path <fr:tex display="inline">C</fr:tex>.
        For motion along a straight line, we have a degenerated case of the line integral:
        <fr:tex display="block">             W = \vec {F} \cdot  \vec {r}         </fr:tex></fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>751</fr:anchor>
                        <fr:addr type="user">thm-0012</fr:addr>
                        <fr:route>thm-0012.xml</fr:route>
                        <fr:title text="Work-Energy Principle">Work-Energy Principle</fr:title>
                        <fr:taxon>Principle</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>An increase in the kinetic energy of a <fr:strong>rigid body</fr:strong> is caused by an equal amount 
    of positive work done on the body by the resultant force acting on that body. 
    Conversely, a decrease in kinetic energy is caused by an equal amount of negative work done by the resultant force.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>Work on a free (no fields), rigid (no internal degrees of freedom) body, is equal to the change
        in kinetic energy <fr:tex display="inline">E_k</fr:tex> corresponding to the linear velocity and angular velocity of that body.
        <fr:tex display="block">             W = \Delta  E_k         </fr:tex></fr:p>
                    <fr:p>The work of forces generated by a potential function is known as potential energy 
        and the forces are said to be <fr:strong>conservative</fr:strong>. 
        Work on an object that is merely displaced in a conservative force field, without 
        change in velocity or rotation, is equal to minus the change of potential energy <fr:tex display="inline">E_p</fr:tex> of the object
        <fr:tex display="block">             W = -\Delta  E_p         </fr:tex></fr:p>
                    <fr:p>The time derivative of the work is called <fr:strong>power</fr:strong>:
        <fr:tex display="block">             P = \frac {dW}{dt}         </fr:tex>
        <fr:tex display="inline">dW</fr:tex> can be written as the dot product of the force and the velocity of the object <fr:tex display="inline">dW = \vec {F} \cdot  d\vec {r}</fr:tex>,
        hence the power can be written as:
        <fr:tex display="block">             P = \vec {F} \cdot  \frac {d\vec {r}}{dt} = \vec {F} \cdot  \vec {v}         </fr:tex>
        The work then can be expressed as the integral of the power over time:
        <fr:tex display="block">             W = \int _{\Delta  t} P dt = \int _{\Delta  t} \vec {F} \cdot  \vec {v} dt          </fr:tex></fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>752</fr:anchor>
                        <fr:addr type="machine">#289</fr:addr>
                        <fr:route>unstable-289.xml</fr:route>
                        <fr:title text="Kinetic Energy">Kinetic Energy</fr:title>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter><fr:p>The kinetic energy of a point object, or a non-rotating rigid body depends on the 
            mass of the body as well as its speed.
            <fr:tex display="block">                 E_k = \frac {1}{2} m v^2 = \frac {p^2}{2m}             </fr:tex></fr:p>
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>753</fr:anchor><fr:addr type="machine">#290</fr:addr><fr:route>unstable-290.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            The work done in accelerating a particle with mass m during the infinitesimal time 
            interval <fr:tex display="inline">dt</fr:tex> is given by the dot product of force <fr:tex display="inline">\vec {F}</fr:tex> and the infinitesimal displacement <fr:tex display="inline">d\vec {x}</fr:tex>
            <fr:tex display="block">                 dW = \vec {F} \cdot  d\vec {x}                  = \frac {d\vec {p}}{dt} \cdot  \vec {v}dt                 = \vec {v}\cdot  d\vec {p} = \vec {v} \cdot  d(m\vec {v})             </fr:tex>
            Applying the product rule of differentiation, we get:
            <fr:tex display="block">                 d(\vec {v}\cdot \vec {v}) = 2\vec {v} \cdot  d\vec {v}             </fr:tex>
            Therefore we have:
            <fr:tex display="block">                 \vec {v} \cdot  d(m\vec {v}) = \frac {m}{2} d(\vec {v} \cdot  \vec {v})              </fr:tex>
            Since this is a total differential (that is, it only depends on the final state, 
            not how the particle got there), we can integrate it and call the result kinetic energy:
            <fr:tex display="block">                 E_k = \int _{v_1}^{v_2} \vec {p} \cdot  d\vec {v} = \frac {1}{2} m (v_2^2-v_1^2)             </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 
<fr:p>If a rigid body <fr:tex display="inline">Q</fr:tex> is rotating about any line through the center of mass then it has <fr:strong>rotational kinetic energy</fr:strong>
            (<fr:tex display="inline">E_r</fr:tex>) which is simply the sum of the kinetic energies of its moving parts, and is thus given by:
            <fr:tex display="block">                 E_r = \int _Q \frac {v^2dm}{2} = \int _Q \frac {(r\omega )^2dm}{2} = \frac {\omega ^2}{2}\int _Qr^2dm = \frac {1}{2}I\omega ^2             </fr:tex>
            <fr:ul><fr:li><fr:tex display="inline">I = \int _Qr^2dm</fr:tex> is the moment of inertia of the body.</fr:li>
                <fr:li><fr:tex display="inline">\omega </fr:tex> is the angular velocity of the body.</fr:li>
                <fr:li><fr:tex display="inline">r</fr:tex> is the distance from the axis of rotation.</fr:li></fr:ul></fr:p></fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>754</fr:anchor>
                    <fr:addr type="machine">#291</fr:addr>
                    <fr:route>unstable-291.xml</fr:route>
                    <fr:title text="Momentum">Momentum</fr:title>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p><fr:strong>Momentum</fr:strong> depends on the frame of reference, but in any inertial frame it is a conserved quantity,
        meaning that if a closed system is not affected by external forces, its total linear momentum does not change.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>755</fr:anchor>
                        <fr:addr type="machine">#292</fr:addr>
                        <fr:route>unstable-292.xml</fr:route>
                        <fr:title text="Definition in Classic Mechanics">Definition in Classic Mechanics</fr:title>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>For a system with one or more particles, the total momentum is the sum of the momenta of the individual particles.
            <fr:tex display="block">                 \vec {p} = \sum  m_i \vec {v}_i             </fr:tex>
            Or use the center of mass:
            <fr:tex display="block">                 \vec {p} = M \vec {V}             </fr:tex>
            where <fr:tex display="inline">M</fr:tex> is the total mass of the system and <fr:tex display="inline">\vec {V}</fr:tex> is the velocity of the center of mass.
            This formula is known as the <fr:strong>Euler&apos;s first law of motion</fr:strong>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>756</fr:anchor>
                        <fr:addr type="machine">#293</fr:addr>
                        <fr:route>unstable-293.xml</fr:route>
                        <fr:title text="Relation to force">Relation to force</fr:title>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>From Newton&apos;s second law, the rate of change of the momentum of a particle is equal to the 
            instantaneous force <fr:tex display="inline">F</fr:tex> acting on it
            <fr:tex display="block">                 \vec {F} = \frac {d\vec {p}}{dt}             </fr:tex>
            Hence the change in momentum in time interval <fr:tex display="inline">(t_1, t_2)</fr:tex> can be written as:
            <fr:tex display="block">                 I = \Delta \vec {p} = \int _{t_1}^{t_2} \vec {F} dt = \int _{\vec {p_1}}^{\vec {p_2}} d\vec {p}             </fr:tex>
            We read this as the <fr:strong>impulse</fr:strong> <fr:tex display="inline">I</fr:tex> is equal to the change in momentum.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>757</fr:anchor>
                        <fr:addr type="machine">#294</fr:addr>
                        <fr:route>unstable-294.xml</fr:route>
                        <fr:title text="Law of Conservation of Momentum">Law of Conservation of Momentum</fr:title>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>In a closed system the total momentum remains constant.
            A closed system means that the system is not affected by external forces.
            Or approximately the external forces are extremely small.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>758</fr:anchor>
                        <fr:addr type="machine">#295</fr:addr>
                        <fr:route>unstable-295.xml</fr:route>
                        <fr:title text="Angular Momentum">Angular Momentum</fr:title>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter><fr:p>A force applied perpendicularly to a lever multiplied by its distance from the 
            lever&apos;s fulcrum (the length of the lever arm) is its <fr:strong>torque</fr:strong>.
            <fr:tex display="block">                 \vec {\tau } = \vec {r} \times  \vec {F}             </fr:tex>
            The magnitude of torque is <fr:tex display="inline">\tau  = rF\sin \theta  </fr:tex> (<fr:tex display="inline">r</fr:tex> is the magnitude of the
            <fr:strong>position vector</fr:strong> <fr:tex display="inline">\vec {r}</fr:tex> and <fr:tex display="inline">\theta </fr:tex> is the angle between the force
            vector and the lever arm vector).</fr:p><fr:p>In three-dimensional Euclidean Space, the torque can be written as the components:
            <fr:tex display="block">                 \vec {\tau } = \begin {pmatrix}                     \tau _x \\                     \tau _y \\                     \tau _z                 \end {pmatrix} = \begin {pmatrix}                     yF_z - zF_y \\                     zF_x - xF_z \\                     xF_y - yF_x                 \end {pmatrix}             </fr:tex>
            The component of torque in the direction of an axis is called the torque to that axis.</fr:p><fr:p>The net torque determines the rate of change of the body&apos;s angular momentum.
            <fr:tex display="block">                 \vec {\tau } = \frac {d\vec {L}}{dt}             </fr:tex>
            The angular momentum of a particle is defined as:
            <fr:tex display="block">                 \vec {L} = \vec {r} \times  \vec {p}             </fr:tex></fr:p>
 
   
   <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>759</fr:anchor><fr:addr type="machine">#296</fr:addr><fr:route>unstable-296.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
            Now we prove the equivalence of definitions.
            <fr:tex display="block">                 \frac {d\vec {L}}{dt} = \vec {r}\times \frac {d\vec {p}}{dt} + \frac {d\vec {r}}{dt}\times \vec {p}             </fr:tex>
            The rate of change of linear momentum is the force and the rate of change of position is velocity.
            <fr:tex display="block">                 \frac {d\vec {L}}{dt} = \vec {r}\times \vec {F} + \vec {v}\times \vec {p}             </fr:tex>
            The cross product of <fr:tex display="inline">\vec {p}</fr:tex> with <fr:tex display="inline">\vec {v}</fr:tex> is <fr:tex display="inline">0</fr:tex> because velocity and momentum are parallel.
            Hence we have:
            <fr:tex display="block">                 \frac {d\vec {L}}{dt} = \vec {r}\times \vec {F} = \tau              </fr:tex>
        </fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
 
<fr:p>The above statement leads to the Conservation of Angular Momentum.</fr:p></fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>760</fr:anchor>
                    <fr:addr type="machine">#297</fr:addr>
                    <fr:route>unstable-297.xml</fr:route>
                    <fr:title text="Rigid Body Dynamics">Rigid Body Dynamics</fr:title>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>761</fr:anchor>
                        <fr:addr type="machine">#298</fr:addr>
                        <fr:route>unstable-298.xml</fr:route>
                        <fr:title text="Moment of Inertia">Moment of Inertia</fr:title>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>When a body is free to rotate around an axis, torque must be applied to change its angular momentum.
            The amount of torque needed to cause any given angular acceleration
            is proportional to the moment of inertia of the body.
            The moment of inertia plays the role in rotational kinetics that mass (inertia) plays in linear kinetics,
            both characterize the resistance of a body to changes in its motion.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="false" numbered="true" show-heading="true" show-metadata="false" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>762</fr:anchor>
                <fr:addr type="user">phy-0005</fr:addr>
                <fr:route>phy-0005.xml</fr:route>
                <fr:title text="Simple Harmonic Motion">Simple Harmonic Motion</fr:title>
                <fr:taxon>Physics</fr:taxon>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>The SHM note is based on Wikipedia.</fr:p>
                <fr:p>In mechanics and physics, <fr:strong>simple harmonic motion</fr:strong> is a special type of periodic motion an object
    experiences by means of a <fr:strong>restoring force</fr:strong> whose magnitude is directly proportional to the 
    distance of the object from an <fr:strong>equilibrium position</fr:strong> and acts towards the equilibrium position.</fr:p>
                <fr:p>In Newtonian mechanics, for one-dimensional simple harmonic motion, the equation of motion, 
    which is a second-order linear ordinary differential equation with constant coefficients,
    can be obtaind by Hooke&apos;s law and Newton&apos;s second law.
    <fr:tex display="block">         F_{\mathrm  {net} }=m{\frac  {\mathrm  {d} ^{2}x}{\mathrm  {d} t^{2}}}=-kx,     </fr:tex>
    where <fr:tex display="inline">m</fr:tex> is the inertial mass og the oscillating body, <fr:tex display="inline">x</fr:tex> is its displacement from 
    the equilibrium position and <fr:tex display="inline">k</fr:tex> is a constant. Therefore we have
    <fr:tex display="block">         {\frac  {\mathrm  {d} ^{2}x}{\mathrm  {d} t^{2}}}=-{\frac  {k}{m}}x,     </fr:tex>
    solving the differential equation we get the sinusoidal function
    <fr:tex display="block">         x(t)=C_{1}\cos  \left (\omega  t\right )+C_{2}\sin  \left (\omega  t\right ),     </fr:tex>
    where <fr:tex display="inline">\omega =\sqrt {\frac {k}{m}}</fr:tex>.</fr:p>
                <fr:p>Let <fr:tex display="inline">t=0</fr:tex> we see that <fr:tex display="inline">C_1 = x(0)</fr:tex> so that <fr:tex display="inline">C_1</fr:tex> is the initial position.
    Taking the derivative of the equation and evaluating at <fr:tex display="inline">0</fr:tex> we get 
    <fr:tex display="inline">x&apos;(0) = \omega  C_2</fr:tex>. So <fr:tex display="inline">C_2</fr:tex> is the initial speed of the object 
    diverged by the angular frequency, <fr:tex display="inline">C_2 = \frac {v_0}{\omega }</fr:tex>. Thus
    <fr:tex display="block">         x(t)=x_{0}\cos  \left ({\sqrt  {\frac  {k}{m}}}t\right )+{\frac  {v_{0}}{\sqrt  {\frac  {k}{m}}}}\sin  \left ({\sqrt  {\frac  {k}{m}}}t\right ).     </fr:tex></fr:p>
                <fr:p>This equation can also be written in the form:
    <fr:tex display="block">         x(t) = Acos(\omega  t-\phi )     </fr:tex>
    where
    <fr:tex display="block">         \begin {align*}             A = \sqrt {C_{1}^{2}+C_{2}^{2}} \\             \phi  = \arctan \left (\frac {C_{2}}{C_{1}}\right ) \\             \sin \phi  = \frac {C_{2}}{A} \\             \cos \phi  = \frac {C_{1}}{A}         \end {align*}     </fr:tex>
    Each of these constants carries a physical meaning of the motion:
    <fr:tex display="inline">A</fr:tex> is the <fr:strong>amplitude</fr:strong> and <fr:tex display="inline">\omega  = 2\pi  f</fr:tex> is the <fr:strong>angular frequency</fr:strong>
    and <fr:tex display="inline">\phi </fr:tex> is the initial <fr:strong>phase</fr:strong>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>763</fr:anchor>
                    <fr:addr type="machine">#282</fr:addr>
                    <fr:route>unstable-282.xml</fr:route>
                    <fr:title text="Energy">Energy</fr:title>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>The kinetic energy of the object at time <fr:tex display="inline">t</fr:tex> is given by
        <fr:tex display="block">             K(t)={\tfrac  {1}{2}}mv^{2}(t)={\tfrac  {1}{2}}m\omega  ^{2}A^{2}\sin  ^{2}(\omega  t-\varphi  )={\tfrac  {1}{2}}kA^{2}\sin  ^{2}(\omega  t-\varphi  )         </fr:tex>
        Besides the kinetic energy, the potential energy of the object at time <fr:tex display="inline">t</fr:tex> is given by
        <fr:tex display="block">             U(t)={\tfrac  {1}{2}}kx^{2}(t)={\tfrac  {1}{2}}kA^{2}\cos  ^{2}(\omega  t-\varphi  )         </fr:tex>
        The total energy of the object is the sum of the kinetic and potential energies
        <fr:tex display="block">             E=K+U={\tfrac  {1}{2}}kA^{2}         </fr:tex>
        which is a constant value. 
        Notice that if we solve <fr:tex display="inline">v</fr:tex> from the energy equation we get
        <fr:tex display="block">             v = \pm \sqrt {\frac {k}{m}(A^{2}-x^{2})} = \pm \omega \sqrt {A^{2}-x^{2}}         </fr:tex>
        which implies that the velocity is maximum when the displacement is zero and vice versa.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>764</fr:anchor>
                    <fr:addr type="machine">#283</fr:addr>
                    <fr:route>unstable-283.xml</fr:route>
                    <fr:title text="Superposition">Superposition</fr:title>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>According to the principle of superposition of SHM, the resultant displacement
        of a number of waves in a medium at a particular point is the vector sum of the individual 
        displacements produced by each of the waves at that point. 
        Consider two waves having the same angular frequency (Suppose <fr:tex display="inline">\phi _2 &gt; \phi _1</fr:tex>) in the same line:
        <fr:tex display="block">             x_{1}(t)=A_{1}\cos (\omega  t+\phi _{1}) \\             x_{2}(t)=A_{2}\cos (\omega  t+\phi _{2})         </fr:tex>
        Use vector addition we can easily compute the resultant displacement
        <fr:tex display="block">             A = \sqrt {A_{1}^{2}+A_{2}^{2}+2A_{1}A_{2}\cos (\phi _{2}-\phi _{1})} \\         </fr:tex>
        and the resultant initial phase
        <fr:tex display="block">             \phi  = \arctan \left (\frac {A_{1}\sin \phi _{1}+A_{2}\sin \phi _{2}}{A_{1}\cos \phi _{1}+A_{2}\cos \phi _{2}}\right )         </fr:tex></fr:p>
                    <fr:p>For some special case, the resultant displacement can be simplified:
        <fr:ul><fr:li>If <fr:tex display="inline">\phi _2 - \phi _1 = 2k\pi , k \in \mathbb {Z}</fr:tex> then the resultant displacement is
                <fr:tex display="block">                     A = A_{1}+A_{2}                 </fr:tex></fr:li>
            <fr:li>If <fr:tex display="inline">\phi _2 - \phi _1 = (2k+1)\pi , k \in \mathbb {Z}</fr:tex> then the resultant displacement is
                <fr:tex display="block">                     A = |A_{1}-A_{2}|                 </fr:tex></fr:li></fr:ul></fr:p>
                    <fr:p>If the angular frequencies are different, the resultant displacement changes with time.
        For instance, given <fr:tex display="block">             x_1 = A_1\cos (\omega _1t+\phi _1) \\             x_2 = A_2\cos (\omega _2t+\phi _2)         </fr:tex>
        the resultant displacement is
        <fr:tex display="block">             A = \sqrt {A_{1}^{2}+A_{2}^{2}+2A_{1}A_{2}\cos ((\omega _{2}-\omega _{1})t+\phi _{2}-\phi _{1})}         </fr:tex></fr:p>
                    <fr:p>If two waves are perpendicular to each other
        <fr:tex display="block">             x = A\cos (\omega  t + \alpha )              \\              y = B\cos (\omega  t + \beta )         </fr:tex>
        we can compute that
        <fr:tex display="block">             \frac {x^2}{A^2} + \frac {y^2}{B^2} -             \frac {xy}{AB}\cos (\beta -\alpha ) = \sin ^2(\beta -\alpha )         </fr:tex>
        which is the equation of an ellipse.</fr:p>
                    <fr:ul><fr:li><fr:tex display="inline">\beta  - \alpha  = 0 \text { or } \pi </fr:tex> the ellipse becomes two line:
            <fr:tex display="block">                 (\frac {x}{A}\pm \frac {y}{B})^2 = 0 \implies  y = \pm  \frac {B}{A}x             </fr:tex>
            The trajectory is two straight line cross the origin.
            The resultant amplitude is <fr:tex display="inline">C = A^2 + B^2</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">\beta  - \alpha  = \pm \frac {\pi }{2}</fr:tex> the ellipse becomes a regular ellipse,
            i.e., the ellipse that takes the coordinates axis as its major axis.
            <fr:tex display="block">                 \frac {x^2}{A^2} + \frac {y^2}{B^2} = 1             </fr:tex>
            If <fr:tex display="inline">\beta  - \alpha  &gt; 0</fr:tex> the ellipse is clockwise, otherwise it is counter-clockwise.</fr:li></fr:ul>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>765</fr:anchor>
                    <fr:addr type="machine">#284</fr:addr>
                    <fr:route>unstable-284.xml</fr:route>
                    <fr:title text="Wave">Wave</fr:title>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A <fr:strong>wave</fr:strong> is a propagating dynamic disturbance (change from equilibrium) of one or more quantities.
        Waves are often described by a wave equation (standing wave field of two opposite waves) or a one-way 
        <fr:strong>wave equation</fr:strong> for single wave propagation in a defined direction.</fr:p>
                    <fr:p>There are two types of waves that are commonly stdudied: mechanical waves and electromagnetic waves.
        <fr:ul><fr:li>A <fr:strong>mechanical wave</fr:strong> is a local deformation (strain) in some physical medium that propagates
                form particle to particle by creating local stresses that cause strain in neighboring particles.</fr:li>
            <fr:li>The electromagnetic wave us propagating by the coupling between the electric and magnetic 
                fields. Electromagnetic waves can travel through a vacuum and through some dielectric media.</fr:li></fr:ul></fr:p>
                    <fr:p>According to the direction of vibration and propagation, waves can be classified into two types.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>766</fr:anchor>
                        <fr:addr type="user">def-004K</fr:addr>
                        <fr:route>def-004K.xml</fr:route>
                        <fr:title text="Transverse wave and Longitudinal wave">Transverse wave and Longitudinal wave</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:ul><fr:li>A <fr:strong>transverse wave</fr:strong> is a wave that oscillates perpendicularly to the direction of the wave&apos;s advance.</fr:li>
    <fr:li>A <fr:strong>longitudinal wave</fr:strong> is a wave that oscillates parallel to the direction of the wave&apos;s advance.</fr:li></fr:ul>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>767</fr:anchor>
                        <fr:addr type="machine">#285</fr:addr>
                        <fr:route>unstable-285.xml</fr:route>
                        <fr:title text="Basic Quantities">Basic Quantities</fr:title>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>The wavelength, frequency, speed and period are four import quantities of a wave.
            Now we give their relations.</fr:p>
                        <fr:p>The <fr:strong>wavelength</fr:strong> <fr:tex display="inline">\lambda </fr:tex> of a sinusoidal waveform traveling at constant speed <fr:tex display="inline">v</fr:tex> is given by
            <fr:tex display="block">                 \lambda  = vT = \frac {v}{f}             </fr:tex>
            where <fr:tex display="inline">f</fr:tex> is the frequency of the wave and <fr:tex display="inline">T</fr:tex> is the period of the wave.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>768</fr:anchor>
                        <fr:addr type="machine">#286</fr:addr>
                        <fr:route>unstable-286.xml</fr:route>
                        <fr:title text="Basic Principle">Basic Principle</fr:title>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>The <fr:strong>principle of superposition</fr:strong> states that when two or more waves overlap, the resultant displacement
            at any point is the vector sum of the displacements of the individual waves at that point.</fr:p>
                        <fr:p>The <fr:strong>Huygens principle</fr:strong> states that each point on a <fr:strong>wavefront</fr:strong> is a source of spherical wavelets and the
            wavefront at a later time is the <fr:strong>envelope</fr:strong> of these wavelets.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>If the displacement of origin <fr:tex display="inline">O</fr:tex> can be expressed as
        <fr:tex display="block">             y_O = A\cos (\omega  t)         </fr:tex> 
        Such a vibration propagates along x-axis, the displacement of a point <fr:tex display="inline">P</fr:tex> (at <fr:tex display="inline">x</fr:tex>) at time <fr:tex display="inline">t</fr:tex> is
        <fr:tex display="block">             y = A\cos (\omega  t - 2\pi  f \frac {x}{v}) = A\cos  \omega (t - \frac {x}{v})         </fr:tex>
        The distance between <fr:tex display="inline">P</fr:tex> and <fr:tex display="inline">O</fr:tex> is <fr:tex display="inline">x</fr:tex>, in this time period the origin vibrates <fr:tex display="inline">\frac {x}{v}f</fr:tex> times.
        Every vibration changes the phase with <fr:tex display="inline">2\pi </fr:tex>. Hence <fr:tex display="inline">P</fr:tex> is behind <fr:tex display="inline">O</fr:tex> in <fr:tex display="inline">2\pi  f \frac {x}{v}</fr:tex> in phase.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
          </fr:mainmatter>
          <fr:backmatter></fr:backmatter>
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
  </fr:backmatter>
</fr:tree>