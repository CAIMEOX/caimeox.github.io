<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1602</fr:anchor><fr:addr type="user">def-000Y</fr:addr><fr:route>def-000Y.xml</fr:route><fr:title text="Partial Order">Partial Order</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>(non-strict) partial order</fr:strong> is a relation <fr:tex display="inline">\leq </fr:tex> that is reflexive, antisymmetric and transitive.
    <fr:ul><fr:li>Reflexive: <fr:tex display="inline">a\leq  a</fr:tex></fr:li>
        <fr:li>Antisymmetric: <fr:tex display="inline">a\leq  b</fr:tex> and <fr:tex display="inline">b\leq  a</fr:tex> implies <fr:tex display="inline">a=b</fr:tex></fr:li>
        <fr:li>Transitive: <fr:tex display="inline">a\leq  b</fr:tex> and <fr:tex display="inline">b\leq  c</fr:tex> implies <fr:tex display="inline">a\leq  c</fr:tex></fr:li></fr:ul>
    A non-strict partial order is also known as an antisymmetric <fr:link type="local" href="def-000Z.xml" addr="def-000Z" title="Preorder">preorder</fr:link>.</fr:p></fr:mainmatter><fr:backmatter><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title text="Context">Context</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1603</fr:anchor><fr:addr type="user">math-0003</fr:addr><fr:route>math-0003.xml</fr:route><fr:title text="Set Theory">Set Theory</fr:title><fr:taxon>Set Theory</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Refer to <fr:link type="local" href="cat-sci-2013.xml" addr="cat-sci-2013" title="Category theory for scientists">Category Theory for Scientists</fr:link>.</fr:p><fr:p><fr:strong>Set</fr:strong> is a common concept in mathematics.
    This post is a brief introduction to set theory aimed at 
    complete all basic knowledge of set theory.
    The following topics will be covered
    <fr:ul><fr:li><fr:strong>Zermelo-Fraenkel Axioms</fr:strong> and <fr:strong>Axiom of Choice</fr:strong></fr:li>
        <fr:li>Cardinality</fr:li>
        <fr:li>Set theory constructions</fr:li></fr:ul></fr:p><fr:p>In this post, we use the Zermelo-Fraenkel set theory with the Axiom of Choice (<fr:strong>ZFC</fr:strong>).</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>559</fr:anchor><fr:addr type="user">def-000S</fr:addr><fr:route>def-000S.xml</fr:route><fr:title text="ZFC Set">ZFC Set</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>ZFC</fr:strong> is the abbreviation of Zermelo-Fraenkel set theory with the Axiom of Choice.
    The axioms of ZFC are listed below.
    <fr:ul><fr:li><fr:strong>Axiom of Extensionality</fr:strong>:
            Two sets are equal if and only if they have the same elements.</fr:li>
        <fr:li><fr:strong>Axiom of Pairing</fr:strong>:
            For any two sets <fr:tex display="inline">a</fr:tex> and <fr:tex display="inline">b</fr:tex>,
            there exists a set <fr:tex display="inline">\{ a,b \}</fr:tex> whose elements are exactly <fr:tex display="inline">a</fr:tex> and <fr:tex display="inline">b</fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom schema of Separation</fr:strong>:
            Let <fr:tex display="inline">P</fr:tex> is a property of sets.
            <fr:tex display="inline">P(u)</fr:tex> means <fr:tex display="inline">u</fr:tex> satisfies the property <fr:tex display="inline">P</fr:tex>.
            then for any set <fr:tex display="inline">X</fr:tex> exists <fr:tex display="inline">Y = \{ u \in  X | P(u) \}</fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom of Union</fr:strong>:
            For any set <fr:tex display="inline">X</fr:tex> (a family of sets), exists union set <fr:tex display="inline">\bigcup  X :\equiv  \{                  u:\exists  v\in  X \text { such that } u\in  v              \}</fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom of Power Set</fr:strong>:
            For any set <fr:tex display="inline">X</fr:tex>, exists the power <fr:tex display="inline">P(X) :\equiv  \{ Y:Y\subseteq  X \}</fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom of Infinity</fr:strong>:
            There exists a set <fr:tex display="inline">\omega </fr:tex> such that <fr:tex display="inline">\emptyset \in \omega </fr:tex> and for any <fr:tex display="inline">x\in \omega </fr:tex>, <fr:tex display="inline">x\cup \{ x \}\in \omega </fr:tex>.</fr:li>
        <fr:li><fr:strong>Axiom of Regularity</fr:strong>:
            For any non-empty set there is a minimal element with respect to the membership relation.</fr:li>
        <fr:li><fr:strong>Axiom schema of Replacement</fr:strong>:
            Let <fr:tex display="inline">F</fr:tex> be a function where <fr:tex display="inline">\text {dom } f = X</fr:tex>, then for any set <fr:tex display="inline">X</fr:tex> exists a set <fr:tex display="inline">Y = \{ F(x):x\in  X \}</fr:tex>.
            <fr:p>This function is not the normal function but some logical stuff.</fr:p></fr:li>
        <fr:li><fr:strong>Axiom of Choice</fr:strong>:
            For any family of non-empty sets <fr:tex display="inline">X</fr:tex>, there exists a function <fr:tex display="inline">f:X\to \bigcup  X</fr:tex> such that for any <fr:tex display="inline">x\in  X</fr:tex>, <fr:tex display="inline">f(x)\in  x</fr:tex>.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>560</fr:anchor><fr:addr type="user">def-002V</fr:addr><fr:route>def-002V.xml</fr:route><fr:title text="Set Operations">Set Operations</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">(X_i)_{i\in  I}</fr:tex> be a family of sets.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>561</fr:anchor><fr:addr type="machine">#238</fr:addr><fr:route>unstable-238.xml</fr:route><fr:title text="Union">Union</fr:title><fr:authors></fr:authors><fr:parent>def-002V</fr:parent></fr:frontmatter><fr:mainmatter><fr:p><fr:tex display="block">         \bigcup _{i\in  I}X_i = \set {x:\exists  i\in  I \text { such that } x\in  X_i}     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>562</fr:anchor><fr:addr type="machine">#239</fr:addr><fr:route>unstable-239.xml</fr:route><fr:title text="Intersection">Intersection</fr:title><fr:authors></fr:authors><fr:parent>def-002V</fr:parent></fr:frontmatter><fr:mainmatter><fr:p><fr:tex display="block">         \bigcap _{i\in  I}X_i = \set {x:\forall  i\in  I, x\in  X_i}     </fr:tex>
    Note that <fr:tex display="inline">I \neq  \emptyset </fr:tex> here.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>563</fr:anchor><fr:addr type="machine">#240</fr:addr><fr:route>unstable-240.xml</fr:route><fr:title text="Disjoint Union">Disjoint Union</fr:title><fr:authors></fr:authors><fr:parent>def-002V</fr:parent></fr:frontmatter><fr:mainmatter><fr:p><fr:tex display="block">         \bigsqcup _{i\in  I}X_i = \set {(x,i):x\in  X_i, i\in  I}     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>564</fr:anchor><fr:addr type="machine">#241</fr:addr><fr:route>unstable-241.xml</fr:route><fr:title text="Product">Product</fr:title><fr:authors></fr:authors><fr:parent>def-002V</fr:parent></fr:frontmatter><fr:mainmatter><fr:p><fr:tex display="block">         \prod _{i\in  I}X_i = \set {(x_i)_{i\in  I}:\forall  i\in  I, x_i\in  X_i}     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>And principles of set theory</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>565</fr:anchor><fr:addr type="user">def-000T</fr:addr><fr:route>def-000T.xml</fr:route><fr:title text="Principle of Extensionality">Principle of Extensionality</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Two sets are equal if and only if they have the same elements.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>566</fr:anchor><fr:addr type="user">def-000U</fr:addr><fr:route>def-000U.xml</fr:route><fr:title text="Principle of Comprehension">Principle of Comprehension</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given a set <fr:tex display="inline">A</fr:tex> and a property <fr:tex display="inline">P(x)</fr:tex>, there exists a set <fr:tex display="inline">B</fr:tex> such that
    <fr:tex display="inline">x\in  B \iff  x\in  A \land  P(x)</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We then define the Cartesian product of two sets</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>567</fr:anchor><fr:addr type="user">def-000V</fr:addr><fr:route>def-000V.xml</fr:route><fr:title text="Cartesian product">Cartesian product</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Given two sets <fr:tex display="inline">A</fr:tex> and <fr:tex display="inline">B</fr:tex>, the Cartesian product <fr:tex display="inline">A\times  B</fr:tex> is the set
    of all ordered pairs <fr:tex display="inline">(a,b)</fr:tex> where <fr:tex display="inline">a\in  A</fr:tex> and <fr:tex display="inline">b\in  B</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>With the Cartesian product, we can define the relation</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>568</fr:anchor><fr:addr type="user">def-000W</fr:addr><fr:route>def-000W.xml</fr:route><fr:title text="Relation">Relation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>relation</fr:strong> <fr:tex display="inline">R</fr:tex> is a subset of the Cartesian product of two sets <fr:tex display="inline">A</fr:tex> and
    <fr:tex display="inline">B</fr:tex>, i.e. <fr:tex display="inline">R\subseteq  A\times  B</fr:tex>.
    If <fr:tex display="inline">(a,b)\in  R</fr:tex>, we write <fr:tex display="inline">aRb</fr:tex>.

    A relation that between <fr:tex display="inline">X</fr:tex> and itself is called <fr:strong>homogeneous relation</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>569</fr:anchor><fr:addr type="user">def-000X</fr:addr><fr:route>def-000X.xml</fr:route><fr:title text="Equivalence Relation">Equivalence Relation</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An equivalence relation <fr:tex display="inline">R</fr:tex> on a set <fr:tex display="inline">A</fr:tex> is a <fr:link type="local" href="def-000W.xml" addr="def-000W" title="Relation">relation</fr:link> that is reflexive,
    symmetric, and transitive.
    <fr:ul><fr:li>Reflexive:
            <fr:tex display="inline">\forall  x\in  A, xRx</fr:tex></fr:li>
        <fr:li>Symmetric:
            <fr:tex display="inline">\forall  x,y\in  A, xRy\implies  yRx</fr:tex></fr:li>
        <fr:li>Transitive:
            <fr:tex display="inline">\forall  x,y,z\in  A, xRy\land  yRz\implies  xRz</fr:tex></fr:li></fr:ul>
    We often denote the equivalence relation by <fr:tex display="inline">\sim </fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>570</fr:anchor><fr:addr type="user">def-002U</fr:addr><fr:route>def-002U.xml</fr:route><fr:title text="Equivalence Class">Equivalence Class</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">\sim </fr:tex> be an <fr:link type="local" href="def-000X.xml" addr="def-000X" title="Equivalence Relation">equivalence relation</fr:link> on a set <fr:tex display="inline">A</fr:tex>.
    For any element <fr:tex display="inline">a\in  A</fr:tex>, the <fr:strong>equivalence class</fr:strong> of <fr:tex display="inline">a</fr:tex> is the set
    <fr:tex display="inline">[a] = \set {b\in  A:b\sim  a}</fr:tex>.
    The set of all equivalence classes is denoted by <fr:tex display="inline">A/\sim </fr:tex>,
    which is called the <fr:strong>quotient set</fr:strong> of <fr:tex display="inline">A</fr:tex> by <fr:tex display="inline">\sim </fr:tex>.
    <fr:p>The equivalence class of <fr:tex display="inline">a</fr:tex> is also denoted by <fr:tex display="inline">\overline {a}</fr:tex>.</fr:p></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>One of the most important relations is the order relation.
    The basic order relation is the preorder.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>571</fr:anchor><fr:addr type="user">def-000Z</fr:addr><fr:route>def-000Z.xml</fr:route><fr:title text="Preorder">Preorder</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>preorder</fr:strong> is a relation <fr:tex display="inline">\leq </fr:tex> that is reflexive and transitive.
    <fr:ul><fr:li>Reflexive: <fr:tex display="inline">a\leq  a</fr:tex></fr:li>
        <fr:li>Transitive: <fr:tex display="inline">a\leq  b</fr:tex> and <fr:tex display="inline">b\leq  c</fr:tex> implies <fr:tex display="inline">a\leq  c</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>572</fr:anchor><fr:addr type="user">def-000Y</fr:addr><fr:route>def-000Y.xml</fr:route><fr:title text="Partial Order">Partial Order</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>(non-strict) partial order</fr:strong> is a relation <fr:tex display="inline">\leq </fr:tex> that is reflexive, antisymmetric and transitive.
    <fr:ul><fr:li>Reflexive: <fr:tex display="inline">a\leq  a</fr:tex></fr:li>
        <fr:li>Antisymmetric: <fr:tex display="inline">a\leq  b</fr:tex> and <fr:tex display="inline">b\leq  a</fr:tex> implies <fr:tex display="inline">a=b</fr:tex></fr:li>
        <fr:li>Transitive: <fr:tex display="inline">a\leq  b</fr:tex> and <fr:tex display="inline">b\leq  c</fr:tex> implies <fr:tex display="inline">a\leq  c</fr:tex></fr:li></fr:ul>
    A non-strict partial order is also known as an antisymmetric <fr:link type="local" href="def-000Z.xml" addr="def-000Z" title="Preorder">preorder</fr:link>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>And the strict partial order (notice the difference between asymmetric and antisymmetric)</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>573</fr:anchor><fr:addr type="user">def-0010</fr:addr><fr:route>def-0010.xml</fr:route><fr:title text="Strict partial orders">Strict partial orders</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A strict partial order is a relation <fr:tex display="inline">&lt;</fr:tex> that is irreflexive, asymmetric and transitive.
    <fr:ul><fr:li>Irreflexive: <fr:tex display="inline">\neg (a&lt;a)</fr:tex></fr:li>
        <fr:li>Asymmetric: <fr:tex display="inline">a&lt;b</fr:tex> implies <fr:tex display="inline">\neg (b&lt;a)</fr:tex></fr:li>
        <fr:li>Transitive: <fr:tex display="inline">a&lt;b</fr:tex> and <fr:tex display="inline">b&lt;c</fr:tex> implies <fr:tex display="inline">a&lt;c</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>With the definition of order, we can define the upper bound and lower bound</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>574</fr:anchor><fr:addr type="user">def-0011</fr:addr><fr:route>def-0011.xml</fr:route><fr:title text="Upper Bound and Lower Bound">Upper Bound and Lower Bound</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let a subset <fr:tex display="inline">S</fr:tex> of a <fr:link type="local" href="def-000Y.xml" addr="def-000Y" title="Partial Order">partially ordered</fr:link> set <fr:tex display="inline">(P, \leq )</fr:tex>,
    <fr:tex display="inline">S</fr:tex> is bounded above if there exists <fr:tex display="inline">x \in  P</fr:tex> such that <fr:tex display="inline">\forall  y \in  S, y \leq  x</fr:tex>. And <fr:tex display="inline">x</fr:tex> is called an <fr:strong>upper bound</fr:strong> of <fr:tex display="inline">S</fr:tex>.
    Dually, <fr:tex display="inline">S</fr:tex> is bounded below if there exists <fr:tex display="inline">x \in  P</fr:tex> such that <fr:tex display="inline">\forall  y \in  S, x \leq  y</fr:tex>. And <fr:tex display="inline">x</fr:tex> is called a <fr:strong>lower bound</fr:strong> of <fr:tex display="inline">S</fr:tex>.</fr:p>
    <fr:p><fr:strong>Supremum (least upper bound)</fr:strong></fr:p>
    <fr:p>An element <fr:tex display="inline">x\in  P</fr:tex> is a supremum of <fr:tex display="inline">S</fr:tex>,
    if for all upper bounds <fr:tex display="inline">z \in  P</fr:tex> of <fr:tex display="inline">S</fr:tex>, <fr:tex display="inline">x \leq  z</fr:tex>.
    Denoted as <fr:tex display="inline">x = \sup  S</fr:tex>.</fr:p>
    <fr:p><fr:strong>Infimum (greatest lower bound)</fr:strong></fr:p>
    <fr:p>An element <fr:tex display="inline">x\in  P</fr:tex> is a infimum of <fr:tex display="inline">S</fr:tex>,
    if for all lower bounds <fr:tex display="inline">z \in  P</fr:tex> of <fr:tex display="inline">S</fr:tex>, <fr:tex display="inline">z \leq  x</fr:tex>.
    Denoted as <fr:tex display="inline">x = \inf  S</fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>575</fr:anchor><fr:addr type="user">def-002G</fr:addr><fr:route>def-002G.xml</fr:route><fr:title text="Function">Function</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets then a <fr:strong>function</fr:strong> <fr:tex display="inline">f:X \to  Y</fr:tex>
    is a mapping that sends each element of <fr:tex display="inline">X</fr:tex> to a unique element of <fr:tex display="inline">Y</fr:tex>,
    denoted by <fr:tex display="inline">f(x) = y</fr:tex>.
    Function is a special case of <fr:link type="local" href="def-000W.xml" addr="def-000W" title="Relation">relation</fr:link>, and it is a relation that is left-total and right-unique.
    <fr:tex display="block">         f \in  X \times  Y \text { and } \forall  x \in  X, \exists ! y \in  Y, (x,y) \in  f     </fr:tex>
    <fr:tex display="inline">X</fr:tex> is said to be the <fr:strong>domain</fr:strong> of <fr:tex display="inline">f</fr:tex> and <fr:tex display="inline">Y</fr:tex> is said to be the <fr:strong>codomain</fr:strong> of <fr:tex display="inline">f</fr:tex>,
    where we denote <fr:tex display="inline">X = \text {dom } f</fr:tex> and <fr:tex display="inline">Y = \text {cod } f</fr:tex>.</fr:p><fr:p>Two functions <fr:tex display="inline">f:X\to  Y</fr:tex> and <fr:tex display="inline">g:Y\to  Z</fr:tex> can be <fr:strong>composed</fr:strong> to form a new function <fr:tex display="inline">g \circ  f : X \to  Z</fr:tex>,
    where the composition is defined by
    <fr:tex display="block">         (g \circ  f)(x) = g(f(x))      </fr:tex></fr:p><fr:p>The set of all functions from <fr:tex display="inline">X</fr:tex> to <fr:tex display="inline">Y</fr:tex> is denoted by <fr:tex display="inline">\hom _\text {set}(X, Y)</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The isomorphism function is defined as follows</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>576</fr:anchor><fr:addr type="user">def-002H</fr:addr><fr:route>def-002H.xml</fr:route><fr:title text="Set Isomorphism">Set Isomorphism</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets and <fr:tex display="inline">f: X \to  Y</fr:tex> be a function.
    The function <fr:tex display="inline">f</fr:tex> is called an <fr:strong>isomorphism</fr:strong> if it is both <fr:link type="local" href="def-002D.xml" addr="def-002D" title="Injective">injective</fr:link> and <fr:link type="local" href="def-002F.xml" addr="def-002F" title="Surjective">surjective</fr:link>.
    In other words, there exists a function <fr:tex display="inline">g: Y \to  X</fr:tex> such that
    <fr:tex display="block">         g \circ  f = \text {id}_X \text { and } f \circ  g = \text {id}_Y     </fr:tex>
    where <fr:tex display="inline">\text {id}_X</fr:tex> and <fr:tex display="inline">\text {id}_Y</fr:tex> are the <fr:strong>identity functions</fr:strong> on <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> respectively.
    And we say <fr:tex display="inline">f</fr:tex> is <fr:strong>invertible</fr:strong> and <fr:tex display="inline">g</fr:tex> is the <fr:strong>inverse</fr:strong> of <fr:tex display="inline">f</fr:tex>.
    If there is a isomorphism between <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex>, we say <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> are <fr:strong>isomorphic</fr:strong>,
    denoted by <fr:tex display="inline">X \cong  Y</fr:tex>.
    Isomorphism is an <fr:link type="local" href="def-000X.xml" addr="def-000X" title="Equivalence Relation">equivalence relation</fr:link>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>With isomorphism, we can define the cardinality of a set.
    Two isomorphic sets have the same cardinality.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>577</fr:anchor><fr:addr type="user">def-002I</fr:addr><fr:route>def-002I.xml</fr:route><fr:title text="Cardinality">Cardinality</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">X</fr:tex> be a set and <fr:tex display="inline">n \in  \mathbb {N}</fr:tex>. 
    <fr:tex display="inline">A</fr:tex> si said to have <fr:strong>cardinality</fr:strong> <fr:tex display="inline">n</fr:tex>, denoted by <fr:tex display="inline"> |A|= n</fr:tex>,
    if there exists an isomorphism between <fr:tex display="inline">A</fr:tex> and <fr:tex display="inline">S_n = \{ 1,2,\cdots ,n \}</fr:tex>.
    If <fr:tex display="inline">A</fr:tex> has finite cardinality, we say <fr:tex display="inline">A</fr:tex> is <fr:strong>finite</fr:strong>, otherwise
    we say <fr:tex display="inline">A</fr:tex> is <fr:strong>infinite</fr:strong>, denoted by <fr:tex display="inline">|A| \geq  \infty </fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The next topic is the product of sets</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>578</fr:anchor><fr:addr type="user">def-002J</fr:addr><fr:route>def-002J.xml</fr:route><fr:title text="Product of Sets">Product of Sets</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets, then the <fr:strong>Cartesian product</fr:strong> of <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> is the set
    <fr:tex display="block">         X \times  Y = \set {(x,y) \mid  x \in  X \text { and } y \in  Y}     </fr:tex>
    There are two natural projections from the Cartesian product to the original sets, namely
    <fr:tex display="block">         \pi _1 : X \times  Y \to  X \text { and } \pi _2 : X \times  Y \to  Y     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>This leads to an improtant concept named <fr:strong>universal property</fr:strong>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>579</fr:anchor><fr:addr type="user">thm-000J</fr:addr><fr:route>thm-000J.xml</fr:route><fr:title text="Universal Property for Product of Sets">Universal Property for Product of Sets</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets.
    For any set <fr:tex display="inline">A</fr:tex> and function
    <fr:tex display="inline">f: A \to  X</fr:tex> and <fr:tex display="inline">g: A \to  Y</fr:tex>,
    there exists a <fr:em>unique</fr:em> function <fr:tex display="inline">h: A \to  X \times  Y</fr:tex> such that
    the following diagram commutes:
    
 
  
  <fr:figure><fr:embedded-tex hash="9ba405e4e358c864e44da11ca76259c7"><fr:embedded-tex-preamble>
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:embedded-tex-preamble><fr:embedded-tex-body>
        \begin {tikzcd}
            &amp; {X\times  Y} \\
            X &amp;&amp; Y \\
            &amp; A
            \arrow [&quot;{\pi _1}&quot;&apos;, from=1-2, to=2-1]
            \arrow [&quot;{\pi _2}&quot;, from=1-2, to=2-3]
            \arrow [&quot;f&quot;, from=3-2, to=2-1]
            \arrow [&quot;g&quot;&apos;, from=3-2, to=2-3]
            \arrow [&quot;{\exists !}&quot;, dashed, from=3-2, to=1-2]
        \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex></fr:figure>
 

    We might denote the unique function by <fr:tex display="inline">\langle  f,g \rangle : A \to  X \times  Y</fr:tex>.
    It is sufficient to define <fr:tex display="inline">\langle  f,g \rangle (a) = (f(a),g(a))</fr:tex> for all <fr:tex display="inline">a\in  A</fr:tex> as the unique function.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Dual to the product of sets, we have the coproduct of sets</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>580</fr:anchor><fr:addr type="user">def-002K</fr:addr><fr:route>def-002K.xml</fr:route><fr:title text="Coproduct of Sets">Coproduct of Sets</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets, then the <fr:strong>coproduct</fr:strong> of <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> is 
    defined as the <fr:strong>disjoint union</fr:strong> of <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex>, denoted by <fr:tex display="inline">X \sqcup  Y</fr:tex>.
    There are two natural injections from the original sets to the coproduct, namely
    <fr:tex display="block">         i_1 : X \to  X \sqcup  Y \text { and } i_2 : Y \to  X \sqcup  Y     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>581</fr:anchor><fr:addr type="user">thm-000K</fr:addr><fr:route>thm-000K.xml</fr:route><fr:title text="Universal Property for Coproduct of Sets">Universal Property for Coproduct of Sets</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">X</fr:tex> and <fr:tex display="inline">Y</fr:tex> be sets. For any set <fr:tex display="inline">A</fr:tex> and function
    <fr:tex display="inline">f : X \to  A</fr:tex> and <fr:tex display="inline">g : Y \to  A</fr:tex>, there exists a <fr:em>unique</fr:em> function
    <fr:tex display="inline">h : X \sqcup  Y \to  A</fr:tex> such that the following diagram commutes:
    
 
  
  <fr:figure><fr:embedded-tex hash="802eca83b7f60b7896d00f9b5aab0536"><fr:embedded-tex-preamble>
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:embedded-tex-preamble><fr:embedded-tex-body>
        \begin {tikzcd}
            &amp; A \\
            X &amp;&amp; Y \\
            &amp; {X\sqcup  Y}
            \arrow [&quot;{i_1}&quot;&apos;, from=2-1, to=3-2]
            \arrow [&quot;{i_2}&quot;, from=2-3, to=3-2]
            \arrow [&quot;f&quot;, from=2-1, to=1-2]
            \arrow [&quot;g&quot;&apos;, from=2-3, to=1-2]
            \arrow [&quot;{\exists !}&quot;, dashed, from=3-2, to=1-2]
        \end {tikzcd}   
    </fr:embedded-tex-body></fr:embedded-tex></fr:figure>
 

    We might denote the unique as <fr:tex display="inline">f\sqcup  g: X \sqcup  Y \to  A</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>In this section we discuss the <fr:em>limits</fr:em> of variously-shaped diagrams of sets.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>582</fr:anchor><fr:addr type="user">def-002L</fr:addr><fr:route>def-002L.xml</fr:route><fr:title text="Pullback of Sets">Pullback of Sets</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose we have sets <fr:tex display="inline">X</fr:tex>, <fr:tex display="inline">Y</fr:tex>, and <fr:tex display="inline">Z</fr:tex> and functions
    <fr:tex display="inline">f : X \to  Z</fr:tex> and <fr:tex display="inline">g : Y \to  Z</fr:tex>.
    
 
  
  <fr:figure><fr:embedded-tex hash="179973374472c6633715b15c33cf9265"><fr:embedded-tex-preamble>
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:embedded-tex-preamble><fr:embedded-tex-body>
        \begin {tikzcd}
            &amp; Y \\
            X &amp; Z
            \arrow [&quot;f&quot;&apos;, from=2-1, to=2-2]
            \arrow [&quot;g&quot;, from=1-2, to=2-2]
        \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex></fr:figure>
 

    Its <fr:strong>fiber product</fr:strong> is the set
    <fr:tex display="block">         X \times _Z Y = \{ (x,w,y) \mid  f(x) = w = g(y) \}     </fr:tex>
    There are obvious projections 
    <fr:tex display="inline">         \pi _1 : X \times _Z Y \to  X \text { and } \pi _2 : X \times _Z Y \to  Y     </fr:tex>
    such that the following diagram commutes (<fr:tex display="inline">W = X \times _Z Y</fr:tex>):
    
 
  
  <fr:figure><fr:embedded-tex hash="33e973b1d56e296b3f27cfc09159319a"><fr:embedded-tex-preamble>
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:embedded-tex-preamble><fr:embedded-tex-body>
        \begin {tikzcd}
            W &amp; Y \\
            X &amp; Z
            \arrow [&quot;f&quot;&apos;, from=2-1, to=2-2]
            \arrow [&quot;g&quot;, from=1-2, to=2-2]
            \arrow [&quot;{\pi _2}&quot;, from=1-1, to=1-2]
            \arrow [&quot;{\pi _1}&quot;&apos;, from=1-1, to=2-1]
            \arrow [&quot;\lrcorner &quot;{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
        \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex></fr:figure>
 

    The <fr:strong>pullback</fr:strong> is defined to be any set <fr:tex display="inline">W \cong  X\times _Z Y</fr:tex>
    The corner symbol indicates <fr:tex display="inline">W</fr:tex> is a <fr:em>pullback</fr:em></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The pullback also satisfies the universal property.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>583</fr:anchor><fr:addr type="user">thm-000L</fr:addr><fr:route>thm-000L.xml</fr:route><fr:title text="Universal Property for Pullback">Universal Property for Pullback</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose the given diagram:
    
 
  
  <fr:figure><fr:embedded-tex hash="d9f72c148652739e355c6d8353f8d3f1"><fr:embedded-tex-preamble>
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:embedded-tex-preamble><fr:embedded-tex-body>
        \begin {tikzcd}
            &amp; Y \\
            X &amp; Z
            \arrow [&quot;t&quot;&apos;, from=2-1, to=2-2]
            \arrow [&quot;u&quot;, from=1-2, to=2-2]
        \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex></fr:figure>
 

    For any set <fr:tex display="inline">A</fr:tex> and commutative solid arrow diagram as below
    (functions <fr:tex display="inline">f:A\to  X</fr:tex> and <fr:tex display="inline">g:A\to  Y</fr:tex> such that <fr:tex display="inline">t\circ  f = u\circ  g</fr:tex>):
    
 
  
  <fr:figure><fr:embedded-tex hash="5b8063571f0aec7fb4d00cd1da1d9244"><fr:embedded-tex-preamble>
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:embedded-tex-preamble><fr:embedded-tex-body>
        \usetikzlibrary {arrows}
        \begin {tikzcd}
            &amp; {X\times _ZY} \\
            \\
            &amp; A \\
            X &amp;&amp; Y \\
            &amp; Z
            \arrow [&quot;f&quot;&apos;, from=3-2, to=4-1]
            \arrow [&quot;g&quot;, from=3-2, to=4-3]
            \arrow [&quot;t&quot;&apos;, from=4-1, to=5-2]
            \arrow [&quot;u&quot;, from=4-3, to=5-2]
            \arrow [&quot;{\exists !}&quot;, dashed, from=3-2, to=1-2]
            \arrow [&quot;{\pi _1}&quot;&apos;, bend right, from=1-2, to=4-1]
	        \arrow [&quot;{\pi _2}&quot;, bend left, from=1-2, to=4-3]
        \end {tikzcd}
    </fr:embedded-tex-body></fr:embedded-tex></fr:figure>
 

    there exists a <fr:em>unique</fr:em> arrow <fr:tex display="inline">\langle  f,g \rangle _Z: A\to  X\times _Z Y</fr:tex> such that
    <fr:tex display="block">         \pi _1\circ \langle  f,g \rangle _Z = f \text { and } \pi _2\circ \langle  f,g \rangle _Z = g     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title text="Backlinks">Backlinks</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1604</fr:anchor><fr:addr type="user">cs-0008</fr:addr><fr:route>cs-0008.xml</fr:route><fr:title text="Algebraic Graphs">Algebraic Graphs</fr:title><fr:taxon>Graph Theory</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This post focus on the the algebra of graphs introduced in paper <fr:strong>Algebraic graphs with class (functional pearl)</fr:strong>,
    which built on rigorous mathematical foundation that allows us to apply equational reasoning for proving the correctness of graph transformation algorithms.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>385</fr:anchor><fr:addr type="machine">#336</fr:addr><fr:route>unstable-336.xml</fr:route><fr:title text="Introduction to Graphs">Introduction to Graphs</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0008</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Graphs are ubiquitous in computing. Roughly speaking, a graph is a collection of vertices and edges, where each edge connects two vertices.
        For the most trivial case, a graph is an ordered pair <fr:tex display="inline"> G=(V,E)</fr:tex> comprising:
        <fr:ul><fr:li><fr:tex display="inline"> V </fr:tex> is a set of vertices.</fr:li>
            <fr:li><fr:tex display="inline"> E \subseteq  \{ (x,y) \mid  x, y \in  V\} </fr:tex> is a set of edges.</fr:li></fr:ul>
        We can define a graph type in some programming languages (e.g. Haskell) as:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Graph a = Graph [a] [(a, a)]</html:code></fr:pre>

        Work with such low-level fiddling with sets of vertices and edges is very painful. And we can easily construct a graph that breaks the invariant of the graph structure like <fr:code>Graph [1] [(1,2)]</fr:code> which has an edge connecting a non-existent vertex.</fr:p><fr:p>How the state-of-art libraries deal with this problem? 
        The <fr:strong>container</fr:strong> library in Haskell provides a type <fr:code>Data.Graph</fr:code> which represents graph using adjacency array:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">type Graph a = Array a [a]</html:code></fr:pre>

        which ensures performance and generality. But the consistency invariant is not <fr:strong>statically</fr:strong> checked, which may lead
        to runtime errors like <fr:code>index out of ranges</fr:code>. Another approach is the <fr:strong>fgl</fr:strong> (Martin Erwig&apos;s Functional Graph Library)
        where the graph is introduced as an <fr:strong>inductive type</fr:strong>. The approach is very complex and its API contains partial functions.
        So is there a <fr:strong>safe</fr:strong> graph construction interface we can build on top?</fr:p><fr:p><fr:strong>Andrey Mokhov</fr:strong>&apos;s paper presents a new interface for constructing and transforming graphs in a safe and convenient manner.
        And abstract away from the actual representation details and characterize graphs by a set of axioms, just like numbers are algebraically characterized
        by rings. The core calculus is based on the algebra of parameterized graphs. Algebraic graphs have a safe and minimalistic core of four graph construction primitives, as captured by the following data type:
        
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Graph a
    = Empty
    | Vertex a
    | Overlay (Graph a) (Graph a)
    | Connect (Graph a) (Graph a)</html:code></fr:pre></fr:p><fr:p>The <fr:code>Empty</fr:code> and <fr:code>Vertex</fr:code> construct the empty and single-vertex graphs respectively. <fr:code>Overlay</fr:code> composes two graphs by taking the union of their vertices and edges, and <fr:code>Connect</fr:code> is similar to <fr:code>Overlay</fr:code> but also creates edges between vertices of the two graphs. 
        
        The overlay and connect operations have three properties:
        <fr:ul><fr:li>(Closure)  They are closed on the set of graphs (all total functions)</fr:li>
            <fr:li>(Complete) They can be used to construct any graph starting from the empty and single-vertex graphs</fr:li>
            <fr:li>(Sound) Malformed graphs are impossible to construct</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>389</fr:anchor><fr:addr type="machine">#337</fr:addr><fr:route>unstable-337.xml</fr:route><fr:title text="Core of Algebraic Graphs">Core of Algebraic Graphs</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0008</fr:parent></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>390</fr:anchor><fr:addr type="machine">#338</fr:addr><fr:route>unstable-338.xml</fr:route><fr:title text="Graph Construction">Graph Construction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#337</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>The simplest possible graph is the empty graph. We denote it by <fr:tex display="inline"> \epsilon  = (\varnothing , \varnothing ) </fr:tex>.
            A graph with a single vertex is <fr:tex display="inline"> \text {Vertex} x = (\{x\}, \varnothing ) </fr:tex>.
            To construct larger graphs from the above primitives we define binary operations overlay and connect, denoted by <fr:tex display="inline"> + </fr:tex> and <fr:tex display="inline"> \to  </fr:tex> respectively.
            The overlay operation <fr:tex display="inline"> + </fr:tex> is defined as:
            <fr:tex display="block">                 (V_1, E_1) + (V_2, E_2) = (V_1 \cup  V_2, E_1 \cup  E_2)             </fr:tex>
            The connect operation <fr:tex display="inline"> \to  </fr:tex> is defined similarly (We give it a higher precedence than <fr:tex display="inline"> + </fr:tex>):
            <fr:tex display="block">                 (V_1, E_1) \to  (V_2, E_2) = (V_1 \cup  V_2, E_1 \cup  E_2 \cup  V_1 \times  V_2)             </fr:tex></fr:p><fr:p>As shown above, the core can be represented by a simple data type <fr:code>Graph</fr:code>, parameterized by the type of vertices <fr:code>a</fr:code>.
            We can push this further by defining a type class <fr:code>GraphLike</fr:code> that captures the core operations of the algebraic graph.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>391</fr:anchor><fr:addr type="machine">#339</fr:addr><fr:route>unstable-339.xml</fr:route><fr:title text="Type Class">Type Class</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#337</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>We abstract the graph construction primitives defined above as the type class Graph (Note that assocaited types requires <fr:code>TypeFamilies</fr:code> GHC extension):
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">class Graph g where
    type Vertex g
    empty :: g
    vertex :: Vertex g -&gt; g
    overlay :: g -&gt; g -&gt; g
    connect :: g -&gt; g -&gt; g</html:code></fr:pre></fr:p><fr:p>This interface is very simple and easy to use, which allows fewer opportunities for usage errors and greater opportunities for reuse.
            Now let&apos;s create some functions to construct graphs. For instance, a single edge is obtained by connecting two vertices:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">edge :: (Graph g) =&gt; Vertex g -&gt; Vertex g -&gt; g
edge x y = connect (vertex x) (vertex y)</html:code></fr:pre></fr:p><fr:p>A graph that contains a given list of isolated vertices can be constructed as follows:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">vertices :: Graph g =&gt; [Vertex g] -&gt; g
vertices = foldr (overlay . vertex) empty</html:code></fr:pre>

            which turns each vertex into a singleton graph and overlay the results. By replacing the 
            <fr:code>overlay</fr:code> with <fr:code>connect</fr:code> we can construct a full connected graph.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">clique :: (Graph g) =&gt; [Vertex g] -&gt; g
clique = foldr (connect . vertex) empty</html:code></fr:pre></fr:p><fr:p>The graph construction functions defined above are total, fully polymorphic, and elegant. 
            Thanks to the minimalistic core type class, it is easy to wrap our favourite graph library into the described interface, 
            and reuse the functions defined with graph class.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>396</fr:anchor><fr:addr type="machine">#340</fr:addr><fr:route>unstable-340.xml</fr:route><fr:title text="Algebraic Structure">Algebraic Structure</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0008</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>In this section we characterise the <fr:code>Graph</fr:code> type class with a set of axioms that reveal an algebraic structure very similar to a semiring. This provides a convenient framework for proving graph properties, using equational reasoning. The presented characterization is generally useful for formal verification, as well as automated testing of graph library APIs.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>397</fr:anchor><fr:addr type="machine">#341</fr:addr><fr:route>unstable-341.xml</fr:route><fr:title text="Axioms">Axioms</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#340</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Notice that the <fr:code>clique</fr:code> and <fr:code>vertices</fr:code> functions use <fr:tex display="inline">\epsilon </fr:tex> as the identity element for the overlay and connect operation respectively.
            Further more we can verify:
            <fr:ul><fr:li><fr:tex display="inline">(G,+,\epsilon )</fr:tex> is an idempotent commutative monoid.</fr:li>
                <fr:li><fr:tex display="inline">(G,\to ,\epsilon )</fr:tex> is a monoid.</fr:li>
                <fr:li><fr:tex display="inline">\to </fr:tex> distributes over <fr:tex display="inline">+</fr:tex>.</fr:li></fr:ul>
            This looks like a semiring, but the identity element are shared between the two operations. 
            What makes the algebra of graphs different is the <fr:strong>decomposition law</fr:strong>:
            <fr:tex display="block">                 x \to  y \to  z = x \to  y + x \to  z + y \to  z             </fr:tex>
            Interestingly, the fact that overlay and connect share the same identity follows from the decomposition law.
            Furthermore, the identity (<fr:tex display="inline">x + \epsilon  = x</fr:tex>) and idempotence (<fr:tex display="inline">x + x = x</fr:tex>) can also be proved from the decomposition law.
            Hence we get a minimal set (8) of axioms that characterize the algebraic graphs.
            <fr:ul><fr:li><fr:tex display="inline">+</fr:tex> is commutative and associative: <fr:tex display="inline">x + y = y + x</fr:tex> and <fr:tex display="inline">(x + y) + z = x + (y + z)</fr:tex></fr:li>
                <fr:li><fr:tex display="inline">(G,\to ,\epsilon )</fr:tex> is a monoid, i.e. <fr:tex display="inline">x \to  y \to  z = x \to  (y \to  z)</fr:tex> and <fr:tex display="inline">\epsilon  \to  x = x, x \to  \epsilon  = x</fr:tex></fr:li>
                <fr:li><fr:tex display="inline">\to </fr:tex> distributes over <fr:tex display="inline">+</fr:tex>: <fr:tex display="inline">(x + y) \to  z = x \to  z + y \to  z</fr:tex></fr:li>
                <fr:li>Decomposition law: <fr:tex display="inline">x \to  y \to  z = x \to  y + x \to  z + y \to  z</fr:tex></fr:li></fr:ul>
            By adding more axioms we can obtain more complex graphs such as directed graphs, hypergraphs, etc.</fr:p><fr:p>Algebraic graphs are <fr:strong>complete</fr:strong> in the sense that it is possible to describe any graph using the core interface. Indeed, given a graph <fr:tex display="inline">G=(V , E)</fr:tex> we can construct it as <fr:code>graph V E</fr:code>, where the function <fr:code>graph</fr:code> is defined as follows.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">graph :: (Graph g) =&gt; [Vertex g] -&gt; [(Vertex g, Vertex g)] -&gt; g
graph vs es = overlay (vertices vs) (edges es)</html:code></fr:pre>

            where <fr:code>edges</fr:code> is defined as:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">edges :: (Graph g) =&gt; [(Vertex g, Vertex g)] -&gt; g
edges = foldr (overlay . uncurry edge) empty</html:code></fr:pre>

            The absorption theorem <fr:tex display="inline">x \to  y + x + y = x \to  y</fr:tex>, derived from decomposition of <fr:tex display="inline">x \to  y \to  \epsilon </fr:tex>, states that an edge <fr:tex display="inline">(u, v)</fr:tex> 
            contains its two vertices <fr:tex display="inline">u, v</fr:tex> and is inseparable from them. Therefore, if the pair <fr:tex display="inline">(V , E)</fr:tex> is inconsistent, the set of vertices <fr:tex display="inline">V</fr:tex> 
            will be expanded to <fr:tex display="inline">\hat {V}</fr:tex> so that <fr:tex display="inline">E\subseteq  \hat {V} \times  \hat {V}</fr:tex> holds. More generally, the absorption theorem states that in 
            addition to being complete, the algebraic graph API is also sound in the sense that it is impossible to construct an inconsistent pair
            <fr:tex display="inline">(V , E)</fr:tex> using the four Graph methods.</fr:p><fr:p>There are many other interesting properties of algebraic graphs can be proved using the axioms:
            <fr:ul><fr:li>(Overlay Identity) <fr:tex display="inline">x + \epsilon  = x</fr:tex></fr:li>
                <fr:li>(Overlay Idempotence) <fr:tex display="inline">x + x = x</fr:tex></fr:li>
                <fr:li>(Absorption) <fr:tex display="inline">x \to  y + x + y = x \to  y</fr:tex></fr:li>
                <fr:li>(Saturation) <fr:tex display="inline">x \to  x \to  x = x \to  x</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>400</fr:anchor><fr:addr type="machine">#342</fr:addr><fr:route>unstable-342.xml</fr:route><fr:title text="Partial Order">Partial Order</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#340</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>It is fairly standard to define <fr:tex display="inline">x \leq  y</fr:tex> as <fr:tex display="inline">x + y = y</fr:tex> for an idempotent operation <fr:tex display="inline">+</fr:tex>, since it gives a <fr:link type="local" href="def-000Y.xml" addr="def-000Y" title="Partial Order">partial order</fr:link> on the elements of the algebra. Formally we call this definition the <fr:strong>subgraph</fr:strong> relation. Therefore, we can check if a graph is a subgraph of another one if we know how to compare graphs for equality.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">isSubgraphOf :: (Graph g, Eq g) =&gt; g -&gt; g -&gt; Bool
isSubgraphOf x y = overlay x y == y</html:code></fr:pre></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>402</fr:anchor><fr:addr type="machine">#343</fr:addr><fr:route>unstable-343.xml</fr:route><fr:title text="Graphs  la Carte">Graphs  la Carte</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>cs-0008</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Now we define some instances of the Grpah, and extend the axioms to construct more complex graphs.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>403</fr:anchor><fr:addr type="machine">#344</fr:addr><fr:route>unstable-344.xml</fr:route><fr:title text="Binary Relation">Binary Relation</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:authors></fr:authors><fr:parent>#343</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>We start by a direct encoding of the graph construction primitives defined into the abstract data type <fr:code>Relation</fr:code> isomorphic to a pair of sets <fr:tex display="inline">(V , E)</fr:tex>: 
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">data Relation a = R {domain :: Set a, relation :: Set (a, a)} deriving (Eq)

instance (Ord a) =&gt; Graph (Relation a) where
    type Vertex (Relation a) = a
    empty = R Set.empty Set.empty
    vertex x = R (singleton x) Set.empty
    overlay x y = R (domain x `union` domain y) (relation x `union` relation y)
    connect x y =
        R (domain x `union` domain y)
        ( relation x
            `union` relation y
            `union` fromAscList [(a, b) | a &lt;- elems (domain x), b &lt;- elems (domain y)]
        )</html:code></fr:pre>

            As we have seen, this implementation satisfies the axioms of the graph algebra. Furthermore, it is a free graph in the sense that it does not satisfy any other laws. This follows from the fact that any algebraic graph expression <fr:tex display="inline">g</fr:tex> can be rewritten in the following canonical form:
            <fr:tex display="block">                 g = \left ( \sum _{v\in  V_g} v \right ) + \left ( \sum _{(u,v)\in  E_g} u \to  v \right )             </fr:tex>
            The existence of the canonical form was proved by <fr:strong>Mokhov</fr:strong> in <fr:em>Algebra of Parameterised Graphs</fr:em> for an extended version of the algebra.
            The core idea is to repeatedly apply the decomposition law to rewrite the graph expression in the form of the above equation,
            until no further decomposition is possible.</fr:p><fr:p>It will be convenient to make <fr:code>Relation</fr:code> an instance of <fr:code>Num</fr:code> type class.
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">instance (Ord a, Num a) =&gt; Num (Relation a) where
    fromInteger = vertex . fromInteger
    (+) = overlay
    (*) = connect
    signum = const empty
    abs = id
    negate = id</html:code></fr:pre>

            With these setups we can use the standard <fr:tex display="inline">+</fr:tex> and <fr:tex display="inline">\times </fr:tex> operators as shortcuts for overlay and connect respectively.
            Note that the Num law <fr:code>abs x * signum x == x</fr:code> is satisfied by the above definition since <fr:tex display="inline">x \to  \epsilon  = x</fr:tex>.
            Any Graph instance can be made an instance of <fr:code>Num</fr:code> if needed.</fr:p><fr:p>Now let&apos;s try to construct some graphs using the <fr:code>Relation</fr:code> type and the <fr:code>Num</fr:code> instance:
            
  <fr:pre><html:code xmlns:html="http://www.w3.org/1999/xhtml" class="language-haskell">ghci&gt; 1 * (2 + 3) :: Relation Int
R {domain = fromList [1,2,3], relation = fromList [(1,2),(1,3)]}
ghci&gt; 1 * 2 * 3 :: Relation Int
R {domain = fromList [1,2,3], relation = fromList [(1,2),(1,3),(2,3)]}</html:code></fr:pre></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1605</fr:anchor><fr:addr type="user">def-0011</fr:addr><fr:route>def-0011.xml</fr:route><fr:title text="Upper Bound and Lower Bound">Upper Bound and Lower Bound</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let a subset <fr:tex display="inline">S</fr:tex> of a <fr:link type="local" href="def-000Y.xml" addr="def-000Y" title="Partial Order">partially ordered</fr:link> set <fr:tex display="inline">(P, \leq )</fr:tex>,
    <fr:tex display="inline">S</fr:tex> is bounded above if there exists <fr:tex display="inline">x \in  P</fr:tex> such that <fr:tex display="inline">\forall  y \in  S, y \leq  x</fr:tex>. And <fr:tex display="inline">x</fr:tex> is called an <fr:strong>upper bound</fr:strong> of <fr:tex display="inline">S</fr:tex>.
    Dually, <fr:tex display="inline">S</fr:tex> is bounded below if there exists <fr:tex display="inline">x \in  P</fr:tex> such that <fr:tex display="inline">\forall  y \in  S, x \leq  y</fr:tex>. And <fr:tex display="inline">x</fr:tex> is called a <fr:strong>lower bound</fr:strong> of <fr:tex display="inline">S</fr:tex>.</fr:p>
    <fr:p><fr:strong>Supremum (least upper bound)</fr:strong></fr:p>
    <fr:p>An element <fr:tex display="inline">x\in  P</fr:tex> is a supremum of <fr:tex display="inline">S</fr:tex>,
    if for all upper bounds <fr:tex display="inline">z \in  P</fr:tex> of <fr:tex display="inline">S</fr:tex>, <fr:tex display="inline">x \leq  z</fr:tex>.
    Denoted as <fr:tex display="inline">x = \sup  S</fr:tex>.</fr:p>
    <fr:p><fr:strong>Infimum (greatest lower bound)</fr:strong></fr:p>
    <fr:p>An element <fr:tex display="inline">x\in  P</fr:tex> is a infimum of <fr:tex display="inline">S</fr:tex>,
    if for all lower bounds <fr:tex display="inline">z \in  P</fr:tex> of <fr:tex display="inline">S</fr:tex>, <fr:tex display="inline">z \leq  x</fr:tex>.
    Denoted as <fr:tex display="inline">x = \inf  S</fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title text="Related">Related</fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1606</fr:anchor><fr:addr type="user">def-000Z</fr:addr><fr:route>def-000Z.xml</fr:route><fr:title text="Preorder">Preorder</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>preorder</fr:strong> is a relation <fr:tex display="inline">\leq </fr:tex> that is reflexive and transitive.
    <fr:ul><fr:li>Reflexive: <fr:tex display="inline">a\leq  a</fr:tex></fr:li>
        <fr:li>Transitive: <fr:tex display="inline">a\leq  b</fr:tex> and <fr:tex display="inline">b\leq  c</fr:tex> implies <fr:tex display="inline">a\leq  c</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:backmatter></fr:tree>