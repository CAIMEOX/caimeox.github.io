<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>847</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001T</fr:addr><fr:route>def-001T.xml</fr:route><fr:title>Dependent Function Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Formation Rule</fr:strong>
    For any type family <fr:tex>B</fr:tex> over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>:
    <fr:tex display="block">          \frac {              \Gamma ,x:A \vdash  B(x) \space \text {type}          }{              \Gamma \vdash   \Pi _{(x:A)}B(x) \space \text {type}          } \Pi      </fr:tex>
    We also require that the operation of forming dependent function types
    respects judgmental equality.
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \equiv  A&apos; \space \text {type}               \quad               \Gamma ,x:A \vdash  B(x) \equiv  B&apos;(x) \space \text {type}          }{              \Gamma \vdash   \Pi _{(x:A)}B(x) \equiv   \Pi _{(x:A&apos;)}B&apos;(x) \space \text {type}          } \Pi \text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Introduction Rule (<fr:tex>\lambda</fr:tex>-abstraction)</fr:strong>
    In order to construct a dependent function we have to
    construct a term <fr:tex>f(x):B(x)</fr:tex> indexed by <fr:tex>x:A</fr:tex> in context <fr:tex>\Gamma</fr:tex>:
    <fr:tex display="block">          \frac {              \Gamma ,x:A \vdash  b(x):B(x)         }{              \Gamma \vdash   \lambda  x.b(x): \Pi _{(x:A)}B(x)         } \lambda      </fr:tex>
    And the congruence rule:
    <fr:tex display="block">          \frac {              \Gamma ,x:A \vdash  b(x) \equiv  b&apos;(x):B(x)         }{              \Gamma \vdash   \lambda  x.b(x) \equiv   \lambda  x.b&apos;(x): \Pi _{(x:A)}B(x)         } \lambda \text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Elimination Rule (Evaluation Rule)</fr:strong>
    In order to use dependent function we need to provide an argument of the domain type.
    <fr:tex display="block">          \frac {              \Gamma \vdash  f: \Pi _{(x:A)}B(x)         }{              \Gamma ,x:A \vdash  f(x):B(x)         }ev     </fr:tex>
    Again we require the judgmental equality to be respected:
    <fr:tex display="block">          \frac {              \Gamma \vdash  f \equiv  f&apos;: \Pi _{(x:A)}B(x)         }{              \Gamma ,x:A \vdash  f(x) \equiv  f&apos;(x):B(x)         }ev \text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Computation Rule (<fr:tex>\beta</fr:tex>-reduction)</fr:strong>
    <fr:tex display="block">          \frac {              \Gamma ,x:A \vdash  b(x):B(x)         }{              \Gamma ,x:A \vdash  ( \lambda  y.b(y))(x) \equiv  b(x):B(x)         } \beta      </fr:tex>
    We postulate that all elements of a dependent function type are dependent functions.
    <fr:tex display="block">          \frac {              \Gamma \vdash  f: \Pi _{(x:A)}B(x)         }{              \Gamma \vdash  f \equiv   \lambda  x.f(x): \Pi _{(x:A)}B(x)         } \eta      </fr:tex></fr:p></fr:mainmatter><fr:backmatter><fr:contributions></fr:contributions><fr:context><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>846</fr:anchor><fr:taxon>Type Theory</fr:taxon><fr:addr>tt-0002</fr:addr><fr:route>tt-0002.xml</fr:route><fr:title>Introduction to Type Theory</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>This is a note on dependent type theory. Refer to <fr:link href="hott-book-2013.xml" type="local" addr="hott-book-2013">HoTT Book</fr:link> and <fr:link href="hott-2022.xml" type="local" addr="hott-2022">Egbert Rijke&apos;s</fr:link>.</fr:p><fr:p><fr:strong>Homotopy type theory</fr:strong> is a foundational language for mathematics, an alternative to Zermelo-Fraenkel set theory.
    The set-theoretic foundation has two two layers:
    <fr:ul><fr:li>the deductive system of first-order logic</fr:li>
        <fr:li>the theory of a particular theory, such as ZFC</fr:li></fr:ul> 
    Type theory itself is a deductive system, which has one basic notation: <fr:em>types</fr:em>.
    Propositions are identified with types.
    
    Thus, the activity of proving a theorem is identified with 
    constructing a <fr:em>inhabitant</fr:em> of a certain type.
</fr:p><fr:p>
    Informally, a deductive system is a collection of rules for deriving <fr:strong>judgments</fr:strong>. 
    The judgment is considered to be the external of the theory, living in the <fr:strong>metatheory</fr:strong>.
</fr:p><fr:p>
    In first order logic, there is only one kind of judgment: a proposition has a proof.
    A proposition <fr:tex>P</fr:tex> gives rise to a judgment &quot;<fr:tex>P</fr:tex> has a proof&quot;.
    The proposition <fr:tex>P</fr:tex> lives inside the theory, while the judgment &quot;<fr:tex>P</fr:tex> has a proof&quot; lives in the metatheory. 
</fr:p><fr:p>
    In type theory, analogous to first order logic,
    &quot;<fr:tex>P</fr:tex> has a proof&quot; is written as &quot;<fr:tex>p:P</fr:tex>&quot; (Type <fr:tex>P</fr:tex> has a term <fr:tex>p</fr:tex>).
    <fr:ul><fr:li>If <fr:tex>P</fr:tex> is a proposition, then <fr:tex>p</fr:tex> is a <fr:strong>witness</fr:strong> to the provability of <fr:tex>P</fr:tex>, 
        or <fr:strong>evidence</fr:strong> of the truth of <fr:tex>P</fr:tex>.</fr:li>
        <fr:li><fr:tex>p:P</fr:tex> can also be interpreted as <fr:tex>p \in  P</fr:tex>,
        but <fr:tex>p:P</fr:tex> is a judgment while <fr:tex>p \in  P</fr:tex> is a proposition.</fr:li></fr:ul>
    Working inside type theory we can&apos;t write down statements like
    &quot;if <fr:tex>p:P</fr:tex> then ...&quot; nor can we disprove the judgment &quot;<fr:tex>p:P</fr:tex>&quot;.
</fr:p><fr:p>
    A key difference between type theory and set theory is the equality.
    The notion of equality in set theory is simply a proposition.
    Howerver, in type theory, there are two kinds of equality.
    <fr:ul><fr:li>The first kind is the <fr:strong>propositional equality</fr:strong> <fr:tex>a=_Ab</fr:tex>.
        This is a proposition</fr:li>
        <fr:li>The second kind is the <fr:strong>judgmental equality</fr:strong> <fr:tex>a \equiv  b:A</fr:tex>.
        This is a judgment</fr:li></fr:ul>
    Two terms <fr:tex>a:A</fr:tex> and <fr:tex>b:A</fr:tex> are propositionally equal if you can prove <fr:tex>a =_A b</fr:tex> , 
    or equivalently if you can construct a term <fr:tex>h : a =_A b</fr:tex>.
</fr:p>
    <fr:p>
        In type theory there is also a requirement for a judgment-level equality.
        This is called <fr:strong>judgmental equality</fr:strong>, meaning &quot;equal by definition&quot;.
    </fr:p>
    <fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>522</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0015</fr:addr><fr:route>def-0015.xml</fr:route><fr:title>Judgemental Equality</fr:title></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Judgemental equality</fr:strong> of terms is given by the following judgement:
    <fr:tex display="block">          \Gamma \vdash  a \equiv  a&apos;:A     </fr:tex>
    <fr:tex>a</fr:tex> and <fr:tex>a&apos;</fr:tex> are judgementally equal terms of type <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>.
</fr:p><fr:p>
    Note that the notation <fr:tex>\equiv</fr:tex> binds more loosely than anything else.
</fr:p></fr:mainmatter></fr:tree>
    <fr:p>
        judgments may depend on <fr:em>assumptions</fr:em> of the form <fr:tex>x:A</fr:tex> where <fr:tex>x</fr:tex> is a
        variable and <fr:tex>A</fr:tex> is a type. And the collection (actually ordered list) of such assumptions is called 
        the <fr:strong>context</fr:strong>, denoted <fr:tex>\Gamma</fr:tex>. (from a topological point of view it 
        may be thought of as a <fr:strong>parameters space</fr:strong>).
        The role of a context is to declare what <fr:strong>hypothetical terms</fr:strong> are assumed, 
        along with their types.
        The notation <fr:tex>\vdash</fr:tex> means making conclusion from assumptions.
    </fr:p>
<fr:p>
    Remember the difference between axiom and (inference) rules.
    <fr:ul><fr:li>Rules allow us to conclude one judgment from a collection of other judgments.</fr:li>
        <fr:li>Axioms are judgments that are assumed to be true without proof.</fr:li></fr:ul></fr:p><fr:p>
    We start by introduction to Matrin Lof&apos;s dependent type theory. 
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>523</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0017</fr:addr><fr:route>def-0017.xml</fr:route><fr:title>Dependent type theory: Judgments</fr:title></fr:frontmatter><fr:mainmatter>
    <fr:p>
        There are four kinds of judgments in Martin Lof&apos;s dependent type theory:
    </fr:p>
    <fr:ul><fr:li><fr:tex>A</fr:tex> is a well-formed type in context <fr:tex>\Gamma</fr:tex>
            <fr:tex display="block">                  \Gamma   \vdash  A  \space \text {type}              </fr:tex></fr:li>
        <fr:li><fr:tex>A</fr:tex> and <fr:tex>B</fr:tex> are judgmentally equal types in context <fr:tex>\Gamma</fr:tex>
            <fr:tex display="block">                  \Gamma   \vdash  A  \equiv  B  \space \text {type}              </fr:tex></fr:li>
        <fr:li><fr:tex>a</fr:tex> is a term of type <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>
            <fr:tex display="block">                  \Gamma   \vdash  a : A             </fr:tex></fr:li>
        <fr:li><fr:tex>a</fr:tex> and <fr:tex>b</fr:tex> are judgmentally equal terms of type <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>
            <fr:tex display="block">                  \Gamma   \vdash  a  \equiv  b : A             </fr:tex></fr:li></fr:ul>
</fr:mainmatter></fr:tree><fr:p>
    All judgments are context dependent, 
    and indeed that even the types of the variables in a context
    may depend on any previous declared variables.

    To introduce types dependent on terms, 
    we need the notation of type families.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>524</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0018</fr:addr><fr:route>def-0018.xml</fr:route><fr:title>Type Family</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Consider a type <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>.
    A <fr:strong>family</fr:strong> of types over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>
    is a type <fr:tex>B(x)</fr:tex> in context <fr:tex>\Gamma , x:A</fr:tex>.
    <fr:tex display="block">          \Gamma , x:A  \vdash  B(x)  \space \text {type}      </fr:tex>
    <fr:tex>B</fr:tex> is a family of types over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>.
    Alternatively, we say that <fr:tex>B(x)</fr:tex> is a type <fr:strong>indexed</fr:strong> by <fr:tex>x:A</fr:tex> in context <fr:tex>\Gamma</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    Now we can define a term of a type family, that is, a section of a type family.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>525</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-0019</fr:addr><fr:route>def-0019.xml</fr:route><fr:title>Section of Type Family</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>B</fr:tex> be a <fr:link href="def-0018.xml" type="local" addr="def-0018">type family</fr:link> over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>.
    A <fr:strong>section</fr:strong> of <fr:tex>B</fr:tex> is a term <fr:tex>b</fr:tex> of type <fr:tex>B(x)</fr:tex> in context <fr:tex>\Gamma ,x:A</fr:tex>.
    <fr:tex display="block">          \Gamma , x:A  \vdash  b : B(x)     </fr:tex>
    Alternatively, we say that <fr:tex>b</fr:tex> is a term of <fr:tex>B(x)</fr:tex> indexed by <fr:tex>x:A</fr:tex> in context <fr:tex>\Gamma</fr:tex>.
</fr:p></fr:mainmatter></fr:tree><fr:p>
    We now ready to present the inference rules for dependent type theory.
    These rules are known as the <fr:strong>structual rules</fr:strong> of the theory.
    There are 6 sets of rules:
    <fr:ul><fr:li>Formation contexts, types and terms</fr:li>
        <fr:li>Postulating that judgmental equality is an equivalence relation</fr:li>
        <fr:li>Vairable conversion</fr:li>
        <fr:li>Substitution</fr:li>
        <fr:li>Weakening</fr:li>
        <fr:li>Generic element</fr:li></fr:ul></fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>526</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001A</fr:addr><fr:route>def-001A.xml</fr:route><fr:title>
    Formation of contexts, types and terms
</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The following rules follow from the presuppotion
    about contexts, types and terms, can be used freely.
</fr:p><fr:ul><fr:li><fr:tex display="block">              \frac {                  \Gamma ,x:A \vdash  B(x) \space \text {type}              }{                  \Gamma \vdash  A \space \text {type}              }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">              \frac {                  \Gamma \vdash  A \equiv  B \space \text {type}              }{                  \Gamma \vdash  A \space \text {type}              }              \quad               \frac {                  \Gamma \vdash  A \equiv  B \space \text {type}              }{                  \Gamma \vdash  B \space \text {type}              }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">              \frac {                  \Gamma \vdash  a:A             }{                  \Gamma \vdash  A \space \text {type}              }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">              \frac {                  \Gamma \vdash  a \equiv  b:A             }{                  \Gamma \vdash  a:A             }              \quad                \frac {                  \Gamma \vdash  a \equiv  b:A             }{                  \Gamma \vdash  b:A             }         </fr:tex></fr:li></fr:ul></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>527</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001B</fr:addr><fr:route>def-001B.xml</fr:route><fr:title>
    Judgmental equality is equivalence relation
</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Judgmental equality on types and on elements is an <fr:link href="def-000X.xml" type="local" addr="def-000X">equivalence relation</fr:link> 
    simply postulate that these relations are reflexive, symmetric, and transitive:
</fr:p><fr:ul><fr:li><fr:tex display="block">              \frac {                  \Gamma \vdash  a:A             }{                  \Gamma \vdash  a \equiv  a:A             }              \quad               \frac {                  \Gamma \vdash  a \equiv  b:A             }{                  \Gamma \vdash  b \equiv  a:A             }              \quad               \frac {                  \Gamma \vdash  a \equiv  b:A                  \quad                   \Gamma \vdash  b \equiv  c:A             }{                  \Gamma \vdash  a \equiv  c:A             }         </fr:tex></fr:li>
    <fr:li><fr:tex display="block">              \frac {                  \Gamma \vdash  A \space \text {type}              }{                  \Gamma \vdash  A \equiv  A \space \text {type}              }              \quad               \frac {                  \Gamma \vdash  A \equiv  B \space \text {type}              }{                  \Gamma \vdash  B \equiv  A \space \text {type}              }              \quad               \frac {                  \Gamma \vdash  A \equiv  B \space \text {type}                   \quad                   \Gamma \vdash  B \equiv  C \space \text {type}              }{                  \Gamma \vdash  A \equiv  C \space \text {type}              }         </fr:tex></fr:li></fr:ul></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>528</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001C</fr:addr><fr:route>def-001C.xml</fr:route><fr:title>Variable Conversion</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    This rule postulates that we can
    convert the type of a variable to a judgmentally equal type.
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \equiv  A&apos; \space \text {type}               \quad               \Gamma ,x:A, \Delta \vdash  B(x) \space \text {type}          }{              \Gamma ,x:A&apos;, \Delta \vdash  B(x) \space \text {type}          }     </fr:tex>
    Similarly, we can convert judgmental equality of types and terms.
    We state all of them at once using a <fr:em>generic judgment thesis</fr:em> <fr:tex>\mathcal {J}</fr:tex>.
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \equiv  A&apos; \space \text {type}               \quad               \Gamma ,x:A, \Delta \vdash   \mathcal {J}         }{              \Gamma ,x:A&apos;, \Delta \vdash   \mathcal {J}         }VC     </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:p>
    Consider a term <fr:tex>f:B(x)</fr:tex> indexed by <fr:tex>x:A</fr:tex> in context <fr:tex>\Gamma</fr:tex>,
    and we also have a term <fr:tex>a:A</fr:tex>.
    We can simultaneously substitute <fr:tex>a</fr:tex> for all occurrences of <fr:tex>x</fr:tex> in <fr:tex>f</fr:tex>
    to obtain a new term <fr:tex>f[x:=a]:B(a)</fr:tex>.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>529</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001D</fr:addr><fr:route>def-001D.xml</fr:route><fr:title>Substitution</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The substitution rule postulates that we can substitute a term for a variable.
    <fr:tex display="block">          \frac {              \Gamma \vdash  a:A              \quad               \Gamma ,x:A, \Delta \vdash   \mathcal {J}         }{              \Gamma , \Delta [x:=a] \vdash   \mathcal {J}[x:=a]         }S     </fr:tex>
    The notation <fr:tex>\Gamma , \Delta [x:=a]</fr:tex> means that we substitute <fr:tex>a</fr:tex> for <fr:tex>x</fr:tex> in <fr:tex>\Delta</fr:tex>.
</fr:p><fr:p>
    With the substitution rule, we need two more <fr:em>congruence rules</fr:em> to
    convert judgmental equality of terms and types.
    <fr:tex display="block">          \frac {              \Gamma \vdash  a \equiv  a&apos;:A              \quad               \Gamma ,x:A, \Delta \vdash  B  \space \text {type}          }{              \Gamma , \Delta [x:=a] \vdash  B[x:=a] \equiv  B[x:=a&apos;]  \space \text {type}          }     </fr:tex>

    <fr:tex display="block">          \frac {              \Gamma \vdash  A \equiv  A&apos; \space \text {type}               \quad               \Gamma ,x:A, \Delta \vdash  b:A         }{              \Gamma , \Delta [x:=a] \vdash  b[x:=a] \equiv  b[x:=a&apos;]:A&apos;[x:=a]  \space \text {type}          }     </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>530</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001G</fr:addr><fr:route>def-001G.xml</fr:route><fr:title>Fiber and Value</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Let <fr:tex>B</fr:tex> be a <fr:link href="def-0018.xml" type="local" addr="def-0018">type family</fr:link> over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>,
    an a well-formed term <fr:tex>a:A</fr:tex>,
    then we say that <fr:tex>B[x:=a]</fr:tex> is the <fr:strong>fiber</fr:strong> of <fr:tex>B</fr:tex> at <fr:tex>a</fr:tex>, denoted <fr:tex>B(a)</fr:tex>.
</fr:p><fr:p>
    Let <fr:tex>b</fr:tex> a <fr:link href="def-0019.xml" type="local" addr="def-0019">section</fr:link> of <fr:tex>B</fr:tex> over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>,
    then we say that <fr:tex>b(a): \equiv  b[x:=a]</fr:tex> is the <fr:strong>value</fr:strong> of <fr:tex>b</fr:tex> at <fr:tex>a</fr:tex>.

</fr:p></fr:mainmatter></fr:tree><fr:p>
    The process of expanding the context by a fresh variable of type <fr:tex>A</fr:tex> is called weakening (by <fr:tex>A</fr:tex>).
    Intuitively, weakening is the process of adding a new hypothesis to the context.
    And the hypothesis will weaken the conclusion.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>531</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001E</fr:addr><fr:route>def-001E.xml</fr:route><fr:title>Weakening</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    Weakening rule asserts that we can add a variable to the context.
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \space \text {type}               \quad                \Gamma , \Delta \vdash   \mathcal {J}         }{              \Gamma ,x:A, \Delta \vdash   \mathcal {J}         }W      </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:p>
    Finally, the generic elemets rule ensures that
    the variables declared in a context.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>532</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001F</fr:addr><fr:route>def-001F.xml</fr:route><fr:title>Generic Elements</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    The rule for the generic element asserts that 
    any hypothetical element <fr:tex>x:A</fr:tex> in context <fr:tex>\Gamma ,x:A</fr:tex>
    is also an element of <fr:tex>A</fr:tex> in context <fr:tex>\Gamma ,x:A</fr:tex>.
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \space \text {type}          }{              \Gamma ,x:A \vdash  x:A         } \delta      </fr:tex>
    This rule is also called the <fr:strong>variable rule</fr:strong>.   
</fr:p></fr:mainmatter></fr:tree><fr:p>
    The next topic is the dependent function type, a fundamental concept of dependent type theory.
    Simply put, a dependent function type is a function whose type of output may depend on the input.
</fr:p><fr:p>
    Consider a section <fr:tex>b</fr:tex> of a family <fr:tex>B</fr:tex> over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>:
    <fr:tex display="block">          \Gamma ,x:A \vdash  b(x):B(x)     </fr:tex>
    Such a section <fr:tex>b</fr:tex> is an operation or assignment <fr:tex>x \mapsto  b(x)</fr:tex> that assigns to each element <fr:tex>x:A</fr:tex>
    to a term <fr:tex>b(x):B(x)</fr:tex>.
    We may see <fr:tex>b</fr:tex> as a function takes <fr:tex>x:A</fr:tex> to <fr:tex>b(x):B(x)</fr:tex>.
    The function <fr:tex>x \mapsto  b(x)</fr:tex> is called a <fr:strong>dependent function</fr:strong>.
    The type of all dependent functions from <fr:tex>A</fr:tex> to <fr:tex>B</fr:tex> is called the <fr:strong>dependent function type</fr:strong>.
    <fr:tex display="block">          \Pi _{(x:A)}B(x)  \text { or } (x:A) \to  B(x)     </fr:tex></fr:p><fr:p>
    To introduce a type we need the following four rules:
    <fr:ul><fr:li>Formation rule</fr:li>
        <fr:li>Introduction rule</fr:li>
        <fr:li>Elimination rule</fr:li>
        <fr:li>Computation rule</fr:li></fr:ul>
    Besides these we also need the <fr:strong>congruence rule</fr:strong> for judgmental equality.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>533</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001T</fr:addr><fr:route>def-001T.xml</fr:route><fr:title>Dependent Function Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Formation Rule</fr:strong>
    For any type family <fr:tex>B</fr:tex> over <fr:tex>A</fr:tex> in context <fr:tex>\Gamma</fr:tex>:
    <fr:tex display="block">          \frac {              \Gamma ,x:A \vdash  B(x) \space \text {type}          }{              \Gamma \vdash   \Pi _{(x:A)}B(x) \space \text {type}          } \Pi      </fr:tex>
    We also require that the operation of forming dependent function types
    respects judgmental equality.
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \equiv  A&apos; \space \text {type}               \quad               \Gamma ,x:A \vdash  B(x) \equiv  B&apos;(x) \space \text {type}          }{              \Gamma \vdash   \Pi _{(x:A)}B(x) \equiv   \Pi _{(x:A&apos;)}B&apos;(x) \space \text {type}          } \Pi \text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Introduction Rule (<fr:tex>\lambda</fr:tex>-abstraction)</fr:strong>
    In order to construct a dependent function we have to
    construct a term <fr:tex>f(x):B(x)</fr:tex> indexed by <fr:tex>x:A</fr:tex> in context <fr:tex>\Gamma</fr:tex>:
    <fr:tex display="block">          \frac {              \Gamma ,x:A \vdash  b(x):B(x)         }{              \Gamma \vdash   \lambda  x.b(x): \Pi _{(x:A)}B(x)         } \lambda      </fr:tex>
    And the congruence rule:
    <fr:tex display="block">          \frac {              \Gamma ,x:A \vdash  b(x) \equiv  b&apos;(x):B(x)         }{              \Gamma \vdash   \lambda  x.b(x) \equiv   \lambda  x.b&apos;(x): \Pi _{(x:A)}B(x)         } \lambda \text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Elimination Rule (Evaluation Rule)</fr:strong>
    In order to use dependent function we need to provide an argument of the domain type.
    <fr:tex display="block">          \frac {              \Gamma \vdash  f: \Pi _{(x:A)}B(x)         }{              \Gamma ,x:A \vdash  f(x):B(x)         }ev     </fr:tex>
    Again we require the judgmental equality to be respected:
    <fr:tex display="block">          \frac {              \Gamma \vdash  f \equiv  f&apos;: \Pi _{(x:A)}B(x)         }{              \Gamma ,x:A \vdash  f(x) \equiv  f&apos;(x):B(x)         }ev \text {-eq}     </fr:tex></fr:p><fr:p><fr:strong>Computation Rule (<fr:tex>\beta</fr:tex>-reduction)</fr:strong>
    <fr:tex display="block">          \frac {              \Gamma ,x:A \vdash  b(x):B(x)         }{              \Gamma ,x:A \vdash  ( \lambda  y.b(y))(x) \equiv  b(x):B(x)         } \beta      </fr:tex>
    We postulate that all elements of a dependent function type are dependent functions.
    <fr:tex display="block">          \frac {              \Gamma \vdash  f: \Pi _{(x:A)}B(x)         }{              \Gamma \vdash  f \equiv   \lambda  x.f(x): \Pi _{(x:A)}B(x)         } \eta      </fr:tex></fr:p></fr:mainmatter></fr:tree><fr:p>
    A degenrated case of dependent function type is the ordinary function type.
</fr:p><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false"><fr:frontmatter><fr:anchor>534</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001U</fr:addr><fr:route>def-001U.xml</fr:route><fr:title>Ordinary Function Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    A special case of <fr:link href="def-001T.xml" type="local" addr="def-001T"><fr:tex>\Pi</fr:tex>-type</fr:link> is the <fr:strong>ordinary function type</fr:strong>.
    Using weakening rule we can obtain thee type <fr:tex>A \to  B</fr:tex> of ordinary function from <fr:tex>A</fr:tex> to <fr:tex>B</fr:tex>
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \space \text {type}               \quad               \Gamma \vdash  B \space \text {type}          }{ \dfrac {              \Gamma ,x:A \vdash  B \space \text {type}          }{              \Gamma \vdash   \Pi _{(x:A)}B \space \text {type}          } \Pi }W     </fr:tex>
    A term <fr:tex>f:  \Pi _{(x:A)}B</fr:tex> is an ordinary function. The type <fr:tex>A  \to  B</fr:tex> is defined:
    <fr:tex display="block">         A \to  B :=  \Pi _{(x:A)}B     </fr:tex>
    The type <fr:tex>A</fr:tex> is called <fr:strong>domain</fr:strong> of <fr:tex>f</fr:tex>,
    and type <fr:tex>B</fr:tex> is called <fr:strong>codomain</fr:strong> of <fr:tex>f</fr:tex>.
    The notation <fr:tex>:=</fr:tex> here means to make a definition.
</fr:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:context><fr:related></fr:related><fr:backlinks><fr:tree xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="true" root="false"><fr:frontmatter><fr:anchor>845</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>def-001U</fr:addr><fr:route>def-001U.xml</fr:route><fr:title>Ordinary Function Type</fr:title></fr:frontmatter><fr:mainmatter><fr:p>
    A special case of <fr:link href="def-001T.xml" type="local" addr="def-001T"><fr:tex>\Pi</fr:tex>-type</fr:link> is the <fr:strong>ordinary function type</fr:strong>.
    Using weakening rule we can obtain thee type <fr:tex>A \to  B</fr:tex> of ordinary function from <fr:tex>A</fr:tex> to <fr:tex>B</fr:tex>
    <fr:tex display="block">          \frac {              \Gamma \vdash  A \space \text {type}               \quad               \Gamma \vdash  B \space \text {type}          }{ \dfrac {              \Gamma ,x:A \vdash  B \space \text {type}          }{              \Gamma \vdash   \Pi _{(x:A)}B \space \text {type}          } \Pi }W     </fr:tex>
    A term <fr:tex>f:  \Pi _{(x:A)}B</fr:tex> is an ordinary function. The type <fr:tex>A  \to  B</fr:tex> is defined:
    <fr:tex display="block">         A \to  B :=  \Pi _{(x:A)}B     </fr:tex>
    The type <fr:tex>A</fr:tex> is called <fr:strong>domain</fr:strong> of <fr:tex>f</fr:tex>,
    and type <fr:tex>B</fr:tex> is called <fr:strong>codomain</fr:strong> of <fr:tex>f</fr:tex>.
    The notation <fr:tex>:=</fr:tex> here means to make a definition.
</fr:p></fr:mainmatter></fr:tree></fr:backlinks><fr:references></fr:references></fr:backmatter></fr:tree>