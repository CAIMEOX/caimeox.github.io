\title{Algebraic Effects}
\taxon{Algebra}
\import{macros}
\date{2024-01-28}
\p{
    Notes about algebraic effects and handlers.
}
\subtree{
    \title{Algebraic Theories}
    \p{
        In algebra we study mathematical structures that are equipped with operations
        satisfying equational laws.
    }
    \transclude{def-004M}
    \transclude{def-004N}
    \transclude{def-004O}
    \transclude{def-004P}
    \transclude{def-004Q}
    \p{
        We may organize the models of an algebraic theory #{T} into a category #{\model(T)}
        whose objects are the models of the theory and the morphisms are the model homomorphisms.
    }
    \p{
        So far we have considered the models of an algebraic theory as sets with operations.
        More generally we can consider models in any category #{C} with finite products.
        Hence the definition of an interpretation and a model may be directly transcribed.
    }
    \transclude{def-004R}
    \p{
        Of special interest are the free models of an algebraic theory.
    }
    \transclude{def-004S}
    \p{
        This can be understood as follows: the free T-model 
        generated by #{X} is the most economical way of making a 
        T-model out of the set #{X}. 
        ("Free" essentially means with as few assumptions as possible.)
    }
    \p{
        For instance, the free group generated by the singleton set #{\{a\}} is the 
        infinite cyclic group, which is isomorphic to #{\Z}. If you have an element #{a},
        then you automatically have all its powers of #{a} in the group.
        We can not make any further assumptions because we need to send this free group 
        to any other group that satisfies the group axioms, the powers of #{a} are going 
        to be "interpreted".
    }
    \p{
        Every algebraic theory #{T} has a free model.
        Given a signature #{\Sigma} and a set #{X},
        define #{\text{Tree}_\Sigma(X)} to be the set of well-founded 
        trees built inductively as follows:
        \ul{
            \li{
                #{\forall x \in X}, there is a tree #{\text{return}(x) \in \text{Tree}_\Sigma(X)}
                (the choice of the label is immaterial in fact)
            }
            \li{
                For each operation symbol #{\op_i} and trees 
                #{t_1, \cdots, t_{\arity_i} \in \text{Tree}_\Sigma(X)},
                there is a tree, denoted by #{\op_i(t_1, \cdots, t_{\arity_i}) \in \text{Tree}_\Sigma(X)},
                whose root is labeled by #{\op_i} and 
                whose children are subtrees #{t_1, \cdots, t_{\arity_i}}.
            }
        }
        In this setting, the #{\Sigma\text{-terms}} in the context #{x_1, \cdots, x_k} are
        the trees in #{\text{Tree}_\Sigma(\{x_1, \cdots, x_k\})}.
        A variable #{x_i} is labeled as #{\text{return}(x_i)} when construed as a tree.
        Suppose #{x_1, \cdots, x_n \mid t} is a term in context and we are given 
        an assignment #{\sigma : \{x_1, \cdots, x_n\} \to \text{Tree}_\Sigma(X)}.
        We can build the tree #{\sigma(t)} inductively as follows:
        \ul{
            \li{
                #{\sigma(t) = \sigma(x_i)} if #{t = x_i}
            }
            \li{
                #{\sigma(t) = \op_i(\sigma(t_1), \cdots, \sigma(t_{\arity_i}))} if #{t = \op_i(t_1, \cdots, t_{\arity_i})}
            }
        }
        Briefly, the tree #{\sigma(t)} is obtained by replacing each 
        variable #{x_i} in #{t} with the corresponding tree #{\sigma(x_i)}.
    }
    \p{
        Let #{\sim_T} be the least equivalence relation on #{\text{Tree}_{\Sigma_T}(X)}
        such that:
        \ul{
            \li{
                For every equation #{x_1, \cdots, x_n \mid l = r} in #{E_T} and 
                for every assignment #{\sigma} we have: #{
                    \sigma(l) \sim_T \sigma(r)
                }
            }
            \li{
                #{\sim_T} is a congruence: for every operation symbol #{\op_i} 
                in #{\sigma_T} and forall trees #{s_1,\cdot,s_{\arity_i}}
                and #{t_1, \cdots, t_{\arity_i}} in #{\text{Tree}_\Sigma(X)}, if
                ##{
                    s_1 \sim_T t_1 \quad \cdots \quad s_{\arity_i} \sim_T t_{\arity_i}
                }
                then the following holds:
                ##{
                    \op_i(s_1, \cdots, s_{\arity_i}) \sim_T \op_i(t_1, \cdots, t_{\arity_i})
                }
            }
        }
    }
    \p{
        Now we define the carrier the free model #{F_T(X)} to be the quotient set 
        ##{
            |F_T(X)| = \text{Tree}_{\Sigma_T}(X)/\sim_T
        }
        Let #{\langle t \rangle} be the #{\sim_T} equivalence class of #{t \in \text{Tree}_{\Sigma_T}(X)},
        the interpretation of the operation symbol #{\op_i} in the free model is defined by:
        ##{
            [\op_i]_{F_T(X)}(\langle t_1 \rangle, \cdots, \langle t_{\arity_i} \rangle) = \langle \op_i(t_1, \cdots, t_{\arity_i}) \rangle
        }
        and the map #{\eta_X : X \to F_T(X)} is defined by
        ##{
            \eta_X(x) = \langle \text{return}(x) \rangle
        }
        Note that if theory #{T} has no equations,
        the free models generated by #{T} is the set of all trees in #{\text{Tree}_{\Sigma_T}(X)}
        because the equivalence relation #{\sim_T} is the identity relation #{=}.
    }
    \p{
        So far we have developed the algebraic theories,
        to get a better fit with computational effects,
        we need to generalize operations in two ways:
        arities and parameters.
    }
    \p{
        \strong{Generalizing arities}:
        One might expect that the generalization of 
        arities is to allow them to be ordinal or cardinal
        numbers, hence they can fit the infinity.
        However, that would be a \strong{non-computational} idea.
        Instead, we can generalize the arities to be functions.
        Notice that the n-ary cartesian product of #{X} is isomorphic
        to the exponential #{X^{[n]}}, where #{[n] = \{1, \cdots, n\}}.
        Now we replace #{[n]} with arbitrary set #{A},
        then we can think of a map #{X^A \to X} as arguments of arity #{A}.
        We need a reasonable notation for writing down
        an operation symbol to #{A\text{-many}} arguments,
        where #{A} is an arbitrary set. 
        To achieve this, we introduce the map #{\kappa:A\to X},
        and thus we simply write #{\op_i(\kappa)} for the operation symbol.
    }
    \p{
        \strong{Generalizing parameters}:
        We can generalize operations to take parameters from a set #{P},
        this naturally models algebraic operations that 
        arise as computational effects.
    }
    \p{
        \strong{Compose them together}:
        Now we can restate the definitions of signatures and  
        algebraic operations with the generalizations incorporated.
        \transclude{def-004T}
    }
}