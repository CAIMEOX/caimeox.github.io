<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" numbered="false" root="true"><frontmatter><anchor>558</anchor>   <addr>index</addr>  <route>index.xml</route>  <authors><author>CAIMEO</author> </authors> <title>The Rabbit Hole</title> </frontmatter> <mainmatter>

<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>559</anchor>  <taxon>Person</taxon> <addr>caimeo</addr>  <route>caimeo.xml</route>   <title>CAIMEO</title> <meta name="position">Student</meta><meta name="external">https://github.com/CAIMEOX</meta></frontmatter> <mainmatter><p>
    A student interested in math and computer science.
</p><tex display="block">
     \text {Life} =  \int _{ \text {birth}}^{ \text {death}}  \text {Learning}  \,   \text {d}t
</tex><ul><li>Learning Programming Language Theory and Type Theory</li>
    <li>Reading Type Theory and Formal Proof and Homotopy Type Theory</li>
    <li>Working on CommandLisp</li></ul></mainmatter> </tree>
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="false" root="false"><frontmatter><anchor>560</anchor>   <addr>about</addr>  <route>about.xml</route>   <title>About this website</title> </frontmatter> <mainmatter><p>
    The choice of the name &quot;<strong>Rabbit Hole</strong>&quot; carries a metaphorical significance inspired by Lewis Carroll's <em>Alice's Adventures 
    in Wonderland</em>, meaning to delve into a topic or pursue a line of thought that leads to unexpected or complex places.
    It can refer to getting deeply involved in researching a subject, exploring a particular interest, or going through 
    a series of trees in the forest that leads to a chain of related topics.
</p>
    <strong>How to navigate?</strong>
    <p>This website is a “<em>forest</em>” created using the <strong>Forester</strong> tool.
    To navigate my forest, press <code>Ctrl-K</code>.
    Here are some standards of this blog.</p>
    <ul><li>All posts starts with a prefix and appends with a hex number</li>
        <li>Available post prefixes:
            <ul><li><code>cs</code> Computer Science</li>
                <li><code>math</code> Mathematics</li>
                <li><code>phy</code> Physics</li>
                <li><code>plt</code> Programming language theory</li>
                <li><code>tt</code> Type Theory</li>
                <li><code>def</code> Definitions (For any topic above)</li>
                <li><code>thm</code> Theorems and propositions (For any topic above)</li>
                <li><code>eg</code> Examples</li>
                <li><code>proj</code> My Project</li></ul></li></ul>
</mainmatter> </tree>
<tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>561</anchor>   <addr>notes</addr>  <route>notes.xml</route>   <title>Notes</title> </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>562</anchor>  <taxon>Notes</taxon> <addr>tt-0001</addr>  <route>tt-0001.xml</route> <date><year>2024</year> <month>1</month> <day>26</day></date>  <title>Untyped Lambda Calculus</title> </frontmatter> <mainmatter><p>
In dealing with functions there are two <strong>construction principles</strong> and one <strong>evalutaion rule</strong>
<ul><li>Construction Principles</li>
<ul><li>Function Abstraction: <tex>\lambda  x.M</tex></li>
<li>Function Application: <tex>M N</tex></li></ul>
<li>Evaluation Rule</li>
<ul><li>Beta Reduction: <tex>( \lambda  x.M)N \to  M[N/x]</tex></li></ul></ul>
The beta reduction makes use of the <strong>substitution</strong> <tex>M[N/x]</tex> which represents the result of replacing all free occurences of <tex>x</tex> in <tex>M</tex> with <tex>N</tex>.
</p>
<p>Expressions in the lambda calculus is called <strong>terms</strong>. The set of terms is denoted <tex>\Lambda</tex>.</p>
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>563</anchor>  <taxon>Definition</taxon> <addr>def-000F</addr>  <route>def-000F.xml</route>   <title>Set of Lambda Terms</title> </frontmatter> <mainmatter><p>
Let <tex>\Lambda</tex> be the set of lambda terms. Then <tex>\Lambda</tex> is defined inductively as follows:
(<tex>V</tex> is the set of variables)
<ul><li>Variable: <tex>\forall  x \in  V, x \in   \Lambda</tex></li>
<li>Abstraction: <tex>\forall  x \in  V, M \in   \Lambda ,  \lambda  x.M \in   \Lambda</tex></li>
<li>Application: <tex>\forall  M,N \in   \Lambda , (MN) \in   \Lambda</tex></li></ul></p><p>
Another way to define <tex>\Lambda</tex> is to use the following grammar (The 3 possibilities are separated by <code>|</code>):
<tex display="block">\Lambda  = V |  \lambda  V. \Lambda  |  \Lambda \Lambda</tex></p></mainmatter> </tree> 
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>564</anchor>   <addr>def</addr>  <route>def.xml</route>   <title>Definitions Collection</title> </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>565</anchor>  <taxon>Definition</taxon> <addr>def-0001</addr>  <route>def-0001.xml</route>   <title>Group</title> </frontmatter> <mainmatter><p>
A <strong>group</strong> is a set <tex>G</tex> with a binary operation <tex>\circ</tex> satisfies the following properties:
<ul><li>Closure: <tex>\forall  a,b \in  G,a  \circ  b \in  G</tex></li>
<li>Associativity: <tex>\forall  a,b,c \in  G, (a \circ  b)  \circ  c= a  \circ  (b  \circ  c)</tex></li>
<li>Identity: <tex>\exists  e \in  G</tex> such that <tex>\forall  g \in  G, g \circ  e=e \circ  g = g</tex></li>
<li>Inverse: <tex>\forall  g \in  G, \exists  g^{-1} \in  G</tex> such that <tex>g \circ  g^{-1}=e</tex></li></ul></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>566</anchor>  <taxon>Definition</taxon> <addr>def-0002</addr>  <route>def-0002.xml</route>   <title>Abel Group</title> </frontmatter> <mainmatter><p>
If in a group <tex>G</tex>, <tex>\forall  a,b \in  G, a \circ  b=b \circ  a</tex> then <tex>G</tex> is called an <strong>abelian (commutative) group</strong>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>567</anchor>  <taxon>Definition</taxon> <addr>def-0003</addr>  <route>def-0003.xml</route>   <title>Group Element Order</title> </frontmatter> <mainmatter><p>
For a group <tex>G</tex> an <tex>x \in  G</tex> define the <strong>order</strong> of <tex>x</tex> be the smallest positive integer <tex>n</tex> (denotes <tex>|x|</tex>) st <tex>x^n=1</tex>. If such <tex>n</tex> does not exist then <tex>x</tex> is said to be of infinite order.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>568</anchor>  <taxon>Definition</taxon> <addr>def-0004</addr>  <route>def-0004.xml</route>   <title>Multiplication Table</title> </frontmatter> <mainmatter><p>
Let <tex>G=  \{ g_1, g_2,  \cdots , g_n \}</tex> is finite group. The multiplication table is the <tex>n \times  n</tex> matrix whose <tex>i,j</tex> entry is the group element <tex>g_i  \circ  g_j</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>569</anchor>  <taxon>Definition</taxon> <addr>def-0005</addr>  <route>def-0005.xml</route>   <title>Generator</title> </frontmatter> <mainmatter><p>
A subset <tex>S \in  G</tex> where <tex>\forall  g \in  G</tex> can be written as a (finite) product of <tex>s \in  S</tex> and <tex>s^{-1}</tex> is called a set of <strong>generators</strong> of <tex>G</tex>
<tex>G= \braket {S}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>570</anchor>  <taxon>Definition</taxon> <addr>def-0006</addr>  <route>def-0006.xml</route>   <title>Field</title> </frontmatter> <mainmatter><p>
A field is a set <tex>F</tex> together with two binary operations <tex>+</tex> and <tex>\times</tex> on <tex>F</tex> st <tex>(F,+)</tex> is an abelian group (identity is <tex>0</tex>) and <tex>(F- \{ 0 \} , \times )</tex> is also an abelian group such that
<tex>a \times (b+c)=a \times  b+a \times  c, \forall  a,b,c \in  F</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>571</anchor>  <taxon>Definition</taxon> <addr>def-0007</addr>  <route>def-0007.xml</route>   <title>Monoid</title> </frontmatter> <mainmatter><p>
A set <tex>S</tex> equipped with a binary operation <tex>S \times  S \to  S</tex>, which we will denote <tex>\circ</tex>, is a <strong>monoid</strong> if it satisfies the following two axioms:
<ul><li>Associativity: <tex>\forall  a,b,c \in  S, (a \circ  b)  \circ  c= a  \circ  (b  \circ  c)</tex></li>
<li>Identity: <tex>\exists  e \in  S</tex> such that <tex>\forall  g \in  S, g \circ  e=e \circ  g = g</tex></li></ul></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>572</anchor>  <taxon>Definition</taxon> <addr>def-0008</addr>  <route>def-0008.xml</route>   <title>Group Action</title> </frontmatter> <mainmatter><p>
A group action of a group <tex>G</tex> on a set <tex>A</tex> is a map from <tex>G \times  A  \to  A</tex> (<tex>g \cdot  a</tex>), <tex>\forall  g \in  G</tex> and <tex>a \in  A</tex> satisfying the following properties:
<ul><li><tex>g_1 \cdot  (g_2 \cdot  a)=(g_1g_2) \cdot  a</tex></li>
<li><tex>\forall  a \in  A,1 \cdot  a = a</tex></li></ul></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>573</anchor>  <taxon>Definition</taxon> <addr>def-0009</addr>  <route>def-0009.xml</route>   <title>Group Homomorphism</title> </frontmatter> <mainmatter><p>
Let <tex>(G, \times )</tex> and <tex>(H, \circ )</tex> be groups. A map <tex>\phi  : G \to  H</tex> such that
<tex>\forall  x,y \in  G, \phi (x \times  y)= \phi (x) \circ \phi (y)</tex> is called a <strong>group homomorphism</strong>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>574</anchor>  <taxon>Definition</taxon> <addr>def-000A</addr>  <route>def-000A.xml</route>   <title>Subgroups</title> </frontmatter> <mainmatter><p>
Let <tex>G</tex> be a group and <tex>H</tex> be a nonempty subset of <tex>G</tex> which is closed under operation <tex>\times</tex> and :
<ul><li><tex>\forall  a,b \in  H,a \times  b \in  H</tex></li>
<li><tex>\forall  h \in  H,h^{-1} \in  H</tex></li></ul>
then <tex>H</tex> is a subgroup of <tex>G</tex>. <tex>e=h \times  h^{-1}</tex> is always in group <tex>H</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>575</anchor>  <taxon>Definition</taxon> <addr>def-000B</addr>  <route>def-000B.xml</route>   <title>Euclidean Topology</title> </frontmatter> <mainmatter><p>
A subset <tex>S</tex> of <tex>\mathbb {R}</tex> is said to be open in the <strong>euclidean topology</strong> on <tex>\mathbb {R}</tex> if <tex>\forall  x \in  S</tex> there exists <tex>a,b \in \mathbb {R}</tex> with <tex>a&lt;b</tex> st <tex>x \in (a,b) \in  S</tex>.
</p><p>The dual definition (using closed sets) is also valid.</p><p>
For each <tex>a</tex> and <tex>b</tex> in <tex>\mathbb {R}</tex> with <tex>a&lt;b</tex> the closed intervcal <tex>[a,b]</tex> is a closed set in the euclidean topology in <tex>\mathbb {R}</tex>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>576</anchor>  <taxon>Definition</taxon> <addr>def-000C</addr>  <route>def-000C.xml</route>   <title>Topological Space</title> </frontmatter> <mainmatter><p>
A <strong>topological space</strong> is a set <tex>S</tex> together with a collection <tex>\tau</tex> of subsets called open sets such that
<ul><li>T1: <tex>S, \varnothing \in \tau</tex></li>
<li>T2: <tex>\forall  U,V \in \tau , U \cap  V \in \tau</tex></li>
<li>T3: The union of any collection of open sets is open.</li></ul></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>577</anchor>  <taxon>Definition</taxon> <addr>def-000D</addr>  <route>def-000D.xml</route>   <title>Relative Topology</title> </frontmatter> <mainmatter><p>
Let <tex>(X, \tau )</tex> be a topological space and <tex>A \subseteq  X</tex>. Then <tex>\tau _A= \{ U \cap  A \mid  U \in \tau \}</tex> is a topology on <tex>A</tex> called the <strong>relative topology</strong> on <tex>A</tex> induced by <tex>\tau</tex>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>578</anchor>  <taxon>Definition</taxon> <addr>def-000E</addr>  <route>def-000E.xml</route>   <title>Co-finite Topology</title> </frontmatter> <mainmatter><p>
Let <tex>X</tex> be a set. The <strong>co-finite topology</strong> on <tex>X</tex> is the topology <tex>\tau</tex> on <tex>X</tex> whose open sets are <tex>\emptyset</tex> and all subsets of <tex>X</tex> whose complement is finite.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>579</anchor>  <taxon>Definition</taxon> <addr>def-000F</addr>  <route>def-000F.xml</route>   <title>Set of Lambda Terms</title> </frontmatter> <mainmatter><p>
Let <tex>\Lambda</tex> be the set of lambda terms. Then <tex>\Lambda</tex> is defined inductively as follows:
(<tex>V</tex> is the set of variables)
<ul><li>Variable: <tex>\forall  x \in  V, x \in   \Lambda</tex></li>
<li>Abstraction: <tex>\forall  x \in  V, M \in   \Lambda ,  \lambda  x.M \in   \Lambda</tex></li>
<li>Application: <tex>\forall  M,N \in   \Lambda , (MN) \in   \Lambda</tex></li></ul></p><p>
Another way to define <tex>\Lambda</tex> is to use the following grammar (The 3 possibilities are separated by <code>|</code>):
<tex display="block">\Lambda  = V |  \lambda  V. \Lambda  |  \Lambda \Lambda</tex></p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>580</anchor>   <addr>posts</addr>  <route>posts.xml</route>   <title>Blog posts</title> </frontmatter> <mainmatter/> </tree><tree expanded="false" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>581</anchor>   <addr>projects</addr>  <route>projects.xml</route>   <title>Projects</title> </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>582</anchor>  <taxon>Project</taxon> <addr>proj-0001</addr>  <route>proj-0001.xml</route>   <title>Command Lisp</title> </frontmatter> <mainmatter><p><link href="https://github.com/CAIMEOX/CommandLisp" type="external">Command Lisp</link> is a simplified language designed for Minecraft Bedrock Command System, characterized by a very high level of abstraction, which is also a dialect of Lisp.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>583</anchor>  <taxon>Project</taxon> <addr>proj-0002</addr>  <route>proj-0002.xml</route>   <title>Pure Eval</title> </frontmatter> <mainmatter><p><link href="https://github.com/PureEval/PureEval" type="external">Pure Eval</link> was created for the <link href="proj-0003.xml" type="local" addr="proj-0003" title="Voxel Geometry">VoxelGeometry</link> project, aiming to build a compact yet powerful JavaScript functional utility toolkit.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>584</anchor>  <taxon>Project</taxon> <addr>proj-0003</addr>  <route>proj-0003.xml</route>   <title>Voxel Geometry</title> </frontmatter> <mainmatter><p><link href="https://github.com/CAIMEOX/VoxelGeometry" type="external">Voxel Geometry</link> is voxel geometry library which is used to construct Space (A collection of 3-dimension Vectors) and perform transformation between Spaces.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>585</anchor>  <taxon>Project</taxon> <addr>proj-0004</addr>  <route>proj-0004.xml</route>   <title>Minecraft ScriptAPI wrapper</title> </frontmatter> <mainmatter><p>These projects create Minecraft Script API wrapper for foreign language that compiles to JavaScript.</p><ul><li><link href="https://github.com/CAIMEOX/rescript-bedrock" type="external">ReScript</link></li>
    <li><link href="https://github.com/CAIMEOX/pure_bedrock" type="external">PureScript</link></li>
    <li><link href="https://github.com/CAIMEOX/BedrockFP" type="external">Idris2</link></li></ul></mainmatter> </tree></mainmatter> </tree></mainmatter> <backmatter><contributions/> <context/> <related/> <backlinks/> <references/></backmatter></tree>