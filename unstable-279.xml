<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
  <fr:frontmatter>
    <fr:anchor>1010</fr:anchor>
    <fr:addr type="machine">#279</fr:addr>
    <fr:route>unstable-279.xml</fr:route>
    <fr:title text="Untyped Lambda Calculus › {-term} modulo {-equivalence}"><fr:link type="local" href="tt-0001.xml" addr="tt-0001" title="Untyped Lambda Calculus">Untyped Lambda Calculus</fr:link> › <fr:tex display="inline">\lambda \text {-term}</fr:tex> modulo <fr:tex display="inline">\alpha \text {-equivalence}</fr:tex></fr:title>
    <fr:date>
      <fr:year>2024</fr:year>
      <fr:month>1</fr:month>
      <fr:day>26</fr:day>
    </fr:date>
    <fr:authors></fr:authors>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:p>As we have seen, the relation <fr:tex display="inline">=_\alpha </fr:tex> is an equivalence relation.
    Hence we can define the set of equivalence classes of terms with respect to <fr:tex display="inline">=_\alpha </fr:tex>.
    Now we can identify a term with its equivalence class.
    We still use <fr:tex display="inline">\equiv </fr:tex> for syntactic equality modulo <fr:tex display="inline">\alpha \text {-equivalence}</fr:tex>.</fr:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Context">Context</fr:title>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>1011</fr:anchor>
            <fr:addr type="user">tt-0001</fr:addr>
            <fr:route>tt-0001.xml</fr:route>
            <fr:title text="Untyped Lambda Calculus">Untyped Lambda Calculus</fr:title>
            <fr:taxon>Type Theory</fr:taxon>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>1</fr:month>
              <fr:day>26</fr:day>
            </fr:date>
            <fr:authors></fr:authors>
          </fr:frontmatter>
          <fr:mainmatter><fr:p>Refer to <fr:link type="local" href="ttafp-2014.xml" addr="ttafp-2014" title="Type Theory and Formal Proofs">Type Theory and Formal Proof</fr:link>.</fr:p><fr:p>The idea to generalize the behavior of functions in mathematics and logic led to the development of the lambda calculus.
    The lambda calculus is a formal system for expressing computation based on function abstraction and application using <fr:em>variable binding</fr:em> and <fr:em>substitution</fr:em>. 
    In dealing with functions there are two <fr:strong>construction principles</fr:strong> and one <fr:strong>evalutaion rule</fr:strong>.
    <fr:ul><fr:li><fr:strong>Construction Principles</fr:strong>: note that expressions do not force to be meaningful.</fr:li>
        <fr:ul><fr:li>Function Abstraction: <fr:tex display="inline">\lambda  x.M</fr:tex></fr:li>
            <fr:li>Function Application: <fr:tex display="inline">M N</fr:tex>, this only produces a new expression,
            in which the function has not yet been executed.</fr:li></fr:ul>
    <fr:li><fr:strong>Evaluation Rule</fr:strong></fr:li>
        <fr:ul><fr:li>Beta Reduction: <fr:tex display="inline">(\lambda  x.M)N\to  M[x:=N]</fr:tex></fr:li></fr:ul></fr:ul>
    The beta reduction makes use of the <fr:strong>substitution</fr:strong> <fr:tex display="inline">M[x:=N]</fr:tex> which represents the result of replacing all free occurrences of <fr:tex display="inline">x</fr:tex> in <fr:tex display="inline">M</fr:tex> with <fr:tex display="inline">N</fr:tex>.
    Note that the application is <fr:strong>left associative</fr:strong>, that is, <fr:tex display="inline">MNP</fr:tex> means <fr:tex display="inline">(MN)P</fr:tex>.
    And application has the highest precedence, that is, <fr:tex display="inline">\lambda  x.MN</fr:tex> means <fr:tex display="inline">\lambda  x.(MN)</fr:tex>.</fr:p><fr:p>The multi-argument function <fr:tex display="inline">\lambda  x_1\ldots  x_n.M</fr:tex> is defined as <fr:tex display="inline">\lambda  x_1.(\lambda  x_2.(\ldots (\lambda  x_n.M)\ldots ))</fr:tex> (right associative),
    that is, simulated by a sequence of single-argument functions. The later function is called <fr:strong>curried function</fr:strong> and the
    process of transforming a multi-argument function into a sequence of single-argument functions is called <fr:strong>currying</fr:strong>.</fr:p>
    <fr:strong>Lambda Terms</fr:strong>
    <fr:p>Expressions in the lambda calculus is called <fr:strong>terms</fr:strong>. The set of terms is denoted <fr:tex display="inline">\Lambda </fr:tex>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>501</fr:anchor><fr:addr type="user">def-000F</fr:addr><fr:route>def-000F.xml</fr:route><fr:title text="Set of Lambda Terms">Set of Lambda Terms</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">\Lambda </fr:tex> be the set of lambda terms. Then <fr:tex display="inline">\Lambda </fr:tex> is defined inductively as follows:
(<fr:tex display="inline">V</fr:tex> is the set of variables)
<fr:ul><fr:li>Variable: <fr:tex display="inline">\forall  x\in  V, x\in  \Lambda </fr:tex></fr:li>
<fr:li>Abstraction: <fr:tex display="inline">\forall  x\in  V, M\in  \Lambda , \lambda  x.M\in  \Lambda </fr:tex></fr:li>
<fr:li>Application: <fr:tex display="inline">\forall  M,N\in  \Lambda , (MN)\in  \Lambda </fr:tex></fr:li></fr:ul></fr:p><fr:p>Another way to define <fr:tex display="inline">\Lambda </fr:tex> is to use the following grammar (The 3 possibilities are separated by <fr:code>|</fr:code>):
<fr:tex display="block">\Lambda  = V | \lambda  V.\Lambda  | \Lambda \Lambda </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
<fr:p>With the following recursive definition we can determine 
    what the <fr:strong>subterms</fr:strong> of a give <fr:tex display="inline">\lambda \text {-term}</fr:tex> are. Here we use 
    a concept named <fr:link type="local" href="def-0035.xml" addr="def-0035" title="Multiset">multiset</fr:link>.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>502</fr:anchor><fr:addr type="user">def-0036</fr:addr><fr:route>def-0036.xml</fr:route><fr:title text="Multiset of Subterms">Multiset of Subterms</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We define a map <fr:tex display="inline">\text {Sub}</fr:tex>:
    <fr:ul><fr:li><fr:strong>Basis</fr:strong>: <fr:tex display="inline">\forall  x\in  V,\text {Sub}(x) =\{ x \}</fr:tex></fr:li>
        <fr:li><fr:strong>Application</fr:strong>: <fr:tex display="inline">\forall  M,N\in \Lambda ,\text {Sub}(MN) = \text {Sub}(M)\cup \text {Sub}(N)\cup \{ MN \}</fr:tex></fr:li>
        <fr:li><fr:strong>Abstraction</fr:strong>: <fr:tex display="inline">\forall  x\in  V,M\in \Lambda ,\text {Sub}(\lambda  x.M) = \text {Sub}(M)\cup \{ \lambda  x.M \}</fr:tex></fr:li></fr:ul>
    <fr:tex display="inline">L</fr:tex> is a subterm of <fr:tex display="inline">M</fr:tex> if <fr:tex display="inline">L\in \text {Sub}(M)</fr:tex>.
    If <fr:tex display="inline">L\not \equiv  M</fr:tex> then we say <fr:tex display="inline">L</fr:tex> is a <fr:strong>proper subterm</fr:strong> of <fr:tex display="inline">M</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The definition above uses a notation <fr:tex display="inline">\equiv </fr:tex> which means <fr:em>syntactic equality</fr:em> here.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>503</fr:anchor><fr:addr type="user">eg-0006</fr:addr><fr:route>eg-0006.xml</fr:route><fr:title text="Subterms">Subterms</fr:title><fr:taxon>Example</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:ul><fr:li><fr:tex display="inline">\text {Sub}((x\space z))</fr:tex> = <fr:tex display="inline">\{ x,z,(x\space z) \}</fr:tex></fr:li>
    <fr:li><fr:tex display="inline">             \text {Sub}(\lambda  x.(x\space x))              = \{ \lambda  x.(x\space x),(x\space x),x,x \}         </fr:tex></fr:li></fr:ul></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The substerm mapping satisfies the following lemma.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>504</fr:anchor><fr:addr type="user">thm-000W</fr:addr><fr:route>thm-000W.xml</fr:route><fr:title text="Lemma of subterms">Lemma of subterms</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:ul><fr:li><fr:strong>Reflexivity</fr:strong>: <fr:tex display="inline">\forall  M\in \Lambda ,M\in \text {Sub}(M)</fr:tex></fr:li>
        <fr:li><fr:strong>Transitivity</fr:strong>: <fr:tex display="inline">\forall  L,M,N\in \Lambda ,L\in \text {Sub}(M)\land  M\in \text {Sub}(N)\implies  L\in \text {Sub}(N)</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Variable occurrences in a <fr:tex display="inline">\lambda \text {-term}</fr:tex> can be divided into 3 categories:
    <fr:ul><fr:li>Bound Occurrences: <fr:tex display="inline">x</fr:tex> is bound in <fr:tex display="inline">M</fr:tex> if <fr:tex display="inline">x</fr:tex> is the argument of an <fr:strong>abstraction</fr:strong> in <fr:tex display="inline">M</fr:tex>.</fr:li>
        <fr:li>Free Occurrences: <fr:tex display="inline">x</fr:tex> is free in <fr:tex display="inline">M</fr:tex> if <fr:tex display="inline">x</fr:tex> is not bound by any <fr:strong>abstraction</fr:strong> in <fr:tex display="inline">M</fr:tex>.</fr:li>
        <fr:li>Binding Occurrences: something after a lambda notation <fr:tex display="inline">\lambda </fr:tex></fr:li></fr:ul>
    We mainly focus on the <fr:strong>free variables</fr:strong> of a term.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>505</fr:anchor><fr:addr type="user">def-0037</fr:addr><fr:route>def-0037.xml</fr:route><fr:title text="Set of Free Variables">Set of Free Variables</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">FV(L)</fr:tex> be the set of free variables in a term <fr:tex display="inline">L</fr:tex>.
    <fr:ul><fr:li><fr:strong>Variable</fr:strong>: <fr:tex display="inline">\forall  x\in  V,\text {FV}(x) = \{ x \}</fr:tex></fr:li>
        <fr:li><fr:strong>Application</fr:strong>: <fr:tex display="inline">\forall  M,N\in \Lambda ,\text {FV}(MN) = \text {FV}(M)\cup \text {FV}(N)</fr:tex></fr:li>
        <fr:li><fr:strong>Abstraction</fr:strong>: <fr:tex display="inline">\forall  x\in  V,M\in \Lambda ,\text {FV}(\lambda  x.M) = \text {FV}(M)\setminus \{ x \}</fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>506</fr:anchor><fr:addr type="user">def-0038</fr:addr><fr:route>def-0038.xml</fr:route><fr:title text="Closed Lambda Terms">Closed Lambda Terms</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:tex display="inline">\lambda \text {-term}</fr:tex> <fr:tex display="inline">M</fr:tex> is <fr:strong>closed</fr:strong> if <fr:tex display="inline">\text {FV}(M) = \emptyset </fr:tex>.
    A closed <fr:tex display="inline">\lambda \text {-term}</fr:tex> is also called a <fr:strong>combinator</fr:strong>.
    The set of all combinators is denoted by <fr:tex display="inline">\Lambda ^0</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>507</fr:anchor><fr:addr type="machine">#278</fr:addr><fr:route>unstable-278.xml</fr:route><fr:title text="Alpha conversion">Alpha conversion</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Functions in <fr:tex display="inline">\lambda \text {-calculus}</fr:tex> have the property that the name of 
    the binding variables is irrelevant.
    In order to describe this equality we need to define a relation
    called <fr:tex display="inline">\alpha \text {-conversion}</fr:tex> or <fr:tex display="inline">\alpha \text {-equivalence}</fr:tex>,
    which is based on the process of renaming binding variables.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>508</fr:anchor><fr:addr type="user">def-0039</fr:addr><fr:route>def-0039.xml</fr:route><fr:title text="Renaming">Renaming</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">M^{x\to y}</fr:tex> be the result of replacing all free occurrences of <fr:tex display="inline">x</fr:tex> in <fr:tex display="inline">M</fr:tex> with <fr:tex display="inline">y</fr:tex>.
    The relation <fr:strong>renaming</fr:strong> is expression with the symbol <fr:tex display="inline">=_\alpha </fr:tex>:
    <fr:tex display="inline">\lambda  x.M=_\alpha \lambda  y.M^{x\to y}</fr:tex> if <fr:tex display="inline">y\not \in \text {FV}(M)</fr:tex> and <fr:tex display="inline">y</fr:tex> is not a binding variable in <fr:tex display="inline">M</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>The definition of <fr:strong>renaming</fr:strong> should be extended to more general terms.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>509</fr:anchor><fr:addr type="user">def-003A</fr:addr><fr:route>def-003A.xml</fr:route><fr:title text="Alpha Equivalence">Alpha Equivalence</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:tex display="inline">\alpha </fr:tex> equivalence is a relation between <fr:tex display="inline">\lambda \text {-term}</fr:tex>, defined as follows:
    <fr:ul><fr:li><fr:strong>Renaming</fr:strong>: <fr:tex display="inline">\lambda  x. M =_\alpha  \lambda  y. M^{x\to y}</fr:tex> if <fr:tex display="inline">y\not \in \text {FV}(M)</fr:tex> and <fr:tex display="inline">y</fr:tex> is not a binding variable in <fr:tex display="inline">M</fr:tex>.</fr:li>
        <fr:li><fr:strong>Compatibility</fr:strong>: If <fr:tex display="inline">M=_\alpha  N</fr:tex> then <fr:tex display="inline">\lambda  x.M=_\alpha \lambda  x.N</fr:tex> and <fr:tex display="inline">ML =_\alpha  NL, LM =_\alpha  LN</fr:tex>.</fr:li>
        <fr:li><fr:strong>Reflexivity</fr:strong>: <fr:tex display="inline">M=_\alpha  M</fr:tex>.</fr:li>
        <fr:li><fr:strong>Symmetry</fr:strong>: If <fr:tex display="inline">M=_\alpha  N</fr:tex> then <fr:tex display="inline">N=_\alpha  M</fr:tex>.</fr:li>
        <fr:li><fr:strong>Transitivity</fr:strong>: If <fr:tex display="inline">M=_\alpha  N</fr:tex> and <fr:tex display="inline">N=_\alpha  L</fr:tex> then <fr:tex display="inline">M=_\alpha  L</fr:tex>.</fr:li></fr:ul>
    The first principle is the basis of alpha equivalence, which is the same as <fr:link type="local" href="def-0039.xml" addr="def-0039" title="Renaming">renaming</fr:link>.
    The last 3 properties ensures that <fr:tex display="inline">=_\alpha </fr:tex> is an <fr:link type="local" href="def-000X.xml" addr="def-000X" title="Equivalence Relation">equivalence relation</fr:link>.</fr:p><fr:p>If <fr:tex display="inline">M=_\alpha  N</fr:tex> then we say <fr:tex display="inline">M</fr:tex> and <fr:tex display="inline">N</fr:tex> are <fr:tex display="inline">\alpha \text {-equivalent}</fr:tex> or <fr:tex display="inline">\alpha \text {-convertible}</fr:tex>.
    <fr:tex display="inline">M</fr:tex> is an <fr:tex display="inline">\alpha \text {-variant}</fr:tex> of <fr:tex display="inline">N</fr:tex> and vice versa.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>In previous sections we informally mentioned the concept of <fr:strong>substitution</fr:strong>.
    Now we give a precise formulation</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>510</fr:anchor><fr:addr type="user">def-003B</fr:addr><fr:route>def-003B.xml</fr:route><fr:title text="Substitution">Substitution</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>substitution</fr:strong> is defined by the following rules:
    <fr:ul><fr:li><fr:tex display="inline">M[x:=N]:\equiv  N</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">y[x:=N]:\equiv  y</fr:tex> if <fr:tex display="inline">y\not \equiv  x</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">(PQ)[x:=N]:\equiv (P[x:=N])(Q[x:=N])</fr:tex></fr:li>
        <fr:li><fr:tex display="inline">(\lambda  y.P)[x:=N]:\equiv \lambda  z.P^{y\to z}[x:=N]</fr:tex> 
            if <fr:tex display="inline">\lambda  z.P^{y\to z} =_\alpha  \lambda  y.P</fr:tex> and <fr:tex display="inline">z\not \in \text {FV}(N)</fr:tex></fr:li></fr:ul>
    The terms with form <fr:tex display="inline">P[x:=N]</fr:tex> are not <fr:tex display="inline">\lambda \text {-term}</fr:tex>,
    but we can regard them as a <fr:em>meta notation</fr:em> that appears
    in the substitution process and the result contains no such terms.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>Renaming can be considered as a special case of substitution.
    We can show that <fr:tex display="inline">M^{x\to u}=_\alpha M[x:=u]</fr:tex> if the conditions of renaming are satisfied.</fr:p><fr:p>We may do <fr:strong>sequential substitution</fr:strong> in a term,
    that is, doing a number of substitutions consecutively.
    And we have the following lemma, which states that the order of substitution is important.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>511</fr:anchor><fr:addr type="user">thm-000X</fr:addr><fr:route>thm-000X.xml</fr:route><fr:title text="Substitution is not commutative">Substitution is not commutative</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">x\not \equiv  y</fr:tex> and assume <fr:tex display="inline">x\not \in \text {FV}(L)</fr:tex>.
    Then <fr:tex display="inline">L[y:=N][x:=M] \equiv  L[x:=M][y:=N[x:=M]]</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>512</fr:anchor><fr:addr type="machine">#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:title text="{-Term} modulo {-equivalence}"><fr:tex display="inline">\lambda \text {-term}</fr:tex> modulo <fr:tex display="inline">\alpha \text {-equivalence}</fr:tex></fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>As we have seen, the relation <fr:tex display="inline">=_\alpha </fr:tex> is an equivalence relation.
    Hence we can define the set of equivalence classes of terms with respect to <fr:tex display="inline">=_\alpha </fr:tex>.
    Now we can identify a term with its equivalence class.
    We still use <fr:tex display="inline">\equiv </fr:tex> for syntactic equality modulo <fr:tex display="inline">\alpha \text {-equivalence}</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p><fr:tex display="inline">\alpha \text {-equivalence}</fr:tex> is a congruence relation, which means that it is conserved by elementary process of term construction.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>513</fr:anchor><fr:addr type="user">thm-000Y</fr:addr><fr:route>thm-000Y.xml</fr:route><fr:title text="Congruence Property of Substitution">Congruence Property of Substitution</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex display="inline">L=_\alpha  M</fr:tex> and <fr:tex display="inline">N=_\alpha  P</fr:tex>.
    <fr:ul><fr:li><fr:tex display="inline">                 LN =_\alpha  MP             </fr:tex></fr:li>
        <fr:li><fr:tex display="inline">                 \lambda  x.L =_\alpha  \lambda  x.M             </fr:tex></fr:li>
        <fr:li><fr:tex display="inline">                 L[x:=N] =_\alpha  M[x:=P]             </fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>514</fr:anchor><fr:addr type="machine">#280</fr:addr><fr:route>unstable-280.xml</fr:route><fr:title text="Barendregt Convention">Barendregt Convention</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The Barendregt Convention states that we should avoid using the same variable name in different abstractions.
    This is to avoid the confusion of free variables. It states that 
    we choose the names for the binding variables in a <fr:tex display="inline">\lambda \text {-term}</fr:tex> in such a manner
    that they are all different, and each of them differs from 
    all free variables occurring in the term.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>515</fr:anchor><fr:addr type="machine">#281</fr:addr><fr:route>unstable-281.xml</fr:route><fr:title text="Beta Reduction">Beta Reduction</fr:title><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since we have formally defined the <fr:strong>substitution</fr:strong>,
        we can rephrase the reduction as a relation on <fr:tex display="inline">\lambda \text {-term}</fr:tex>, namely <fr:tex display="inline">\beta \text {-reduction}</fr:tex>.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>516</fr:anchor><fr:addr type="user">def-003C</fr:addr><fr:route>def-003C.xml</fr:route><fr:title text="One Step Beta Reduction">One Step Beta Reduction</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>One step beta reduction</fr:strong> (<fr:tex display="inline">\to _\beta </fr:tex>) is defined as follows:
    <fr:ul><fr:li><fr:strong>Basis</fr:strong>:
            <fr:tex display="inline">                 (\lambda  x.M)N\to _\beta M[x:=N]             </fr:tex></fr:li>
        <fr:li><fr:strong>Compatibility</fr:strong>:
            If <fr:tex display="inline">M\to _\beta  N</fr:tex> then <fr:tex display="inline">\lambda  x.M\to _\beta \lambda  x.N</fr:tex>,
            <fr:tex display="inline">ML\to _\beta  NL</fr:tex> and <fr:tex display="inline">LM\to _\beta  LN</fr:tex>.</fr:li></fr:ul></fr:p><fr:p>The term of the form <fr:tex display="inline">(\lambda  x.M)N</fr:tex> is called a <fr:strong>redex (reducible expression)</fr:strong>.
    The term of the form <fr:tex display="inline">M[x:=N]</fr:tex> is called the <fr:strong>contractum</fr:strong> (of the redex).</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>517</fr:anchor><fr:addr type="user">eg-0007</fr:addr><fr:route>eg-0007.xml</fr:route><fr:title text="Divergent Combinator">Divergent Combinator</fr:title><fr:taxon>Example</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An interesting example named <fr:strong>omega combinator</fr:strong> of beta reduction is the following:
    <fr:tex display="block">         ((\lambda  x.(x\space x))\space (\lambda  x.(x\space x)))         \to _\beta          ((\lambda  x.(x\space x))\space (\lambda  x.(x\space x)))     </fr:tex>
    The result of the beta reduction is the same term as the original term,
    and never terminates.</fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:p>We can often perform a sequence of beta reductions. This leads to the definition.</fr:p><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>518</fr:anchor><fr:addr type="user">def-003D</fr:addr><fr:route>def-003D.xml</fr:route><fr:title text="Beta Reduction">Beta Reduction</fr:title><fr:taxon>Definition</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>(zero-or-more-step) beta reduction</fr:strong> (<fr:tex display="inline">\twoheadrightarrow _{\beta }</fr:tex>) is a
    generalized version of the <fr:link type="local" href="def-003C.xml" addr="def-003C" title="One Step Beta Reduction">one step beta reduction</fr:link>.
    <fr:tex display="inline">M\twoheadrightarrow _{\beta } N</fr:tex> if there exists <fr:tex display="inline">n\geq  0</fr:tex> and there are terms <fr:tex display="inline">M_0,M_1,\ldots ,M_n</fr:tex>
    such that <fr:tex display="inline">M_0=M</fr:tex>, <fr:tex display="inline">M_n=N</fr:tex> and <fr:tex display="inline">M_i\to _\beta  M_{i+1}</fr:tex> for <fr:tex display="inline">0\leq  i&lt;n</fr:tex>.
    In other words there exists a chain of one-step beta reductions from <fr:tex display="inline">M</fr:tex> to <fr:tex display="inline">N</fr:tex>.
    <fr:tex display="block">         M\equiv  M_0\to _\beta  M_1\to _\beta \cdots \to _\beta  M_n\equiv  N     </fr:tex></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>519</fr:anchor><fr:addr type="user">thm-000Z</fr:addr><fr:route>thm-000Z.xml</fr:route><fr:title text="Properties of Beta Reduction">Properties of Beta Reduction</fr:title><fr:taxon>Lemma</fr:taxon><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:ul><fr:li><fr:strong>Compatibility</fr:strong>:
            <fr:tex display="inline">\twoheadrightarrow _{\beta }</fr:tex> extends <fr:tex display="inline">\to _\beta </fr:tex>, i.e. if <fr:tex display="inline">M\to _\beta  N</fr:tex> then <fr:tex display="inline">M\twoheadrightarrow _{\beta } N</fr:tex>.</fr:li>
        <fr:li><fr:strong>Reflixivity</fr:strong>:
            <fr:tex display="inline">                 M\twoheadrightarrow _{\beta } M             </fr:tex></fr:li>
        <fr:li><fr:strong>Transitivity</fr:strong>:
            <fr:tex display="inline">                 M\twoheadrightarrow _{\beta } N \land  N\twoheadrightarrow _{\beta } P \implies  M\twoheadrightarrow _{\beta } P             </fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree></fr:mainmatter>
          <fr:backmatter></fr:backmatter>
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
  </fr:backmatter>
</fr:tree>