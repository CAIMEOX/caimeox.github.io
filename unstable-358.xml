<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree toc="true" numbered="true" show-heading="true" show-metadata="true" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
  <fr:frontmatter>
    <fr:anchor>929</fr:anchor>
    <fr:addr type="machine">#358</fr:addr>
    <fr:route>unstable-358.xml</fr:route>
    <fr:title text="Categorical Semantics for Type Theories › Logic, Types and Categories"><fr:link type="local" href="cs-0007.xml" addr="cs-0007" title="Categorical Semantics for Type Theories">Categorical Semantics for Type Theories</fr:link> › Logic, Types and Categories</fr:title>
    <fr:date>
      <fr:year>2024</fr:year>
      <fr:month>3</fr:month>
      <fr:day>21</fr:day>
    </fr:date>
    <fr:authors></fr:authors>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:p>One important principle in type theory is the <fr:strong>Curry-Howard Isomorphism</fr:strong> (Propositions as types).
        It depicts the connection between logic and types. A program can represent a logical argument, and 
        operations in logic find meaningful correspondences in program execution.
        The principle was later extended with category theory due to <fr:strong>Lambek</fr:strong>. In his work, he showed
        a correspondence between STLC and <fr:strong>Cartesian Closed Categories (CCC)</fr:strong> and revealed the connection
        between types and categories. The correspondence is called the <fr:strong>Curry-Howard-Lambek Isomorphism</fr:strong>.</fr:p>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>638</fr:anchor>
        <fr:addr type="machine">#359</fr:addr>
        <fr:route>unstable-359.xml</fr:route>
        <fr:title text="Syntax and Semantics">Syntax and Semantics</fr:title>
        <fr:date>
          <fr:year>2024</fr:year>
          <fr:month>3</fr:month>
          <fr:day>21</fr:day>
        </fr:date>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:p>In general, there are two approaches to understand or design a type system: the <fr:strong>syntactic</fr:strong> view 
            and <fr:strong>semantic</fr:strong> view.

            The syntactic view focuses on the syntactic structure of types and programs. We study about <fr:strong>subject reduction</fr:strong>,
            <fr:strong>cut elimination</fr:strong> and etc, simply by manipulating the syntax. It is usually more direct and easier to understand
            as it is often conducted via induction on some syntactic structures. And it also suggest algorithms which can be implemented.
            The disadvantage is that it is limited and hard to proof some properties like normalization.

            The semantic appoaches are more powerful in general. It is based on mathematics models of type systems.
            In exchange of the strength and generality, it is usually harder to understand and heavyweight, requries
            more intuition of the concepts.</fr:p>
        <fr:p>One clasical semantic approach to logic is algebraic logic. A logical system is modeled by some algebraic theory.
            (often related to <fr:strong>lattices</fr:strong> and <fr:strong>semi-lattices</fr:strong>). Famous examples include <fr:strong>Boolean algebras</fr:strong>
            for classic propositional logic and <fr:strong>Heyting algebras</fr:strong> for intuitionistic counterpart. 
            The algebraic logic is a powerful tool to study the properties of logical systems, but has a limitation that 
            all operations are limited in one structured set.</fr:p>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>639</fr:anchor>
        <fr:addr type="machine">#360</fr:addr>
        <fr:route>unstable-360.xml</fr:route>
        <fr:title text="Computations as Monads">Computations as Monads</fr:title>
        <fr:date>
          <fr:year>2024</fr:year>
          <fr:month>3</fr:month>
          <fr:day>21</fr:day>
        </fr:date>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:p>An important result from ategorical semantics could be <fr:strong>monads</fr:strong>.
            In <fr:strong>Moggi</fr:strong>&apos;s paper, he showed that monads can be used to model computational effects.</fr:p>
        <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>640</fr:anchor>
            <fr:addr type="user">def-003T</fr:addr>
            <fr:route>def-003T.xml</fr:route>
            <fr:title text="Monad">Monad</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors></fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>A <fr:strong>monad</fr:strong> of a category <fr:tex display="inline">\mathcal {C}</fr:tex> is an endofunctor <fr:tex display="inline">M:\mathcal {C}\to \mathcal {C}</fr:tex> with two natural
    transformations <fr:tex display="inline">\eta :\text {id}_{\mathcal {C}}\Rightarrow  M</fr:tex> and <fr:tex display="inline">\mu :M^2\Rightarrow  M</fr:tex> satisfying the following conditions:
    
 
  
  <fr:figure><fr:resource hash="65b705e596b5ade3ad3981d38dbae97a"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzQ0MS4xMzcwMDZwdCcgaGVpZ2h0PScyMTcuMjkwOTE5cHQnIHZpZXdCb3g9Jy03MiAtNzIgMjk0LjA5MTMzNyAxNDQuODYwNjEzJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQS9RQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wbW1OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzhBQUFBMEU4T3pIMW9aV0ZrQUFBQ0lBQUFBQzRBQUFBMktmUEd0MmhvWldFQUFBSlFBQUFBSGdBQUFDUUZMQUs0YUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1hmQUpwc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURZQWFHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWdibUZ0WlFBQUFwd0FBQURKQUFBQk11c0lrZWh3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm02bUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWRJbERNMEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkpqMW40SHhPRE1EZ3h3REF5TWZJenVidUJnWWlyQXBxZXN4cXF1cG01bmJNWnFiR1ltSnNqRWVDV3BsWlZiaTROS3Q0R0JrazNKVTlGS3daV0d4VmZCU2RKUmlZMlI2YnZaMVQyeWxoSGhWS2dzWEM1ZUpiSlJ0d1lvVmhiYVJzaVpjTEp3TVFNRElrQXkwYXdMUUxta2doNDBkWkp1YVBxTUoyQUloTlhVMUlFTmNqbEZjakhFQzFGUm1KbGIxY0RWVHhyUmlkbVptaUlXTURCQXpHVms1T0Zoa2s4T2FHS1YreDNKenN6S0NMUVFBRWFNamozamFZMkJrWUdBQTRqMkJFY3ZqK1cyK01qQ3pNSURBNDZPT2R4SDBmd2JtSUdZUWw0T0JDVVFCQURxeUNxSUFBSGphWTJCa1lHQm0rTThBSklNWWtobVNHWTh6QUVWUUFCTUFSc2tDNmdBQUExSUFBQUlxQUpvQVl3QUFBQUFBQUFBMkFHaDQybU5nWkdCZ1lHYVFad0RSREZBU0NRQUFBNzhBSmdCNDJqMk1NUXZDTUJDRnYySVZyWU9ENE9BZ3dSOVF0T3JtNXVEazZ1Qm1UWkFPVFNXdFJSZnhwM3NOd1FzNXZudnYzUUVKSHlLNmlwajQzbFVzYnhLNHo1aHA0SUhvaThBSmM1YjBpT0tSS0F2MmdXT0dYQUwzbVpFSEhvaitDcHl3NVh1b3lzZXpNVTZkS20yY3ZaVnVkemF1TGlxcjF1bXFHNC9HR25kdGpGYjVXK20ycU50N3FUWnBsbVljcUNoNThLVEI0RkNjUk5HZUxUZnhIRHZPZnE0cHhMT1NXWk95K3J0SGNhMVBYUDBWTFltY3QzUk5LenUxOUx0a0ZSdlp5N3IvQTFXNExrVUFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUb0FBb0FBQUFBQlp3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wVEdOdFlYQUFBQUU0QUFBQU5RQUFBRHdBVGdCK1oyeDVaZ0FBQVhBQUFBSVRBQUFDWU5ZdzlUbG9aV0ZrQUFBRGhBQUFBQzRBQUFBMktYVEd1R2hvWldFQUFBTzBBQUFBSHdBQUFDUUZSd0lSYUcxMGVBQUFBOVFBQUFBVUFBQUFGQWp0QVdOc2IyTmhBQUFENkFBQUFBNEFBQUFPQWV3Qk1tMWhlSEFBQUFQNEFBQUFGd0FBQUNBQUNBQThibUZ0WlFBQUJCQUFBQURKQUFBQk11MEtrZXh3YjNOMEFBQUUzQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1NbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1CZ3pNL3dIOHBraDBraHEvZ09GQWJOUERIOEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEthaklZLy84UDVHc3dHUDcvLy8vbS8wdGdWVUFBQUl1RkNNWUFBQUI0MmtXUVRXc1RRUnlINS9lZmRJWnM2U1loeWVhOVNiYnVMcTB4b1MrN3F5bW1qZGphMUpjVzIwVFFWRnFMRld1UnRCWnZCYWtSRCtLSDZFbTkrQUY2RnNIdm9UZEJFRUY2MERwTER6SXdNLzg1UFBQd01MRDlVK0FGWnl6TEdGSkdRb29JaEJTR3VrWmdPMnI1OWd3ODdBeEoyYXpMU3h5ZExVME92WEwxUVl2b2d1NXhCb3FLcVozbzd1ZTNKMnZoS09IQlFibDBzTG4zMGpwVVNMYWcrS3RuL0xpaXBneVpFRktIN1UvTm9BRy9Dc2QyUGIvYjl3TGdxT2s5ellGSFZydmd1L05oQ003T2FIZVBaamMyU2VPaDJJMGZSNSsrMVRVUkpzWUNmazl0WCtrRHk2Z3pKb3hwSkd1SXdKMmM4SnlZRHNjMVBOOHpjSWVYV3M2ajVkNjgweXJ4eW1xaXZEK1pIS1EzZjc1a2t4WUhrWlhNa3BZSTR4d1pWV2dCdDhrWURkQjdOc3FZSmN1K3AyeEoxUkJ5R0VwL1JOaU9zaDlHU2tjUXpQZDhOZEpBOGU4OWtQeWR1OEtYYnRxZGpHTUFabHdiSXp6YmVQaWFVM3U2UFhicnB6V282WFI4bkJmaVYyNnJ2MDQ0NzVJVnllZVF0RnRQT0I3ZnY3WmRtVFBuZ0pBMkd3OWMvTlB2cE5NN1ZsZkRpSEM5VlBCWkEyNFZVZ2taS1ZVMDBKbFFkUU0vNVNSVjEvOFB2b3BRQmRJWHN5RlJ0aWZUeVFTZnQ0cnR3Z1RQWjhaRDFQdjRuSEIxdWQwRkhlNnM5em5NV2hISW11YTJXVnZodUk0T2owV0pJNUpQTjh2Tm1nS1ZSUzFWQUx6RzR0TGw4YzFpZkt1eHZNZlJYaWpsUzVtWXhTc0YwT0xhN1JYMkQ4eU5YKzhBZU5wallHUmdZQURpQmZ0K3pJL250L25Ld016Q0FBS1BqenJlUmREL0daa3VNNE80SEF4TUlBb0FhWWtNREFBQWVOcGpZR1JnWUdiNHo4REF3SFNad1p6QmtvbVBBU2lDQWxnQVBqMENYZ0FDMHdBQUFja0FkQUhKQUVnQ1J3QndBRUVBTndBQUFBQUFNQUJnQUl3QTBnRXdBQUI0Mm1OZ1pHQmdZR093WmdEUkRGQVNDUUFBQnN3QVJRQjQyajJNTVF2Q01CQ0Z2MklWcllPRDRPQWd3UjlRdEFvdWJnNU9yZzV1MWdUcDBGVFNXblFSZjdyWEVMeVE0N3YzM2gyUThDR2lxNGlKNzEzRjhpYUIrNHlaQmg2SXZnaWNNR2RKanlnZWliSmdIemhteUNWd254bDU0SUhvcjhBSlc3Nkhxbnc4RytQVXFkTEcyVnZwZG1majZxS3lhcDJ1dXZGb3JISFh4bWlWdjVWdWk3cTlsMnFUWm1uR2dZcVNCMDhhREE3RlNSVHQyWElUejdIajdPZWFRandybVRVcHE3OTdGTmY2eE5WZjBaTEllVXZYdExKVFM3OUxWckdSdmF6N1Axa3lMazBBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVI4QUFvQUFBQUFCVWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXaDFkR050WVhBQUFBRTRBQUFBTVFBQUFEd0FkUUNmWjJ4NVpnQUFBV3dBQUFHekFBQUNFT3dvM3c5b1pXRmtBQUFESUFBQUFDOEFBQUEyS3M3SGRHaG9aV0VBQUFOUUFBQUFIZ0FBQUNRSFRBS1phRzEwZUFBQUEzQUFBQUFNQUFBQURBbW5BRWhzYjJOaEFBQURmQUFBQUFnQUFBQUlBSFlCQ0cxaGVIQUFBQU9FQUFBQUZ3QUFBQ0FBQlFCaGJtRnRaUUFBQTV3QUFBRFVBQUFCUHBrUmRjZHdiM04wQUFBRWNBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbU5tZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHI2TWtRd00vd0g4cGtoMGtocS9nT0ZBYjF3RE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUSytqSkUvUDhQNUlQcC8xdityd0tyQWdJQWxCc0pEZ0FBQUhqYU5aQzlqdE5BRklYbjNCblB4STQ5ZHVMWTFpck9KTktDTFVGSWhNTGFBbW16QlFVSUNpaG9rSkJBU0dpWEFvcEZDRUhEVHdGSVM4VTd3QU1nS3JUaUlhaW9xR2twS0VNWU85Q016dHh6N3BXK3c4Q202N1U0UTEvWkpjYkFReGhVR25Pb3NpalBWVmxhMVRHa0tuYTZrSWxNeDBpVDFwWFdXNktPcTdKUml5ck5ZaXpSQ0ZrV2tuOStLNENUNXhFNEw1NTdEcUxnZ25IZS83a3JlK0hOSTRIaDZVQkNpL3Y3UVNCMnAvSTFMcG9vZkJmN3VJN0hIZDEvTTBUWXIwZjBZUFdqcndJcFJncWNFOXhRQXJHaHE2c25XdkNFbnEyK2FUZmVBc2pWVFFKRCs1NmFVQjV4UHJKUjFWc2QwMlV0d1hNRkpNemlzWHk5NXZ0MHpHN2JUMTNWTXlxWEdLTzJYQU81clMxV0NLc05GdGsvenJhRnhSSTdjNFN3Z2RiS1dxdVlvN1gyaU0rd0xUZVhNb1BtVUlKZkh5Tk80eGkyZ3NNN0xwSHZ6ZmFTcmZwVjc4UTFiM1RXVitUTHc1ZXVBNzlqakhOdzY2QWJnY1lkWld2em5VZWJoZkpLRVh4LzZ1VFRoSnJoSmozSjhlR1R6Z1krdkEyMWtGcHlNMGgzajJZM3ZwZ1E1RFhJVFYrQkVuMFYvcjczc0pzRmd5NVI1LzlDS0dsUytqOWhvaDdYbXlFbFNpUU9ZMzhCNHJ4RDFBQjQybU5nWkdCZ0FHS3hsN0dDOGZ3Mlh4bVlXUmhBNFBGUng3c0krdjkvRmwybWZVQXVCd01UU0JRQU5Id0xtd0I0Mm1OZ1pHQmdadmpQQUNRZk1zajgzOEtpeXdBVVFRSE1BRis5QSt3QUFBSjJBQUFENFFBc0ExQUFIQUFBQUFBQWRnRUllTnBqWUdSZ1lHQm1TR0FBMFF4UUVna0FBQW9ZQUdjQWVOcE5qckZxd3pBVVJZK3BZNmhieUpRTUhZcW1qTVoyK2dHRkRKbXlaaXdra1FndVNBcXlZOGdTK2dIOTZENHJHdnFFSGtmblhRa0JKWGN5cHNxWXh6NVZUaUduQjg5NFlaRzRrS1VTbDd5eDRva3NmeGJ6em1maW5GZStFczlZOHAyNEVQK1R1T1NEMzQyM2wrdGdndHA1YllJN1dkczE5ZDZFdnZOT05WWDlFRnZqVERnTVJxdmpUZW14NjhlelZldXFyVm8yZUN3WHJnd1lndnhzSjBaSGRweGtadWxvcU5sSDE4dkp5MFNKcThUK1Qyd2w0V0xxRUYvVGtqcHlrNjRaSmROTFAwdGFzWmE3N2JUL0FPQ0NNTDE0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMktTSEd0MmhvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGpLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaUR6Yzc3OGZ6MjN4bFlHWmhBSUhIUngzdkl1ai9ERXdOekNBdUJ3TVRpQUlBY0E0TDlBQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZdzlpOEpBRUlhZllDSVlDeHV4c0xqYndqb2swZm9hQ3l0YnEydlVYU1ZGTnJLSkFVRXM3M2M3V1JkdVlJZm4vWmdGVWw1RURCTXg4M3VZbUVUVWh4T216QU9QUlgwSFRsbXlZa1FVVDhUNTRpZHdMTWx2NElRRmw4Qmo4WitCVXpiOGJadjZkdStNVS90R0cyZlB0U3Z5ZzNGdDFWaFZaTG5YTzJPTk8zWkdxOU5ENmI1cSsydXQxbG1abFd4cHFMbHhwOFBnVU96RjBaNHRaOGtjQlRrSDc3UlVrbHBwRldUaS91Yzd5YTN2SFAxUFdqb25IckkxdlZ5MXNxL1NWcXpsc2h6ZUcyUEhMeEVBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVFQUFvQUFBQUFCZUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hlcDRyR050WVhBQUFBRThBQUFBTXdBQUFFUUF5UVJ1WjJ4NVpnQUFBWEFBQUFJeEFBQUNvQzNpRTZGb1pXRmtBQUFEcEFBQUFDOEFBQUEyS3pER20yaG9aV0VBQUFQVUFBQUFJQUFBQUNRSHdnTXNhRzEwZUFBQUEvUUFBQUFRQUFBQUVBeENBSzlzYjJOaEFBQUVCQUFBQUFvQUFBQUtBZFFBN20xaGVIQUFBQVFRQUFBQUZ3QUFBQ0FBQmdCU2JtRnRaUUFBQkNnQUFBRFBBQUFCT1BOaEtxTndiM04wQUFBRStBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUZtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUV6QXhKSUtTNUxCMHI2TW05blp2Z1A1RE16TUlLRUdSRXEvZ09GQWRSSURZb0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtmQm0yTW0vLy94L0Irci9sdis4Zkg3QmFNQUFBQkVBTU5BQjQyaTJSelc3VFFCU0ZmZTZNWjJMSEdUdngyQk9hTkVtVE51NFBTZ29KRG0xS1N0VVdpc1NpYkZFWGJKQ1FRR1VERXR2Q3BnaWtDaUVoWG9BMWo5QU5Zc1U3c09JeDBqS3BxbG5NblhQdWxjNDMxNEh6K1BLU245RzVjK2c0WUZLa1RlUmE5QkdpMjhjd04yaytpaUZrT3l0Q21KbWJHb1UrcEhVbk1CT000bEZ1NjQ3bzVtYVFweWFleVlQY2FKRjFCVTlQT1dRbGE0YnUrNTN0SXFOSWJjNnpMeGRQZksxeGZPcUNkRjhWZ05COTlkSm5oSkxjV25WUE9BcVJqaGRRQ2I4bUFYdU9UNzdTbitkUmlVWjFlakg5WjZRRThZNEVCN1BKeWhLb3pOSGU5SU5tZFRxZS9rMTRVR2ZFUEd0d2JodWlBdGhhalNpVkFveTNiYnNYVDgvcFFGay9EdTFUT3hiZEdWd3UwVGY4Y3ZZZHg4U1dLelU2WkFvbXRaRGJmSUxCVENDRlJGOHB5R2Rmb1lXMHA1dGRYVmtJQmRudVpxTXowclVGa3NZb1JrRzBlWFBQZUZsVGVsV3Z3VVhIQ0UvcFZ0c3JjTjhURkpkcmVYZ1FVN2F5TXg0MEl6dFlTdkNEN2dZZG9xYWJQRHNhVnpxTEhZN2I3ZkwzZHplVWo2WTBINCtTbmtycm9QMnNKa0RrdXp1dEFhUHFRRFJiSEkyVFRkV2hxR3laMWkzVEEveDI3czEyZTUwdG5sQTNzN1dDcFdIZGJKdmxkNGJYU2g4OTVLTUp6UWhOZzBMUTFtdEs1cFFHZjhNWnBTdmp3MnJveTNudGVrbGR3MThMaWlLTUcrMmlLLzJpUUJvRzJjYWp3dUJwNitFd0FHQXV0b05aa2dSL1N0WGxXMFM3eThsYzQrMmhEaFdpOHVyUDlaNkpranB3djZlTEZpUGFyYWN0V3RvWUw1TGJINVpxZGkzL0FiVVNVSWNBQUFCNDJtTmdaR0JnQU9MTDdlWFI4ZncyWHhtWVdSaEE0UEZSeDdzSStyOHFTei9UZmlDWGc0RUpKQW9BVGwwTDR3QjQybU5nWkdCZ1p2alB3TURBRXMxZzhQOE1TejhEVUFRRnNBQUFYY3dEOWdMR0FBQUVXd0JNQXNjQU13SmFBREFBQUFBQUFJUUE3Z0ZRQUFCNDJtTmdaR0JnWUdFSVpBRFJERkFTQ1FBQUNMd0FXUUI0MmsyTVBXL0NNQkNHbjRnRWlUQ3dvQTRkaW9mT0VRUWt0aTRNVEt4TUxJQmRsTUUyY2tJa3BLcGpmM2N2cm9lZTVOUHpmcHlCa204eWhzbVl4VDFNVGlIcWp3dW16Qk9QUlMwU2w3enl6b2dzbjRqenhrZmlYSkpUNG9JWFBoT1B4ZjlLWExMaForZnQvZEdab0E1ZW0rQ3UxamJib3dsdDQ1MWFWY3VvOThhWmNPNk1WcGVuMG4zVDlqZXIxbFZkMWV6d1dPNDg2REFFRkFkeGRHVEhWVEpMdzVaamRGcGhMNzVpUmNYeVg3NlgzTVhPT2Y2a3BYUGhLVnZUUzZPVmZaT3VZaTJYOWZCK0Fjd3JML2tBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTTUFBb0FBQUFBQlVRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoV2gyaTJOdFlYQUFBQUU0QUFBQU1RQUFBRHdBZFFDZloyeDVaZ0FBQVd3QUFBSEdBQUFDRk9UU1dFNW9aV0ZrQUFBRE5BQUFBQzhBQUFBMks4dkhjR2hvWldFQUFBTmtBQUFBSUFBQUFDUUlrQVFnYUcxMGVBQUFBNFFBQUFBTUFBQUFEQXpxQU9Gc2IyTmhBQUFEa0FBQUFBZ0FBQUFJQUlJQkNtMWhlSEFBQUFPWUFBQUFGd0FBQUNBQUJRQmFibUZ0WlFBQUE3QUFBQURPQUFBQk9QTmRLcDl3YjNOMEFBQUVnQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm04V09jd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjByNk1rUXdNL3dIOHBraDBraHEvZ09GQWNZcERPVUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEsrakpFL1A4UDVJUHAvMXYrcndLckFnSUFsQnNKRGdBQUFIamFKWkE5aXhOUkZJYm5QZmZtM3AxazVzN1huWm5OMXdheU9Ba3FpYXhtUmxaTWRCR0xiY1JDc0ZZYlVVdkJSZ1hGZ0JZUkxkMVNCTVcvb0JiK0EvK0IxWGIyZ2lUcjJVMTFQdDVUbk9keDREdzdXdFpPMHpmbnB1TkFhSlgxVUdhcHdSaTZHRndvODUyeVNxQUcvV0xRZ0ZaNW1lVnFUQnhOa1U5UkpkV2tHRU1WRTc0OHoxa0Mzbk5qdGRMYmhaS2Y1d0p1ZkRhTUVhdkZtd2ladmRnVmk5VWtEVTJkRm5NcDl0MFFsTzFlZmh3UW9vMXJRL0ZjUkxaall4dCtUQVA1RWwrOE5QcGdFcGRVcytyU3ZlVmhvQ1FJeWt0ZFNDa01sekNuM2VYcnRnZ04zVjhlYnA0NlRuc2tJQ213ZFlnek9mNTV2Z1NnZk9zQ2JyTDhUdnRHODl6MENZZ2NPSGVQVnZJU083ak5EcEl0TUVDYWFUYlFYMk15WWtEcXhNMGF2eitveW1xS0dZa1J0cG0rcVBLcXpBMEdmWjN6ZnNUQ3B1aFJsZVZXNmI3U2RQQ2oxajFuTEZwWDl0NUZoTGpXYWFIMjl0VWpWd0crOWZpWnpkbmVBeU9FTU5kdmJJVi9QOVU2T3laQjg4WDdRQ0JTbmZiVHI4MEl0aTE1bUYxOUdGQzlQcm8xd256MTB6T00yejdHalppVy9Mcis4K1NPNTdyS0p4SnJEMUhna1JpMkc3OWhHd0ZiYUpHVWlKTUc0bDhIYVpxNlpObkxpYThOaTg3d1B5RDdTU2tBQUhqYVkyQmtZR0FBNHRSN3YwcmorVzIrTWpDek1JREE0Nk9PZHhIMC83K3NXa3g3Z0Z3T0JpYVFLQUJzT2d6YUFIamFZMkJrWUdCbStNL0F3TUNxekpEOC95ZXJGZ05RQkFVd0F3QlpTQU82QTFRQUFBVWpBSDRFY3dCakFBQUFBQUNDQVFwNDJtTmdaR0JnWUdhSVpBRFJERkFTQ1FBQUNXa0FZQUI0MmsyTVBXL0NNQkNHbjRnRWlUQ3dvQTRkaW9mT0VRUll1ekF3c1RLeEFIWlJCdHZJQ1pHUXFvNzkzYjI0SG5xU1Q4LzdjUVpLdnNrWUptTVc5ekE1aGFnL0xwZ3lUendXdFVoYzhzbzdJN0o4SXM0Ykg0bHpTVTZKQzE3NFREd1cveXR4eVlhZm5iZjNSMmVDT25odGdydGEyMnlQSnJTTmQycFZMYVBlRzJmQ3VUTmFYWjVLOTAzYjM2eGFWM1ZWczhOanVmT2d3eEJRSE1UUmtSMVh5U3dOVzQ3UmFZVzkrSW9WRmN0LytWNXlGenZuK0pPV3pvV25iRTB2alZiMlRicUt0VnpXdy9zRnlKc3Y4UUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNDcuNTk3MDksLTY1LjQzOTMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDc1LjA0NTY2NiwxLjUyOTA3MSlzY2FsZSgtMSwtMSknPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTUuMzM3NjEzLC0xMjMuMjQxNjI1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTYuMDYyNSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDk1LjMzNzYxMywtMTIzLjI0MTYyNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSc5NS4zMzc2MTMnIHk9Jy0xMjMuMjQxNjI1Jz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzEwNi4wODg5NTYnIHk9Jy0xMjYuODU2OTg5Jz4yPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzExMC41NTgzMjYnIHk9Jy0xMjMuMjQxNjI1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzExNC40MzI3JyB5PSctMTIzLjI0MTYyNSc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScxMjMuNDY4MjU1JyB5PSctMTIzLjI0MTYyNSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNTkuODMxODE0LC0xMjMuMjQxNjI1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIyMi4wOTEzMzcsLTEyMy4yNDE2MjUpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMy44MTk0NCwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDIyMi4wOTEzMzcsLTEyMy4yNDE2MjUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjIyLjA5MTMzNycgeT0nLTEyMy4yNDE2MjUnPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjMyLjg0MjY3OScgeT0nLTEyMy4yNDE2MjUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjM2LjcxNzA1MycgeT0nLTEyMy4yNDE2MjUnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjQ1Ljc1MjYwOScgeT0nLTEyMy4yNDE2MjUnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjg0LjM1MDg2LC0xMjMuMjQxNjI1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM0OC44NDUwNiwtMTIzLjI0MTYyNSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE2LjA2MjUsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgzNDguODQ1MDYsLTEyMy4yNDE2MjUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMzQ4Ljg0NTA2JyB5PSctMTIzLjI0MTYyNSc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSczNTkuNTk2NDAzJyB5PSctMTI2Ljg1Njk4OSc+MjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczNjQuMDY1NzcyJyB5PSctMTIzLjI0MTYyNSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSczNjcuOTQwMTQ2JyB5PSctMTIzLjI0MTYyNSc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczNzYuOTc1NzAyJyB5PSctMTIzLjI0MTYyNSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NS4zMzc2MTMsLTg4LjA1NDA3NSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNTkuODMxODE0LC04OC4wNTQwNzUpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjIyLjA5MTMzNywtODguMDU0MDc1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTMuODE5NDQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgyMjIuMDkxMzM3LC04OC4wNTQwNzUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjIyLjA5MTMzNycgeT0nLTg4LjA1NDA3NSc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScyMzIuODQyNjc5JyB5PSctODguMDU0MDc1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzIzNi43MTcwNTMnIHk9Jy04OC4wNTQwNzUnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjQ1Ljc1MjYwOScgeT0nLTg4LjA1NDA3NSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NS4zMzc2MTMsLTYzLjk4NDU2KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDk1LjMzNzYxMywtMzQuMjk2MTAzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE1OS44MzE4MTQsLTM0LjI5NjEwMylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE2LjA2MjUsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxNTkuODMxODE0LC0zNC4yOTYxMDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTU5LjgzMTgxNCcgeT0nLTM0LjI5NjEwMyc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxNzAuNTgzMTU2JyB5PSctMzcuOTExNDY3Jz4zPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzE3NS4wNTI1MjYnIHk9Jy0zNC4yOTYxMDMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTc4LjkyNjknIHk9Jy0zNC4yOTYxMDMnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTg3Ljk2MjQ1NScgeT0nLTM0LjI5NjEwMyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMjIuMDkxMzM3LC0zNC4yOTYxMDMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjg0LjM1MDg2LC0zNC4yOTYxMDMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNi4wNjI1LDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMjg0LjM1MDg2LC0zNC4yOTYxMDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjg0LjM1MDg2JyB5PSctMzQuMjk2MTAzJz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzI5NS4xMDIyMDInIHk9Jy0zNy45MTE0NjcnPjI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjk5LjU3MTU3MicgeT0nLTM0LjI5NjEwMyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSczMDMuNDQ1OTQ2JyB5PSctMzQuMjk2MTAzJz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzMxMi40ODE1MDEnIHk9Jy0zNC4yOTYxMDMnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTUuMzM3NjEzLDEuNTI5MDcxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE1OS44MzE4MTQsMS41MjkwNzEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNi4wNjI1LDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTU5LjgzMTgxNCwxLjUyOTA3MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PScxNTkuODMxODE0JyB5PScxLjUyOTA3MSc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxNzAuNTgzMTU2JyB5PSctMi4wODYyOTMnPjI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTc1LjA1MjUyNicgeT0nMS41MjkwNzEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTc4LjkyNjknIHk9JzEuNTI5MDcxJz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzE4Ny45NjI0NTUnIHk9JzEuNTI5MDcxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIyMi4wOTEzMzcsMS41MjkwNzEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjg0LjM1MDg2LDEuNTI5MDcxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTMuODE5NDQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgyODQuMzUwODYsMS41MjkwNzEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjg0LjM1MDg2JyB5PScxLjUyOTA3MSc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScyOTUuMTAyMjAyJyB5PScxLjUyOTA3MSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PScyOTguOTc2NTc2JyB5PScxLjUyOTA3MSc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczMDguMDEyMTMyJyB5PScxLjUyOTA3MSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTYyLjQ5My0zNS44Mzk1MVYtNTMuMDM5NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLC02Mi40OTMsLTUzLjIzOTU4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04OC41MzgxLC00NC44NTIwMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPsK1PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc5Ljg4OTgyMScgeT0nMi44NjI5NjcnPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nODYuODI5MTQ1JyB5PScyLjg2Mjk2Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc4OS41Mjc0JyB5PScyLjg2Mjk2Nyc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc5NS40NTMxNzgnIHk9JzIuODYyOTY3Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS00MS45MjQ5Ni02Mi45MzkzSDQzLjc2ODA1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQzLjk2ODAzLC02Mi45MzkzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00LjUzMzYzLC01OS4yMjU0NiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPsK1PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc5Ljg4OTgyMScgeT0nMi41MzA4ODQnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNMCA1My40Mzk1NlYzNi4yMzk0NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwzNi4wMzk0OSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyLjM1Mjc1LDQzLjY3ODQ0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg3NS4wNDU2NjYsMS41MjkwNzEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNzUuMDQ1NjY2JyB5PScxLjUyOTA3MSc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc3OS4wMTY5MDcnIHk9JzIuODYyOTY3Jz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jzg1Ljk1NjIzJyB5PScyLjg2Mjk2Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc4OC42NTQ0ODUnIHk9JzIuODYyOTY3Jz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jzk0LjU4MDI2MycgeT0nMi44NjI5NjcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTEwNi42NjEwMSA1Ni41OTY3NkwtMTguNzEwMzMgMzIuMTcyNzMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC45NjM0OSwtMC4yNjc1NSwwLjI2NzU1LDAuOTYzNDksLTE4LjUxNzY1LDMyLjExOTIzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03Ni4xNTYwNSwzOC45NjQ2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPsK1PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc5Ljg4OTgyMScgeT0nMi41MzA4ODQnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTE4LjMyNDk4IDYyLjI5OTI5SC0xMDYuMjYxMDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsLTEwNi40NjEwMyw2Mi4yOTkyOSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNzUuMDkwMyw2Ni40MDIwNCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nODMuMzkwNzc5JyB5PScxLjUyOTA3MSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc4Ni41MDQxMjInIHk9JzEuNTI5MDcxJz7OtzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc5MC42MDg5MScgeT0nMi41MzA4ODQnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nOTcuMDMyODE4JyB5PScxLjUyOTA3MSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00xOC4zMjQ5OCA2Mi4yOTkyOUgxMDYuMjYxMDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA2LjQ2MTAzLDYyLjI5OTI5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjAxNzg4LDY3LjI0MDk0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg3NS4wNDU2NjYsMS41MjkwNzEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNzUuMDQ1NjY2JyB5PScxLjUyOTA3MSc+zrc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNzkuMTUwNDU0JyB5PScyLjg2Mjk2Nyc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc4Ni4wODk3NzgnIHk9JzIuODYyOTY3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzg4Ljc4ODAzMycgeT0nMi44NjI5NjcnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nOTQuNzEzODExJyB5PScyLjg2Mjk2Nyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00xMDYuNjYxMDEgNTYuNTk2NzZMMTguNzEwMzMgMzIuMTcyNzMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuOTYzNDksLTAuMjY3NTUsMC4yNjc1NSwtMC45NjM0OSwxOC41MTc2NSwzMi4xMTkyMyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2NC44NDU3NSwzOC45NjQ2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPsK1PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc5Ljg4OTgyMScgeT0nMi41MzA4ODQnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNNjIuNDkzLTM1LjgzOTUxVi01My42Nzk2MScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDYyLjQ5MywtNTMuODc5NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2NC44NDU3NSwtNDUuNzg1OTMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDc1LjA0NTY2NiwxLjUyOTA3MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSc3NS4wNDU2NjYnIHk9JzEuNTI5MDcxJz7CtTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc3OS44ODk4MjEnIHk9JzIuNTMwODg0Jz5YPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS00MS45MjQ5Ni0yNi45Nzk3OEg0MS41MjUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuNzI0OTgsLTI2Ljk3OTc4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMi45NjgzNywtMjIuODc3MDMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDc1LjA0NTY2NiwxLjUyOTA3MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSc3NS4wNDU2NjYnIHk9JzEuNTI5MDcxJz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzgzLjM5MDc3OScgeT0nMS41MjkwNzEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nODYuNTA0MTIyJyB5PScxLjUyOTA3MSc+wrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nOTEuMzQ4Mjc3JyB5PScyLjUzMDg4NCc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSc5Ny43NzIxODUnIHk9JzEuNTI5MDcxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4="></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            {M^2(X)} &amp;&amp; {M(X)} &amp;&amp; {M^2(X)} \\
            &amp;&amp; {M(X)} \\
            \\
            &amp; {M^3(X)} &amp;&amp; {M^2(X)} \\
            &amp; {M^2(X)} &amp;&amp; {M(X)}
            \arrow [&quot;{\mu _{M(X)}}&quot;&apos;, from=4-2, to=5-2]
            \arrow [&quot;{\mu _X}&quot;, from=5-2, to=5-4]
            \arrow [&quot;{1_{M(X)}}&quot;, from=1-3, to=2-3]
            \arrow [&quot;{\mu _X}&quot;&apos;, from=1-1, to=2-3]
            \arrow [&quot;{M(\eta _X)}&quot;&apos;, from=1-3, to=1-1]
            \arrow [&quot;{\eta _{ M(X)}}&quot;, from=1-3, to=1-5]
            \arrow [&quot;{\mu _X}&quot;, from=1-5, to=2-3]
            \arrow [&quot;{\mu _X}&quot;, from=4-4, to=5-4]
            \arrow [&quot;{M(\mu _X)}&quot;, from=4-2, to=4-4]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure></fr:p>
          </fr:mainmatter>
          <fr:backmatter></fr:backmatter>
        </fr:tree>
        <fr:p>It requires an operation over functors named <fr:strong>whiskering</fr:strong></fr:p>
        <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>641</fr:anchor>
            <fr:addr type="user">def-003U</fr:addr>
            <fr:route>def-003U.xml</fr:route>
            <fr:title text="Whiskering">Whiskering</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors></fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Let <fr:tex display="inline">F,G:C\to  D</fr:tex> and <fr:tex display="inline">H,D\to  E</fr:tex> be functors and <fr:tex display="inline">\eta :F\to  G</fr:tex> be a natural 
    transformation whose coordinate at any object <fr:tex display="inline">A</fr:tex> of <fr:tex display="inline">C</fr:tex> is <fr:tex display="inline">\eta _A</fr:tex>, then 
    <fr:strong>whiskering</fr:strong> <fr:tex display="inline">H</fr:tex> and <fr:tex display="inline">\eta </fr:tex> yields the natural transformation 
    <fr:tex display="inline">H\circ \eta :H\circ  F\to  H\circ  G</fr:tex> whose coordinate at <fr:tex display="inline">A</fr:tex> is <fr:tex display="inline">H(\eta _A)</fr:tex>.</fr:p>
          </fr:mainmatter>
          <fr:backmatter></fr:backmatter>
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:anchor>642</fr:anchor>
        <fr:addr type="machine">#361</fr:addr>
        <fr:route>unstable-361.xml</fr:route>
        <fr:title text="Logic as Adjoint Functors">Logic as Adjoint Functors</fr:title>
        <fr:date>
          <fr:year>2024</fr:year>
          <fr:month>3</fr:month>
          <fr:day>21</fr:day>
        </fr:date>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:p>Categorical logic is a new approach to logic, due to <fr:strong>Lawvere</fr:strong>. 
            He showed that logical constructs are fundamentally just <fr:strong>adjoint functors</fr:strong>.
            This allows us to capture many logical constructs by using only one categorical concept.
            Adjoint also provides a strong guarantee about the derived syntactic formulation.</fr:p>
        <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>643</fr:anchor>
            <fr:addr type="user">def-003V</fr:addr>
            <fr:route>def-003V.xml</fr:route>
            <fr:title text="Adjoint Functor">Adjoint Functor</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:authors></fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>Let <fr:tex display="inline">\mathcal {C}</fr:tex> and <fr:tex display="inline">\mathcal {D}</fr:tex> be categories and a pair of functors 
    <fr:tex display="inline">F:\mathcal {C}\to \mathcal {D}</fr:tex> and <fr:tex display="inline">G:\mathcal {D}\to \mathcal {C}</fr:tex>. This is called 
    pair of <fr:strong>adjoint functors</fr:strong> (or <fr:strong>adjunction</fr:strong>) with <fr:tex display="inline">F</fr:tex> the left adjoint
    and <fr:tex display="inline">G</fr:tex> the right adjoint denoted 
    <fr:tex display="block">         F\dashv  G     </fr:tex>
    if there is a natural isomorphism between the hom-functors:
    <fr:tex display="block">         \hom _{\mathcal {D}}(F(-),-)\cong \hom _{\mathcal {C}}(-,G(-))     </fr:tex>
    which means forall objects <fr:tex display="inline">C\in \mathcal {C}</fr:tex> and <fr:tex display="inline">D\in \mathcal {D}</fr:tex>, there is a bijection
    <fr:tex display="block">         \hom _{\mathcal {D}}(F(C),D)\cong \hom _{\mathcal {C}}(C,G(D)) \\          (F(C)\xrightarrow {f}D) \mapsto  (C\xrightarrow {G(f)}G(D))     </fr:tex>
    which is natural in both <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex>.</fr:p>
          </fr:mainmatter>
          <fr:backmatter></fr:backmatter>
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree toc="false" numbered="false" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
      <fr:frontmatter>
        <fr:title text="Context">Context</fr:title>
        <fr:authors></fr:authors>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree toc="true" numbered="false" show-heading="true" show-metadata="true" expanded="false" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
          <fr:frontmatter>
            <fr:anchor>930</fr:anchor>
            <fr:addr type="user">cs-0007</fr:addr>
            <fr:route>cs-0007.xml</fr:route>
            <fr:title text="Categorical Semantics for Type Theories">Categorical Semantics for Type Theories</fr:title>
            <fr:taxon>Type Theory</fr:taxon>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>3</fr:month>
              <fr:day>21</fr:day>
            </fr:date>
            <fr:authors></fr:authors>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:p>This is a collection of notes on categorical semantics for type theories.
    The notes are based on the <fr:link type="local" href="cs-tt-2020.xml" addr="cs-tt-2020" title="Categorical Semantics for Type Theories">paper</fr:link> by Jason Z.S. Hu and <fr:link type="local" href="ncatlab.xml" addr="ncatlab" title="NLab">NLab</fr:link>.</fr:p>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>626</fr:anchor>
                <fr:addr type="machine">#355</fr:addr>
                <fr:route>unstable-355.xml</fr:route>
                <fr:title text="Introduction">Introduction</fr:title>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>3</fr:month>
                  <fr:day>21</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Over the last few decades, many type systems are designed for different purposes:
        general program safety, security, and correctness. The <fr:strong>categorical semantics</fr:strong>
        is a collection of methods which define meanings of types and programs in category theory.</fr:p>
                <fr:p>Category theory is a branch of mathematics studying an abstract kind of mappings, called morphisms,
        and their algebraic relations. Its generality serves as a common language for navigating connections
        between different concepts in different areas. We will first go over some basic concepts in category theory.</fr:p>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>627</fr:anchor>
                <fr:addr type="machine">#356</fr:addr>
                <fr:route>unstable-356.xml</fr:route>
                <fr:title text="Basic Category Theory concepts">Basic Category Theory concepts</fr:title>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>3</fr:month>
                  <fr:day>21</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Formally, a definition in category theory consists of two parts: data and axioms.
        The most basic definition is the <fr:strong>category</fr:strong></fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>628</fr:anchor>
                    <fr:addr type="user">def-003E</fr:addr>
                    <fr:route>def-003E.xml</fr:route>
                    <fr:title text="Category">Category</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>567</fr:anchor><fr:addr type="machine">#321</fr:addr><fr:route>unstable-321.xml</fr:route><fr:title text="With one collection"><fr:strong>With one collection</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex display="inline">C</fr:tex> consists
    <fr:ul><fr:li>A collection of <fr:strong>objects</fr:strong> <fr:tex display="inline">C_0</fr:tex> (<fr:tex display="inline">\text {Ob}(C)</fr:tex>).</fr:li>
        <fr:li>A collection <fr:tex display="inline">C_1</fr:tex> (<fr:tex display="inline">\text {Mor}(C)</fr:tex>) of <fr:strong>morphisms</fr:strong> (arrows).</fr:li>
        <fr:li>For every morphism <fr:tex display="inline">f</fr:tex> there are an object <fr:tex display="inline">s(f)</fr:tex> (<fr:strong>source</fr:strong>, domain) and an object <fr:tex display="inline">t(f)</fr:tex> (<fr:strong>target</fr:strong>, codomain).</fr:li>
        <fr:li>For every pair of morphisms <fr:tex display="inline">f, g</fr:tex> such that <fr:tex display="inline">t(f) = s(g)</fr:tex>, there is a morphism <fr:tex display="inline">g \circ  f</fr:tex> (<fr:strong>composition</fr:strong>) (Also written <fr:tex display="inline">gf</fr:tex> or <fr:tex display="inline">f;g</fr:tex>).</fr:li>
        <fr:li>For every object <fr:tex display="inline">x</fr:tex>, there is a morphism <fr:tex display="inline">\text {id}_x</fr:tex> (or <fr:tex display="inline">1_x</fr:tex>) called <fr:strong>identity</fr:strong>.</fr:li>
        <fr:li>The following properties hold:
            <fr:ul><fr:li><fr:tex display="inline">s(g \circ  f) = s(f)</fr:tex> and <fr:tex display="inline">t(g \circ  f) = t(g)</fr:tex>.</fr:li>
                <fr:li><fr:tex display="inline">s(1_x) = x</fr:tex> and <fr:tex display="inline">t(1_x) = x</fr:tex>.</fr:li>
                <fr:li>Composition is <fr:strong>associative</fr:strong>: <fr:tex display="inline">h \circ  (g \circ  f) = (h \circ  g) \circ  f</fr:tex> when <fr:tex display="inline">t(f) = s(g)</fr:tex>, and <fr:tex display="inline">t(g) = s(h)</fr:tex>.</fr:li>
                <fr:li>Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex display="inline">f \circ  \text {id}_x = f</fr:tex> and <fr:tex display="inline">\text {id}_y \circ  f = f</fr:tex></fr:li></fr:ul></fr:li></fr:ul>
    If the identity map and its axioms are omitted then one speaks of a <fr:strong>semicategory</fr:strong>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>

    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>568</fr:anchor><fr:addr type="machine">#322</fr:addr><fr:route>unstable-322.xml</fr:route><fr:title text="With a family of collections of morphisms"><fr:strong>With a family of collections of morphisms</fr:strong></fr:title><fr:authors></fr:authors></fr:frontmatter><fr:mainmatter>
    A <fr:strong>category</fr:strong> <fr:tex display="inline">C</fr:tex> consists
    <fr:ul><fr:li>A collection of <fr:strong>objects</fr:strong> <fr:tex display="inline">C_0</fr:tex> (<fr:tex display="inline">\text {Ob}(C)</fr:tex>).</fr:li>
        <fr:li>For every pair of objects <fr:tex display="inline">x, y</fr:tex>, a collection <fr:tex display="inline">C_1(x, y)</fr:tex> (<fr:tex display="inline">\hom _C(x,y)</fr:tex>) of <fr:strong>morphisms</fr:strong> from <fr:tex display="inline">x</fr:tex> to <fr:tex display="inline">y</fr:tex>.</fr:li>
        <fr:li>For each pair of morphisms <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex> and <fr:tex display="inline">g</fr:tex> in <fr:tex display="inline">C_1(y,z)</fr:tex>, a morphism <fr:tex display="inline">g \circ  f</fr:tex> in <fr:tex display="inline">C_1(x,z)</fr:tex>.
            called their <fr:strong>composition</fr:strong>.</fr:li>
        <fr:li>For each object <fr:tex display="inline">x</fr:tex>, a morphism <fr:tex display="inline">\text {id}_x</fr:tex> in <fr:tex display="inline">C_1(x,x)</fr:tex> called the <fr:strong>identity</fr:strong> on <fr:tex display="inline">x</fr:tex>.</fr:li>
        <fr:li>The following properties hold:
            <fr:ul><fr:li>Composition is <fr:strong>associative</fr:strong>: <fr:tex display="inline">h \circ  (g \circ  f) = (h \circ  g) \circ  f</fr:tex> for all <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex>, <fr:tex display="inline">g</fr:tex> in <fr:tex display="inline">C_1(y,z)</fr:tex>, and <fr:tex display="inline">h</fr:tex> in <fr:tex display="inline">C_1(z,w)</fr:tex>.</fr:li>
                <fr:li>Composition satifies the <fr:strong>identity laws</fr:strong>: <fr:tex display="inline">f \circ  \text {id}_x = f</fr:tex> and <fr:tex display="inline">\text {id}_y \circ  f = f</fr:tex> for all <fr:tex display="inline">f</fr:tex> in <fr:tex display="inline">C_1(x,y)</fr:tex>.</fr:li></fr:ul></fr:li></fr:ul>
    Usually we write <fr:tex display="inline">\text {Mor}(C)</fr:tex> for the disjoint union <fr:tex display="inline">\bigsqcup _{x,y \in  C_0} C_1(x,y)</fr:tex>.
</fr:mainmatter><fr:backmatter></fr:backmatter></fr:tree>
</fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>We only talk about <fr:strong>collections</fr:strong> here, which is vague, because we do not specify 
        they are sets or classes. If both objects and morphisms fit in sets, we say the category
        is <fr:strong>small</fr:strong>. For a counterexample, the category of all sets is not small. However,
        all functions between sets can be contained in a set. In this case, the category is <fr:strong>locally small</fr:strong>.
        When morphisms between two objects fit in a set, we call the set <fr:strong>hom-set</fr:strong>.</fr:p>
                <fr:p>Since category theory is constructed to study structures and a category is actually a structure,
        we can talk about the category of all small categories <fr:tex display="inline">\mathbf {Cat}</fr:tex>. Similar to morphisms, we can 
        define <fr:strong>functor</fr:strong> between categories.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>629</fr:anchor>
                    <fr:addr type="user">def-003G</fr:addr>
                    <fr:route>def-003G.xml</fr:route>
                    <fr:title text="Functor">Functor</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A <fr:strong>functor</fr:strong> <fr:tex display="inline">F</fr:tex> from a category <fr:tex display="inline">C</fr:tex> to a category <fr:tex display="inline">D</fr:tex> is a map
    sending each <fr:tex display="inline">x\in  C</fr:tex> to an object <fr:tex display="inline">F(x)\in  D</fr:tex> and each morphism
    <fr:tex display="inline">f:x\to  y</fr:tex> in <fr:tex display="inline">C</fr:tex> to morphism <fr:tex display="inline">F(f):F(x)\to  F(y)</fr:tex> in <fr:tex display="inline">D</fr:tex>, such that 
    <fr:ul><fr:li>Composition is preserved: <fr:tex display="inline">F(g\circ  f) = F(g)\circ  F(f)</fr:tex>.</fr:li>
        <fr:li>Identity is preserved: <fr:tex display="inline">F(\text {id}_x) = \text {id}_{F(x)}</fr:tex>.</fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>We can push this idea further by considering functors as objects and <fr:strong>natural transformations</fr:strong> as morphisms.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>630</fr:anchor>
                    <fr:addr type="user">def-003I</fr:addr>
                    <fr:route>def-003I.xml</fr:route>
                    <fr:title text="Functor Category">Functor Category</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex> be categories, the functor category <fr:tex display="inline">D^C</fr:tex> 
    (or <fr:tex display="inline">[C,D]</fr:tex>) is the category whose
    <fr:ul><fr:li>objects are functors from <fr:tex display="inline">C</fr:tex> to <fr:tex display="inline">D</fr:tex>.</fr:li>
        <fr:li>morphisms are <fr:strong>natural transformations</fr:strong> between functors.</fr:li></fr:ul></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>Here we use a <fr:strong>commutative diagram</fr:strong> to represent a natural transformation.
        When a diagram commutes, morphisms composed by different paths with the same end points
        are equal. The following diagram represents the equality that <fr:tex display="inline">G(f)\circ \alpha _x = \alpha _y\circ  F(f)</fr:tex>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>631</fr:anchor>
                    <fr:addr type="user">def-003J</fr:addr>
                    <fr:route>def-003J.xml</fr:route>
                    <fr:title text="Natural Transformation">Natural Transformation</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Let <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex> be categories and <fr:tex display="inline">F,G:C\to  D</fr:tex> be functors.
    A <fr:strong>natural transformation</fr:strong> <fr:tex display="inline">\alpha :F\Rightarrow   G</fr:tex> is 
    an assignment to every object <fr:tex display="inline">x\in  C</fr:tex> of a morphism <fr:tex display="inline">\alpha _x:F(x)\to  G(x)</fr:tex> in <fr:tex display="inline">D</fr:tex>,
    (called the <fr:strong>component</fr:strong> of <fr:tex display="inline">\alpha </fr:tex> at <fr:tex display="inline">x</fr:tex>)
    the following diagram commutes in <fr:tex display="inline">D</fr:tex>:
    
 
  
  <fr:figure><fr:resource hash="b5e91e181820d504fc4e45a8daad99b3"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE2MC42MTcwMTFwdCcgaGVpZ2h0PScxMDkuODE1MzkycHQnIHZpZXdCb3g9Jy03MiAtNzIgMTA3LjA3ODAwNyA3My4yMTAyNjInPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS1hUR3VHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREpBQUFCTXUwS2tleHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHFNVzR0ZmorVzIrTWpDek1JREE0Nk9PZHhIMGYwYW15OHdnTGdjREU0Z0NBRHRkQ3dJQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1RdkNNQkNGdjJJVnJZT0Q0T0Fnd1I5UXRBb3ViZzVPcmc1dTFnVHAwRlRTV25RUmY3clhFTHlRNDd2MzNoMlE4Q0dpcTRpSjcxM0Y4aWFCKzR5WkJoNkl2Z2ljTUdkSmp5Z2VpYkpnSHpobXlDVndueGw1NElIb3I4QUpXNzZIcW53OEcrUFVxZExHMlZ2cGRtZmo2cUt5YXAydXV2Rm9ySEhYeG1pVnY1VnVpN3E5bDJxVFptbkdnWXFTQjA4YURBN0ZTUlR0MlhJVHo3SGo3T2VhUWp3cm1UVXBxNzk3Rk5mNnhOVmYwWkxJZVV2WHRMSlRTNzlMVnJHUnZhejdQMWt5TGswQUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSOEFBb0FBQUFBQlRnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWk4xZ1dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFETVoyeDVaZ0FBQVdRQUFBRy9BQUFDRUgxRjE0eG9aV0ZrQUFBREpBQUFBQzhBQUFBMktmWEZxMmhvWldFQUFBTlVBQUFBSGdBQUFDUUdHUUtaYUcxMGVBQUFBM1FBQUFBTUFBQUFEQWxxQUx4c2IyTmhBQUFEZ0FBQUFBZ0FBQUFJQUlvQkNHMWhlSEFBQUFPSUFBQUFGd0FBQUNBQUJRQmFibUZ0WlFBQUE2QUFBQURPQUFBQk9QTmRLcDl3YjNOMEFBQUVjQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1WbWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwV01GUXlNL3dIOHBraDBraHEvZ09GQWI4ZURRVUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aVYvLzhEeVlyLy8vOTNndmtNQUZjckJ0VjQya1dRMzJyVFlCakc4N3hKazNacGtpWk52L1JQbG5WZGtpOWQyMlJ0bGtSUjJqSW1va3dtYklLaU1zRWpEN3dDUmZBU3ZBQlBSZkFPUE5jNzhFNDhkbjVSUk43bjVQM3p2UEQ4SkVoWDF6L3BLNzVManlVSktUUVRtbXBCS0VERnlxcXNQT2E1bWxwWHpFMksrUnI1aW5sTTFkZ2VWdVVHWlNGY3NWaG5pUGx4VlZ0SzVxMVJpU3RUZkN6aWt0NjZVU1BPZHpSclR3VW83VWZQQm1EdEpoSzlrMThPSHU0N0o0OGV5RFR0MlNQQUduZWQvdVMya1JoWWpNWlh3NmI1NTlCYVhRYm5vODQybjUwUmtxd0hFeCtNQm1qTzdPMmJ2dDQ5Rk5icTFBS1I3cThzNDBqQllPRW54Tk5vN0hxTnhOUmxXczQvM25TU0FGVGVONGxvWnpjMzIwc0YvcXlYRVY5TVFveE1lUzRKRE5MejY1Uys0SnQwTGhwWkVFbnhQM2FBWElRVHFrbnhtTWQxNHJqbVp1S0EvME1Rd0ZQcm1hQllNOXJRWHlDTVByM1kvZnowNUM2UWVNNFFjQ1pPWmgzZGNRNkNscnVaVjhXeEFpOHlnQ0JjTzNLemJUUVI2RFkvWGE1QnVoY0NXWGdyNmdUUUM0VUZGZ1B3N3RmN2w2K0JuSWVoeTFxSHV0V2lhVGU4TjdQSElOKy84QytlRFB3RTJCWjZTMFR1NVk0dDBPUjg2TjU0TlZzbVVDSXIwcVkvV0FMSEprbjZEU3FPUWZVQWVOcGpZR1JnWUFCaWwzK3NqUEg4Tmw4Wm1Ga1lRT0R4VWNlN0NQcS9Ibk1JNHpFZ2w0T0JDU1FLQUNTYkN0SUFlTnBqWUdSZ1lHYjR6d0FrUXhoaUdSeVpkakVBUlZBQU13QkN4UUs1QUFBRFZBQUFBeW9BWHdMc0FGMEFBQUFBQUlvQkNIamFZMkJrWUdCZ1pvaGtBTkVNVUJJSkFBQUphUUJnQUhqYVRZdzliOEl3RUlhZmlBU0pNTENnRGgyS2g4NFJCRmk3TURDeE1yRUFkbEVHMjhnSmtaQ3FqdjNkdmJnZWVwSlB6L3R4QmtxK3lSZ21ZeGIzTURtRnFEOHVtREpQUEJhMVNGenl5anNqc253aXpoc2ZpWE5KVG9rTFh2aE1QQmIvSzNISmhwK2R0L2RIWjRJNmVHMkN1MXJiYkk4bXRJMTNhbFV0bzk0Ylo4SzVNMXBkbmtyM1RkdmZyRnBYZFZXencyTzU4NkRERUZBY3hOR1JIVmZKTEExYmp0RnBoYjM0aWhVVnkzLzVYbklYTytmNGs1Yk9oYWRzVFMrTlZ2Wk51b3ExWE5iRCt3WElteS94QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVg4QUFvQUFBQUFCeUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXRjAybU50WVhBQUFBRTRBQUFBTlFBQUFEd0F2UUJ6WjJ4NVpnQUFBWEFBQUFNa0FBQUQzT2hicVBGb1pXRmtBQUFFbEFBQUFDOEFBQUEyS2F6R3VXaG9aV0VBQUFURUFBQUFIZ0FBQUNRR0xBRzhhRzEwZUFBQUJPUUFBQUFVQUFBQUZBeHNBSlpzYjJOaEFBQUUrQUFBQUF3QUFBQU1BZTRDNEcxaGVIQUFBQVVFQUFBQUZ3QUFBQ0FBQndCYWJtRnRaUUFBQlJ3QUFBRFVBQUFCUHBrUmRjZHdiM04wQUFBRjhBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXFtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHE2TVZReU0vd0g4cGtoMGtocS9nT0ZBZGtIRFNzQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS3VqTlUvdjhQNUxzeFZQei8vMy8zLzI2d0tpQUFBSmNiQ1NvQUFBQjQyaVdTUzQvYlZCaUcvWjVqK3lTT2I0bHZtZGl4azB6R1RpWTBrOG5GVHRJeXFVWXRVNGJlbUtLSyt3YllWT3hhSVNGVmJLZzZRdUlIQUJJL2dtVi9BSWdmd0o0MVc2U3lBVTM0UEdOWlBqNzZQbHZuZWI5SGdwUnR0eHpzbFhRcVNSQnFvUG9KbXdhdWVnQ1JwZGs4RC95OGNEWVlRNlgzYnU1YmNOTU5Gbms2UXFvS1BxTnlIa3dUVU1IRWJpOHI4aXhQZDVGdkZFRDM4b2pMbHZqeHZLckFNdGV4Y2k0RGV5dkx4bXRINTE0SWhWMy81RHh4bE9OUE43bkZkY0VaNUNWWFJJMXhqYkZPZ1h0Ym4xV3JqRUUzVlhBcVZ5MFZjR0lXMTRVaDVFZ0FWZWVYU05ZbXJYVUJlK2ZpUHd5dUIweFJtZm1uVWRIMWtmQ2JFbDJRWnR1L2VJMzlJZDJuRGFlakV0MEc4OVFrYUF0cUVLUHdDMkxaNEFqcEFkUWpKS3lZbXNoUzFXTFVORVpXdHBaclh2WVZmdUFIaE81ejdTWlhOUUprZVB6eitlaDJzMll6K2ZuOWNPazBpc0FVTUp3aWdTbnVuSHhwb0NidkIycFhVNWlvdGl0R21xN2YrdVlIeGgvTlQ1KytlRFFjcUhkTTZPejNpMy9wS3lhczlNTW51SnQvL05IK2V6dlBQZ2V6RmExNXNvb2FGY1o0VkFHNDNDTDRSdWZiekZQQmhwN2RzWnJnUHozLzd0bnAvSXpML1QzemdjbjRGWHU4ZmMwaS9DYTlUeHVDOWR3WWhEQUxmTThscEV1b2N1bWwyUkdLcWUrcXdrOG9oK0lJaXpFRXpabDBJQmt1dVhNL29BbzlUWkppTWMrTE1pMzZLUjd2R25KcmRSYkNFRXBjczRmSDQwSmpZVFR0cnhtU3ByNFRPYmJ0OUdaNk8yUjc5ZkRkTnFzSkJYR3RNVGh1SG52Vi9JMzJUWTUrNWtSKzNYS252dUpoOGYzQ3M4TUJYejNRd1NydW9Wcy9rSEVRYTBsWDd2WmFYZGo3Ylprc3dYcnk1S2svQ3NHV0QzVlFjdTdVcVU5a3hJZHV3UkZuU1FUUGNEc3lXU1FQdGRGVkhtUDhnMStsdDY5Y0lINlMreElwaTB2cThpYm8wbjhpdm9xZ1ZHYU15d2hpZUJTUjZxbGxGQnRPL2djZS92NHNlSGsydWJIblZ1a2tXV0JOamY3U2phUHE2TWJrSFJZbEprZGRoSVhQVlNGa05HcU56aks3VmpIbUNOUFptM3pzbVkxR3lQSHk0dXNQdm1JNHZKc0FadENPZU5zQyt1SHczdUFhVU56cWZmRXdHVFExWUhXaTA5RHRTYXRKa1V4MnJTaDVjYnM5Wi9JdDY5Vlo0U1BVYU96L0E0UEdmWUY0Mm1OZ1pHQmdBR0lwOXQzRzhmdzJYeG1ZV1JoQTRQRlJ4N3NJK3I4ZU16ZlRGU0NYZzRFSkpBb0FGa01LWHdCNDJtTmdaR0JnWnZqUEFDUlZHZVQrVDJUbVpnQ0tvQUJXQUVnWUF1NEFBQUoyQUFBQ2tnQW5BeVVBTXdKSkFCNEI5Z0FlQUFBQUFBQjBBUElCZWdIdWVOcGpZR1JnWUdCbGlHUUEwUXhRRWdrQUFBbWZBR0lBZU5wTmpyRnF3ekFVUlkrcFk2aGJ5SlFNSFlxbWpNWjIrZ0dGREpteVppd2trUWd1U0FxeVk4Z1MrZ0g5NkQ0ckd2cUVIa2ZuWFFrQkpYY3lwc3FZeHo1VlRpR25CODk0WVpHNGtLVVNsN3l4NG9rc2Z4Ynp6bWZpbkZlK0VzOVk4cDI0RVArVHVPU0QzNDIzbCt0Z2d0cDViWUk3V2RzMTlkNkV2dk5PTlZYOUVGdmpURGdNUnF2alRlbXg2OGV6VmV1cXJWbzJlQ3dYcmd3WWd2eHNKMFpIZHB4a1p1bG9xTmxIMTh2SnkwU0pxOFQrVDJ3bDRXTHFFRi9Ua2pweWs2NFpKZE5MUDB0YXNaYTc3YlQvQU9DQ01MMTQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVc0QUFvQUFBQUFCckFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hlRjRlR050WVhBQUFBRThBQUFBTlFBQUFFUUFld1JqWjJ4NVpnQUFBWFFBQUFMZEFBQURiSzJKM1dWb1pXRmtBQUFFVkFBQUFDOEFBQUEyS2dIR3VHaG9aV0VBQUFTRUFBQUFIZ0FBQUNRR29nSXBhRzEwZUFBQUJLUUFBQUFVQUFBQUZBNXJBUmxzYjJOaEFBQUV1QUFBQUF3QUFBQU1BYndDbm0xaGVIQUFBQVRFQUFBQUdBQUFBQ0FBQ0FCUGJtRnRaUUFBQk53QUFBRFBBQUFCT1BOaEtxTndiM04wQUFBRnJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzUTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFIwWTk3SXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBZVZnNU1BSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGszQm5TbURmKy93OWt1VUZZLzNmL24vc25HS3dXREFEMlpBdmJBQUFBZU5wRmtrOXZHMFVZaC9mM3puakg2N1YzMXV2MXJ1dkUzc1pqNzZaS0V4ZHZ0QnRDNmsxYkdsSTNiUnFKcWswcTZEK3BFWENnQjFTaDNub3BOMVJWUFhCQkFuSGhEQnk0MHk4QVJ6NER4M0tObWEwRWFLU1Izdm5OYU9hWjV6VmdmRENmc3h2MHE3RmpHQkJtNktkaDVtQU1NWWl6TU1qeVZwWm44UmltcnBheVFDSlFjYmtpVkd3S2x1b05VNlNUVUpLcEJrbEJXYXp3Y2NFUlpRclMvTzRyaVdaamM5Rjh6Z0RMVFNKNERpbS93VnBvK1JWaUZ4OStHN21WQzhmRmxzT0U3WUxuZ2xzdW1Ba2FiV0EybDd4SlhBbHdIZ21nMWFOT3JTNTB5QWE2dElLZnU2eTdYdVJBSXppWlkvUmV3NWIrbjE1Rk5oWmFuY0RRT01idS9DOTJqLzR3cnVtQ09WQkpuQlJZUTZMZjdrQUVvUjc1SkN0WUZpZXhNS2VJS0orRVRwbHJJTDFQSDlHejV0VWppQkNFdWY0VGRyZGdvbTdyZHdEMzc2eStQSGozTXZoMnZiRXptejdwMkI1Z2QzcjltS1E0dVBuWUlaTG1Ta2NFZnFVZFdXZWVYWDcxSTlqdGpmMm5MKzZzbVdmTldWMDQ5TnZKWEZhSnJFYnY5dWRFNDcydG4yNStNYkdyeTdReUhzNnFsa1VNYktrS0J1NUt6ZDA4L2RIMVhpWHhWa2JzaDZmUEgrK21OeGhYWERYMkhXSWw4OVg1bUQ2bDM0M3RrbG5pTGVrZ1RyUW1UV3NLalRGRndWUXBOSjNpcmI1QU15djlCVm11VFRza2tXYUJtZUQ3VFplN1hldkNPOHVid0xBZE04aElTamxjWXIwMXVkZW5sanlRYlNlNHFNNXNBU3JRdWR1WDB2UDZ0V3IzYmhuajFjbnJXWE43M2IvRVl0VS9UVU16c1MwQ3Y5cis1dTlicGNSYmh3dEpQQnIrSCtGVXZQbzFIMVNoOVJsa0ZQTTM5QXRlRzJzbHphaVBYUGZiZXFxMSthWXdZNjFIL0tlbmoxQ2psZTBZb1krU1c4ditWM1hvYS9hTXp2SEFyZzNyWHMxRXVucHE2cC85Y3Zmb0h2R2Rwbjl3ZlAyVE9vRXVMVlpFVGNkZEszckp3U3Zuemk5Y0d5WDY0alI2OHVKb21jTmJ0RUUxTHlWU21VcEJ4MWNlN1B2dSt3eEhlL2JTNU1OSGJnMUU3WjNtbGM4T3gycHl5S0JXTjU0dHJKOEhEZjRCRURkNkh3QUFBSGphWTJCa1lHQUE0cXV4dHl2aitXMitNakN6TUlEQTQ2T09keEgwZjMzbUJLWkxRQzRIQXhOSUZBQmNod3dxQUhqYVkyQmtZR0JtK004QUpQc1k3UDlQWlU1Z0FJcWdBRllBVy9NRDBRQUFBc1lBQUFMbEFFY0RqZ0JJQWpvQVN3TDRBRDhBQUFBQUFHNEE2QUZPQWJaNDJtTmdaR0JnWUdYd1kyQmlBQUZHQmpRQUFBaWpBRmg0MmsyTVBXL0NNQkNHbjRnRWlUQ3dvQTRkaW9mT0VRUWt0aTRNVEt4TUxJQmRsTUUyY2tJa3BLcGpmM2N2cm9lZTVOUHpmcHlCa204eWhzbVl4VDFNVGlIcWp3dW16Qk9QUlMwU2w3enl6b2dzbjRqenhrZmlYSkpUNG9JWFBoT1B4ZjlLWExMaForZnQvZEdab0E1ZW0rQ3UxamJib3dsdDQ1MWFWY3VvOThhWmNPNk1WcGVuMG4zVDlqZXIxbFZkMWV6d1dPNDg2REFFRkFkeGRHVEhWVEpMdzVaamRGcGhMNzVpUmNYeVg3NlgzTVhPT2Y2a3BYUGhLVnZUUzZPVmZaT3VZaTJYOWZCK0Fjd3JML2tBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMktTSEd0MmhvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGpLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaUR6Yzc3OGZ6MjN4bFlHWmhBSUhIUngzdkl1ai9ERXdOekNBdUJ3TVRpQUlBY0E0TDlBQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZdzlpOEpBRUlhZllDSVlDeHV4c0xqYndqb2swZm9hQ3l0YnEydlVYU1ZGTnJLSkFVRXM3M2M3V1JkdVlJZm4vWmdGVWw1RURCTXg4M3VZbUVUVWh4T216QU9QUlgwSFRsbXlZa1FVVDhUNTRpZHdMTWx2NElRRmw4Qmo4WitCVXpiOGJadjZkdStNVS90R0cyZlB0U3Z5ZzNGdDFWaFZaTG5YTzJPTk8zWkdxOU5ENmI1cSsydXQxbG1abFd4cHFMbHhwOFBnVU96RjBaNHRaOGtjQlRrSDc3UlVrbHBwRldUaS91Yzd5YTN2SFAxUFdqb25IckkxdlZ5MXNxL1NWcXpsc2h6ZUcyUEhMeEVBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE4LjQ2MDk5OSwtMzMuOTc3MjkxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01My43Mzk3OCwtMjkuMTU5NzcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xOC40NjA5OTksLTMzLjk3NzI5MSlzY2FsZSgtMSwtMSknPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNTMzNjU0LC04Ny4wOTc2Mzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMC42NTYyNywwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zLjUzMzY1NCwtODcuMDk3NjM5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zLjUzMzY1NCcgeT0nLTg3LjA5NzYzOSc+RjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc0LjI1NjYwMicgeT0nLTg3LjA5NzYzOSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc4LjEzMDk3NScgeT0nLTg3LjA5NzYzOSc+eDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScxMy44MjQ5MDgnIHk9Jy04Ny4wOTc2MzknPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzUuMzAzOTk2LC04Ny4wOTc2Mzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzMuOTE1NjU3LC04Ny4wOTc2Mzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMC40Mjk0MywwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDczLjkxNTY1NywtODcuMDk3NjM5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9JzczLjkxNTY1NycgeT0nLTg3LjA5NzYzOSc+RjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc4MS43MDU5MTMnIHk9Jy04Ny4wOTc2MzknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nODUuNTgwMjg3JyB5PSctODcuMDk3NjM5Jz55PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzkwLjgyMjIzJyB5PSctODcuMDk3NjM5Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjUzMzY1NCwtNjMuMDI4MTI1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjUzMzY1NCwtMzMuOTc3MjkxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTAuNjc3NzgsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMy41MzM2NTQsLTMzLjk3NzI5MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMy41MzM2NTQnIHk9Jy0zMy45NzcyOTEnPkc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNC4yOTk0NjMnIHk9Jy0zMy45NzcyOTEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nOC4xNzM4MzcnIHk9Jy0zMy45NzcyOTEnPng8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTMuODY3NzY5JyB5PSctMzMuOTc3MjkxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM1LjMwMzk5NiwtMzMuOTc3MjkxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDczLjkxNTY1NywtMzMuOTc3MjkxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTAuNDUwOTQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg3My45MTU2NTcsLTMzLjk3NzI5MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSc3My45MTU2NTcnIHk9Jy0zMy45NzcyOTEnPkc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nODEuNzQ4Nzc0JyB5PSctMzMuOTc3MjkxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jzg1LjYyMzE0OCcgeT0nLTMzLjk3NzI5MSc+eTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc5MC44NjUwOTEnIHk9Jy0zMy45NzcyOTEnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS0yMy41OTQ2NSAyNi42NTk3N0gyMy42NDgzNicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMy44NDgzNCwyNi42NTk3NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOC4zMTQyLDMwLjc2MjUzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTguNDYwOTk5LC0zMy45NzcyOTEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE4LjQ2MDk5OScgeT0nLTMzLjk3NzI5MSc+RjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTIuMzM2MDE3JyB5PSctMzMuOTc3MjkxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy05LjIyMjY3NCcgeT0nLTMzLjk3NzI5MSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNC41NTYwOScgeT0nLTMzLjk3NzI5MSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00tMjMuNTczMTQtMjYuNjU5NzdIMjMuNjI2ODUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjMuODI2ODMsLTI2LjY1OTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04LjM1MzIxLC0yMi41NTcwMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE4LjQ2MDk5OSwtMzMuOTc3MjkxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xOC40NjA5OTknIHk9Jy0zMy45NzcyOTEnPkc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTEyLjI1ODI3NicgeT0nLTMzLjk3NzI5MSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctOS4xNDQ5MzInIHk9Jy0zMy45NzcyOTEnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQuNDc4MzQ4JyB5PSctMzMuOTc3MjkxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS0zOC43NTY0NSAxNy44MDAwNVYtMTcuNDAwMDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwtMzguNzU2NDUsLTE3LjYwMDA3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zNi40MDM3LC0xLjAwNjk0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTguNDYwOTk5LC0zMy45NzcyOTEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE4LjQ2MDk5OScgeT0nLTMzLjk3NzI5MSc+zrE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTEzLjI4MTY1OCcgeT0nLTMyLjk4MTAyNyc+eDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00zOC45ODMyOSAxNy44MDAwNVYtMTcuNDAwMDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwzOC45ODMyOSwtMTcuNjAwMDcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMzM2MDQsLTAuNTIwODQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xOC40NjA5OTksLTMzLjk3NzI5MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTguNDYwOTk5JyB5PSctMzMuOTc3MjkxJz7OsTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTMuMjgxNjU4JyB5PSctMzIuOTgxMDI3Jz55PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4="></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            {F(x)} &amp;&amp; {F(y)} \\
            \\
            {G(x)} &amp;&amp; {G(y)}
            \arrow [&quot;{F(f)}&quot;, from=1-1, to=1-3]
            \arrow [&quot;{G(f)}&quot;, from=3-1, to=3-3]
            \arrow [&quot;{\alpha _x}&quot;, from=1-1, to=3-1]
            \arrow [&quot;{\alpha _y}&quot;, from=1-3, to=3-3]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>632</fr:anchor>
                <fr:addr type="machine">#357</fr:addr>
                <fr:route>unstable-357.xml</fr:route>
                <fr:title text="Basic Category Theory Structures">Basic Category Theory Structures</fr:title>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>3</fr:month>
                  <fr:day>21</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>Though the theory is already rich by only considering sets and categories, 
        it would not be interesting enough. We want to know a little more about the 
        category that we are working with. To achieve so, we can require some additional
        structures on the category. A common structure is the cartesian product.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>633</fr:anchor>
                    <fr:addr type="user">def-003P</fr:addr>
                    <fr:route>def-003P.xml</fr:route>
                    <fr:title text="Cartesian Product">Cartesian Product</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Given any category <fr:tex display="inline">\mathcal {C}</fr:tex>, and any set <fr:tex display="inline">\{X_i\}_{i\in  I}</fr:tex> of
    its objects, the product of all these objects is, if it exists, an object
    <fr:tex display="inline">         \prod _{i\in  I} X_i \in  \mathcal {C}     </fr:tex>
    equipped with morphisms (projections)
    <fr:tex display="block">         p_i : \left (\prod _{i\in  I} X_i\right ) \to  X_i     </fr:tex>
    for each <fr:tex display="inline">i\in  I</fr:tex>, such that it is <fr:strong>universal with this property</fr:strong>, i.e.
    such that given any other object <fr:tex display="inline">Q\in  C</fr:tex> with morphisms
    <fr:tex display="inline">         Q \xrightarrow {f_i} X_i      </fr:tex>
    there is a <fr:strong>unique</fr:strong> morphism
    <fr:tex display="block">         (f_i)_{i\in  I} : Q \to  \prod _{i\in  I} X_i     </fr:tex>
    where the following diagram commutes:
    
 
  
  <fr:figure><fr:resource hash="d048e45614c73265beb2fc1d1f8d51d6"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3OC42MjAwNDVwdCcgaGVpZ2h0PScxMDUuMjc1MDU5cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE5LjA4MDAzIDcwLjE4MzM3Mic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21leDEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNd0FBb0FBQUFBQTVnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdjRnBhUkdOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9Da1oyeDVaZ0FBQVd3QUFBQmhBQUFBYk55UGowMW9aV0ZrQUFBQjBBQUFBQzBBQUFBMktpM0F0MmhvWldFQUFBSUFBQUFBSGdBQUFDUUczZmd1YUcxMGVBQUFBaUFBQUFBSUFBQUFDQVdjQURsc2IyTmhBQUFDS0FBQUFBWUFBQUFHQURZQUFHMWhlSEFBQUFJd0FBQUFGd0FBQUNBQUJBQWhibUZ0WlFBQUFrZ0FBQURWQUFBQlBxQW5kY1p3YjNOMEFBQURJQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Pc2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFBQkpIWktjVms2QTl1RHdBZUJ6T0pmTkJrWW1NVzVyd09GR1JFcS92OW5ZQUFBUk1vUVhBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROEMvLytIa1BJYndQSU1BR2NuQjQwQUFIamFZMkJrc1B6RHdOekR3TUFnejhEQXFHaHF4Nmd1YUthbWJxb295c2NvTHNnbUppNEtFVk1Fc1JrTC9wMzBVV1JtVnZSaER2WUcwZDcvVHZrb3N2eHpCNHI4WWRCa01wVmk1cEV5WmRJRXNmNThnYkdZWS84c0JySVpBT1d3RlRrQUFBQjQybU5nWkdCZ0FPTFlTVXZUNC9sdHZqSXdzekNBd09PampuY1I5QjhHNWg2d01BY0RFNGdDQURvbkNzVUFBQUI0Mm1OZ1pHQmdGditpQ1NTUE0xZ3lXRFAzTUFCRlVBQVRBRTBUQXdrQUFBSFZBQUFEeHdBNUFBQUFBQUEyQUFCNDJtTmdaR0JnWUdKUVlBRFJERkFTQ1FBQUE3MEFKZ0I0MmsyT3NXckRNQkNHUDFQSFVMZlFxUjB5RkUwWmplMzBBUW9aTW1YTkdFaWlJN2hnT2NpT1NaYlNCK2hEOTZ4bzZBbjlmUHJ2djBOQXpqY0pVeVc4QkowcUpkUFhuV2M4OFJvNTAyTWk1OHhaOEVDU1Bxcnp6bWZrbEdkMmtXZTg4UlU1VS84bmNzNEh2NnV1UFY4RzhXYlRXZkh1Mk1xMUtyZmkrNlp6cGlyS3U3RVdKMzQvaURXSG03RmowNCtuMWl5THVxaFowZEZ5NXNLQTRQVm5HM1ZzWU1kUmU4S1ZpcEp0OEhvYTdUdk5WUlRxL2src2xWeEk3Y00ycTZrRE4xWExxSE85NmtuemhxWE8xdFA5QSsxck1Oa0FBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTThBQW9BQUFBQUE2UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncWxPVlhtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSmJaMng1WmdBQUFXd0FBQUIzQUFBQWdGcnJ4MUZvWldGa0FBQUI1QUFBQUM4QUFBQTJLdmJHdDJob1pXRUFBQUlVQUFBQUlBQUFBQ1FHOGdFMmFHMTBlQUFBQWpRQUFBQUlBQUFBQ0FnY0FLUnNiMk5oQUFBQ1BBQUFBQVlBQUFBR0FFQUFBRzFoZUhBQUFBSkVBQUFBRndBQUFDQUFCQUFvYm1GdFpRQUFBbHdBQUFET0FBQUJPQk45S3Jkd2IzTjBBQUFETEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNFdPY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeG9BQUhHQ09sdUN5ZGdVMkpRNG1EV2V1UEpRTURzeGJ6Y2FBd0kwTHAvLzhNREFETlZ3M21BQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVW9jLy85RHlMcy93ZklNQUZEV0JvWUFBSGphWTJCa1dQSi9Cck1TVXdhREdnT0RxcUljbzdpeG1aZ0ltN3F5bWpvSW1wbURJRlNJajVGZEVjUmkrdjczQmZmMm5sTzhjbks4NS9xeXhVVmpXRmhpUk1Xeis4NkJSRTcxYk9kbWtnQ3lIaGZPWldiazFPUmtaQW9VRWszbzdVMFFGUXBrQWdzd3p5MWs1TkxnWW1CZ0FBRGRLaHRNQUhqYVkyQmtZR0FBNHYvNW0wTGorVzIrTWpDek1JREE0Nk9PZHhIMC94a3NvVXdaUUM0SEF4TklGQUJiUFF3T0FIamFZMkJrWUdEVyttUEp3TUFTeXJDRVlTbXpFZ05RQkFVd0FRQlJpUU11QkZVQUFBUEhBS1FBQUFBQUFFQUFBSGphWTJCa1lHQmdZbEJuQU5FTVVCSUpBQUFFYkFBdEFIamFUWXc5YjhJd0VJYWZpQVNKTUxCVUhUcUFCK1lJUWxtN01EQ3hNckVBTmloREhHU0hTSkdxanYzZHZiZ2VPTW1uNS8wNEF6ay9KQXlUTUF0N21KUk0xRDluVEhtTFBCYTFpSnp6d1pJUlNUb1JaODVYNUZTU1UrU01kMjZSeCtKL1I4NzU1SGZYMUk5bmE1dzZOTm80ZTYxOXZ6MGE1NnZHcW5XeENucHZySEhuMW1oMTZaWHVLdC9kYTdVcHlxSmtSMFBOZ3ljdEJvZmlJSTRPYkxsSzV1blpjZ3lPcDVMVVNtdE53ZW9sMzB0dVErY2NmdExTdVVpaWhEcTU4ckx2MGxaczVMSWMzaC93Y3pCSkFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS1hUR3VHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREpBQUFCTXUwS2tleHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHFNVzR0ZmorVzIrTWpDek1JREE0Nk9PZHhIMGYwYW15OHdnTGdjREU0Z0NBRHRkQ3dJQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1RdkNNQkNGdjJJVnJZT0Q0T0Fnd1I5UXRBb3ViZzVPcmc1dTFnVHAwRlRTV25RUmY3clhFTHlRNDd2MzNoMlE4Q0dpcTRpSjcxM0Y4aWFCKzR5WkJoNkl2Z2ljTUdkSmp5Z2VpYkpnSHpobXlDVndueGw1NElIb3I4QUpXNzZIcW53OEcrUFVxZExHMlZ2cGRtZmo2cUt5YXAydXV2Rm9ySEhYeG1pVnY1VnVpN3E5bDJxVFptbkdnWXFTQjA4YURBN0ZTUlR0MlhJVHo3SGo3T2VhUWp3cm1UVXBxNzk3Rk5mNnhOVmYwWkxJZVV2WHRMSlRTNzlMVnJHUnZhejdQMWt5TGswQUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU2dBQW9BQUFBQUJWd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFd4MU4yTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWNRQ25aMng1WmdBQUFXd0FBQUhWQUFBQ0pFbmVseUJvWldGa0FBQURSQUFBQUM4QUFBQTJLZ2pHd21ob1pXRUFBQU4wQUFBQUhnQUFBQ1FHaGdJOWFHMTBlQUFBQTVRQUFBQU1BQUFBREFqdkFFNXNiMk5oQUFBRG9BQUFBQWdBQUFBSUFJQUJFbTFoZUhBQUFBT29BQUFBRmdBQUFDQUFCd0JoYm1GdFpRQUFBOEFBQUFEVUFBQUJQcGtSZGNkd2IzTjBBQUFFbEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtK3NVNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUU1aSWhnWnZnUDVETkRwSkhVL0FjS0F3QUVkQTJUZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLQmpKRS9QOFA1SVBwL3h2K3J3S3JBZ0lBbEpjSkVnQUFBSGphTlZCTmF4TlJGSDNudnBuMzhqRWZTWnpKSUNRemFSTm5RdEdKTWMxTUkwMWlWNlZTVTBIcFFnUUZMUTBpV3FzdUZBU3JLM1doSVA0RS9RSHVGRGYrQVJldS9BbHVYZWpTK0NaQjd1YWVjKzY1Y0E3ajdNeHNRSC9vTzR2WUJwc3dkc0pIV2szU0VhcFNxQWs3Q01jUVVZd29TYlB4NFdXODBNTm9oQXpONlV4ZkZ0S0M1MVM5ek4xUEZKQSs4Rlg2emZxbVF3NjVkaEJ0ckp1OFNOcXdmZkNXODR1clczZWZQbmhOZkdLV2QvOSs0eHpEbFhTSmJ2YjhVaDI0TVJrOEg1dzlqYlhIY1R1bjRkeHlCN1FrQmwzZ1ZGS0EwMjlIZlkySElxenRsSUUzUnk4ZVhrZ3VjWHIzNU9VOXQzS3JSY0hLQ05wMnNMNjNsdTZQcHdmWW11eCtXdHU4M1VLRlpQRUtSN2ZSTUJsallMWFpqTy9URjNaTkFSVWxKcFVyVUIwRWNFUlRaUkEyMU82ajUxVmRDeDNJS0l4V2s1NksySUdOZVVnbGVYTkp0VFdYeHNSak5NWGlrK2NqZStUaTE0Y1NwK0FZWU9xSDEvTkVSaUVldThmVForWFdUcUhlTlNRWjR2QW9yOFBJK2I0K3ZUb3Rsa0JCVG1xQW9kOWZHS0x6b2ZuamtWNDc2VkpHTHE0Yk5iei9hSG1PZ1lJbG9XclVoQ1c0NzFTSHIrTExuMzBiVkxDRTRnbDVVMm9WYWYvZXUxUDBUS2RJbFB0dnNBVTFJdU1uL0ZLWld3dVNYS201T21QL0FIVnpUYVlBQUFCNDJtTmdaR0JnQU9MNHQrKzJ4dlBiZkdWZ1ptRUFnY2RISGU4aTZQK1d6T2xNbDRCY0RnWW1rQ2dBYnV3TXBBQjQybU5nWkdCZ1p2alBBQ1FER0dUK3YyUk9ad0NLb0FCbUFGb25BOGtBQUFKMkFBQURLUUF5QTFBQUhBQUFBQUFBZ0FFU2VOcGpZR1JnWUdCbVNBQmlFR0JrUUFNQUNrWUFhUUFBZU5wTmpyRnF3ekFVUlkrcFk2aGJ5SlFNSFlxbWpNWjIrZ0dGREpteVppd2trUWd1U0FxeVk4Z1MrZ0g5NkQ0ckd2cUVIa2ZuWFFrQkpYY3lwc3FZeHo1VlRpR25CODk0WVpHNGtLVVNsN3l4NG9rc2Z4Ynp6bWZpbkZlK0VzOVk4cDI0RVArVHVPU0QzNDIzbCt0Z2d0cDViWUk3V2RzMTlkNkV2dk5PTlZYOUVGdmpURGdNUnF2alRlbXg2OGV6VmV1cXJWbzJlQ3dYcmd3WWd2eHNKMFpIZHB4a1p1bG9xTmxIMTh2SnkwU0pxOFQrVDJ3bDRXTHFFRi9Ua2pweWs2NFpKZE5MUDB0YXNaYTc3YlQvQU9DQ01MMTQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVZvQUFvQUFBQUFCbHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXUjBoMk50WVhBQUFBRTRBQUFBT3dBQUFFd0JGQUVFWjJ4NVpnQUFBWFFBQUFLS0FBQURFRHR6MHlGb1pXRmtBQUFFQUFBQUFERUFBQUEyS1diR3QyaG9aV0VBQUFRMEFBQUFJQUFBQUNRRmJBR2NhRzEwZUFBQUJGUUFBQUFVQUFBQUZBci9BTHhzYjJOaEFBQUVhQUFBQUF3QUFBQU1BVllDTm0xaGVIQUFBQVIwQUFBQUdBQUFBQ0FBQ0FCUGJtRnRaUUFBQkl3QUFBRFBBQUFCT1BOaEtxTndiM04wQUFBRlhBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbU1tS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TWhRd00vd0g4cGtoMGtocS9nT0ZBYjE5RE5zQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdDeUFOQmNEQjFDT2ljR1RJWTBoazZIZy8zK2dHSno5ZjhmL09mOW4vWjhDMWdFRkFGZTdEZzhBZU5wRmtyMXYwMEFZeHUrNWMrNmF1UGpzMkRuSEpYSFNPTFZiQWttYUQ2ZHFTNXEwdEVqOUVFSUlTaGZZa0ZxeE1pRWtSbUJnWW1CbEFQNEpSdm9IVkl5SWlaRVp0aEl1UlFqZHF4dmU1ejNwK2IzUEVaRE55WVF1MEUra1FRaVk0S3FDMU9NdEt1SVdlcW5mU1FkdTJrK2pKT0pEVk9nR1F2QWs1dmo0d29Cd3JsWWwzN241eW1UVThWWkt4a3VEaG9GVmc1MDVydS9jc09HNmd6STlPZi91Q3dGcVJBSU1Ccmh3Qk55QVZtZXpGak5xMDZhdXNnQThvaTJRdlVtTG50QXpNcHI2a1hyY2dxakZ5UkJkNVNzdXRMOGhObGpFNDlUdkRqSFEvWTd5TFVSeEVxY0RiZHFpRXQxVThRVHZWbTNEbnN1T2x4ZFhnWG9oWnBBVktXVjlucFdiY2ora3Jyd3RDNWJhakpiV2dVaHAzUTZsek9mRDNNemN3Nm1NTjc4Lzd6cWpucmZGNGlpczBqcFB6Q3lGc1ZkNCsvT1FhZXVIUjVlVGVLSCtYMElRWDN0dDFHYWdVUWdsN2NrdlBLSWZTSTZzYXhvTjBrUi9pSTVpRzBqN1BWSGpna2RKblBRR3FUNGhmQzdwbEhlNjliVHJoeEI2UUw5SlV1eGp2dWdWRURXOHM5RWNEOEoxRDQ3SlVUU2RhTmpvQTVrZ3lFdWJsU3ByTG5XeUhNck1SOWUxUU9sek5RLzRVczBINXovZWIzcDJ3dFkyYlVxejFySXFORFBvMUIxN1BGNjhVdDNHeHZVOHBYN2JWMDBEeXd0RlFpZVR5UXBkeGFsMmYwQ0k3dzU2Y2FJaExMVFFSS3BYUDBpVi8vZm0vNnh5SFZsQmg5UlJCVS9EQ1o1Yy9DSlhjUDlpZG9oK1U0ZkZENTR3NllZMU15Tnlta1BKMlNRTXhsTHR0MWNlTURhMjgzdjNtcDJzNndvRHNwYXpMNG5IOTAzbW1HWG5OSVdydW92YmJyR01SaGpzUHNPWFNxRUVqSnFlcVdudHJaS3FBbUhEYjFIY09UcSs1VGxiakM0NVczZExGcDltbDdPeWhnRkhDdGo0K20xMm9aN0JldEorR3ZWYWlBbjVBNEVzWlZnQUFIamFZMkJrWUdBQTRpTXptTy9IODl0OFpXQm1ZUUNCeDBjZDc4TG8vLy8vNnpNZFk3b0k1SEl3TUlGRUFYZk1Ea1FBQUFCNDJtTmdaR0JnWnZqUHdNREFkT3ovLy84WG1MSVlnQ0lvZ0JVQWovb0dDd0xHQUFBQ0JnQkNBam9BU3dHZUFEQUNXdi8vQUFBQUFBQklBSzRCRGdHSWVOcGpZR1JnWUdCbDhHTmdZZ0FCUmdZMEFBQUlvd0JZZU5wTmpEMXZ3akFRaHArSUJJa3dzS0FPSFlxSHpoRUVKTFl1REV5c1RDeUFYWlRCTm5KQ0pLU3FZMzkzTDY2SG51VFQ4MzZjZ1pKdk1vYkptTVU5VEU0aDZvOExwc3dUajBVdEVwZTg4czZJTEorSTg4Wkg0bHlTVStLQ0Z6NFRqOFgvU2x5eTRXZm43ZjNSbWFBT1hwdmdydFkyMjZNSmJlT2RXbFhMcVBmR21YRHVqRmFYcDlKOTAvWTNxOVpWWGRYczhGanVQT2d3QkJRSGNYUmt4MVV5UzhPV1kzUmFZUysrWWtYRjhsKytsOXpGempuK3BLVno0U2xiMDB1amxYMlRybUl0bC9Yd2ZnSE1LeS81QUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTThBQW9BQUFBQUE2QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncWxHVWttTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSmJaMng1WmdBQUFXd0FBQUIxQUFBQWZCZVpiMUpvWldGa0FBQUI1QUFBQUM4QUFBQTJLakxHdUdob1pXRUFBQUlVQUFBQUhnQUFBQ1FHTmdBMWFHMTBlQUFBQWpRQUFBQUlBQUFBQ0Fha0FHOXNiMk5oQUFBQ1BBQUFBQVlBQUFBR0FENEFBRzFoZUhBQUFBSkVBQUFBRndBQUFDQUFCQUFuYm1GdFpRQUFBbHdBQUFEUEFBQUJPQk9CS3J0d2IzTjBBQUFETEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRG1LY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeG9BQUhHQ09sdUN5ZGdVMkpRNG1EV2ZHUEVRTURzeUx6T2FBd0kwTHAvLzhNREFEajB3NFhBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVW9jLy85RHlMcy93ZklNQUZEV0JvWUFBSGphWTJCa3lQKy9rV2tKVXdDREtnT0RxcUljbzdpeG1aZ0ltN3F5bWo2am1ycVpPUWhDUmZnWTJSVkJMS2FhZjJxOFM2clc4MGxKODI3dVNCU0xZR1lPNStaSjdOZ01FbGhmdFlTWDhSYVE5Ynh3QWhNamh3b0hJM093V0V4N1N3d3ZkekF6bU04MG9aQ1JVNW1UZ1FFQUpBOFpZUUFBQUhqYVkyQmtZR0FBNGg2V3RQeDRmcHV2RE13c0RDRHcrS2pqWFFUOWZ5UHpSS1lBSUplRGdRa2tDZ0F1ZndzNkFIamFZMkJrWUdCVy9HTUVKQ2N5NURQa015MWhBSXFnQUNZQVZjb0Rid0FBQTVFQUFBTVRBRzhBQUFBQUFENEFBSGphWTJCa1lHQmdZbEJqQU5FTVVCSUpBQUFFVXdBc0FIamFUWXc5YjhJd0VJYWZpQVNKTUxCVUhUcUFCK1lJUWlXMkxneE1yRXdzZ0EzS0VBZlpJVktrcW1OL2R5K3VCMDd5NlhrL3prRE9Ed25ESk16Q0hpWWxFL1hQR1ZQZUlvOUZMU0xuZkxCa1JKSk94Sm56RlRtVjVCUTU0NTFiNUxINDM1RnpQdm5kTmZYajJScW5EbzAyemw1cjMyK1B4dm1xc1dwZHJJTGVHMnZjdVRWYVhYcWx1OHAzOTFwdGlySW8yZEZROCtCSmk4R2hPSWlqQTF1dWtubDZ0aHlENDZra3RkSmFVN0I2eWZlUzI5QTVoNSswZEM2U0tLRk9ycnpzdTdRVkc3a3NoL2NIOUFNd1VRQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRSUFBb0FBQUFBQkpnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoV1IwOVdOdFlYQUFBQUU0QUFBQU1RQUFBRHdBbXdDR1oyeDVaZ0FBQVd3QUFBRkJBQUFCYUt2K2pBcG9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktmWEhhR2hvWldFQUFBTGdBQUFBSGdBQUFDUUYwQUpvYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWYzQU5Cc2IyTmhBQUFEREFBQUFBZ0FBQUFJQUU0QXRHMWhlSEFBQUFNVUFBQUFHQUFBQUNBQUJnQkNibUZ0WlFBQUF5d0FBQURPQUFBQk9QTmRLcDl3YjNOMEFBQUQvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1XczQ0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUMFpNaGtadmdQNURORHBKSFUvQWNLQXdEbk13MUplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtlakprL3Y4UDVJUHAvenYrendTckFnSUFsWXdKR3dBQUFIamFKWTVMVGdKQkdJUzcvaGthNXNFTUE5MDk4bkFJWUtZaEVoNEJoNDBPUklrbUxtVGwwc1RFQXhqakFkeVplQUV2NFJWY2V3ZHY0QVZjS2pheGFsSEo5MjJLZ1QxdXQvUkE3MnpNR0N5dTJzaVVERENtRUYwOXoyS1ZMV3JaUE5WcGthZEhPZHEwaEpLQzY1VGo2d1d1SElZU05YNTV0Ym1va0pUSGlmMXN1YUxqVmNTT2JqYm5OU1ZPOXVudTU1TVhRT0MrZEdBQlZtUVdVWU5penl2c0FDK0xmMEdoY0kxaEpzUnV0dC80b0RmbXNwVjVGNkRZVFhWT3FpYUszSFFFblMydHpGd3pKa0JQcDNxK3lFd1R4RHkwdU9SeGprV09XYXp3U3IxbXBRbm93L3BrMzQ4R3ArTVZ5SW43clJJaDZhNnFWc2t2bDVCNGtWNVBjeURvamh5Yk9qb1A3Skx2Ty9TMGR3Q2w2ajAwZmtsTVJYVnNZektveSt6MkxDbjJnWHpoT1VTdW5GV2ppWTE1R3JldTd4dGVwV2ZSZWhnYXcvNEFiVVVySUFBQUFIamFZMkJrWUdBQTRsZTdGbGpHODl0OFpXQm1ZUUNCeDBjZDd5TG8vMStaUTVqMkFMa2NERXdnVVFCbHpnekZBSGphWTJCa1lHQm0rTThBSkVNWVloa0VtQW9aZ0NJb2dCa0FPVlVDUHdBQUExUUFBQUtCQUhNQ0lnQmRBQUFBQUFCT0FMUjQybU5nWkdCZ1lHWndaR0JpQUFGR0JqUUFBQWNvQUVsNDJrMk1QVy9DTUJDR240Z0VpVEN3b0E0ZGlvZk9FUVJZdXpBd3NUS3hBSFpSQnR2SUNaR1Fxbzc5M2IyNEhucVNUOC83Y1FaS3Zza1lKbU1XOXpBNWhhZy9McGd5VHp3V3RVaGM4c283STdKOElzNGJINGx6U1U2SkMxNzRURHdXL3l0eHlZYWZuYmYzUjJlQ09uaHRncnRhMjJ5UEpyU05kMnBWTGFQZUcyZkN1VE5hWFo1SzkwM2IzNnhhVjNWVnM4Tmp1Zk9nd3hCUUhNVFJrUjFYeVN3Tlc0N1JhWVc5K0lvVkZjdC8rVjV5Rnp2bitKT1d6b1duYkUwdmpWYjJUYnFLdFZ6V3cvc0Z5SnN2OFFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21leDEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04Ljg5Mzg3OSwtMzYuOTA4MzE2KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01Ni4xODM4LC0yOC4wMzM4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOC44OTM4NzksLTM2LjkwODMxNilzY2FsZSgtMSwtMSknPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTMuMDk0OTUyLC04OS40NzUyMjgpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjk1Mjc3LDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTMuMDk0OTUyLC04OS40NzUyMjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTMuMDk0OTUyJyB5PSctODkuNDc1MjI4Jz5RPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEzLjA5NDk1MiwtNjUuOTU5MjExKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEzLjA5NDk1MiwtMzYuOTA4MzE2KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTcuNzY1NzUsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxMy4wOTQ5NTIsLTM2LjkwODMxNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y2JyB4PScxMy4wOTQ5NTInIHk9Jy00NC4zODAzNTcnPu6BkTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScyMi41MDQxNDEnIHk9Jy0zMy45MTk0NzknPmk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjUuMzIyODY4JyB5PSctMzMuOTE5NDc5Jz7iiIg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMzAuNjkxNjUnIHk9Jy0zMy45MTk0NzknPkk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMzYuOTIzMDkyJyB5PSctMzYuOTA4MzE2Jz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzQ1LjE3Njg4MScgeT0nLTM1LjQxMzkzNSc+aTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1OC45OTQwODksLTM2LjkwODMxNilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5Mi45NzkxNjMsLTM2LjkwODMxNilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuODA3LDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoOTIuOTc5MTYzLC0zNi45MDgzMTYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nOTIuOTc5MTYzJyB5PSctMzYuOTA4MzE2Jz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzEwMS4yMzI5NTInIHk9Jy0zNS40MTM5MzUnPmk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS0xMS44NDEyMy0yNS41MzM4SDM1LjM1ODc1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM1LjU1ODczLC0yNS41MzM4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDguMzEzNjQsLTIxLjgxOTk2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOC44OTM4NzksLTM2LjkwODMxNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOC44OTM4NzknIHk9Jy0zNi45MDgzMTYnPnA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQuNzg2OTIzJyB5PSctMzUuOTEyMDUyJz5pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS0yNS42NTQyIDIxLjY2OThMMzUuNDI0NjUtMTguNTMwNicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjgzNTI3LC0wLjU0OTc0LDAuNTQ5NzQsMC44MzUyNywzNS41OTE2NywtMTguNjQwNTIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNy40MDUsNS4xNzM1MiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTguODkzODc5LC0zNi45MDgzMTYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTguODkzODc5JyB5PSctMzYuOTA4MzE2Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01LjAwOTA5MicgeT0nLTM1LjkxMjA1Mic+aTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00tMzQuMTEyNTIgMTguOTI2MDlWLTE2LjI3NDA1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsLTM0LjExMjUyLC0xNi40NzQwMyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjEuMTksLTAuNjIzOTYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC04Ljg5Mzg3OSwtMzYuOTA4MzE2KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy04Ljg5Mzg3OScgeT0nLTM2LjkwODMxNic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNS43ODA1MzYnIHk9Jy0zNi45MDgzMTYnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTEuODk1NzQ5JyB5PSctMzUuOTEyMDUyJz5pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzEuMjYwMjYzJyB5PSctMzYuOTA4MzE2Jz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzQuMzczNjA2JyB5PSctMzUuOTA2NTA0Jz5pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzcuMDMxNScgeT0nLTM1LjkwNjUwNCc+4oiIPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzExLjczNjE0NycgeT0nLTM1LjkwNjUwNCc+STwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+"></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            Q \\
            \\
            {\prod _{i\in  I} X_i} &amp;&amp; {X_i}
            \arrow [&quot;{p_i}&quot;, from=3-1, to=3-3]
            \arrow [&quot;{f_i}&quot;, from=1-1, to=3-3]
            \arrow [&quot;{(f_i)_{i\in  I}}&quot;&apos;, from=1-1, to=3-1]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>With this definition, it is natural to ask what can serve as a <fr:strong>nullary product</fr:strong>.
        The concept is characterized by terminal objects.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>634</fr:anchor>
                    <fr:addr type="user">def-003Q</fr:addr>
                    <fr:route>def-003Q.xml</fr:route>
                    <fr:title text="Terminal Object">Terminal Object</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>A <fr:strong>terminal object</fr:strong> in a category <fr:tex display="inline">\mathcal {C}</fr:tex> is an object <fr:tex display="inline">\top </fr:tex> of <fr:tex display="inline">\mathcal {C}</fr:tex> 
    satisfying the following universal property: for any object <fr:tex display="inline">X</fr:tex> in <fr:tex display="inline">\mathcal {C}</fr:tex>,
    there exists a unique morphism <fr:tex display="inline">!:X\to  \top </fr:tex>.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>When making math statements, we often encounter concepts that are dual to each other.
        In category theory, this phenomenon is captured by the concept of <fr:strong>duality</fr:strong>.
        Intuitively, duality offers us free dual theorem from the original one.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>635</fr:anchor>
                    <fr:addr type="user">def-003R</fr:addr>
                    <fr:route>def-003R.xml</fr:route>
                    <fr:title text="Opposite Category">Opposite Category</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>For a category <fr:tex display="inline">\mathcal {C}</fr:tex>, the <fr:strong>opposite category</fr:strong> <fr:tex display="inline">\mathcal {C}^{op}</fr:tex> 
    has the same objects as <fr:tex display="inline">\mathcal {C}</fr:tex>, but the morphisms are reversed.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:p>For example, the product in the opposite category, all <fr:strong>universal properties</fr:strong> corresponds
        to a dual concept.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>636</fr:anchor>
                    <fr:addr type="user">def-003S</fr:addr>
                    <fr:route>def-003S.xml</fr:route>
                    <fr:title text="Coproduct">Coproduct</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>For <fr:tex display="inline">\mathcal {C}</fr:tex> a category and <fr:tex display="inline">X, Y \in \text {Ob}{\mathcal {C}}</fr:tex>,
    the <fr:strong>coproduct</fr:strong> is an object <fr:tex display="inline">X\sqcup   Y</fr:tex> equipped with 
    two morphisms <fr:tex display="inline">i_X:X\to  X\sqcup   Y</fr:tex> and <fr:tex display="inline">i_Y:Y\to  X\sqcup   Y</fr:tex> such that
    it is universal with this property. That is, for any object <fr:tex display="inline">Z</fr:tex> and morphisms
    <fr:tex display="inline">f:X\to  Z</fr:tex> and <fr:tex display="inline">g:Y\to  Z</fr:tex>, there exists a unique morphism <fr:tex display="inline">\langle  f, g\rangle :X\sqcup   Y\to  Z</fr:tex>
    such that the following diagram commutes:
    
 
  
  <fr:figure><fr:resource hash="201c2fae0554c137f88cc7a14c567ddc"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI0OS43NzExODNwdCcgaGVpZ2h0PSc5OS4zMTA5ODRwdCcgdmlld0JveD0nLTcyIC03MiAxNjYuNTE0MTIyIDY2LjIwNzMyMyc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTU1BQW9BQUFBQUEzUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFhaMEQyTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWNRQzJaMng1WmdBQUFXd0FBQUJJQUFBQVNFRUxLRDVvWldGa0FBQUJ0QUFBQUM0QUFBQTJLWFRHdDJob1pXRUFBQUhrQUFBQUh3QUFBQ1FFVEFINGFHMTBlQUFBQWdRQUFBQUtBQUFBQ2dRL0FJdHNiMk5oQUFBQ0VBQUFBQWdBQUFBSUFCSUFKRzFoZUhBQUFBSVlBQUFBRndBQUFDQUFCUUFKYm1GdFpRQUFBakFBQUFESkFBQUJNdTBLa2V4d2IzTjBBQUFDL0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtUE1zNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwU01ab2hsWnZnUDVETkRwSkhVL0FjS0F3RDFkUTEwZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLUmpQRS92OFA1SVBwLzh2K0x3V3JBZ0lBbGw0SklRQUFBQUFCQUl2L0FBRXBBd0FBQndBQUFTTVJNeFVqRVRNQktaNmViR3ovQUFRQU12eGtBQUFCQUNIL0FBQytBd0FBQndBQUV4RWpOVE1SSXpXK25XdHJBd0Q4QURJRG5ESUFBSGphWTJCa1lHQUE0cHRaSzdqaitXMitNakN6TUlEQTQ2T09keEgwZndhbXk4d2dMZ2NERTRnQ0FENVlDd3dBQUhqYVkyQmtZR0JtK00vQXdNQjBtVUdSUVlsUmt3RW9nZ0tZQUR4TEFra0FBdE1BQUFGTEFJc0FJUUFBQUFBQUFBQVNBQ1I0Mm1OZ1pHQmdZR2JnWUFEUkRGQVNDUUFBQVlBQUR3QjQyajJNTVF2Q01CQ0Z2MklWcllPRDRPQWd3UjlRdEFvdWJnNU9yZzV1MWdUcDBGVFNXblFSZjdyWEVMeVE0N3YzM2gyUThDR2lxNGlKNzEzRjhpYUIrNHlaQmg2SXZnaWNNR2RKanlnZWliSmdIemhteUNWd254bDU0SUhvcjhBSlc3Nkhxbnc4RytQVXFkTEcyVnZwZG1majZxS3lhcDJ1dXZGb3JISFh4bWlWdjVWdWk3cTlsMnFUWm1uR2dZcVNCMDhhREE3RlNSVHQyWElUejdIajdPZWFRandybVRVcHE3OTdGTmY2eE5WZjBaTEllVXZYdExKVFM3OUxWckdSdmF6N1Axa3lMazBBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJzQUFvQUFBQUFCU0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hYTjE3Mk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNzWjJ4NVpnQUFBV1FBQUFHdkFBQUIrTDFxallKb1pXRmtBQUFERkFBQUFDOEFBQUEyS3R6SGNtaG9aV0VBQUFORUFBQUFId0FBQUNRSG9RTE9hRzEwZUFBQUEyUUFBQUFNQUFBQURBc1RBTTlzYjJOaEFBQURjQUFBQUFnQUFBQUlBSWdBL0cxaGVIQUFBQU40QUFBQUZ3QUFBQ0FBQlFCYWJtRnRaUUFBQTVBQUFBRE9BQUFCT1BOZEtwOXdiM04wQUFBRVlBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbTNzZzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFNNWUloa1p2Z1A1RE5EcEpIVS9BY0tBd0RyTkExVGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpUi8vOER5WWovLy8rdkJQTVpBRlNMQnJWNDJpMlF3VzdUUUJDRzk1OTFkbXZIWGlmcnpab21KbEVUWkJjSjJWR2hObEpSUWlOVUlZVFVFNEl6UGJiY3VYQkJnaXNDY2VzNUoxNGhjT0FGS2g0QWlSZmdpTVFwWVZOeG0vbG4vdEY4UHdNNzI2eTlJMXF4RjR3aEdlSnViWHRXVnBEallvWjBocnhDVEVJS080Sk5SVVZPYitwbWhqbnhFaE9SSCtaTjJ0U3BRakdXcWROTENHY2NVV05USStSWVNMcjgxcm81VlFiOWg0dVBYWUp1WlgyMFByeDc1UXNnTXFFRWJzd1g1NHB6cms1T2g1Mi95MVoyb0JMc3Z2MFVjM1JGTm5qelpiY0xNL0JjTXorK2lDa0l5bWNsM3ErL2h3b2lIQkNIMXpVQktBcms3OWN2UTk4WEVSRVBSOWVET0NTK1Ayai9nbW5IRUZHZlBBODZhVVAvdU96MWVqNFo0OFB0VWJ4amtPMHpzSXZOaHYraHIrd3hZejZrY0NhSDdrSlJxQ2hHWHR5clUxdlA4WisrZHFUWDlGTElCSTYvR09lRkUrYzQyQVl3VVpCOHVyNjY3WVBnNnpzZERTMU9uajU1cEdGMU05b3BWektybENhN09QN3NhSFdVV1ZwQ21kQ2JpQkJrN3orWWxsNEkzVDVjR0RwYS8xenUrVXA0N3BZSWU5dS80VUp6QmVLOUZaNTNJZ2M0M0ZKRGIvTWdmMzBGYmxSS3NyMlZ3V1dRQk40dHpkZy9jYkZCQ1FCNDJtTmdaR0JnQU9JOUo2WWF4L1BiZkdWZ1ptRUFnY2RISGU4aTZQLy9XS3laOWdLNUhBeE1JRkVBWEhVTWhnQjQybU5nWkdCZ1p2alB3TURBVXN5US9EK2N4Wm9CS0lJQ21BRlU0d04zQUFOVUFBQUVjd0JqQTB3QWJBQUFBQUFBaUFEOGVOcGpZR1JnWUdCbWlHUUEwUXhRRWdrQUFBbHBBR0FBZU5wTmpEMXZ3akFRaHArSUJJa3dzS0FPSFlxSHpoRUVXTHN3TUxFeXNRQjJVUWJieUFtUmtLcU8vZDI5dUI1NmtrL1ArM0VHU3I3SkdDWmpGdmN3T1lXb1B5NllNazg4RnJWSVhQTEtPeU95ZkNMT0d4K0pjMGxPaVF0ZStFdzhGdjhyY2NtR241MjM5MGRuZ2pwNGJZSzdXdHRzanlhMGpYZHFWUzJqM2h0bndya3pXbDJlU3ZkTjI5K3NXbGQxVmJQRFk3bnpvTU1RVUJ6RTBaRWRWOGtzRFZ1TzBXbUZ2ZmlLRlJYTGYvbGVjaGM3NS9pVGxzNkZwMnhOTDQxVzlrMjZpclZjMXNQN0JjaWJML0VBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVRFQUFvQUFBQUFCYmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hYTjA4Mk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUN0WjJ4NVpnQUFBV1FBQUFINkFBQUNnT3BGVWxab1pXRmtBQUFEWUFBQUFDOEFBQUEyS2dqSGNtaG9aV0VBQUFPUUFBQUFIZ0FBQUNRR2hnR2JhRzEwZUFBQUE3QUFBQUFRQUFBQUVBclNBSHBzYjJOaEFBQUR3QUFBQUFvQUFBQUtBZElCQUcxaGVIQUFBQVBNQUFBQUZ3QUFBQ0FBQmdCaGJtRnRaUUFBQStRQUFBRFVBQUFCUHBrUmRjZHdiM04wQUFBRXVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbTJzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFNNWUloaVp2Z1A1RE5EcEpIVS9BY0tBd0RzQ2cxV2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoUi8vOER5WWovLy8rdkJQTVpBRlNjQnJaNDJrMlJUWXZUVUJTRzg1NmIzSnVrK1dpbSthQzJUYVoyVEJqUVZxZE9xZ050RmdxQ0lDTE1Ua0ZSMUJFR2tSRVJOenFPUzMrR3FFdkZoWWdvYnZ3Ukx0eTQwcFdnNEhJNjNpVDRzYnZuUGVkZXp2TmNCVXAzYjQ5ZHAzZktSVVhCSko4TUtac2h3U1JNNFBPQkE4RmR5SE9NY1JRR0RrWVFXWm9kemNjenJJN2dRZzVVcmFocXBTTlVyWUxZRUFOZXZ4VEZLQjhLOE9OWmsxSFNBbXh0NjVKQlpKbkRJbWhQZHJ5bHMyYnZpQ1hJNGxzUERRMldIc2ZheG9XTlJoT1U2RUlGTE8xMmZTRTduZHFmN21uZGd3R1ZZVDI5Mk1YVFYwN2tXekFkQWNhZ2NvZXoyQStuajRmcmIyTVhaRHBjNWdUREZ1cUNjSDlkdmRtSWJMOUJwUCs1NEhKYXpLeHZpSnNlYytxUUFxRUdtaUsxS0V2U2tTVWRuWlFGY3lRMkQzaUMvSitPS013THl2NkhEaU9mcDF4MHBOTWhzblMxU2xkcXBYUmx6alYyU0tNNDdjSGlqMG9NeDFsTFJOOVc3MnY3U2ppN2hyT0R3K3p1ZDdlQmpzZGg4MnZydHFXUHB5R2Rtbi9tbHZQYUZ4S085ZXAxZFZjQS92TE9jUS9uV3MyL0ZCS1JERy8rQVo3djlzeXlMbDIwdWJiY3J0alc5dWIwbGQ0ckJ4VEZ3SGdsTDVDUHcwQTR5UHE4QUFiN3VlRFZ4eGFZSWVybmdyN3Nmbnp4NEZaUFY3bDlSalVYNWljNlVHbjYvTTVtQjVZQnBoNlRJVjUyR1QzWjNkNjg0V3RrL0pTN1VLTkYyNWZQaTlLMlpyNnBFdVUzZUI5Vm1RQUFlTnBqWUdSZ1lBQml5WkxTM2ZIOE5sOFptRmtZUU9EeFVjZTdDUHIvUCtaMHByMUFMZ2NERTBnVUFFUHREQ0lBZU5wallHUmdZR2I0endBa0F4aGsvcnN4cHpNQVJWQUFDd0JNeVFNbkFBQUNkZ0FBQTFBQUhBSlNBQ1FDdWdBNkFBQUFBQUNTQVFBQlFBQUFlTnBqWUdSZ1lHQmhTR0FBMFF4UUVna0FBQW96QUdnQWVOcE5qckZxd3pBVVJZK3BZNmhieUpRTUhZcW1qTVoyK2dHRkRKbXlaaXdra1FndVNBcXlZOGdTK2dIOTZENHJHdnFFSGtmblhRa0JKWGN5cHNxWXh6NVZUaUduQjg5NFlaRzRrS1VTbDd5eDRva3NmeGJ6em1maW5GZStFczlZOHAyNEVQK1R1T1NEMzQyM2wrdGdndHA1YllJN1dkczE5ZDZFdnZOT05WWDlFRnZqVERnTVJxdmpUZW14NjhlelZldXFyVm8yZUN3WHJnd1lndnhzSjBaSGRweGtadWxvcU5sSDE4dkp5MFNKcThUK1Qyd2w0V0xxRUYvVGtqcHlrNjRaSmROTFAwdGFzWmE3N2JUL0FPQ0NNTDE0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVY0FBb0FBQUFBQmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVWQwV0dOdFlYQUFBQUU0QUFBQU5RQUFBRVFBZkFEL1oyeDVaZ0FBQVhBQUFBSkdBQUFDdkRQS0pVTm9aV0ZrQUFBRHVBQUFBQzhBQUFBMktXZkd0V2hvWldFQUFBUG9BQUFBSUFBQUFDUUZtUUdjYUcxMGVBQUFCQWdBQUFBVUFBQUFGQW96QVJwc2IyTmhBQUFFSEFBQUFBd0FBQUFNQVNnQjdtMWhlSEFBQUFRb0FBQUFHQUFBQUNBQUNBQkZibUZ0WlFBQUJFQUFBQURQQUFBQk9QTmhLcU53YjNOMEFBQUZFQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm00bUtjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBycU1HUXlNL3dIOHBraDBraHEvZ09GQWFxbkRJOEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UjBHTklaTXYvL0I3UFNRS3ovVi8vUCtUOGJyQllNQU9kUkMzVUFBQUI0MmtXU1BXL1RRQnpHNzdsenprM2Q1T3pFUGpjaGRlTFlzUU50a3liT2k5U21lWVdodE9KbGlvb1FuV0JnUXFxRUVCT2ZnQUV4c0RMQWQyRHZGK2pHZDJBdUVnTU41eUxFM1hSNi9ycDdmajhkQVRsZjdaTXI4cHBJUW9ZNjExdm9EWVllSEM3QTlTZ2VETWY0dm1FVUs5VmFPUXkxUnJZaERBYWVWTTAxSGZDN1BqRHVMUHU1TG1oT3ozVE9pRm9neDZzMmZVa3Z5VlFkV0hwUkhubzlpc2RJcEN1NUxxc1lZOElDSGczY1pBejFSTktWYmg1QkZFZURZZFJHbmdva0E4bGpmTjQzTmJPY25YV2ErMERvUkF5aUtvUUlmYmJWRWljZUxZckh3c25MZVhCN0JBUlM1YVluUktIZ3JhK1Z6OUlZSDY4djdsdlRucjFnVWVEVmFNaGpJMHVoSFR1ZnJwYXNybU41ZWl1T0d1SC9DS1ZvOTcxV1gwUEtRc25PYXBjMmNFRmFaSkhTS0JKK1E2SWEyMXgzWlNKVFJ4T2s2cFN1ZEh0d0ZaVWFZQk1NWWdYRjlWU0JkTHZwS1BWZlpjL2Z0SjlwcXE4bGtTOVVMTjhlQlJXcHU4T2oyU2xsTTJFZG5UYjdPVll1NUJ4OGFEUFlUcSs4cURtbWhTajI1cFVOSFcrdlorMG5qRG83VzM2eGFIanJHUXFqVXRxclBVMDBMQjg5ZjFBVWR4bENhVXFZMXZXdmI4Sm9CQnFhL1dnMmZUaEVveVp5TjJ4N3E1OTRRYitTZFRKU2JBcXRoZjRZWFpuMjd2ZjB1dW9kcVA2OWYxUmMwQlFrNVJna3JxZFU2SCt4Y1FKLzAzWVFiTnVYMHpJdmVTTWJsc0d4YVZqQmVMc1BaRXFsZ2pCWnBYcFFwRmFXUXhxRjRGQUZsTDZUNmcrNVF2cWwzeisrekcwelpnZHprOUpzdmlPZFZnYmQwREpucythZDJqMU1EZ3VVdW51dWJHbm9ORGIvQUh3UlhTQUFBSGphWTJCa1lHQUE0bXR2azY3SDg5dDhaV0JtWVFDQngwY2Q3eUxvLzdwTXg1Z3VBcmtjREV3Z1VRQjErZzBDQUhqYVkyQmtZR0JtK00vQXdNQjBqRUhuL3dXbUxBYWdDQXBnQlFCbEhRUTVBc1lBQUFGYkFITUNPZ0JMQWpvQUxBR2VBREFBQUFBQUFDb0FrQUQrQVY1NDJtTmdaR0JnWUdWd1lXQmlBQUZHQmpRQUFBZXBBRTU0MmsyTVBXL0NNQkNHbjRnRWlUQ3dvQTRkaW9mT0VRUWt0aTRNVEt4TUxJQmRsTUUyY2tJa3BLcGpmM2N2cm9lZTVOUHpmcHlCa204eWhzbVl4VDFNVGlIcWp3dW16Qk9QUlMwU2w3enl6b2dzbjRqenhrZmlYSkpUNG9JWFBoT1B4ZjlLWExMaForZnQvZEdab0E1ZW0rQ3UxamJib3dsdDQ1MWFWY3VvOThhWmNPNk1WcGVuMG4zVDlqZXIxbFZkMWV6d1dPNDg2REFFRkFkeGRHVEhWVEpMdzVaamRGcGhMNzVpUmNYeVg3NlgzTVhPT2Y2a3BYUGhLVnZUUzZPVmZaT3VZaTJYOWZCK0Fjd3JML2tBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTWNBQW9BQUFBQUEzd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYUlCaWYyTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPREhaMng1WmdBQUFXd0FBQUJRQUFBQVVNUEZoclZvWldGa0FBQUJ2QUFBQUM4QUFBQTJLYjNIR1dob1pXRUFBQUhzQUFBQUhnQUFBQ1FGeGYrRmFHMTBlQUFBQWd3QUFBQUlBQUFBQ0FYR0FEMXNiMk5oQUFBQ0ZBQUFBQVlBQUFBR0FDZ0FBRzFoZUhBQUFBSWNBQUFBRndBQUFDQUFCQUFYYm1GdFpRQUFBalFBQUFEVkFBQUJQcTgzZGVOd2IzTjBBQUFEREFBQUFCQUFBQUFnQUFNQUFYamFZMkJtZXN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBQUJKSFpLY1ZrNkE5dURrZ2NsekZKL05Ca1ltS1dZcndPRkdSRXEvdjluWUFBQVZWOFF2UUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUTlLL3YrSGtQSzlZSGtHQUdvR0I3QUFBQUFCQUQzLy93SnRBbU1BRlFBQUFSRVdCaWNoQmlZM0VTWTJNaFlIRVNFUkpqWXlGZ0pzQVE0WS9od1hEd0VCQ0J3SEFRSGNBUWNjQ0FJLy9lWVpEUUVCRGhnQ0dnOFZGUS85NmdJV0R4VVZlTnBqWUdSZ1lBRGk1a25kMHZIOE5sOFptRmtZUU9EeFVjZTdDUHIvZjJZWnBtUWdsNE9CQ1NRS0FEMkpDM3dBZU5wallHUmdZSmI2b3dra1pSaHNHV3laY2htQUlpaUFDUUE3MGdKUEFBQURIQUFBQXFvQVBRQUFBQUFBS0FBQWVOcGpZR1JnWUdCaUVHTUEwUXhRRWdrQUFBTERBQndBZU5wTmpyRnF3ekFVUlkrcFk2Z2I2SlFNSFlxbWpNWjI4Z0dGREpteVppd2trUWd1V0E2U1kvQlMrZ0g1NkR3ckd2cUVIa2YzM3ZjUWtQTkx3bFFKNzZGUGxaTEo2OGt6M2xoRXp1U295RGtmckhnaFNWOUYrZVFyY3NxYzc4Z3psdnhFemtUL2k1eXo0Yjd0MnV1dE4wN3RPMjJjUGJkK3JNcURjYjdwcktxSzhpbnNqRFh1MkJ1dFRxUFNRK09IUzZ2V1JWM1ViT2xvdVhLangrRGtaM3RSZEdETFdUelBTRVhKSVdpZVJud3J1WXBDMVArSm5TUnNTQjNETmkycGszaEthSkE1TC8waWVjVmFadXZwUGdBSjN6RVZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDExLjI1NzA1NywtMzcuODI1Mzc5KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04My41NjkyNywtMjguNDkzMDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDExLjI1NzA1NywtMzcuODI1Mzc5KXNjYWxlKC0xLC0xKSc+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMC4wNjQyODUsLTg3Ljc5MDg3MSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuNTM0NzEsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgyMC4wNjQyODUsLTg3Ljc5MDg3MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PScyMC4wNjQyODUnIHk9Jy04Ny43OTA4NzEnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuNzgxODIsLTg3Ljc5MDg3MSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NS4wMzMsLTg3Ljc5MDg3MSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE0LjEwNDExLDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoOTUuMDMzLC04Ny43OTA4NzEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nOTUuMDMzJyB5PSctODcuNzkwODcxJz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzEwNi4yODI0MjInIHk9Jy04Ny43OTA4NzEnPu6BtDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScxMTUuMTM4MDcnIHk9Jy04Ny43OTA4NzEnPlk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTM3LjI4NDE4LC04Ny43OTA4NzEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTY5LjQ4MjgzMiwtODcuNzkwODcxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNC4wMTM4OSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDE2OS40ODI4MzIsLTg3Ljc5MDg3MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PScxNjkuNDgyODMyJyB5PSctODcuNzkwODcxJz5ZPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIwLjA2NDI4NSwtNjYuMjEyMDE3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIwLjA2NDI4NSwtMzcuODI1Mzc5KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjc4MTgyLC0zNy44MjUzNzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTUuMDMzLC0zNy44MjUzNzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc3MDgzLDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoOTUuMDMzLC0zNy44MjUzNzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nOTUuMDMzJyB5PSctMzcuODI1Mzc5Jz5aPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzIuNzk5ODUsMS41OTk5MScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00uNTIwODMgMTcuODAwMDVWLTE3LjQwMDA5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC41MjA4MywtMTcuNjAwMDcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE3LjE0MDcsLTEuNzUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDExLjI1NzA1NywtMzcuODI1Mzc5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9JzExLjI1NzA1NycgeT0nLTM3LjgyNTM3OSc+WzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScxMy41MTI1MDInIHk9Jy0zNy44MjUzNzknPmY8dHNwYW4geD0nMTcuNzUwMTM4Jz4sZzwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzI0LjI1MzIzJyB5PSctMzcuODI1Mzc5Jz5dPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTY1LjY4ODc3IDE4LjEzNzE4TC04LjA4ODMtMjAuMjYxMScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjgzMjAyLC0wLjU1NDY2LDAuNTU0NjYsMC44MzIwMiwtNy45MjE5MiwtMjAuMzcyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00My43NTg5OSwtOC4zODY3MiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTEuMjU3MDU3LC0zNy44MjUzNzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTEuMjU3MDU3JyB5PSctMzcuODI1Mzc5Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTTY2LjczMDQyIDI0LjE1OTc3SDE5LjUzMDQ0JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDE5LjMzMDQ2LDI0LjE1OTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM4LjUxMDU3LDI3LjUxODA4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxMS4yNTcwNTcsLTM3LjgyNTM3OSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScxMS4yNTcwNTcnIHk9Jy0zNy44MjUzNzknPmk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTQuMDc1Nzg0JyB5PSctMzYuODIzNTY2Jz5ZPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS02NS42ODg3NyAyNC4xNTk3N0gtMTguNDg4NzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE4LjI4ODgsMjQuMTU5NzcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ2LjUyNzQ0LDI3LjUxODA4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxMS4yNTcwNTcsLTM3LjgyNTM3OSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScxMS4yNTcwNTcnIHk9Jy0zNy44MjUzNzknPmk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTQuMDc1Nzg0JyB5PSctMzYuODIzNTY2Jz5YPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTTY2LjczMDQyIDE4LjQ0MjU1TDkuMTI5MjYtMjAuMjIyMDMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuODMwMjYsLTAuNTU3MywwLjU1NzMsLTAuODMwMjYsOC45NjMyNCwtMjAuMzMzNDcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMDc5ODggMi4zOTk4NkMtMS42OTk4OSAuOTU5OTItLjg1MzEzIC4yNzk5OCAwIDBDLS44NTMxMy0uMjc5OTgtMS42OTk4OS0uOTU5OTItMi4wNzk4OC0yLjM5OTg2JyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDAuMTE2NTYsLTYuMzY3ODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDExLjI1NzA1NywtMzcuODI1Mzc5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzExLjI1NzA1NycgeT0nLTM3LjgyNTM3OSc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+"></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            X &amp;&amp; {X\sqcup  Y} &amp;&amp; Y \\
            \\
            &amp;&amp; Z
            \arrow [&quot;{[f,g]}&quot;&apos;, dashed, from=1-3, to=3-3]
            \arrow [&quot;f&quot;&apos;, from=1-1, to=3-3]
            \arrow [&quot;{i_Y}&quot;&apos;, from=1-5, to=1-3]
            \arrow [&quot;{i_X}&quot;, from=1-1, to=1-3]
            \arrow [&quot;g&quot;, from=1-5, to=3-3]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure></fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
            <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
              <fr:frontmatter>
                <fr:anchor>637</fr:anchor>
                <fr:addr type="machine">#358</fr:addr>
                <fr:route>unstable-358.xml</fr:route>
                <fr:title text="Logic, Types and Categories">Logic, Types and Categories</fr:title>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>3</fr:month>
                  <fr:day>21</fr:day>
                </fr:date>
                <fr:authors></fr:authors>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:p>One important principle in type theory is the <fr:strong>Curry-Howard Isomorphism</fr:strong> (Propositions as types).
        It depicts the connection between logic and types. A program can represent a logical argument, and 
        operations in logic find meaningful correspondences in program execution.
        The principle was later extended with category theory due to <fr:strong>Lambek</fr:strong>. In his work, he showed
        a correspondence between STLC and <fr:strong>Cartesian Closed Categories (CCC)</fr:strong> and revealed the connection
        between types and categories. The correspondence is called the <fr:strong>Curry-Howard-Lambek Isomorphism</fr:strong>.</fr:p>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>638</fr:anchor>
                    <fr:addr type="machine">#359</fr:addr>
                    <fr:route>unstable-359.xml</fr:route>
                    <fr:title text="Syntax and Semantics">Syntax and Semantics</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>In general, there are two approaches to understand or design a type system: the <fr:strong>syntactic</fr:strong> view 
            and <fr:strong>semantic</fr:strong> view.

            The syntactic view focuses on the syntactic structure of types and programs. We study about <fr:strong>subject reduction</fr:strong>,
            <fr:strong>cut elimination</fr:strong> and etc, simply by manipulating the syntax. It is usually more direct and easier to understand
            as it is often conducted via induction on some syntactic structures. And it also suggest algorithms which can be implemented.
            The disadvantage is that it is limited and hard to proof some properties like normalization.

            The semantic appoaches are more powerful in general. It is based on mathematics models of type systems.
            In exchange of the strength and generality, it is usually harder to understand and heavyweight, requries
            more intuition of the concepts.</fr:p>
                    <fr:p>One clasical semantic approach to logic is algebraic logic. A logical system is modeled by some algebraic theory.
            (often related to <fr:strong>lattices</fr:strong> and <fr:strong>semi-lattices</fr:strong>). Famous examples include <fr:strong>Boolean algebras</fr:strong>
            for classic propositional logic and <fr:strong>Heyting algebras</fr:strong> for intuitionistic counterpart. 
            The algebraic logic is a powerful tool to study the properties of logical systems, but has a limitation that 
            all operations are limited in one structured set.</fr:p>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>639</fr:anchor>
                    <fr:addr type="machine">#360</fr:addr>
                    <fr:route>unstable-360.xml</fr:route>
                    <fr:title text="Computations as Monads">Computations as Monads</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>An important result from ategorical semantics could be <fr:strong>monads</fr:strong>.
            In <fr:strong>Moggi</fr:strong>&apos;s paper, he showed that monads can be used to model computational effects.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>640</fr:anchor>
                        <fr:addr type="user">def-003T</fr:addr>
                        <fr:route>def-003T.xml</fr:route>
                        <fr:title text="Monad">Monad</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>A <fr:strong>monad</fr:strong> of a category <fr:tex display="inline">\mathcal {C}</fr:tex> is an endofunctor <fr:tex display="inline">M:\mathcal {C}\to \mathcal {C}</fr:tex> with two natural
    transformations <fr:tex display="inline">\eta :\text {id}_{\mathcal {C}}\Rightarrow  M</fr:tex> and <fr:tex display="inline">\mu :M^2\Rightarrow  M</fr:tex> satisfying the following conditions:
    
 
  
  <fr:figure><fr:resource hash="65b705e596b5ade3ad3981d38dbae97a"><fr:resource-content><fr:img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMi4yIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzQ0MS4xMzcwMDZwdCcgaGVpZ2h0PScyMTcuMjkwOTE5cHQnIHZpZXdCb3g9Jy03MiAtNzIgMjk0LjA5MTMzNyAxNDQuODYwNjEzJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQS9RQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wbW1OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzhBQUFBMEU4T3pIMW9aV0ZrQUFBQ0lBQUFBQzRBQUFBMktmUEd0MmhvWldFQUFBSlFBQUFBSGdBQUFDUUZMQUs0YUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1hmQUpwc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURZQWFHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWdibUZ0WlFBQUFwd0FBQURKQUFBQk11c0lrZWh3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm02bUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWRJbERNMEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkpqMW40SHhPRE1EZ3h3REF5TWZJenVidUJnWWlyQXBxZXN4cXF1cG01bmJNWnFiR1ltSnNqRWVDV3BsWlZiaTROS3Q0R0JrazNKVTlGS3daV0d4VmZCU2RKUmlZMlI2YnZaMVQyeWxoSGhWS2dzWEM1ZUpiSlJ0d1lvVmhiYVJzaVpjTEp3TVFNRElrQXkwYXdMUUxta2doNDBkWkp1YVBxTUoyQUloTlhVMUlFTmNqbEZjakhFQzFGUm1KbGIxY0RWVHhyUmlkbVptaUlXTURCQXpHVms1T0Zoa2s4T2FHS1YreDNKenN6S0NMUVFBRWFNamozamFZMkJrWUdBQTRqMkJFY3ZqK1cyK01qQ3pNSURBNDZPT2R4SDBmd2JtSUdZUWw0T0JDVVFCQURxeUNxSUFBSGphWTJCa1lHQm0rTThBSklNWWtobVNHWTh6QUVWUUFCTUFSc2tDNmdBQUExSUFBQUlxQUpvQVl3QUFBQUFBQUFBMkFHaDQybU5nWkdCZ1lHYVFad0RSREZBU0NRQUFBNzhBSmdCNDJqMk1NUXZDTUJDRnYySVZyWU9ENE9BZ3dSOVF0T3JtNXVEazZ1Qm1UWkFPVFNXdFJSZnhwM3NOd1FzNXZudnYzUUVKSHlLNmlwajQzbFVzYnhLNHo1aHA0SUhvaThBSmM1YjBpT0tSS0F2MmdXT0dYQUwzbVpFSEhvaitDcHl3NVh1b3lzZXpNVTZkS20yY3ZaVnVkemF1TGlxcjF1bXFHNC9HR25kdGpGYjVXK20ycU50N3FUWnBsbVljcUNoNThLVEI0RkNjUk5HZUxUZnhIRHZPZnE0cHhMT1NXWk95K3J0SGNhMVBYUDBWTFltY3QzUk5LenUxOUx0a0ZSdlp5N3IvQTFXNExrVUFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUb0FBb0FBQUFBQlp3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wVEdOdFlYQUFBQUU0QUFBQU5RQUFBRHdBVGdCK1oyeDVaZ0FBQVhBQUFBSVRBQUFDWU5ZdzlUbG9aV0ZrQUFBRGhBQUFBQzRBQUFBMktYVEd1R2hvWldFQUFBTzBBQUFBSHdBQUFDUUZSd0lSYUcxMGVBQUFBOVFBQUFBVUFBQUFGQWp0QVdOc2IyTmhBQUFENkFBQUFBNEFBQUFPQWV3Qk1tMWhlSEFBQUFQNEFBQUFGd0FBQUNBQUNBQThibUZ0WlFBQUJCQUFBQURKQUFBQk11MEtrZXh3YjNOMEFBQUUzQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1NbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1CZ3pNL3dIOHBraDBraHEvZ09GQWJOUERIOEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEthaklZLy84UDVHc3dHUDcvLy8vbS8wdGdWVUFBQUl1RkNNWUFBQUI0MmtXUVRXc1RRUnlINS9lZmRJWnM2U1loeWVhOVNiYnVMcTB4b1MrN3F5bW1qZGphMUpjVzIwVFFWRnFMRld1UnRCWnZCYWtSRCtLSDZFbTkrQUY2RnNIdm9UZEJFRUY2MERwTER6SXdNLzg1UFBQd01MRDlVK0FGWnl6TEdGSkdRb29JaEJTR3VrWmdPMnI1OWd3ODdBeEoyYXpMU3h5ZExVME92WEwxUVl2b2d1NXhCb3FLcVozbzd1ZTNKMnZoS09IQlFibDBzTG4zMGpwVVNMYWcrS3RuL0xpaXBneVpFRktIN1UvTm9BRy9Dc2QyUGIvYjl3TGdxT2s5ellGSFZydmd1L05oQ003T2FIZVBaamMyU2VPaDJJMGZSNSsrMVRVUkpzWUNmazl0WCtrRHk2Z3pKb3hwSkd1SXdKMmM4SnlZRHNjMVBOOHpjSWVYV3M2ajVkNjgweXJ4eW1xaXZEK1pIS1EzZjc1a2t4WUhrWlhNa3BZSTR4d1pWV2dCdDhrWURkQjdOc3FZSmN1K3AyeEoxUkJ5R0VwL1JOaU9zaDlHU2tjUXpQZDhOZEpBOGU4OWtQeWR1OEtYYnRxZGpHTUFabHdiSXp6YmVQaWFVM3U2UFhicnB6V282WFI4bkJmaVYyNnJ2MDQ0NzVJVnllZVF0RnRQT0I3ZnY3WmRtVFBuZ0pBMkd3OWMvTlB2cE5NN1ZsZkRpSEM5VlBCWkEyNFZVZ2taS1ZVMDBKbFFkUU0vNVNSVjEvOFB2b3BRQmRJWHN5RlJ0aWZUeVFTZnQ0cnR3Z1RQWjhaRDFQdjRuSEIxdWQwRkhlNnM5em5NV2hISW11YTJXVnZodUk0T2owV0pJNUpQTjh2Tm1nS1ZSUzFWQUx6RzR0TGw4YzFpZkt1eHZNZlJYaWpsUzVtWXhTc0YwT0xhN1JYMkQ4eU5YKzhBZU5wallHUmdZQURpQmZ0K3pJL250L25Ld016Q0FBS1BqenJlUmREL0daa3VNNE80SEF4TUlBb0FhWWtNREFBQWVOcGpZR1JnWUdiNHo4REF3SFNad1p6QmtvbVBBU2lDQWxnQVBqMENYZ0FDMHdBQUFja0FkQUhKQUVnQ1J3QndBRUVBTndBQUFBQUFNQUJnQUl3QTBnRXdBQUI0Mm1OZ1pHQmdZR093WmdEUkRGQVNDUUFBQnN3QVJRQjQyajJNTVF2Q01CQ0Z2MklWcllPRDRPQWd3UjlRdEFvdWJnNU9yZzV1MWdUcDBGVFNXblFSZjdyWEVMeVE0N3YzM2gyUThDR2lxNGlKNzEzRjhpYUIrNHlaQmg2SXZnaWNNR2RKanlnZWliSmdIemhteUNWd254bDU0SUhvcjhBSlc3Nkhxbnc4RytQVXFkTEcyVnZwZG1majZxS3lhcDJ1dXZGb3JISFh4bWlWdjVWdWk3cTlsMnFUWm1uR2dZcVNCMDhhREE3RlNSVHQyWElUejdIajdPZWFRandybVRVcHE3OTdGTmY2eE5WZjBaTEllVXZYdExKVFM3OUxWckdSdmF6N1Axa3lMazBBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVI4QUFvQUFBQUFCVWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXaDFkR050WVhBQUFBRTRBQUFBTVFBQUFEd0FkUUNmWjJ4NVpnQUFBV3dBQUFHekFBQUNFT3dvM3c5b1pXRmtBQUFESUFBQUFDOEFBQUEyS3M3SGRHaG9aV0VBQUFOUUFBQUFIZ0FBQUNRSFRBS1phRzEwZUFBQUEzQUFBQUFNQUFBQURBbW5BRWhzYjJOaEFBQURmQUFBQUFnQUFBQUlBSFlCQ0cxaGVIQUFBQU9FQUFBQUZ3QUFBQ0FBQlFCaGJtRnRaUUFBQTV3QUFBRFVBQUFCUHBrUmRjZHdiM04wQUFBRWNBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbU5tZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHI2TWtRd00vd0g4cGtoMGtocS9nT0ZBYjF3RE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUSytqSkUvUDhQNUlQcC8xdityd0tyQWdJQWxCc0pEZ0FBQUhqYU5aQzlqdE5BRklYbjNCblB4STQ5ZHVMWTFpck9KTktDTFVGSWhNTGFBbW16QlFVSUNpaG9rSkJBU0dpWEFvcEZDRUhEVHdGSVM4VTd3QU1nS3JUaUlhaW9xR2twS0VNWU85Q016dHh6N3BXK3c4Q202N1U0UTEvWkpjYkFReGhVR25Pb3NpalBWVmxhMVRHa0tuYTZrSWxNeDBpVDFwWFdXNktPcTdKUml5ck5ZaXpSQ0ZrV2tuOStLNENUNXhFNEw1NTdEcUxnZ25IZS83a3JlK0hOSTRIaDZVQkNpL3Y3UVNCMnAvSTFMcG9vZkJmN3VJN0hIZDEvTTBUWXIwZjBZUFdqcndJcFJncWNFOXhRQXJHaHE2c25XdkNFbnEyK2FUZmVBc2pWVFFKRCs1NmFVQjV4UHJKUjFWc2QwMlV0d1hNRkpNemlzWHk5NXZ0MHpHN2JUMTNWTXlxWEdLTzJYQU81clMxV0NLc05GdGsvenJhRnhSSTdjNFN3Z2RiS1dxdVlvN1gyaU0rd0xUZVhNb1BtVUlKZkh5Tk80eGkyZ3NNN0xwSHZ6ZmFTcmZwVjc4UTFiM1RXVitUTHc1ZXVBNzlqakhOdzY2QWJnY1lkWld2em5VZWJoZkpLRVh4LzZ1VFRoSnJoSmozSjhlR1R6Z1krdkEyMWtGcHlNMGgzajJZM3ZwZ1E1RFhJVFYrQkVuMFYvcjczc0pzRmd5NVI1LzlDS0dsUytqOWhvaDdYbXlFbFNpUU9ZMzhCNHJ4RDFBQjQybU5nWkdCZ0FHS3hsN0dDOGZ3Mlh4bVlXUmhBNFBGUng3c0krdjkvRmwybWZVQXVCd01UU0JRQU5Id0xtd0I0Mm1OZ1pHQmdadmpQQUNRZk1zajgzOEtpeXdBVVFRSE1BRis5QSt3QUFBSjJBQUFENFFBc0ExQUFIQUFBQUFBQWRnRUllTnBqWUdSZ1lHQm1TR0FBMFF4UUVna0FBQW9ZQUdjQWVOcE5qckZxd3pBVVJZK3BZNmhieUpRTUhZcW1qTVoyK2dHRkRKbXlaaXdra1FndVNBcXlZOGdTK2dIOTZENHJHdnFFSGtmblhRa0JKWGN5cHNxWXh6NVZUaUduQjg5NFlaRzRrS1VTbDd5eDRva3NmeGJ6em1maW5GZStFczlZOHAyNEVQK1R1T1NEMzQyM2wrdGdndHA1YllJN1dkczE5ZDZFdnZOT05WWDlFRnZqVERnTVJxdmpUZW14NjhlelZldXFyVm8yZUN3WHJnd1lndnhzSjBaSGRweGtadWxvcU5sSDE4dkp5MFNKcThUK1Qyd2w0V0xxRUYvVGtqcHlrNjRaSmROTFAwdGFzWmE3N2JUL0FPQ0NNTDE0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMktTSEd0MmhvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGpLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaUR6Yzc3OGZ6MjN4bFlHWmhBSUhIUngzdkl1ai9ERXdOekNBdUJ3TVRpQUlBY0E0TDlBQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZdzlpOEpBRUlhZllDSVlDeHV4c0xqYndqb2swZm9hQ3l0YnEydlVYU1ZGTnJLSkFVRXM3M2M3V1JkdVlJZm4vWmdGVWw1RURCTXg4M3VZbUVUVWh4T216QU9QUlgwSFRsbXlZa1FVVDhUNTRpZHdMTWx2NElRRmw4Qmo4WitCVXpiOGJadjZkdStNVS90R0cyZlB0U3Z5ZzNGdDFWaFZaTG5YTzJPTk8zWkdxOU5ENmI1cSsydXQxbG1abFd4cHFMbHhwOFBnVU96RjBaNHRaOGtjQlRrSDc3UlVrbHBwRldUaS91Yzd5YTN2SFAxUFdqb25IckkxdlZ5MXNxL1NWcXpsc2h6ZUcyUEhMeEVBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVFQUFvQUFBQUFCZUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hlcDRyR050WVhBQUFBRThBQUFBTXdBQUFFUUF5UVJ1WjJ4NVpnQUFBWEFBQUFJeEFBQUNvQzNpRTZGb1pXRmtBQUFEcEFBQUFDOEFBQUEyS3pER20yaG9aV0VBQUFQVUFBQUFJQUFBQUNRSHdnTXNhRzEwZUFBQUEvUUFBQUFRQUFBQUVBeENBSzlzYjJOaEFBQUVCQUFBQUFvQUFBQUtBZFFBN20xaGVIQUFBQVFRQUFBQUZ3QUFBQ0FBQmdCU2JtRnRaUUFBQkNnQUFBRFBBQUFCT1BOaEtxTndiM04wQUFBRStBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUZtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUV6QXhKSUtTNUxCMHI2TW05blp2Z1A1RE16TUlLRUdSRXEvZ09GQWRSSURZb0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtmQm0yTW0vLy94L0Irci9sdis4Zkg3QmFNQUFBQkVBTU5BQjQyaTJSelc3VFFCU0ZmZTZNWjJMSEdUdngyQk9hTkVtVE51NFBTZ29KRG0xS1N0VVdpc1NpYkZFWGJKQ1FRR1VERXR2Q3BnaWtDaUVoWG9BMWo5QU5Zc1U3c09JeDBqS3BxbG5NblhQdWxjNDMxNEh6K1BLU245RzVjK2c0WUZLa1RlUmE5QkdpMjhjd04yaytpaUZrT3l0Q21KbWJHb1UrcEhVbk1CT000bEZ1NjQ3bzVtYVFweWFleVlQY2FKRjFCVTlQT1dRbGE0YnUrNTN0SXFOSWJjNnpMeGRQZksxeGZPcUNkRjhWZ05COTlkSm5oSkxjV25WUE9BcVJqaGRRQ2I4bUFYdU9UNzdTbitkUmlVWjFlakg5WjZRRThZNEVCN1BKeWhLb3pOSGU5SU5tZFRxZS9rMTRVR2ZFUEd0d2JodWlBdGhhalNpVkFveTNiYnNYVDgvcFFGay9EdTFUT3hiZEdWd3UwVGY4Y3ZZZHg4U1dLelU2WkFvbXRaRGJmSUxCVENDRlJGOHB5R2Rmb1lXMHA1dGRYVmtJQmRudVpxTXowclVGa3NZb1JrRzBlWFBQZUZsVGVsV3Z3VVhIQ0UvcFZ0c3JjTjhURkpkcmVYZ1FVN2F5TXg0MEl6dFlTdkNEN2dZZG9xYWJQRHNhVnpxTEhZN2I3ZkwzZHplVWo2WTBINCtTbmtycm9QMnNKa0RrdXp1dEFhUHFRRFJiSEkyVFRkV2hxR3laMWkzVEEveDI3czEyZTUwdG5sQTNzN1dDcFdIZGJKdmxkNGJYU2g4OTVLTUp6UWhOZzBMUTFtdEs1cFFHZjhNWnBTdmp3MnJveTNudGVrbGR3MThMaWlLTUcrMmlLLzJpUUJvRzJjYWp3dUJwNitFd0FHQXV0b05aa2dSL1N0WGxXMFM3eThsYzQrMmhEaFdpOHVyUDlaNkpranB3djZlTEZpUGFyYWN0V3RvWUw1TGJINVpxZGkzL0FiVVNVSWNBQUFCNDJtTmdaR0JnQU9MTDdlWFI4ZncyWHhtWVdSaEE0UEZSeDdzSStyOHFTei9UZmlDWGc0RUpKQW9BVGwwTDR3QjQybU5nWkdCZ1p2alB3TURBRXMxZzhQOE1TejhEVUFRRnNBQUFYY3dEOWdMR0FBQUVXd0JNQXNjQU13SmFBREFBQUFBQUFJUUE3Z0ZRQUFCNDJtTmdaR0JnWUdFSVpBRFJERkFTQ1FBQUNMd0FXUUI0MmsyTVBXL0NNQkNHbjRnRWlUQ3dvQTRkaW9mT0VRUWt0aTRNVEt4TUxJQmRsTUUyY2tJa3BLcGpmM2N2cm9lZTVOUHpmcHlCa204eWhzbVl4VDFNVGlIcWp3dW16Qk9QUlMwU2w3enl6b2dzbjRqenhrZmlYSkpUNG9JWFBoT1B4ZjlLWExMaForZnQvZEdab0E1ZW0rQ3UxamJib3dsdDQ1MWFWY3VvOThhWmNPNk1WcGVuMG4zVDlqZXIxbFZkMWV6d1dPNDg2REFFRkFkeGRHVEhWVEpMdzVaamRGcGhMNzVpUmNYeVg3NlgzTVhPT2Y2a3BYUGhLVnZUUzZPVmZaT3VZaTJYOWZCK0Fjd3JML2tBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTTUFBb0FBQUFBQlVRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoV2gyaTJOdFlYQUFBQUU0QUFBQU1RQUFBRHdBZFFDZloyeDVaZ0FBQVd3QUFBSEdBQUFDRk9UU1dFNW9aV0ZrQUFBRE5BQUFBQzhBQUFBMks4dkhjR2hvWldFQUFBTmtBQUFBSUFBQUFDUUlrQVFnYUcxMGVBQUFBNFFBQUFBTUFBQUFEQXpxQU9Gc2IyTmhBQUFEa0FBQUFBZ0FBQUFJQUlJQkNtMWhlSEFBQUFPWUFBQUFGd0FBQUNBQUJRQmFibUZ0WlFBQUE3QUFBQURPQUFBQk9QTmRLcDl3YjNOMEFBQUVnQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm04V09jd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjByNk1rUXdNL3dIOHBraDBraHEvZ09GQWNZcERPVUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEsrakpFL1A4UDVJUHAvMXYrcndLckFnSUFsQnNKRGdBQUFIamFKWkE5aXhOUkZJYm5QZmZtM3AxazVzN1huWm5OMXdheU9Ba3FpYXhtUmxaTWRCR0xiY1JDc0ZZYlVVdkJSZ1hGZ0JZUkxkMVNCTVcvb0JiK0EvK0IxWGIyZ2lUcjJVMTFQdDVUbk9keDREdzdXdFpPMHpmbnB1TkFhSlgxVUdhcHdSaTZHRndvODUyeVNxQUcvV0xRZ0ZaNW1lVnFUQnhOa1U5UkpkV2tHRU1WRTc0OHoxa0Mzbk5qdGRMYmhaS2Y1d0p1ZkRhTUVhdkZtd2ladmRnVmk5VWtEVTJkRm5NcDl0MFFsTzFlZmh3UW9vMXJRL0ZjUkxaall4dCtUQVA1RWwrOE5QcGdFcGRVcytyU3ZlVmhvQ1FJeWt0ZFNDa01sekNuM2VYcnRnZ04zVjhlYnA0NlRuc2tJQ213ZFlnek9mNTV2Z1NnZk9zQ2JyTDhUdnRHODl6MENZZ2NPSGVQVnZJU083ak5EcEl0TUVDYWFUYlFYMk15WWtEcXhNMGF2eitveW1xS0dZa1J0cG0rcVBLcXpBMEdmWjN6ZnNUQ3B1aFJsZVZXNmI3U2RQQ2oxajFuTEZwWDl0NUZoTGpXYWFIMjl0VWpWd0crOWZpWnpkbmVBeU9FTU5kdmJJVi9QOVU2T3laQjg4WDdRQ0JTbmZiVHI4MEl0aTE1bUYxOUdGQzlQcm8xd256MTB6T00yejdHalppVy9Mcis4K1NPNTdyS0p4SnJEMUhna1JpMkc3OWhHd0ZiYUpHVWlKTUc0bDhIYVpxNlpObkxpYThOaTg3d1B5RDdTU2tBQUhqYVkyQmtZR0FBNHRSN3YwcmorVzIrTWpDek1JREE0Nk9PZHhIMC83K3NXa3g3Z0Z3T0JpYVFLQUJzT2d6YUFIamFZMkJrWUdCbStNL0F3TUNxekpEOC95ZXJGZ05RQkFVd0F3QlpTQU82QTFRQUFBVWpBSDRFY3dCakFBQUFBQUNDQVFwNDJtTmdaR0JnWUdhSVpBRFJERkFTQ1FBQUNXa0FZQUI0MmsyTVBXL0NNQkNHbjRnRWlUQ3dvQTRkaW9mT0VRUll1ekF3c1RLeEFIWlJCdHZJQ1pHUXFvNzkzYjI0SG5xU1Q4LzdjUVpLdnNrWUptTVc5ekE1aGFnL0xwZ3lUendXdFVoYzhzbzdJN0o4SXM0Ykg0bHpTVTZKQzE3NFREd1cveXR4eVlhZm5iZjNSMmVDT25odGdydGEyMnlQSnJTTmQycFZMYVBlRzJmQ3VUTmFYWjVLOTAzYjM2eGFWM1ZWczhOanVmT2d3eEJRSE1UUmtSMVh5U3dOVzQ3UmFZVzkrSW9WRmN0LytWNXlGenZuK0pPV3pvV25iRTB2alZiMlRicUt0VnpXdy9zRnlKc3Y4UUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNDcuNTk3MDksLTY1LjQzOTMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDc1LjA0NTY2NiwxLjUyOTA3MSlzY2FsZSgtMSwtMSknPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTUuMzM3NjEzLC0xMjMuMjQxNjI1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTYuMDYyNSwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDk1LjMzNzYxMywtMTIzLjI0MTYyNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSc5NS4zMzc2MTMnIHk9Jy0xMjMuMjQxNjI1Jz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzEwNi4wODg5NTYnIHk9Jy0xMjYuODU2OTg5Jz4yPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzExMC41NTgzMjYnIHk9Jy0xMjMuMjQxNjI1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzExNC40MzI3JyB5PSctMTIzLjI0MTYyNSc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScxMjMuNDY4MjU1JyB5PSctMTIzLjI0MTYyNSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNTkuODMxODE0LC0xMjMuMjQxNjI1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIyMi4wOTEzMzcsLTEyMy4yNDE2MjUpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMy44MTk0NCwwLjApJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDIyMi4wOTEzMzcsLTEyMy4yNDE2MjUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjIyLjA5MTMzNycgeT0nLTEyMy4yNDE2MjUnPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjMyLjg0MjY3OScgeT0nLTEyMy4yNDE2MjUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjM2LjcxNzA1MycgeT0nLTEyMy4yNDE2MjUnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjQ1Ljc1MjYwOScgeT0nLTEyMy4yNDE2MjUnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjg0LjM1MDg2LC0xMjMuMjQxNjI1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM0OC44NDUwNiwtMTIzLjI0MTYyNSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE2LjA2MjUsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgzNDguODQ1MDYsLTEyMy4yNDE2MjUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMzQ4Ljg0NTA2JyB5PSctMTIzLjI0MTYyNSc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSczNTkuNTk2NDAzJyB5PSctMTI2Ljg1Njk4OSc+MjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczNjQuMDY1NzcyJyB5PSctMTIzLjI0MTYyNSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSczNjcuOTQwMTQ2JyB5PSctMTIzLjI0MTYyNSc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczNzYuOTc1NzAyJyB5PSctMTIzLjI0MTYyNSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NS4zMzc2MTMsLTg4LjA1NDA3NSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJy8+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNTkuODMxODE0LC04OC4wNTQwNzUpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjIyLjA5MTMzNywtODguMDU0MDc1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTMuODE5NDQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgyMjIuMDkxMzM3LC04OC4wNTQwNzUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjIyLjA5MTMzNycgeT0nLTg4LjA1NDA3NSc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScyMzIuODQyNjc5JyB5PSctODguMDU0MDc1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzIzNi43MTcwNTMnIHk9Jy04OC4wNTQwNzUnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjQ1Ljc1MjYwOScgeT0nLTg4LjA1NDA3NSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NS4zMzc2MTMsLTYzLjk4NDU2KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDk1LjMzNzYxMywtMzQuMjk2MTAzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE1OS44MzE4MTQsLTM0LjI5NjEwMylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE2LjA2MjUsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxNTkuODMxODE0LC0zNC4yOTYxMDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTU5LjgzMTgxNCcgeT0nLTM0LjI5NjEwMyc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxNzAuNTgzMTU2JyB5PSctMzcuOTExNDY3Jz4zPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzE3NS4wNTI1MjYnIHk9Jy0zNC4yOTYxMDMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTc4LjkyNjknIHk9Jy0zNC4yOTYxMDMnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTg3Ljk2MjQ1NScgeT0nLTM0LjI5NjEwMyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZT0nIzAwMCcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMjIuMDkxMzM3LC0zNC4yOTYxMDMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjg0LjM1MDg2LC0zNC4yOTYxMDMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNi4wNjI1LDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMjg0LjM1MDg2LC0zNC4yOTYxMDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjg0LjM1MDg2JyB5PSctMzQuMjk2MTAzJz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzI5NS4xMDIyMDInIHk9Jy0zNy45MTE0NjcnPjI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjk5LjU3MTU3MicgeT0nLTM0LjI5NjEwMyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSczMDMuNDQ1OTQ2JyB5PSctMzQuMjk2MTAzJz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzMxMi40ODE1MDEnIHk9Jy0zNC4yOTYxMDMnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTUuMzM3NjEzLDEuNTI5MDcxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknLz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE1OS44MzE4MTQsMS41MjkwNzEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNi4wNjI1LDAuMCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTU5LjgzMTgxNCwxLjUyOTA3MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PScxNTkuODMxODE0JyB5PScxLjUyOTA3MSc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxNzAuNTgzMTU2JyB5PSctMi4wODYyOTMnPjI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTc1LjA1MjUyNicgeT0nMS41MjkwNzEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTc4LjkyNjknIHk9JzEuNTI5MDcxJz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzE4Ny45NjI0NTUnIHk9JzEuNTI5MDcxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlPScjMDAwJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIyMi4wOTEzMzcsMS41MjkwNzEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KScvPgo8ZyBzdHJva2U9JyMwMDAnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjg0LjM1MDg2LDEuNTI5MDcxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTMuODE5NDQsMC4wKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgyODQuMzUwODYsMS41MjkwNzEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjg0LjM1MDg2JyB5PScxLjUyOTA3MSc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScyOTUuMTAyMjAyJyB5PScxLjUyOTA3MSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PScyOTguOTc2NTc2JyB5PScxLjUyOTA3MSc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczMDguMDEyMTMyJyB5PScxLjUyOTA3MSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTYyLjQ5My0zNS44Mzk1MVYtNTMuMDM5NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLC02Mi40OTMsLTUzLjIzOTU4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04OC41MzgxLC00NC44NTIwMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPsK1PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc5Ljg4OTgyMScgeT0nMi44NjI5NjcnPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nODYuODI5MTQ1JyB5PScyLjg2Mjk2Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc4OS41Mjc0JyB5PScyLjg2Mjk2Nyc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc5NS40NTMxNzgnIHk9JzIuODYyOTY3Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS00MS45MjQ5Ni02Mi45MzkzSDQzLjc2ODA1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQzLjk2ODAzLC02Mi45MzkzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00LjUzMzYzLC01OS4yMjU0NiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPsK1PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc5Ljg4OTgyMScgeT0nMi41MzA4ODQnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNMCA1My40Mzk1NlYzNi4yMzk0NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwzNi4wMzk0OSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyLjM1Mjc1LDQzLjY3ODQ0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg3NS4wNDU2NjYsMS41MjkwNzEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNzUuMDQ1NjY2JyB5PScxLjUyOTA3MSc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc3OS4wMTY5MDcnIHk9JzIuODYyOTY3Jz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jzg1Ljk1NjIzJyB5PScyLjg2Mjk2Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc4OC42NTQ0ODUnIHk9JzIuODYyOTY3Jz5YPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jzk0LjU4MDI2MycgeT0nMi44NjI5NjcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTEwNi42NjEwMSA1Ni41OTY3NkwtMTguNzEwMzMgMzIuMTcyNzMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC45NjM0OSwtMC4yNjc1NSwwLjI2NzU1LDAuOTYzNDksLTE4LjUxNzY1LDMyLjExOTIzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03Ni4xNTYwNSwzOC45NjQ2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPsK1PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc5Ljg4OTgyMScgeT0nMi41MzA4ODQnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNLTE4LjMyNDk4IDYyLjI5OTI5SC0xMDYuMjYxMDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsLTEwNi40NjEwMyw2Mi4yOTkyOSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNzUuMDkwMyw2Ni40MDIwNCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nODMuMzkwNzc5JyB5PScxLjUyOTA3MSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc4Ni41MDQxMjInIHk9JzEuNTI5MDcxJz7OtzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc5MC42MDg5MScgeT0nMi41MzA4ODQnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nOTcuMDMyODE4JyB5PScxLjUyOTA3MSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00xOC4zMjQ5OCA2Mi4yOTkyOUgxMDYuMjYxMDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA2LjQ2MTAzLDYyLjI5OTI5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjAxNzg4LDY3LjI0MDk0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg3NS4wNDU2NjYsMS41MjkwNzEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNzUuMDQ1NjY2JyB5PScxLjUyOTA3MSc+zrc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNzkuMTUwNDU0JyB5PScyLjg2Mjk2Nyc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc4Ni4wODk3NzgnIHk9JzIuODYyOTY3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzg4Ljc4ODAzMycgeT0nMi44NjI5NjcnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nOTQuNzEzODExJyB5PScyLjg2Mjk2Nyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMC4zOTk5OCc+CjxwYXRoIGQ9J00xMDYuNjYxMDEgNTYuNTk2NzZMMTguNzEwMzMgMzIuMTcyNzMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuOTYzNDksLTAuMjY3NTUsMC4yNjc1NSwtMC45NjM0OSwxOC41MTc2NSwzMi4xMTkyMyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2NC44NDU3NSwzOC45NjQ2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNzUuMDQ1NjY2LDEuNTI5MDcxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjA0NTY2NicgeT0nMS41MjkwNzEnPsK1PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc5Ljg4OTgyMScgeT0nMi41MzA4ODQnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzAuMzk5OTgnPgo8cGF0aCBkPSdNNjIuNDkzLTM1LjgzOTUxVi01My42Nzk2MScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDYyLjQ5MywtNTMuODc5NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4wNzk4OCAyLjM5OTg2Qy0xLjY5OTg5IC45NTk5Mi0uODUzMTMgLjI3OTk4IDAgMEMtLjg1MzEzLS4yNzk5OC0xLjY5OTg5LS45NTk5Mi0yLjA3OTg4LTIuMzk5ODYnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2NC44NDU3NSwtNDUuNzg1OTMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDc1LjA0NTY2NiwxLjUyOTA3MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSc3NS4wNDU2NjYnIHk9JzEuNTI5MDcxJz7CtTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc3OS44ODk4MjEnIHk9JzIuNTMwODg0Jz5YPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScwLjM5OTk4Jz4KPHBhdGggZD0nTS00MS45MjQ5Ni0yNi45Nzk3OEg0MS41MjUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuNzI0OTgsLTI2Ljk3OTc4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjA3OTg4IDIuMzk5ODZDLTEuNjk5ODkgLjk1OTkyLS44NTMxMyAuMjc5OTggMCAwQy0uODUzMTMtLjI3OTk4LTEuNjk5ODktLjk1OTkyLTIuMDc5ODgtMi4zOTk4NicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMi45NjgzNywtMjIuODc3MDMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDc1LjA0NTY2NiwxLjUyOTA3MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSc3NS4wNDU2NjYnIHk9JzEuNTI5MDcxJz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzgzLjM5MDc3OScgeT0nMS41MjkwNzEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nODYuNTA0MTIyJyB5PScxLjUyOTA3MSc+wrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nOTEuMzQ4Mjc3JyB5PScyLjUzMDg4NCc+WDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSc5Ny43NzIxODUnIHk9JzEuNTI5MDcxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4="></fr:img></fr:resource-content><fr:resource-source type="latex" part="preamble">
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D&lt;&gt;{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     &gt;={Triangle[open]},-&gt;.&gt;
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}-&gt;
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}-&gt;
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {-&gt;},
   square/south/.style = {-&gt;},
   square/west/.style = {-&gt;},
   square/east/.style = {-&gt;},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  </fr:resource-source><fr:resource-source type="latex" part="body">
        \begin {tikzcd}
            {M^2(X)} &amp;&amp; {M(X)} &amp;&amp; {M^2(X)} \\
            &amp;&amp; {M(X)} \\
            \\
            &amp; {M^3(X)} &amp;&amp; {M^2(X)} \\
            &amp; {M^2(X)} &amp;&amp; {M(X)}
            \arrow [&quot;{\mu _{M(X)}}&quot;&apos;, from=4-2, to=5-2]
            \arrow [&quot;{\mu _X}&quot;, from=5-2, to=5-4]
            \arrow [&quot;{1_{M(X)}}&quot;, from=1-3, to=2-3]
            \arrow [&quot;{\mu _X}&quot;&apos;, from=1-1, to=2-3]
            \arrow [&quot;{M(\eta _X)}&quot;&apos;, from=1-3, to=1-1]
            \arrow [&quot;{\eta _{ M(X)}}&quot;, from=1-3, to=1-5]
            \arrow [&quot;{\mu _X}&quot;, from=1-5, to=2-3]
            \arrow [&quot;{\mu _X}&quot;, from=4-4, to=5-4]
            \arrow [&quot;{M(\mu _X)}&quot;, from=4-2, to=4-4]
        \end {tikzcd}
    </fr:resource-source></fr:resource></fr:figure></fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                    <fr:p>It requires an operation over functors named <fr:strong>whiskering</fr:strong></fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>641</fr:anchor>
                        <fr:addr type="user">def-003U</fr:addr>
                        <fr:route>def-003U.xml</fr:route>
                        <fr:title text="Whiskering">Whiskering</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Let <fr:tex display="inline">F,G:C\to  D</fr:tex> and <fr:tex display="inline">H,D\to  E</fr:tex> be functors and <fr:tex display="inline">\eta :F\to  G</fr:tex> be a natural 
    transformation whose coordinate at any object <fr:tex display="inline">A</fr:tex> of <fr:tex display="inline">C</fr:tex> is <fr:tex display="inline">\eta _A</fr:tex>, then 
    <fr:strong>whiskering</fr:strong> <fr:tex display="inline">H</fr:tex> and <fr:tex display="inline">\eta </fr:tex> yields the natural transformation 
    <fr:tex display="inline">H\circ \eta :H\circ  F\to  H\circ  G</fr:tex> whose coordinate at <fr:tex display="inline">A</fr:tex> is <fr:tex display="inline">H(\eta _A)</fr:tex>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
                <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                  <fr:frontmatter>
                    <fr:anchor>642</fr:anchor>
                    <fr:addr type="machine">#361</fr:addr>
                    <fr:route>unstable-361.xml</fr:route>
                    <fr:title text="Logic as Adjoint Functors">Logic as Adjoint Functors</fr:title>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:authors></fr:authors>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:p>Categorical logic is a new approach to logic, due to <fr:strong>Lawvere</fr:strong>. 
            He showed that logical constructs are fundamentally just <fr:strong>adjoint functors</fr:strong>.
            This allows us to capture many logical constructs by using only one categorical concept.
            Adjoint also provides a strong guarantee about the derived syntactic formulation.</fr:p>
                    <fr:tree toc="true" numbered="true" show-heading="true" show-metadata="false" expanded="true" root="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml">
                      <fr:frontmatter>
                        <fr:anchor>643</fr:anchor>
                        <fr:addr type="user">def-003V</fr:addr>
                        <fr:route>def-003V.xml</fr:route>
                        <fr:title text="Adjoint Functor">Adjoint Functor</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                        <fr:authors></fr:authors>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <fr:p>Let <fr:tex display="inline">\mathcal {C}</fr:tex> and <fr:tex display="inline">\mathcal {D}</fr:tex> be categories and a pair of functors 
    <fr:tex display="inline">F:\mathcal {C}\to \mathcal {D}</fr:tex> and <fr:tex display="inline">G:\mathcal {D}\to \mathcal {C}</fr:tex>. This is called 
    pair of <fr:strong>adjoint functors</fr:strong> (or <fr:strong>adjunction</fr:strong>) with <fr:tex display="inline">F</fr:tex> the left adjoint
    and <fr:tex display="inline">G</fr:tex> the right adjoint denoted 
    <fr:tex display="block">         F\dashv  G     </fr:tex>
    if there is a natural isomorphism between the hom-functors:
    <fr:tex display="block">         \hom _{\mathcal {D}}(F(-),-)\cong \hom _{\mathcal {C}}(-,G(-))     </fr:tex>
    which means forall objects <fr:tex display="inline">C\in \mathcal {C}</fr:tex> and <fr:tex display="inline">D\in \mathcal {D}</fr:tex>, there is a bijection
    <fr:tex display="block">         \hom _{\mathcal {D}}(F(C),D)\cong \hom _{\mathcal {C}}(C,G(D)) \\          (F(C)\xrightarrow {f}D) \mapsto  (C\xrightarrow {G(f)}G(D))     </fr:tex>
    which is natural in both <fr:tex display="inline">C</fr:tex> and <fr:tex display="inline">D</fr:tex>.</fr:p>
                      </fr:mainmatter>
                      <fr:backmatter></fr:backmatter>
                    </fr:tree>
                  </fr:mainmatter>
                  <fr:backmatter></fr:backmatter>
                </fr:tree>
              </fr:mainmatter>
              <fr:backmatter></fr:backmatter>
            </fr:tree>
          </fr:mainmatter>
          <fr:backmatter></fr:backmatter>
        </fr:tree>
      </fr:mainmatter>
      <fr:backmatter></fr:backmatter>
    </fr:tree>
  </fr:backmatter>
</fr:tree>