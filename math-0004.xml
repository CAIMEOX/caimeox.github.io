<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2568</anchor>  <taxon>Math Analysis</taxon> <addr>math-0004</addr>  <route>math-0004.xml</route> <date><year>2024</year> <month>1</month> <day>27</day></date>  <title>The construction of <tex>\mathbb {R}</tex></title> </frontmatter> <mainmatter><p>
    We start constructing <tex>\mathbb {R}</tex> from <tex>\mathbb {Q}</tex> by a way that it satisfies the existence theorem,
    the core of construction.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb></trail> <anchor>2569</anchor>  <taxon>Theorem</taxon> <addr>thm-0003</addr>  <route>thm-0003.xml</route>   <title>Existence theorem</title> </frontmatter> <mainmatter><p>
    There exists an ordered field <tex>\mathbb {R}</tex> that satisfies the <link href="def-0012.xml" type="local" title="Least upper bound property">least upper bound property</link>.
    Moreover <tex>\mathbb {R}</tex> contains <tex>\mathbb {Q}</tex> as a subfield.
</p></mainmatter> </tree><p>
    The least-upper-bound property mentioned above is defined:
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb></trail> <anchor>2570</anchor>  <taxon>Definition</taxon> <addr>def-0012</addr>  <route>def-0012.xml</route>   <title>Least upper bound property</title> </frontmatter> <mainmatter><p>
    A set <tex>S</tex> has the least upper bound property if every non-empty subset <tex>T</tex> of <tex>S</tex> that is bounded above has a least upper bound <tex>\sup  T</tex>.
</p></mainmatter> </tree><p>
    Why do we need the least-upper-bound property?
    Consider the set <tex>S =  \{ x  \in   \mathbb {Q} | x^2 &lt; 2 \}</tex>.
    <tex>S</tex> is bounded above by <tex>2</tex>, but it does not have a least upper bound in <tex>\mathbb {Q}</tex>.
    Therefore we can't express <tex>\sqrt {2}</tex> in field <tex>\mathbb {Q}</tex> since some &quot;gaps&quot; exist.
    This fact motivates us to construct a more complete field <tex>\mathbb {R}</tex>.
    We have constructed <tex>\mathbb {Q}</tex> from <tex>\mathbb {Z}</tex>, and now we construct <tex>\mathbb {R}</tex> from <tex>\mathbb {Q}</tex>.
</p><p>
    Then we should find a way to express &quot;<tex>\sqrt {2}</tex>&quot; using <tex>\mathbb {Q}</tex>.
    A crucial idea is <strong>approximating</strong> <tex>\sqrt {2}</tex> by a sequence of rational numbers.
    <tex display="block">
         \sqrt {2} :=  \{  p^2&lt;2  \lor  p&lt;0, p \in \mathbb {Q}  \} 
    </tex>
    We can cut the number axis into two pieces by <tex>\sqrt {2}</tex>, such cut is called a <strong>Dedekind cut</strong>. 
    A cut should be well-defined rather than just an intuitive concept.
</p><p>
    As we use set theory to construct <tex>\mathbb {R}</tex>, it motivates us to define Dedekind cut as a set.
    It should satisfies some properties:
    <ul><li>Can't be empty or the whole <tex>\mathbb {Q}</tex></li>
        <li>Closed downward</li>
        <li>Contains not the largest number</li></ul>
    A formal definition is given below:
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb></trail> <anchor>2571</anchor>  <taxon>Definition</taxon> <addr>def-0013</addr>  <route>def-0013.xml</route>   <title>Dedekind cuts</title> </frontmatter> <mainmatter><p>
    A Dedekind cut is a partition of the rationals <tex>\mathbb {Q}</tex> into two non-empty sets <tex>L</tex> and <tex>R</tex> such that:
    <ul><li><tex>L \neq \emptyset</tex></li>
        <li><tex>R \neq \emptyset</tex></li>
        <li>if <tex>x,y \in \mathbb {Q}, x&lt;y</tex> and <tex>y \in  L</tex> then <tex>x \in  L</tex></li>
        <li>if <tex>p \in  L</tex> then exists <tex>q \in  L</tex> such that <tex>p&lt;q</tex></li></ul></p></mainmatter> </tree><p>
    Now we can defined the real number as a set of Dedekind cuts.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb></trail> <anchor>2572</anchor>  <taxon>Definition</taxon> <addr>def-0014</addr>  <route>def-0014.xml</route>   <title>Real Number System</title> </frontmatter> <mainmatter><p>
    The element of <tex>\mathbb {R}</tex> is a <link href="def-0013.xml" type="local" title="Dedekind cuts">Dedekind Cut</link> in <tex>\mathbb {Q}</tex>.
    <tex display="block">
         \mathbb {R} :=  \{  L | (L,R)  \text { is a Dedekind Cut}  \} 
    </tex></p></mainmatter> </tree><p>
    Now define the order relation on <tex>\mathbb {R}</tex>.
    We have defined <tex>\mathbb {R}</tex> as the set of Dedekind cuts, so we can define the strict partial order relation <tex>&lt;</tex> on <tex>\mathbb {R}</tex> by the set operation <tex>\subset</tex>.
    The irreflexive, asymmetric and transitive properties are trivial. 
</p></mainmatter> <backmatter><contributions/> <context><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2573</anchor>   <addr>notes</addr>  <route>notes.xml</route>   <title>Notes</title> </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>5</crumb></trail> <anchor>2574</anchor>  <taxon>Type Theory</taxon> <addr>tt-0001</addr>  <route>tt-0001.xml</route> <date><year>2024</year> <month>1</month> <day>26</day></date>  <title>Untyped Lambda Calculus</title> </frontmatter> <mainmatter><p>
In dealing with functions there are two <strong>construction principles</strong> and one <strong>evalutaion rule</strong>
<ul><li>Construction Principles</li>
<ul><li>Function Abstraction: <tex>\lambda  x.M</tex></li>
<li>Function Application: <tex>M N</tex></li></ul>
<li>Evaluation Rule</li>
<ul><li>Beta Reduction: <tex>( \lambda  x.M)N \to  M[N/x]</tex></li></ul></ul>
The beta reduction makes use of the <strong>substitution</strong> <tex>M[N/x]</tex> which represents the result of replacing all free occurences of <tex>x</tex> in <tex>M</tex> with <tex>N</tex>.
</p>
<p>Expressions in the lambda calculus is called <strong>terms</strong>. The set of terms is denoted <tex>\Lambda</tex>.</p>
<tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>5</crumb> <crumb>1</crumb></trail> <anchor>2575</anchor>  <taxon>Definition</taxon> <addr>def-000F</addr>  <route>def-000F.xml</route>   <title>Set of Lambda Terms</title> </frontmatter> <mainmatter><p>
Let <tex>\Lambda</tex> be the set of lambda terms. Then <tex>\Lambda</tex> is defined inductively as follows:
(<tex>V</tex> is the set of variables)
<ul><li>Variable: <tex>\forall  x \in  V, x \in   \Lambda</tex></li>
<li>Abstraction: <tex>\forall  x \in  V, M \in   \Lambda ,  \lambda  x.M \in   \Lambda</tex></li>
<li>Application: <tex>\forall  M,N \in   \Lambda , (MN) \in   \Lambda</tex></li></ul></p><p>
Another way to define <tex>\Lambda</tex> is to use the following grammar (The 3 possibilities are separated by <code>|</code>):
<tex display="block">\Lambda  = V |  \lambda  V. \Lambda  |  \Lambda \Lambda</tex></p></mainmatter> </tree> 
</mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb></trail> <anchor>2576</anchor>  <taxon>Set Theory</taxon> <addr>math-0003</addr>  <route>math-0003.xml</route> <date><year>2024</year> <month>1</month> <day>26</day></date>  <title>Set Theory</title> </frontmatter> <mainmatter><p>
    We will first start by introducing sets
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb> <crumb>1</crumb></trail> <anchor>2577</anchor>  <taxon>Definition</taxon> <addr>def-000S</addr>  <route>def-000S.xml</route>   <title>Set</title> </frontmatter> <mainmatter><p>
    A set is a collection of objects.
</p><p><strong>Element</strong>
    <tex>x \in  A</tex> means <tex>A</tex> is a collection and <tex>x</tex> is an element of a collection.
</p><p><strong>Subset</strong>
    <tex>A \subseteq  B</tex> means <tex>A</tex> is a <strong>subset</strong> of <tex>B</tex>.
    <tex>A \subset  B</tex> means <tex>A</tex> is a <strong>proper subset</strong> of <tex>B</tex>.
</p><p><strong>Power Set</strong>
    <tex>\mathcal {P}(A)</tex> is the set of all subsets of <tex>A</tex>.
</p></mainmatter> </tree><p>
    And principles of set theory
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb> <crumb>2</crumb></trail> <anchor>2578</anchor>  <taxon>Definition</taxon> <addr>def-000T</addr>  <route>def-000T.xml</route>   <title>Principle of Extensionality</title> </frontmatter> <mainmatter><p>
    Two sets are equal if and only if they have the same elements.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb> <crumb>3</crumb></trail> <anchor>2579</anchor>  <taxon>Definition</taxon> <addr>def-000U</addr>  <route>def-000U.xml</route>   <title>Principle of Comprehension</title> </frontmatter> <mainmatter><p>
    Given a set <tex>A</tex> and a property <tex>P(x)</tex>, there exists a set <tex>B</tex> such that
    <tex>x \in  B  \iff  x \in  A  \land  P(x)</tex>.
</p></mainmatter> </tree><p>
    We then define the Cartesian product of two sets
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb> <crumb>4</crumb></trail> <anchor>2580</anchor>  <taxon>Definition</taxon> <addr>def-000V</addr>  <route>def-000V.xml</route>   <title>Cartesian product</title> </frontmatter> <mainmatter><p>
    Given two sets <tex>A</tex> and <tex>B</tex>, the Cartesian product <tex>A \times  B</tex> is the set
    of all ordered pairs <tex>(a,b)</tex> where <tex>a \in  A</tex> and <tex>b \in  B</tex>.
</p></mainmatter> </tree><p>
    With the Cartesian product, we can define the relation
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb> <crumb>5</crumb></trail> <anchor>2581</anchor>  <taxon>Definition</taxon> <addr>def-000W</addr>  <route>def-000W.xml</route>   <title>Relation</title> </frontmatter> <mainmatter><p>
    A <strong>relation</strong> <tex>R</tex> is a subset of the Cartesian product of two sets <tex>A</tex> and
    <tex>B</tex>, i.e. <tex>R \subseteq  A \times  B</tex>.
    If <tex>(a,b) \in  R</tex>, we write <tex>aRb</tex>.

    A relation that between <tex>X</tex> and itself is called <strong>homogeneous relation</strong>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb> <crumb>6</crumb></trail> <anchor>2582</anchor>  <taxon>Definition</taxon> <addr>def-000X</addr>  <route>def-000X.xml</route>   <title>Equivalence relation</title> </frontmatter> <mainmatter><p>
    An equivalence relation <tex>R</tex> on a set <tex>A</tex> is a <link href="def-000W.xml" type="local" title="Relation">relation</link> that is reflexive,
    symmetric, and transitive.
    <ul><li>Reflexive:
            <tex>\forall  x \in  A, xRx</tex></li>
        <li>Symmetric:
            <tex>\forall  x,y \in  A, xRy \implies  yRx</tex></li>
        <li>Transitive:
            <tex>\forall  x,y,z \in  A, xRy \land  yRz \implies  xRz</tex></li></ul></p></mainmatter> </tree><p>
    One of the most important relations is the order relation.
    The basic order relation is the preorder.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb> <crumb>7</crumb></trail> <anchor>2583</anchor>  <taxon>Definition</taxon> <addr>def-000Z</addr>  <route>def-000Z.xml</route>   <title>Preorder</title> </frontmatter> <mainmatter><p>
    A <strong>preorder</strong> is a relation <tex>\leq</tex> that is reflexive and transitive.
    <ul><li>Reflexive: <tex>a \leq  a</tex></li>
        <li>Transitive: <tex>a \leq  b</tex> and <tex>b \leq  c</tex> implies <tex>a \leq  c</tex></li></ul></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb> <crumb>8</crumb></trail> <anchor>2584</anchor>  <taxon>Definition</taxon> <addr>def-000Y</addr>  <route>def-000Y.xml</route>   <title>Partial Order</title> </frontmatter> <mainmatter><p>
    A <strong>(non-strict) partial order</strong> is a relation <tex>\leq</tex> that is reflexive, antisymmetric and transitive.
    <ul><li>Reflexive: <tex>a \leq  a</tex></li>
        <li>Antisymmetric: <tex>a \leq  b</tex> and <tex>b \leq  a</tex> implies <tex>a=b</tex></li>
        <li>Transitive: <tex>a \leq  b</tex> and <tex>b \leq  c</tex> implies <tex>a \leq  c</tex></li></ul>
    A non-strict partial order is also known as an antisymmetric <link href="def-000Z.xml" type="local" title="Preorder">preorder</link>.
</p></mainmatter> </tree><p>
    And the strict partial order (notice the difference between asymmetric and antisymmetric)
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb> <crumb>9</crumb></trail> <anchor>2585</anchor>  <taxon>Definition</taxon> <addr>def-0010</addr>  <route>def-0010.xml</route>   <title>Strict partial orders</title> </frontmatter> <mainmatter><p>
    A strict partial order is a relation <tex>&lt;</tex> that is irreflexive, asymmetric and transitive.
    <ul><li>Irreflexive: <tex>\neg (a&lt;a)</tex></li>
        <li>Asymmetric: <tex>a&lt;b</tex> implies <tex>\neg (b&lt;a)</tex></li>
        <li>Transitive: <tex>a&lt;b</tex> and <tex>b&lt;c</tex> implies <tex>a&lt;c</tex></li></ul></p></mainmatter> </tree><p>
    With the definition of order, we can define the upper bound and lower bound
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb> <crumb>10</crumb></trail> <anchor>2586</anchor>  <taxon>Definition</taxon> <addr>def-0011</addr>  <route>def-0011.xml</route>   <title>Upper Bound and Lower Bound</title> </frontmatter> <mainmatter><p>
    Let a subset <tex>S</tex> of a <link href="def-000Y.xml" type="local" title="Partial Order">partially ordered</link> set <tex>(P,  \leq )</tex>,
    <tex>S</tex> is bounded above if there exists <tex>x  \in  P</tex> such that <tex>\forall  y  \in  S, y  \leq  x</tex>. And <tex>x</tex> is called an <strong>upper bound</strong> of <tex>S</tex>.
    Dually, <tex>S</tex> is bounded below if there exists <tex>x  \in  P</tex> such that <tex>\forall  y  \in  S, x  \leq  y</tex>. And <tex>x</tex> is called a <strong>lower bound</strong> of <tex>S</tex>.
</p>
    <p><strong>Supremum (least upper bound)</strong></p>
    <p>
    An element <tex>x \in  P</tex> is a supremum of <tex>S</tex>,
    if for all upper bounds <tex>z  \in  P</tex> of <tex>S</tex>, <tex>x  \leq  z</tex>.
    Denoted as <tex>x =  \sup  S</tex>.
    </p>
    <p><strong>Infimum (greatest lower bound)</strong></p>
    <p>
    An element <tex>x \in  P</tex> is a infimum of <tex>S</tex>,
    if for all lower bounds <tex>z  \in  P</tex> of <tex>S</tex>, <tex>z  \leq  x</tex>.
    Denoted as <tex>x =  \inf  S</tex>.
    </p>
</mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>8</crumb></trail> <anchor>2587</anchor>  <taxon>Linear Algebra</taxon> <addr>math-0001</addr>  <route>math-0001.xml</route> <date><year>2024</year> <month>1</month> <day>26</day></date>  <title>Vector Space</title> </frontmatter> <mainmatter><p>
    The motivation for the definition of a vector space comes from the properties
    of vectors in Euclidean space <tex>\mathbb {R}^n</tex> and <tex>\mathbb {C}^n</tex>.
    The definition abstracts and generalizes these properties.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>8</crumb> <crumb>1</crumb></trail> <anchor>2588</anchor>  <taxon>Definition</taxon> <addr>def-000H</addr>  <route>def-000H.xml</route>   <title>Vector Space</title> </frontmatter> <mainmatter><p>
    A vector space over a <link href="def-0006.xml" type="local" title="Field">field</link> <tex>F</tex> is a non-empty set <tex>V</tex> together with a binary operation and a binary function that satisfy the axioms listed below. 
    In this context, the elements of <tex>F</tex> are commonly called <strong>vectors</strong>, and the elements of <tex>F</tex> are called <strong>scalars</strong>.
    <ul><li>Commutativity: <tex>
             \forall  x, y  \in  V, x + y = y + x
        </tex></li>
        <li>Associativity: <tex>
             \forall  x, y, z  \in  V, (x + y) + z = x + (y + z)
        </tex></li>
        <li>Additive Identity: <tex>
             \exists  0  \in  V  \text { such that }  \forall  x  \in  V, x + 0 = x
        </tex></li>
        <li>Multiplicative Identity: <tex>
             \forall  x  \in  V, 1x = x
        </tex></li>
        <li>Additive Inverse: <tex>
             \forall  x  \in  V,  \exists  y  \in  V  \text { such that } x + y = 0
        </tex></li>
        <li>Distributivity: <tex>
             \forall  x, y  \in  V,  \forall  c, d  \in  F, c(x + y) = cx + cy, (c + d)x = cx + dx
        </tex></li></ul></p><p>
    Elements of a vector space are called <strong>vectors</strong> or <strong>points</strong>.
</p></mainmatter> </tree><p>
    When dealing with vector spaces, we usually interested only in subspaces.
    And the union of subspaces is rarely a subspace, thus
    we are more interested with sums of subspaces.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>8</crumb> <crumb>2</crumb></trail> <anchor>2589</anchor>  <taxon>Definition</taxon> <addr>def-000I</addr>  <route>def-000I.xml</route>   <title>Linear Subspace</title> </frontmatter> <mainmatter><p>
    A subset <tex>U</tex> of a vector space <tex>V</tex> over a field <tex>F</tex> is called a <strong>subspace</strong> of <tex>V</tex> if <tex>U</tex> is itself a <strong>vector space</strong> over <tex>F</tex> with the operations of addition and scalar multiplication on <tex>V</tex>.
    The subset also satisfies the following axioms (vice versa):
    <ul><li>Additive identity: <tex>0 \in  U</tex></li>
        <li>Closure: <tex>\forall  u,v \in  U, u+v \in  U</tex></li>
        <li>Closed Scalar multiplication: <tex>\forall  u \in  U,  \forall  c \in  F, cu \in  U</tex></li></ul></p></mainmatter> </tree><p>
    After that we can define the sum of subsets.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>8</crumb> <crumb>3</crumb></trail> <anchor>2590</anchor>  <taxon>Definition</taxon> <addr>def-000J</addr>  <route>def-000J.xml</route>   <title>Sum of subsets</title> </frontmatter> <mainmatter><p>
    Let <tex>U_1,  \dots , U_n</tex> be subsets of a vector space <tex>V</tex>.
    The <strong>sum</strong> of <tex>U_1,  \dots , U_n</tex> is defined as
    <tex display="block">U_1 +  \dots  + U_n =  \{ u_1 +  \dots  + u_n  \mid  u_i  \in  U_i \}</tex>.
</p></mainmatter> </tree><p>
    The sum of subspaces is the smallest subspace that contains all the subspaces.
</p><p>
    Every element in <tex>U_1 +  \dots  + U_n</tex> can be written as a sum of elements <tex>u_i</tex> in <tex>U_i</tex>:
    <tex display="block">
        u_1+ \cdots +u_n
    </tex>
    We will interested in cases where each vector in <tex>U_1 +  \dots  + U_n</tex> can be represented in the form above
    in only one way. This leads to the definition of direct sum.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>8</crumb> <crumb>4</crumb></trail> <anchor>2591</anchor>  <taxon>Definition</taxon> <addr>def-000K</addr>  <route>def-000K.xml</route>   <title>Direct Sum</title> </frontmatter> <mainmatter><p>
    Let <tex>U_1,  \dots , U_n</tex> be subspaces of a vector space <tex>V</tex>.
    The <strong>direct sum</strong> of <tex>U_1,  \dots , U_n</tex> is defined as
    <tex display="block">
        U_1  \oplus   \dots   \oplus  U_n =  \{ u_1 +  \dots  + u_n  \mid  u_i  \in  U_i \} 
    </tex>
    if every element in <tex>U_1  \oplus   \dots   \oplus  U_n</tex> can be written as <tex>u_1 +  \dots  + u_n </tex> in only one way.
    This definition requires every vector in the sum have a unique representation.
</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb></trail> <anchor>2592</anchor>  <taxon>Linear Algebra</taxon> <addr>math-0002</addr>  <route>math-0002.xml</route> <date><year>2024</year> <month>1</month> <day>26</day></date>  <title>Finite Dimensional Vector Space</title> </frontmatter> <mainmatter><p>
    Adding up scalar mulitples of vectors in a list gives a linear combination.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>1</crumb></trail> <anchor>2593</anchor>  <taxon>Definition</taxon> <addr>def-000L</addr>  <route>def-000L.xml</route>   <title>Linear Combination</title> </frontmatter> <mainmatter><p>
    Let <tex>V</tex> be a <link href="def-000H.xml" type="local" title="Vector Space">vector space</link> over a field <tex>F</tex>.
    Let <tex>v_1,  \dots , v_n</tex> be vectors in <tex>V</tex>.
    A <strong>linear combination</strong> of <tex>v_1,  \dots , v_n</tex> is an expression of the form
    <tex display="block">
        a_1 v_1 +  \dots  + a_n v_n
    </tex>
    where <tex>a_1,  \dots , a_n  \in  F</tex>.
</p></mainmatter> </tree><p>
    To talk about a structure, we usually define a collection of this structure.
    Hence we have span for linear combinations.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>2</crumb></trail> <anchor>2594</anchor>  <taxon>Definition</taxon> <addr>def-000M</addr>  <route>def-000M.xml</route>   <title>Linear Span</title> </frontmatter> <mainmatter><p>
    Let <tex>V</tex> be a vector space over a field <tex>F</tex>.
    Let <tex>v_1,  \dots , v_n</tex> be vectors in <tex>V</tex>.
    The <strong>span</strong> of <tex>v_1,  \dots , v_n</tex> is defined as
    <tex display="block">
         \text {span} (v_1,  \dots , v_n) =  \{ a_1 v_1 +  \dots  + a_n v_n  \mid  a_i  \in  F \} 
    </tex>
    The span of empty set is defined to be <tex>\{ 0 \}</tex>.    
</p><p>
    If <tex>\text {span} (v_1,  \dots , v_n) = V</tex>, we say that <tex>v_1,  \dots , v_n</tex> <strong>spans</strong> <tex>V</tex>.
</p></mainmatter> </tree><p>
    Suppose we have span <tex>S= \text {span} (v_1,  \dots , v_n)</tex>. (Span is trivially a subspace.)
    Obviously for all <tex>v_j (1  \leq  j  \leq  n)</tex>, <tex>v_j  \in  S</tex>.
    Because subspaces are closed under scalar multiplication and addition, every
    subspace of <tex>V</tex> containing <tex>v_1,  \dots , v_n</tex> must contain <tex>S</tex>.
    Thus we conclude that <tex>S</tex> is the smallest subspace containing <tex>v_1,  \dots , v_n</tex>.
</p><p>
    The discussion about <strong>spans</strong> leads to a key definition in linear algebra.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>3</crumb></trail> <anchor>2595</anchor>  <taxon>Definition</taxon> <addr>def-000N</addr>  <route>def-000N.xml</route>   <title>Finite-Dimensional Vector Space</title> </frontmatter> <mainmatter><p>
    A <link href="def-000H.xml" type="local" title="Vector Space">vector space</link> <tex>V</tex> is called <strong>finite-dimensional</strong> if some <link href="def-000G.xml" type="local" title="List">list</link> of vectors <tex>v_1,  \dots , v_n</tex> <link href="def-000M.xml" type="local" title="Linear Span">spans</link> <tex>V</tex>.
</p></mainmatter> </tree><p>
    The opposite of finite-dimensional is infinite-dimensional.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>4</crumb></trail> <anchor>2596</anchor>  <taxon>Definition</taxon> <addr>def-000O</addr>  <route>def-000O.xml</route>   <title>Infinite-dimensional vector space</title> </frontmatter> <mainmatter><p>
    A vector space <tex>V</tex> is called <strong>infinite-dimensional</strong> if it is not <link href="def-000N.xml" type="local" title="Finite-Dimensional Vector Space">finite-dimensional</link>.
</p></mainmatter> </tree><p>
    Consider the situation that there is only one way to
    express a vector <tex>v</tex> as a linear combination of vectors in a list <tex>v_1,  \dots , v_n</tex>.
    What property of the list <tex>v_1,  \dots , v_n</tex> does this situation imply? The answer is
    linear independence.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>5</crumb></trail> <anchor>2597</anchor>  <taxon>Definition</taxon> <addr>def-000P</addr>  <route>def-000P.xml</route>   <title>Linearly independent</title> </frontmatter> <mainmatter><p>
    A set of vectors <tex>\{ v_1,  \dots , v_n \}</tex> is called <strong>linearly independent</strong> if
    <tex display="block">a_1 v_1 +  \dots  + a_n v_n = 0</tex>
    implies that <tex>a_1 =  \dots  = a_n = 0</tex>.
    The trivial case of <tex>\{ 0 \}</tex> is also considered linearly independent.
</p></mainmatter> </tree><p>
    If some vectors are not linearly independent, then there are more than one way to
    express a vector as a linear combination of vectors in the list. This leads to 
    the following definition.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>6</crumb></trail> <anchor>2598</anchor>  <taxon>Definition</taxon> <addr>def-000Q</addr>  <route>def-000Q.xml</route>   <title>Linearly dependent</title> </frontmatter> <mainmatter><p>
    A set of vectors <tex>\{ v_1,  \dots , v_n \}</tex> is called <strong>linearly dependent</strong> if
    <tex display="block">a_1 v_1 +  \dots  + a_n v_n = 0</tex>
    for some <tex>a_1,  \dots , a_n  \in   \mathbb {F}</tex> with at least one <tex>a_i  \neq  0</tex> (not all <tex>0</tex>).
</p></mainmatter> </tree><p>
    The following lemma is a direct consequence of the definition of linear independence.
    It states that for a given linearly dependent list, we can always remove a vector
    without changing the span.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>7</crumb></trail> <anchor>2599</anchor>  <taxon>Lemma</taxon> <addr>thm-0001</addr>  <route>thm-0001.xml</route>   <title>Linear Dependence Lemma</title> </frontmatter> <mainmatter><p>
    Let <tex>v_1,  \dots , v_n</tex> be vectors in a vector space <tex>V</tex> over a field <tex>\mathbb {F}</tex>.
    If <tex>v_1,  \dots , v_n</tex> are linearly dependent, then there exists <tex>1  \leq  i  \leq  n</tex> such that
    <ul><li><tex>v_i  \in   \text {span} (v_1,  \dots , v_{i-1})</tex></li>
        <li>Remove <tex>v_i</tex> from the list <tex>v_1,  \dots , v_n</tex> and the span does not change</li></ul></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>8</crumb></trail> <anchor>2600</anchor>  <taxon>Lemma</taxon> <addr>thm-0002</addr>  <route>thm-0002.xml</route>   <title>Length of linearly independent list <tex>\leq</tex> length of spanning list</title> </frontmatter> <mainmatter><p>
    In a finite dimensional vector space, the length of a linearly independent list is less than or equal to the length of a spanning list.
</p></mainmatter> </tree><p>
    We have discussed linear independent lists and spanning lists.
    Now we are ready to define a basis.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>9</crumb></trail> <anchor>2601</anchor>  <taxon>Definition</taxon> <addr>def-000R</addr>  <route>def-000R.xml</route>   <title>Basis</title> </frontmatter> <mainmatter><p>
    A basis of <tex>V</tex> is a list of vectors in <tex>V</tex>
    that is linearly independent and spans <tex>V</tex>. 
</p><p><strong>Criterion for basis</strong>
    A list of vectors <tex>\{ v_1,  \dots , v_n \}</tex> is a basis of <tex>V</tex> if and only if
    every <tex>v  \in  V</tex> can be written <strong>uniquely</strong> as a linear combination of <tex>v_1,  \dots , v_n</tex>.
</p></mainmatter> </tree><p>
    For instance, we have standard basis <tex>\{ e_1,  \dots , e_n \}</tex> for <tex>\mathbb {F}^n</tex>,
    where <tex>e_i</tex> is the vector with <tex>1</tex> at <tex>i</tex>-th position and <tex>0</tex> elsewhere.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>10</crumb></trail> <anchor>2602</anchor>  <taxon>Theorem</taxon> <addr>thm-0005</addr>  <route>thm-0005.xml</route>   <title>Spanning List contains a basis</title> </frontmatter> <mainmatter><p>
    Every spanning list in a vector space can be reduced to a basis.
</p></mainmatter> </tree><p>
    From the <link href="thm-0005.xml" type="local" title="Spanning List contains a basis">theorem</link> we can infer a corollary.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>11</crumb></trail> <anchor>2603</anchor>  <taxon>Corollary</taxon> <addr>thm-0006</addr>  <route>thm-0006.xml</route>   <title>Basis of finite-dimensional vector space</title> </frontmatter> <mainmatter><p>
    Every finite-dimensional vector space has a basis.
</p></mainmatter> </tree><p>
    The next result states for a spanning list can be reduced to a basis.
    We can adjoin one or more vectors to a linearly independent list to form a basis.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>12</crumb></trail> <anchor>2604</anchor>  <taxon>Theorem</taxon> <addr>thm-0007</addr>  <route>thm-0007.xml</route>   <title>Linearly dependent list extends to a basis</title> </frontmatter> <mainmatter><p>
    Every linearly independent list of vectors in  a finite-dimensional vector space can be extended to a basis.
</p></mainmatter> </tree><p>
    Remind the definition of <link href="der-000K" type="external">direct sum</link>, we can now show that
    every subspace of a finite-dimensional vecrtor space can be paired
    with another subspace to form a direct sum of the whole space.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>13</crumb></trail> <anchor>2605</anchor>  <taxon>Theorem</taxon> <addr>thm-0008</addr>  <route>thm-0008.xml</route>   <title>Direct Sum of Subspaces of <tex>V</tex></title> </frontmatter> <mainmatter><p>
    Suppose <tex>V</tex> is a finite dimensional vector space,
    and <tex>U</tex> is a subspace of <tex>V</tex>.
    Then there exists a subspace <tex>W</tex> of <tex>V</tex> such that
    <tex>V = U  \oplus  W</tex>.
</p></mainmatter> </tree><p>
    This post discusses about <em>finite-dimensional vector space</em>.
    But we have not yet defined what is dimension.
    We tempted to define the dimension as the length of basis intuitively.
    With this definition we should prove its well-definedness.
    That is, every basis has the same length.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>14</crumb></trail> <anchor>2606</anchor>  <taxon>Theorem</taxon> <addr>thm-0009</addr>  <route>thm-0009.xml</route>   <title>Basis length is invariant</title> </frontmatter> <mainmatter><p>
    Let <tex>V</tex> be a finite-dimensional vector space.
    Then every basis of <tex>V</tex> has the same length.
</p></mainmatter> </tree><p>
    This can be proved by <link href="thm-0002.xml" type="local" title="Length of linearly independent list  length of spanning list">Lemma 8</link>.
    Now we can formally define the dimension of such spaces.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>15</crumb></trail> <anchor>2607</anchor>  <taxon>Definition</taxon> <addr>def-001V</addr>  <route>def-001V.xml</route>   <title>Dimension</title> </frontmatter> <mainmatter><p>
    The <strong>dimension</strong> of a finite-dimensional vector space <tex>V</tex> is the length of any basis of the vector space.
    Denoted by <tex>\dim  V</tex>.
</p></mainmatter> </tree><p>
    Every subspace of a finite-dimensional vector space is also finite-dimensional.
    Hence we can talk about the dimension of a subspace.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>16</crumb></trail> <anchor>2608</anchor>  <taxon>Theorem</taxon> <addr>thm-000A</addr>  <route>thm-000A.xml</route>   <title>Dimension of a subspace</title> </frontmatter> <mainmatter><p>
    Let <tex>V</tex> be a finite-dimensional vector space,
    and <tex>U</tex> be a subspace of <tex>V</tex>.
    Then <tex>\dim  U  \leq   \dim  V</tex>.
</p></mainmatter> </tree><p>
    According to the definition of <link href="def-000P.xml" type="local" title="Linearly independent">linearly independent</link>,
    to show a list of vectors is a basis, we only need to show it is linearly independent,
    and it spans the whole space.
    The next theorems simplifies the task:
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>17</crumb></trail> <anchor>2609</anchor>  <taxon>Theorem</taxon> <addr>thm-000B</addr>  <route>thm-000B.xml</route>   <title>Linearly independent list of the right length is a basis</title> </frontmatter> <mainmatter><p>
    Let <tex>V</tex> be a finite-dimensional vector space.
    Then every <link href="def-000P.xml" type="local" title="Linearly independent">linearly independent</link> list of vectors in <tex>V</tex> with length equal to <tex>\dim  V</tex> is a basis of <tex>V</tex>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>18</crumb></trail> <anchor>2610</anchor>  <taxon>Theorem</taxon> <addr>thm-000C</addr>  <route>thm-000C.xml</route>   <title>Spanning list of the right length is a basis</title> </frontmatter> <mainmatter><p>
    Let <tex>V</tex> be a finite-dimensional vector space.
    Then every <link href="def-000M.xml" type="local" title="Linear Span">spanning</link> list of vectors in <tex>V</tex> with length equal to <tex>\dim  V</tex> is a basis of <tex>V</tex>.
</p></mainmatter> </tree><p>
    Now we move to the discussion of the dimension of the sum of two subspaces.
    This is analogous to the <link href="thm-000E.xml" type="local" title="Inclusion-Exclusion Principle">inclusion-exclusion principle</link>.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb> <crumb>19</crumb></trail> <anchor>2611</anchor>  <taxon>Theorem</taxon> <addr>thm-000D</addr>  <route>thm-000D.xml</route>   <title>Dimension of a sum</title> </frontmatter> <mainmatter><p>
    Let <tex>V</tex> be a finite-dimensional vector space,
    and <tex>U</tex> and <tex>W</tex> be subspaces of <tex>V</tex>.
    Then
    <tex display="block">
         \dim (U + W) =  \dim  U +  \dim  W -  \dim (U  \cap  W).
    </tex></p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>10</crumb></trail> <anchor>2612</anchor>  <taxon>Compute Science</taxon> <addr>cs-0001</addr>  <route>cs-0001.xml</route> <date><year>2024</year> <month>1</month> <day>29</day></date>  <title>Is JavaScript an untyped language?</title> </frontmatter> <mainmatter><p>
    This is a note about the the argument that JavaScript is an untyped language.
    Most opinions came from the References.
</p><p>
    The first thing I want to classify is the word <strong>strong typing</strong> and <strong>weak typing</strong> are meaningless.
    In a limit case we can compare two languages that have similar type system, and talk about which one is <em>stronger</em>.
    But for the common case, it's totally nonsense.
</p><p>
    Static and dynamic typing is a meaningful classsification. But the discussion about dynamic and static languages is mostly wrong on the Internet.
    Dynamic language is a popular concept, however, it is rather a <strong>marketing</strong> than a well-defined terminology.
    It's designed to confuse rather than inform.
</p><p>
    In fact, dynamic typing is just a special case of static typing.
    It limits more than contributes.The root of the problem is the confusion 
    between type and class. It's very useful to have multiple classes of values
    of a same type.
    They are interchangeable because they represent values of the same type.
    Only the form of presentation differs.
</p><p>
    The distinction between two classes of the same type is dynamic.
    But this does not conflict with the fact that only one static type.
    In type theory this is what we called <strong>Sum Type</strong>.
    Being a sum type we can dispatch on the class of the value of the type,
    and decide what to do at runtime.
</p><p>
    This characteristics is same to dynamic language where values can be classified into
    various forms that can be distinguished at runtime.
    The answer is now clear: dynamic language classifies all values in this way.
    What they do just merge all values of the language into a single type.
    The so-called <strong>untyped</strong> language is just <strong>unityped</strong>.
</p><p>
    Therefore, JavaScript is definitely untyped.
</p>
    <p><strong>References</strong></p>
    <ul><li><link href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/" type="external">Dynamic and static language</link></li>
        <li><link href="https://stackoverflow.com/questions/964910/is-javascript-an-untyped-language" type="external">stackoverflow</link></li>
        <li><link href="https://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html" type="external">What to know before debating type systems</link></li>
        <li><em>Practical Foundations for Programming Languages</em>, Robert Harper</li></ul>
</mainmatter> </tree></mainmatter> </tree></context> <related/> <backlinks/> <references/></backmatter></tree>